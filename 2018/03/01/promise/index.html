<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="开发,JavaScript,Promise," />










<meta name="description" content="基本介绍 Promise对象是异步编程的一种解决方案，它表示一个尚未完成且预计在未来完成的异步操作。它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。 当Promise的状态由pending转变为resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是它名字Promise-承诺的由来。">
<meta name="keywords" content="开发,JavaScript,Promise">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise对象">
<meta property="og:url" content="https://chongtianhong.github.io/2018/03/01/promise/index.html">
<meta property="og:site_name" content="Ice&#39;s Blog">
<meta property="og:description" content="基本介绍 Promise对象是异步编程的一种解决方案，它表示一个尚未完成且预计在未来完成的异步操作。它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。 当Promise的状态由pending转变为resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是它名字Promise-承诺的由来。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://chongtianhong.github.io/images/catch.png">
<meta property="og:updated_time" content="2018-03-04T04:27:12.986Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Promise对象">
<meta name="twitter:description" content="基本介绍 Promise对象是异步编程的一种解决方案，它表示一个尚未完成且预计在未来完成的异步操作。它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。 当Promise的状态由pending转变为resolved或rejected时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是它名字Promise-承诺的由来。">
<meta name="twitter:image" content="https://chongtianhong.github.io/images/catch.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chongtianhong.github.io/2018/03/01/promise/"/>





  <title>Promise对象 | Ice's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/chongtianHong">
      <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png">
    </a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ice's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">知耻而后勇</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chongtianhong.github.io/2018/03/01/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xiaobing Hong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Promise对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-01T22:38:04+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发/" itemprop="url" rel="index">
                    <span itemprop="name">开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>Promise对象是异步编程的一种解决方案，它表示一个尚未完成且预计在未来完成的异步操作。它有三种状态，分别是<code>pending</code>-进行中、<code>resolved</code>-已完成、<code>rejected</code>-已失败。</li>
<li>当Promise的状态由<code>pending</code>转变为<code>resolved</code>或<code>rejected</code>时，会执行相应的方法，并且状态一旦改变，就无法再次改变状态，这也是它名字Promise-承诺的由来。<a id="more"></a>
</li>
</ul>
<h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><ul>
<li>JavaScript的执行环境是「单线程」。 <ul>
<li>单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为<strong>主线程</strong>（同步）。 </li>
<li>但实际上还有<strong>其他线程</strong>（异步），如事件触发线程、ajax请求线程等。</li>
</ul>
</li>
<li>这也就引发了<strong>同步</strong>和<strong>异步</strong>的问题。</li>
</ul>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><ul>
<li><p><strong>同步模式</strong>，即上述所说的<strong>单线程模式</strong>，<strong>一次只能执行一个任务</strong>，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致<strong>「线程阻塞」</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 例1.1 */</span><br><span class="line">var x = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(x); //死循环</span><br><span class="line">console.log(<span class="string">"don't carry out"</span>);    //不会执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的例子即同步模式，其中的while是一个<strong>死循环</strong>，它会<strong>阻塞进程</strong>，因此第三句console不会执行。 </p>
</li>
<li><strong>同步模式</strong>比较<strong>简单</strong>，也较<strong>容易编写</strong>。但问题也显而易见，<strong>如果请求的时间较长，而阻塞了后面代码的执行</strong>，体验是很不好的。因此对于一些耗时的操作，<strong>异步模式</strong>则是<strong>更好的选择</strong>。</li>
</ul>
<h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><ul>
<li><strong>异步模式</strong>，即与同步模式相反，<strong>可以一起执行多个任务</strong>，函数调用后不会立即返回执行的结果，如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。 </li>
<li><p><strong>最常见的异步模式</strong>就数<strong>定时器</strong>了，例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 例1.2 */</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'taskA, asynchronous'</span>);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(<span class="string">'taskB, synchronize'</span>);</span><br><span class="line">//<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">-------ouput-------</span><br><span class="line">taskB, synchronize</span><br><span class="line">taskA, asynchronous</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，定时器延时的时间为0，但taskA还是晚于taskB执行。这是由于定时器是异步的，<strong>异步任务会在当前脚本的所有同步任务执行完才会执行</strong>。如果同步代码中含有死循环，即将上例的注释去掉，那么这个异步任务就不会执行，因为同步任务阻塞了进程。</p>
</li>
</ul>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><ul>
<li>回调函数可以简单理解为：（执行完）回（来）调（用）的函数。</li>
<li>回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码。<ul>
<li>可以理解为是将一个函数func2作为参数传入另一个函数func1中，当func1执行到某一步或者满足某种条件的时候才执行传入的参数func2。</li>
</ul>
</li>
<li><p>回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。<strong>在同步调用下，回调函数一般是最后执行的</strong>。而<strong>异步调用下，可能一段时间后执行或不执行（未达到执行的条件）</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 例1.3 */</span><br><span class="line">/******************同步回调******************/</span><br><span class="line">var fun1 = <span class="keyword">function</span>(callback) &#123;</span><br><span class="line">    //<span class="keyword">do</span> something</span><br><span class="line">    console.log(<span class="string">"before callback"</span>);</span><br><span class="line">    (callback &amp;&amp; typeof(callback) === <span class="string">'function'</span>) &amp;&amp; callback();</span><br><span class="line">    console.log(<span class="string">"after callback"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var fun2 = <span class="keyword">function</span>(param) &#123;</span><br><span class="line">    //<span class="keyword">do</span> something</span><br><span class="line">    var start = new Date();</span><br><span class="line">    <span class="keyword">while</span>((new Date() - start) &lt; 3000) &#123; //delay 3s</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(<span class="string">"I'm callback"</span>);</span><br><span class="line">&#125;</span><br><span class="line">fun1(fun2);</span><br><span class="line"></span><br><span class="line">-------output--------</span><br><span class="line">before callback</span><br><span class="line">//after 3s</span><br><span class="line">I’m callback</span><br><span class="line">after callback</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于是同步回调，会阻塞后面的代码，如果fun2是个死循环，后面的代码就不执行了。</p>
</li>
<li><strong>setTimeout</strong>是常见的<strong>异步回调</strong>，另外常见的异步回调即<strong>ajax请求</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 例1.4 */</span><br><span class="line">/******************异步回调******************/</span><br><span class="line"><span class="keyword">function</span> request(url, param, successFun, errorFun) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">'GET'</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        param: param,</span><br><span class="line">        async: <span class="literal">true</span>,    //默认为<span class="literal">true</span>,即异步请求；<span class="literal">false</span>为同步请求</span><br><span class="line">        success: successFun,</span><br><span class="line">        error: errorFun</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">request(<span class="string">'test.html'</span>, <span class="string">''</span>, <span class="keyword">function</span>(data) &#123;</span><br><span class="line">    //请求成功后的回调函数，通常是对请求回来的数据进行处理</span><br><span class="line">    console.log(<span class="string">'请求成功啦, 这是返回的数据:'</span>, data);</span><br><span class="line">&#125;,<span class="keyword">function</span>(error) &#123;</span><br><span class="line">    console.log(<span class="string">'sorry, 请求失败了, 这是失败信息:'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="为什么使用Promise"><a href="#为什么使用Promise" class="headerlink" title="为什么使用Promise"></a>为什么使用Promise</h4><ul>
<li>一般来说我们会碰到的回调嵌套都不会很多，一般就一到两级，但是某些情况下，回调嵌套很多时，代码就会非常繁琐，会给我们的编程带来很多的麻烦，这种情况俗称——回调地狱。</li>
<li>由此，<strong>Promise</strong>的概念就由社区提出并实现，<strong>作用</strong>与回调方法几乎一致，都是<strong>在某种情况下执行预先设定好的方法</strong>，但是使用它却能够让代码变得更简洁清晰。</li>
<li><p>利用Promise改写例1.4的异步回调如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* 例1.5 */</span><br><span class="line"><span class="keyword">function</span> request(url, param, successFun, errorFun) &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">'GET'</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        param: param,</span><br><span class="line">        async: <span class="literal">true</span>,    //默认为<span class="literal">true</span>,即异步请求；<span class="literal">false</span>为同步请求</span><br><span class="line">        success: successFun,</span><br><span class="line">        error: errorFun</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> sendRequest(url, param) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">        request(url, param, resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendRequest(<span class="string">'test.html'</span>, <span class="string">''</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">    //异步操作成功后的回调</span><br><span class="line">    console.log(<span class="string">'请求成功啦, 这是返回的数据:'</span>, data);</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    //异步操作失败后的回调</span><br><span class="line">    console.log(<span class="string">'sorry, 请求失败了, 这是失败信息:'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise的真正强大之处在于它的<strong>多重链式调用</strong>，可以<strong>避免层层嵌套回调</strong>。如果我们在第一次ajax请求后，还要用它返回的结果再次请求时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 例1.6 */</span><br><span class="line">request(<span class="string">'test1.html'</span>, <span class="string">''</span>, <span class="keyword">function</span>(data1) &#123;</span><br><span class="line">    console.log(<span class="string">'第一次请求成功, 这是返回的数据:'</span>, data1);</span><br><span class="line">    request(<span class="string">'test2.html'</span>, data1, <span class="keyword">function</span> (data2) &#123;</span><br><span class="line">        console.log(<span class="string">'第二次请求成功, 这是返回的数据:'</span>, data2);</span><br><span class="line">        request(<span class="string">'test3.html'</span>, data2, <span class="keyword">function</span> (data3) &#123;</span><br><span class="line">            console.log(<span class="string">'第三次请求成功, 这是返回的数据:'</span>, data3);</span><br><span class="line">            //request... 继续请求</span><br><span class="line">        &#125;, <span class="keyword">function</span>(error3) &#123;</span><br><span class="line">            console.log(<span class="string">'第三次请求失败, 这是失败信息:'</span>, error3);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="keyword">function</span>(error2) &#123;</span><br><span class="line">        console.log(<span class="string">'第二次请求失败, 这是失败信息:'</span>, error2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="keyword">function</span>(error1) &#123;</span><br><span class="line">    console.log(<span class="string">'第一次请求失败, 这是失败信息:'</span>, error1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上出现了多层回调嵌套，有种晕头转向的感觉。这也就是我们常说的厄运回调金字塔（Pyramid of Doom），编程体验十分不好。而使用Promise，我们就可以<strong>利用then进行「链式回调」，将异步操作以同步操作的流程表示出来</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 例1.7 */</span><br><span class="line">sendRequest(<span class="string">'test.html'</span>, <span class="string">''</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(data1) &#123;</span><br><span class="line">    console.log(<span class="string">'第一次请求成功, 这是返回的数据:'</span>, data1);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data2) &#123;</span><br><span class="line">    console.log(<span class="string">'第二次请求成功, 这是返回的数据:'</span>, data2);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(data3) &#123;</span><br><span class="line">    console.log(<span class="string">'第三次请求成功, 这是返回的数据:'</span>, data3);</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">    //用catch捕捉前面的错误</span><br><span class="line">    console.log(<span class="string">'sorry, 请求失败了, 这是失败信息:'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a>Promise的基本用法</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>Promise对象代表一个未完成、但预计将来会完成的操作。它有以下三种状态：<ul>
<li><code>pending</code>：初始值，不是fulfilled，也不是rejected</li>
<li><code>fulfilled</code>：代表操作成功</li>
<li><code>rejected</code>：代表操作失败</li>
</ul>
</li>
<li>Promise有两种状态改变的方式，既可以从<code>pending</code>转变为<code>fulfilled</code>，也可以从<code>pending</code>转变为<code>rejected</code>。一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，<code>promise.then</code>绑定的函数就会被调用。</li>
<li>注意：Promise<strong>一旦新建就会「立即执行」，无法取消</strong>。这也是它的<strong>缺点</strong>之一。</li>
<li><p>声明一个Promise对象有两种方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.1 */</span><br><span class="line">//构建Promise</span><br><span class="line">// 方法1</span><br><span class="line"><span class="built_in">let</span> promise = new Promise ( <span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( success ) &#123;</span><br><span class="line">        resolve(a) // pending ——&gt; resolved 参数将传递给对应的回调方法</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(err) // pending ——&gt; rejectd</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br><span class="line">// 注意：实例化的Promise对象会立即执行</span><br><span class="line">// 方法2</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">promise</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise ( <span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( success ) &#123;</span><br><span class="line">            resolve(a)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类似构建对象，我们使用new来构建一个Promise。<strong>Promise接受一个「函数」作为参数</strong>，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。这两个函数就是就是<strong>「回调函数」，由JavaScript引擎提供</strong>。</p>
<ul>
<li>resolve函数的作用：在<strong>异步操作成功时调用</strong>，并<strong>将异步操作的结果，作为参数传递出去</strong>； </li>
<li>reject函数的作用：在<strong>异步操作失败时调用</strong>，并<strong>将异步操作报出的错误，作为参数传递出去</strong>。</li>
</ul>
</li>
<li><p>Promise实例生成以后，可以用<code>then</code>方法指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 接例2.1 */</span><br><span class="line">promise.then(onFulfilled, onRejected);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">  // <span class="keyword">do</span> something when success</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">  // <span class="keyword">do</span> something when failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>then</code>方法会返回一个Promise。它有两个参数，分别为Promise从<code>pending</code>变为<code>fulfilled</code>和<code>rejected</code>时的回调函数（第二个参数非必选）。这两个函数都接受Promise对象传出的值作为参数。</p>
</li>
<li><p>简单来说，<code>then</code>就是定义<code>resolve</code>和<code>reject</code>函数的，其resolve参数相当于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> resolveFun(data) &#123;</span><br><span class="line">    //data为promise传出的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而新建Promise中的’resolve(data)’，则相当于执行resolveFun函数。<br>Promise新建后就会立即执行。而<code>then</code>方法中指定的回调函数，将<strong>在当前脚本所有<em>同步任务</em>执行完才会执行</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.2 */</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  console.log(<span class="string">'before resolved'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(<span class="string">'after resolved'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">'resolved'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'outer'</span>);</span><br><span class="line"></span><br><span class="line">-------output-------</span><br><span class="line">before resolved</span><br><span class="line">after resolved</span><br><span class="line">outer</span><br><span class="line">resolved</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于<code>resolve</code>指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行，因此最后打印’resolved’，这个和例1.2是一样的道理。</p>
</li>
</ul>
<blockquote>Promise.prototype.then() VS Promise.prototype.catch()</blockquote>

<ul>
<li><p><code>then</code>()方法是Promise原型链上的方法，它包含两个参数方法，分别是已成功<code>resolved</code>的回调函数和已失败<code>rejected</code>的回调函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">    console.log(<span class="string">'this is success callback'</span>);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    console.log(<span class="string">'this is fail callback'</span>);</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>.catch()的作用是捕获Promise的错误，与<code>then</code>()的rejected回调作用几乎一致。但是由于Promise的抛错具有冒泡性质，能够不断传递，这样就能够在下一个catch()中统一处理这些错误。同时catch()也能够捕获<code>then</code>()中抛出的错误，所以<strong>建议不要使用<code>then</code>()的rejected回调</strong>，而是<strong>统一使用catch()来处理错误</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">    console.log(<span class="string">'this is success callback'</span>);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">    console.log(<span class="string">'this is fail callback'</span>);</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样，catch()中也可以抛出错误，由于抛出的错误会在下一个catch中被捕获处理，因此可以再添加catch()。</p>
</li>
</ul>
<h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><h5 id="then"><a href="#then" class="headerlink" title=".then()"></a>.then()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：Promise.prototype.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<ul>
<li>对promise添加<code>onFulfilled</code>和<code>onRejected</code>回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的<code>resolve</code>函数。</li>
<li>因此，我们可以使用链式写法，如上文的例1.7。由于前一个回调函数，返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待<strong>该Promise对象的状态发生变化，才会被调用</strong>。</li>
</ul>
<h5 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：Promise.prototype.catch(onRejected)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>该方法是<code>.then(undefined, onRejected)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.3 */</span><br><span class="line">promise.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">    console.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;).catch(<span class="keyword">function</span>(error) &#123;</span><br><span class="line">    console.log(<span class="string">'error'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/*******等同于*******/</span><br><span class="line">promise.then(<span class="keyword">function</span>(data) &#123;</span><br><span class="line">    console.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    console.log(<span class="string">'error'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reject</code>方法的作用，等同于抛错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.4 */</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    throw new Error(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">/*******等同于*******/</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    reject(new Error(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//用catch捕获</span><br><span class="line">promise.catch(<span class="keyword">function</span> (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">Error: <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>promise对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个<code>catch</code>所捕获。<code>then</code>方法指定的回调函数，若抛出错误，也会被下一个<code>catch</code>捕获。<code>catch</code>中也能抛错，则需要后面的<code>catch</code>来捕获。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.5 */</span><br><span class="line">sendRequest(<span class="string">'test.html'</span>).<span class="keyword">then</span>(<span class="keyword">function</span>(data1) &#123;</span><br><span class="line">    //<span class="keyword">do</span> something</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> (data2) &#123;</span><br><span class="line">    //<span class="keyword">do</span> something</span><br><span class="line">&#125;).catch(<span class="keyword">function</span> (error) &#123;</span><br><span class="line">    //处理前面三个Promise产生的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦<code>fulfilled</code>了，再抛错，也不会变为<code>rejected</code>，就不会被<code>catch</code>了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.6 */</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  resolve();</span><br><span class="line">  throw <span class="string">'error'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="keyword">function</span>(e) &#123;</span><br><span class="line">   console.log(e);      //This is never called</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有使用<code>catch</code>方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.7 */</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="keyword">function</span> (data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：Promise.all(iterable)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>该方法用于将<strong>多个Promise实例，包装成一个新的Promise实例</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.all</code>方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用<code>Promise.resolve</code>转换为一个promise)。它的<strong>状态由这三个promise实例决定</strong>。</p>
<ul>
<li>当p1, p2, p3状态都变为<code>fulfilled</code>，p的状态才会变为<code>fulfilled</code>，并将三个promise返回的结果，按<strong>参数的顺序</strong>（而不是<code>resolved</code>的顺序）存入数组，传给p的回调函数，如例2.8。</li>
<li>当p1, p2, p3其中之一状态变为<code>rejected</code>，p的状态也会变为<code>rejected</code>，并把<strong>第一个被<code>reject</code>的promise的返回值</strong>，传给p的回调函数，如例2.9。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.8 */</span><br><span class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    setTimeout(resolve, 3000, <span class="string">"first"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    resolve(<span class="string">'second'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">var p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 1000, <span class="string">"third"</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2, p3]).<span class="keyword">then</span>(<span class="keyword">function</span>(values) &#123; </span><br><span class="line">  console.log(values); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">-------output-------</span><br><span class="line">//约 3s 后</span><br><span class="line">[<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.9 */</span><br><span class="line">var p1 = new Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">  setTimeout(resolve, 1000, <span class="string">"one"</span>); </span><br><span class="line">&#125;); </span><br><span class="line">var p2 = new Promise((resolve, reject) =&gt; &#123; </span><br><span class="line">  setTimeout(reject, 2000, <span class="string">"two"</span>); </span><br><span class="line">&#125;);</span><br><span class="line">var p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(<span class="string">"three"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all([p1, p2, p3]).<span class="keyword">then</span>(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    console.log(<span class="string">'resolve'</span>, value);</span><br><span class="line">&#125;, <span class="keyword">function</span> (error) &#123;</span><br><span class="line">    console.log(<span class="string">'reject'</span>, error);    // =&gt; reject three</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">-------output-------</span><br><span class="line">reject three</span><br></pre></td></tr></table></figure>
</li>
<li><p>这多个 promise 是<strong>同时开始、并行执行</strong>的，而不是顺序执行。从下面例子可以看出。如果一个个执行，至少需要 1+32+64+128(ms)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.10 */</span><br><span class="line"><span class="keyword">function</span> timerPromisefy(delay) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            resolve(delay);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var startDate = Date.now();</span><br><span class="line"></span><br><span class="line">Promise.all([</span><br><span class="line">    timerPromisefy(1),</span><br><span class="line">    timerPromisefy(32),</span><br><span class="line">    timerPromisefy(64),</span><br><span class="line">    timerPromisefy(128)</span><br><span class="line">]).<span class="keyword">then</span>(<span class="keyword">function</span> (values) &#123;</span><br><span class="line">    console.log(Date.now() - startDate + <span class="string">'ms'</span>);</span><br><span class="line">    console.log(values);</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">133ms       //不一定，但大于128ms</span><br><span class="line">[1,32,64,128]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="race"><a href="#race" class="headerlink" title=".race()"></a>.race()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：Promise.race(iterable)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>该方法同样是将多个Promise实例，包装成一个新的Promise实例。不同的是，参数中的p1、p2、p3只要有一个改变状态，promise就会立刻变成相同的状态并执行对其的回调。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise.race方法同样接受一个数组（或具有Iterator接口）作参数。<strong>当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变</strong>。并把<strong>第一个改变状态的promise的返回值</strong>，传给p的回调函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.11 */</span><br><span class="line">var p1 = new Promise(<span class="keyword">function</span>(resolve, reject) &#123; </span><br><span class="line">    setTimeout(reject, 500, <span class="string">"one"</span>); </span><br><span class="line">&#125;);</span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span>(resolve, reject) &#123; </span><br><span class="line">    setTimeout(resolve, 100, <span class="string">"two"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p1, p2]).<span class="keyword">then</span>(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    console.log(<span class="string">'resolve'</span>, value); </span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    //not called</span><br><span class="line">    console.log(<span class="string">'reject'</span>, error); </span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">resolve two</span><br><span class="line"></span><br><span class="line">var p3 = new Promise(<span class="keyword">function</span>(resolve, reject) &#123; </span><br><span class="line">    setTimeout(resolve, 500, <span class="string">"three"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">var p4 = new Promise(<span class="keyword">function</span>(resolve, reject) &#123; </span><br><span class="line">    setTimeout(reject, 100, <span class="string">"four"</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.race([p3, p4]).<span class="keyword">then</span>(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    //not called</span><br><span class="line">    console.log(<span class="string">'resolve'</span>, value);              </span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    console.log(<span class="string">'reject'</span>, error); </span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">reject four</span><br></pre></td></tr></table></figure>
</li>
<li><p>在第一个promise对象变为resolve后，并不会取消其他promise对象(相同状态)的执行，如下例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.12 */</span><br><span class="line">var fastPromise = new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">'fastPromise'</span>);</span><br><span class="line">        resolve(<span class="string">'resolve fastPromise'</span>);</span><br><span class="line">    &#125;, 100);</span><br><span class="line">&#125;);</span><br><span class="line">var slowPromise = new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">'slowPromise'</span>);</span><br><span class="line">        resolve(<span class="string">'resolve slowPromise'</span>);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">// 第一个promise变为resolve后程序停止</span><br><span class="line">Promise.race([fastPromise, slowPromise]).<span class="keyword">then</span>(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    console.log(value);    // =&gt; resolve fastPromise</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">fastPromise</span><br><span class="line">resolve fastPromise</span><br><span class="line">slowPromise     //仍会执行</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="resolve"><a href="#resolve" class="headerlink" title=".resolve()"></a>.resolve()</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">Promise.resolve(value);</span><br><span class="line">Promise.resolve(promise);</span><br><span class="line">Promise.resolve(thenable);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>它可以看做<code>new Promise()</code>的快捷方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(<span class="string">'Success'</span>);</span><br><span class="line"></span><br><span class="line">/*******等同于*******/</span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    resolve(<span class="string">'Success'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码会让这个Promise对象立即进入<code>resolved</code>状态，并将结果<code>success</code>传递给<code>then</code>指定的<code>onFulfilled</code>回调函数。由于<code>Promise.resolve()</code>也是返回Promise对象，因此可以用<code>.then()</code>处理其返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.13 */</span><br><span class="line">Promise.resolve(<span class="string">'success'</span>).<span class="keyword">then</span>(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.14 */</span><br><span class="line">//Resolving an array</span><br><span class="line">Promise.resolve([1,2,3]).<span class="keyword">then</span>(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">  console.log(value[0]);    // =&gt; 1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//Resolving a Promise</span><br><span class="line">var p1 = Promise.resolve(<span class="string">'this is p1'</span>);</span><br><span class="line">var p2 = Promise.resolve(p1);</span><br><span class="line">p2.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    console.log(value);     // =&gt; this is p1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.resolve()</code>的另一个作用就是将<code>thenable</code>对象（即带有then方法的对象）转换为promise对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.15 */</span><br><span class="line">var p1 = Promise.resolve(&#123; </span><br><span class="line">    <span class="keyword">then</span>: <span class="keyword">function</span> (resolve, reject) &#123; </span><br><span class="line">        resolve(<span class="string">"this is an thenable object!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(p1 instanceof Promise);     // =&gt; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">p1.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    console.log(value);     // =&gt; this is an thenable object!</span><br><span class="line">  &#125;, <span class="keyword">function</span>(e) &#123;</span><br><span class="line">    //not called</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成<code>resolved</code>或<code>rejected</code>，状态不会再改变，这和新建promise是一样的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* 例2.16 */</span><br><span class="line">//在回调函数前抛异常</span><br><span class="line">var p1 = &#123; </span><br><span class="line">    <span class="keyword">then</span>: <span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">      throw new Error(<span class="string">"error"</span>);</span><br><span class="line">      resolve(<span class="string">"Resolved"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p2 = Promise.resolve(p1);</span><br><span class="line">p2.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    //not called</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    console.log(error);       // =&gt; Error: error</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//在回调函数后抛异常</span><br><span class="line">var p3 = &#123; </span><br><span class="line">    <span class="keyword">then</span>: <span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">        resolve(<span class="string">"Resolved"</span>);</span><br><span class="line">        throw new Error(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p4 = Promise.resolve(p3);</span><br><span class="line">p4.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">    console.log(value);     // =&gt; Resolved</span><br><span class="line">&#125;, <span class="keyword">function</span>(error) &#123;</span><br><span class="line">    //not called</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="reject"><a href="#reject" class="headerlink" title=".reject()"></a>.reject()</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：Promise.reject(reason)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这个方法和上述的<code>Promise.resolve()</code>类似，它也是<code>new Promise()</code>的快捷方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(new Error(<span class="string">'error'</span>));</span><br><span class="line"></span><br><span class="line">/*******等同于*******/</span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    reject(new Error(<span class="string">'error'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码会让这个Promise对象立即进入<code>rejected</code>状态，并将错误对象传递给<code>then</code>指定的<code>onRejected</code>回调函数。</p>
</li>
</ul>
<h3 id="Promise常见问题"><a href="#Promise常见问题" class="headerlink" title="Promise常见问题"></a>Promise常见问题</h3><ul>
<li>总结一下创建promise的流程:<ol>
<li>使用<code>new Promise(fn)</code>或者它的快捷方式<code>Promise.resolve()</code>、<code>Promise.reject()</code>，返回一个promise对象。</li>
<li>在<code>fn</code>中指定异步的处理：<ul>
<li>处理结果正常，调用<code>resolve</code></li>
<li>处理结果错误，调用<code>reject</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="情景1：reject-和-catch-的区别"><a href="#情景1：reject-和-catch-的区别" class="headerlink" title="情景1：reject 和 catch 的区别"></a>情景1：reject 和 catch 的区别</h4><ol>
<li>promise.then(onFulfilled, onRejected)<br>在<code>onFulfilled</code>中发生异常的话，在<code>onRejected</code>中是捕获不到这个异常的。</li>
<li>promise.then(onFulfilled).catch(onRejected)<br><code>.then</code>中产生的异常能在<code>.catch</code>中捕获。</li>
</ol>
<ul>
<li>一般情况，还是建议使用第二种，因为<strong>能捕获之前的所有异常</strong>。当然了，第二种的<code>.catch()</code>也可以使用<code>.then()</code>表示，它们本质上是没有区别的，<code>.catch === .then(null, onRejected)</code>。</li>
</ul>
<h4 id="情景2：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误"><a href="#情景2：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误" class="headerlink" title="情景2：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误"></a>情景2：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* 例3.1 */</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taskA</span></span>() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">    console.log(<span class="string">"Task A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taskB</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"Task B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> onRejected(error) &#123;</span><br><span class="line">    console.log(<span class="string">"Catch Error: A or B"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">finalTask</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"Final Task"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var promise = Promise.resolve();</span><br><span class="line">promise</span><br><span class="line">    .<span class="keyword">then</span>(taskA)</span><br><span class="line">    .<span class="keyword">then</span>(taskB)</span><br><span class="line">    .catch(onRejected)</span><br><span class="line">    .<span class="keyword">then</span>(finalTask);</span><br><span class="line">    </span><br><span class="line">-------output-------</span><br><span class="line">Catch Error: A or B,ReferenceError: x is not defined</span><br><span class="line">Final Task</span><br></pre></td></tr></table></figure>
<p><img src="/images/catch.png"></p>
<ul>
<li><p>根据例3.1的输出结果及流程图，可以看出，A抛错时，会按照 taskA → onRejected → finalTask这个流程来处理。A抛错后，若没有对它进行处理，如例2.7，状态就会维持rejected，taskB不会执行，直到catch了错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* 例3.2 */</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taskA</span></span>() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">    console.log(<span class="string">"Task A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taskB</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"Task B"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> onRejectedA(error) &#123;</span><br><span class="line">    console.log(<span class="string">"Catch Error: A"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> onRejectedB(error) &#123;</span><br><span class="line">    console.log(<span class="string">"Catch Error: B"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">finalTask</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"Final Task"</span>);</span><br><span class="line">&#125;</span><br><span class="line">var promise = Promise.resolve();</span><br><span class="line">promise</span><br><span class="line">    .<span class="keyword">then</span>(taskA)</span><br><span class="line">    .catch(onRejectedA)</span><br><span class="line">    .<span class="keyword">then</span>(taskB)</span><br><span class="line">    .catch(onRejectedB)</span><br><span class="line">    .<span class="keyword">then</span>(finalTask);</span><br><span class="line">    </span><br><span class="line">-------output-------</span><br><span class="line">Catch Error: A ReferenceError: x is not defined</span><br><span class="line">Task B</span><br><span class="line">Final Task</span><br></pre></td></tr></table></figure>
</li>
<li><p>将例3.2与3.1对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。</p>
</li>
</ul>
<h4 id="情景3：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据"><a href="#情景3：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据" class="headerlink" title="情景3：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据"></a>情景3：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* 例3.3 */</span><br><span class="line">//方法1：对同一个promise对象同时调用 <span class="keyword">then</span> 方法</span><br><span class="line">var p1 = new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    resolve(100);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    <span class="built_in">return</span> value * 2;</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    <span class="built_in">return</span> value * 2;</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    console.log(<span class="string">"finally: "</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">finally: 100</span><br><span class="line"></span><br><span class="line">//方法2：对 <span class="keyword">then</span> 进行 promise chain 方式进行调用</span><br><span class="line">var p2 = new Promise(<span class="keyword">function</span> (resolve) &#123;</span><br><span class="line">    resolve(100);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    <span class="built_in">return</span> value * 2;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    <span class="built_in">return</span> value * 2;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    console.log(<span class="string">"finally: "</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">finally: 400</span><br></pre></td></tr></table></figure>
<ul>
<li>第一种方法中，<code>then</code>的调用几乎是同时开始执行的，且传给每个<code>then</code>的value都是100，这种方法应当避免。方法二才是正确的链式调用。</li>
<li><p>因此容易出现下面的错误写法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 例3.4 */</span><br><span class="line"><span class="keyword">function</span> badAsyncCall(data) &#123;</span><br><span class="line">    var promise = Promise.resolve(data);</span><br><span class="line">    promise.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">        //<span class="keyword">do</span> something</span><br><span class="line">        <span class="built_in">return</span> value + 1;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line">badAsyncCall(10).<span class="keyword">then</span>(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">   console.log(value);          //想要得到11，实际输出10</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
</li>
<li><p>正确的写法应该是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 改写例3.4 */</span><br><span class="line"><span class="keyword">function</span> goodAsyncCall(data) &#123;</span><br><span class="line">    var promise = Promise.resolve(data);</span><br><span class="line">    <span class="built_in">return</span> promise.then(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">        //<span class="keyword">do</span> something</span><br><span class="line">        <span class="built_in">return</span> value + 1;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">goodAsyncCall(10).<span class="keyword">then</span>(<span class="keyword">function</span>(value) &#123;</span><br><span class="line">   console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">-------output-------</span><br><span class="line">11</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="情景4：在异步回调中抛错，不会被catch到"><a href="#情景4：在异步回调中抛错，不会被catch到" class="headerlink" title="情景4：在异步回调中抛错，不会被catch到"></a>情景4：在异步回调中抛错，不会被catch到</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Errors thrown inside asynchronous <span class="built_in">functions</span> will act like uncaught errors</span><br><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    throw <span class="string">'Uncaught Exception!'</span>;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="keyword">function</span>(e) &#123;</span><br><span class="line">  console.log(e);       //This is never called</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="情景5：-promise状态变为resove或reject，就凝固了，不会再改变"><a href="#情景5：-promise状态变为resove或reject，就凝固了，不会再改变" class="headerlink" title="情景5： promise状态变为resove或reject，就凝固了，不会再改变"></a>情景5： promise状态变为resove或reject，就凝固了，不会再改变</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">new Promise(<span class="keyword">function</span> (resolve, reject)&#123;</span><br><span class="line">    reject(); //promise状态变为reject</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">        resolve();            //not called</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>()&#123; //跳过这里</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;, <span class="function"><span class="title">function</span></span>()&#123; //等同步过程执行完后执行这里</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br><span class="line"></span><br><span class="line">-------output-------</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    
  <div>
    
      <div>
    
        <div style="text-align:center;color: #666;font-size:14px;">
            ------ 本文结束 ------
        </div>
    
</div>
    
  </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/开发/" rel="tag"><i class="fa fa-tag"></i> 开发</a>
          
            <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          
            <a href="/tags/Promise/" rel="tag"><i class="fa fa-tag"></i> Promise</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/28/ajax/" rel="next" title="前后端交互指南">
                <i class="fa fa-chevron-left"></i> 前后端交互指南
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/02/thinkjs/" rel="prev" title="ThinkJS学习笔记(一)">
                ThinkJS学习笔记(一) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Xiaobing Hong" />
            
              <p class="site-author-name" itemprop="name">Xiaobing Hong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chongtianHong/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:hongxb@mail2.sysu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本介绍"><span class="nav-number">1.</span> <span class="nav-text">基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步与异步"><span class="nav-number">1.1.</span> <span class="nav-text">同步与异步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#同步"><span class="nav-number">1.1.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步"><span class="nav-number">1.1.2.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回调函数"><span class="nav-number">1.1.3.</span> <span class="nav-text">回调函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用Promise"><span class="nav-number">1.2.</span> <span class="nav-text">为什么使用Promise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise的基本用法"><span class="nav-number">2.</span> <span class="nav-text">Promise的基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本用法"><span class="nav-number">2.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本API"><span class="nav-number">2.2.</span> <span class="nav-text">基本API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#then"><span class="nav-number">2.2.1.</span> <span class="nav-text">.then()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#catch"><span class="nav-number">2.2.2.</span> <span class="nav-text">.catch()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#all"><span class="nav-number">2.2.3.</span> <span class="nav-text">.all()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#race"><span class="nav-number">2.2.4.</span> <span class="nav-text">.race()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#resolve"><span class="nav-number">2.2.5.</span> <span class="nav-text">.resolve()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reject"><span class="nav-number">2.2.6.</span> <span class="nav-text">.reject()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise常见问题"><span class="nav-number">3.</span> <span class="nav-text">Promise常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#情景1：reject-和-catch-的区别"><span class="nav-number">3.1.</span> <span class="nav-text">情景1：reject 和 catch 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#情景2：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误"><span class="nav-number">3.2.</span> <span class="nav-text">情景2：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#情景3：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据"><span class="nav-number">3.3.</span> <span class="nav-text">情景3：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#情景4：在异步回调中抛错，不会被catch到"><span class="nav-number">3.4.</span> <span class="nav-text">情景4：在异步回调中抛错，不会被catch到</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#情景5：-promise状态变为resove或reject，就凝固了，不会再改变"><span class="nav-number">3.5.</span> <span class="nav-text">情景5： promise状态变为resove或reject，就凝固了，不会再改变</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiaobing Hong</span>

  
</div>









<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
&nbsp本站访客数&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人&nbsp
</span>
<span>&nbsp|&nbsp</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
&nbsp本站总访问量&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次
</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
