<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2019-01-27T13:04:58.997Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单跨域请求和复杂跨域请求的区别</title>
    <link href="https://chongtianhong.github.io/2018/07/07/crossOriginResourceSharing/"/>
    <id>https://chongtianhong.github.io/2018/07/07/crossOriginResourceSharing/</id>
    <published>2018-07-07T08:21:27.000Z</published>
    <updated>2019-01-27T13:04:58.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><strong>跨域</strong>是因为浏览器有<strong>同源策略</strong>的限制，一段脚本只能读取来自<strong>同一来源</strong>的窗口和文档的属性，只要来源的<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>有任何一个不同，都被当作是不同的域，网站间的数据请求与传输便构成了<strong>跨域调用</strong>，因此便会受到<strong>同源策略</strong>的限制。 <a id="more"></a></li></ul><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ul><li>一个域是由<strong>协议（schema）</strong>、<strong>域名（host）</strong>、<strong>端口（port）</strong>三者共同组成，<strong>与路径无关</strong>。</li><li><strong>跨域资源共享</strong>(Cross-Origin Resource Sharing, CORS)是为解决<strong>Ajax技术难实现跨域问题</strong>而提出的一个规范，这个规范试着<strong>从根本上解决安全的跨域资源共享问题</strong>。在此之前，解决此类问题的途径往往是<strong>服务器代理</strong>、<strong>JSONP</strong>等，治标不治本。目前基本所有浏览器都已经支持该规范。</li><li>CORS是通过<strong>客户端 + 服务端协作声明</strong>的方式来确保请求安全的。</li><li>CORS约定<strong>服务器端</strong>和<strong>浏览器</strong>在HTTP协议之上，通过一些<strong>额外HTTP头部信息</strong>，进行<strong>跨域资源共享</strong>的协商。服务器端和浏览器都必需遵循规范中的要求。<ul><li>服务端会在<strong>HTTP请求头</strong>中增加一系列HTTP请求参数(例如<code>Access-Control-Allow-Origin</code>等)，来限制哪些域的请求和声明哪些请求类型可以接受。</li><li>客户端<strong>在发起请求时</strong>必须<strong>声明自己的源(Orgin)</strong>，否则服务器将不予处理，如果客户端不作声明，请求甚至会被浏览器直接拦截都到不了服务端。(<strong>对于支持CORS的浏览器，请求头会自动添加Origin，值为当前host</strong>)</li><li>服务端收到HTTP请求后会<strong>进行域的比较</strong>，只有<strong>同域的请求</strong>才会处理。</li></ul></li></ul><h4 id="CORS中HTTP请求的分类"><a href="#CORS中HTTP请求的分类" class="headerlink" title="CORS中HTTP请求的分类"></a>CORS中HTTP请求的分类</h4><ul><li>最近在使用CORS的时候，由于需要<strong>使用<code>PUT</code>和<code>DELETE</code>等请求方法</strong>，发现原来<strong>CORS的规范定义远不止这些</strong>。</li><li>CORS把HTTP请求分成<strong>两类</strong>，不同类别按不同的策略进行<strong>跨域资源共享</strong>协商，这两类请求分别是：<ul><li>简单跨域请求</li><li>复杂跨域请求，即带预检(Preflighted)的跨域请求</li></ul></li></ul><h5 id="简单跨域请求"><a href="#简单跨域请求" class="headerlink" title="简单跨域请求"></a>简单跨域请求</h5><ul><li>当HTTP请求出现以下两种情况时，浏览器认为是<strong>简单跨域请求</strong>：<br>1). 请求方法是<code>GET</code>、<code>HEAD</code>或者<code>POST</code>，并且当请求方法是<code>POST</code>时，Content-Type必须是<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>或着<code>text/plain</code>中的一个值。<br>2). 请求中<strong>没有自定义HTTP头部</strong>。</li><li>对于简单跨域请求，浏览器要做的就是<strong>在HTTP请求中添加Origin Header</strong>，将JavaScript脚本所在域填充进去，向其他域的服务器请求资源。服务器端收到一个简单跨域请求后，根据资源权限配置，在响应头中添加<code>Access-Control-Allow-Origin Header</code>。浏览器收到响应后，查看<code>Access-Control-Allow-Origin Header</code>，如果<strong>当前域已经得到授权</strong>，则<strong>将结果返回给JavaScript</strong>。<strong>否则浏览器忽略此次响应</strong>。</li></ul><h5 id="带预检-Preflighted-的跨域请求"><a href="#带预检-Preflighted-的跨域请求" class="headerlink" title="带预检(Preflighted)的跨域请求"></a>带预检(Preflighted)的跨域请求</h5><ul><li>当HTTP请求出现以下两种情况时，浏览器认为是<strong>带预检(Preflighted)的跨域请求</strong>：<br>1). 除<code>GET</code>、<code>HEAD</code>和<code>POST</code>(only with application/x-www-form-urlencoded, multipart/form-data, text/plain Content-Type)以外的<strong>其他HTTP方法</strong>。<br>2). 请求中<strong>出现自定义HTTP头部</strong>。</li><li>“预检”其实相当于做检查，检查如果通过则允许传输数据，检查不通过则不再发送真正想要发送的消息。</li></ul><blockquote>浏览器端</blockquote><ul><li><strong>带预检(Preflighted)的跨域</strong>请求需要<strong>浏览器</strong>在<strong>发送真实HTTP请求之前先发送一个OPTIONS的预检请求</strong>，检测<strong>服务器端</strong>是否支持真实请求进行跨域资源访问。</li><li>真实请求的信息在<code>OPTIONS</code>请求中通过<code>Access-Control-Request-Method Header</code>和<code>Access-Control-Request-Headers Header</code>描述。</li><li>此外，与简单跨域请求一样，<strong>浏览器</strong>也会<strong>添加Origin Header</strong>。</li><li><strong>注</strong>：<strong>带预检(Preflighted)的跨域请求</strong>的<strong>第一次请求</strong>，header中不会带自定义的header头信息。表示<strong>真实请求的自定义Header列表</strong>的是<code>Access-Control-Request-Headers</code>HTTP<strong>请求头</strong>。</li></ul><blockquote>服务器端</blockquote><ul><li><strong>服务器端</strong>接到<strong>预检请求</strong>后，根据资源权限配置，在<strong>响应头</strong>中放入<code>Access-Control-Allow-Origin Header</code>、<code>Access-Control-Allow-Methods</code>和<code>Access-Control-Allow-Headers Header</code>，分别表示允许跨域资源请求的<strong>域</strong>、<strong>请求方法</strong>和<strong>请求头</strong>。</li><li>此外，服务器端还可以加入<code>Access-Control-Max-Age Header</code>，允许浏览器<strong>在指定时间内，无需再发送预检请求进行协商</strong>，直接用本次协商结果即可。</li></ul><blockquote>浏览器端</blockquote><ul><li>浏览器根据<code>OPTIONS</code>请求返回的结果来<strong>决定是否继续发送真实的请求</strong>进行跨域资源访问。这个过程对<strong>真实请求的调用者</strong>来说是<strong>透明</strong>的。</li></ul><h4 id="CORS协议规定的HTTP头"><a href="#CORS协议规定的HTTP头" class="headerlink" title="CORS协议规定的HTTP头"></a>CORS协议规定的HTTP头</h4><ul><li><code>XMLHttpRequest</code>支持通过<code>withCredentials</code>属性实现<strong>在跨域请求携带身份信息</strong>(Credential，例如Cookie或者HTTP认证信息)。</li><li><p>跨域请求<strong>默认不会携带Cookie信息</strong>，如果需要携带，请配置下述参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 服务端</span><br><span class="line"><span class="string">"Access-Control-Allow-Credentials"</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 客户端需要设置withCredentials</span><br><span class="line">// Ajax设置</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>浏览器将携带Cookie Header的请求发送到服务器端后，如果服务器没有响应<code>Access-Control-Allow-Credentials Header</code>，那么浏览器会忽略掉这次响应。</p></li><li>这里讨论的HTTP请求是指由<code>Ajax XMLHttpRequest</code>对象发起的，所有的CORS HTTP请求头都<strong>可由浏览器填充，无需在XMLHttpRequest对象中设置</strong>。</li><li>以下是CORS协议规定的HTTP头，用来进行浏览器发起跨域资源请求时进行协商：<ol><li><code>Origin</code>。HTTP<strong>请求头</strong>，任何涉及CORS的请求都必需携带。</li><li><code>Access-Control-Request-Method</code>。HTTP<strong>请求头</strong>，在带预检(Preflighted)的跨域请求中用来表示<strong>真实请求的方法</strong>。</li><li><code>Access-Control-Request-Headers</code>。HTTP<strong>请求头</strong>，在带预检(Preflighted)的跨域请求中用来表示<strong>真实请求的自定义Header列表</strong>。</li><li><code>Access-Control-Allow-Origin</code>。HTTP<strong>响应头</strong>，指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是<strong>在响应一个携带身份信息(Credential)的HTTP请求时</strong>，<code>Access-Control-Allow-Origin</code><strong>必须指定具体的域，不能用通配符</strong>。</li><li><code>Access-Control-Allow-Methods</code>。HTTP<strong>响应头</strong>，指定服务器允许进行跨域资源访问的<strong>请求方法</strong>列表，一般用在<strong>响应预检请求</strong>上。</li><li><code>Access-Control-Allow-Headers</code>。HTTP<strong>响应头</strong>，指定服务器允许进行跨域资源访问的<strong>请求头</strong>列表，一般用在<strong>响应预检请求</strong>上。</li><li><code>Access-Control-Max-Age</code>。HTTP<strong>响应头</strong>，用在<strong>响应预检请求</strong>上，表示<strong>本次预检响应的有效时间</strong>。<strong>在此时间内</strong>，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而<strong>无需再次发送预检请求</strong>。</li><li><code>Access-Control-Allow-Credentials</code>。HTTP<strong>响应头</strong>，凡是<strong>浏览器请求中携带了身份信息</strong>，而<strong>响应头中没有返回</strong><code>Access-Control-Allow-Credentials: true</code>的，<strong>浏览器都会忽略此次响应</strong>。</li></ol></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>同时满足以下两个条件时，则是简单请求，否则为复杂请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、请求方式：HEAD、GET、POST</span><br><span class="line">2、请求头信息不超出以下几种字段：</span><br><span class="line">    Accept</span><br><span class="line">    Accept-Language</span><br><span class="line">    Content-Language</span><br><span class="line">    Last-Event-ID</span><br><span class="line">    Content-Type 对应的值是以下三个中的任意一个:</span><br><span class="line">        application/x-www-form-urlencoded</span><br><span class="line">        multipart/form-data</span><br><span class="line">        text/plain</span><br></pre></td></tr></table></figure></li><li><p>简单请求和复杂请求（<strong>带预检(Preflighted)的跨域</strong>请求）的区别：</p><ul><li>简单请求：一次请求。</li><li>复杂请求：两次请求，它是<strong>对服务器有特殊要求</strong>的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。复杂请求在发送数据之前会先发一次请求用于做“预检”，只有“预检”通过后才再发送第二次请求。</li></ul></li><li>预检请求为<code>OPTIONS</code>请求，用于向服务器请求权限信息的。预检请求被成功响应后，才会发出真实请求，携带真实数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨域&lt;/strong&gt;是因为浏览器有&lt;strong&gt;同源策略&lt;/strong&gt;的限制，一段脚本只能读取来自&lt;strong&gt;同一来源&lt;/strong&gt;的窗口和文档的属性，只要来源的&lt;strong&gt;协议&lt;/strong&gt;、&lt;strong&gt;域名&lt;/strong&gt;、&lt;strong&gt;端口&lt;/strong&gt;有任何一个不同，都被当作是不同的域，网站间的数据请求与传输便构成了&lt;strong&gt;跨域调用&lt;/strong&gt;，因此便会受到&lt;strong&gt;同源策略&lt;/strong&gt;的限制。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="交互" scheme="https://chongtianhong.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="AJAX" scheme="https://chongtianhong.github.io/tags/AJAX/"/>
    
      <category term="跨域" scheme="https://chongtianhong.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目中axios的封装</title>
    <link href="https://chongtianhong.github.io/2018/07/06/encapsulationOfAxiosInVue/"/>
    <id>https://chongtianhong.github.io/2018/07/06/encapsulationOfAxiosInVue/</id>
    <published>2018-07-06T06:36:12.000Z</published>
    <updated>2019-01-27T09:27:15.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>在vue项目中，和<strong>后台交互获取数据</strong>这块，我们通常使用的是<code>axios</code>库，它是基于<code>promise</code>的http库，可运行在浏览器端和<code>node.js</code>中。<code>axios</code>有很多优秀的特性，例如<strong>拦截请求和响应</strong>、<strong>取消请求</strong>、<strong>转换json</strong>、<strong>客户端防御XSRF</strong>等。<a id="more"></a></li><li>在一个完整的项目中，和服务端的交互会很频繁，一个项目会有很多请求，冗余代码很多。所以<strong>将请求封装，统一管理</strong>还是很有必要的。</li><li>本文介绍的<code>axios</code>的封装主要目的就是在<strong>帮助我们简化项目代码</strong>和<strong>利于后期的更新维护</strong>。</li></ul><h3 id="axios的安装"><a href="#axios的安装" class="headerlink" title="axios的安装"></a>axios的安装</h3><ul><li>在项目中使用npm安装<code>axios</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios; // 安装axios</span><br></pre></td></tr></table></figure></li></ul><h3 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h3><ul><li>一般在项目的<code>src</code>目录中会新建一个<code>request</code>文件夹，然后在里面新建一个<code>http.js</code>和一个<code>api.js</code>文件。<code>http.js</code>文件用来<strong>封装<code>axios</code></strong>，而<code>api.js</code>用来<strong>统一管理接口</strong>。</li><li><p>代码示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 在http.js中引入axios</span><br><span class="line">import axios from <span class="string">'axios'</span>; // 引入axios</span><br><span class="line">import QS from <span class="string">'qs'</span>; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br><span class="line">// vant的toast提示框组件，大家可根据自己的ui组件更改。</span><br><span class="line">import &#123; Toast &#125; from <span class="string">'vant'</span>;</span><br></pre></td></tr></table></figure></li><li><p>接下来对封装<code>axios</code>的<code>http.js</code>文件内容进行分析。</p></li></ul><h4 id="设置请求超时"><a href="#设置请求超时" class="headerlink" title="设置请求超时"></a>设置请求超时</h4><ul><li>可以通过<code>axios.defaults.timeout</code>设置默认的<strong>请求超时时间</strong>。例如超过了10s，就会告知用户当前请求超时，请刷新等：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout = 10000;</span><br></pre></td></tr></table></figure></li></ul><h4 id="设置默认请求头"><a href="#设置默认请求头" class="headerlink" title="设置默认请求头"></a>设置默认请求头</h4><ul><li>可以在封装<code>axios</code>的文件中进行一个默认的设置，为<strong>post请求</strong>设置请求头：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h4><ul><li>在<strong>发送请求前</strong>可以进行一个<strong>请求的拦截</strong>。比如，有些请求是需要用户登录之后才能访问的，或者<strong>post请求</strong>的时候，我们需要<strong>序列化我们提交的数据</strong>。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//http 请求拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">// 每次发送请求之前判断cookie中是否存在token</span><br><span class="line">    const token = getCookie(<span class="string">'token'</span>);// 注意使用的时候需要引入cookie方法，推荐js-cookie</span><br><span class="line">    config.data = JSON.stringify(config.data);</span><br><span class="line">    config.headers = &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    &#125;</span><br><span class="line">    // 如存在token，则在请求的header中携带token</span><br><span class="line">    // <span class="keyword">if</span>(token)&#123;</span><br><span class="line">    //   config.headers.Authorization = token;</span><br><span class="line">    // &#125;</span><br><span class="line">    <span class="built_in">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> Promise.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="响应拦截"><a href="#响应拦截" class="headerlink" title="响应拦截"></a>响应拦截</h4><ul><li>与请求拦截类似，在<strong>拿到服务器返回给我们的数据前</strong>可以进行一个<strong>响应的拦截</strong>，从而进行我们想要的操作。如果后台返回的状态码是200，则正常返回数据，否则的<strong>根据错误的状态码类型进行一些我们需要的错误处理</strong>。</li><li>下面的例子主要是进行了<strong>错误的统一处理</strong>和<strong>没登录或登录过期后调整登录页</strong>的操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// vant的toast提示框组件，大家可根据自己项目中使用的ui组件进行更改</span><br><span class="line">import &#123; Toast &#125; from <span class="string">'vant'</span>;</span><br><span class="line"></span><br><span class="line">// 响应拦截器</span><br><span class="line">axios.interceptors.response.use( </span><br><span class="line">  response =&gt; &#123; </span><br><span class="line"> <span class="keyword">if</span> (response.status === 200) &#123;  </span><br><span class="line">        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span><br><span class="line">      <span class="built_in">return</span> Promise.resolve(response); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        // 否则的话抛出错误</span><br><span class="line">      <span class="built_in">return</span> Promise.reject(response); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125;, </span><br><span class="line">  // 后台返回的状态码不是200</span><br><span class="line">  // 这里可以跟后台开发人员协商好统一的错误状态码 </span><br><span class="line">  // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等</span><br><span class="line">  error =&gt; &#123;  </span><br><span class="line"> <span class="keyword">if</span> (error.response.status) &#123;  </span><br><span class="line">    switch (error.response.status) &#123;  </span><br><span class="line">        // 401: 未登录</span><br><span class="line">        // 未登录则跳转登录页面，并携带当前页面的路径</span><br><span class="line">        // 在登录成功后返回当前页面，这一步需要在登录页操作。  </span><br><span class="line">  <span class="keyword">case</span> 401:   </span><br><span class="line">     router.replace(&#123;   </span><br><span class="line">   path: <span class="string">'/login'</span>,   </span><br><span class="line">   query: &#123; </span><br><span class="line">    redirect: router.currentRoute.fullPath </span><br><span class="line">   &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">break</span>;</span><br><span class="line">        // 403 token过期</span><br><span class="line">        // 登录过期对用户进行提示</span><br><span class="line">        // 清除本地token </span><br><span class="line">        // 跳转登录页面  </span><br><span class="line">  <span class="keyword">case</span> 403:</span><br><span class="line">     Toast(&#123;</span><br><span class="line">   message: <span class="string">'登录过期，请重新登录'</span>,</span><br><span class="line">   duration: 1000,</span><br><span class="line">   forbidClick: <span class="literal">true</span></span><br><span class="line">     &#125;);</span><br><span class="line">     // 清除token</span><br><span class="line">     removeCookie(<span class="string">'token'</span>);</span><br><span class="line">     // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 </span><br><span class="line">     setTimeout(() =&gt; &#123;   </span><br><span class="line">   router.replace(&#123;    </span><br><span class="line">      path: <span class="string">'/login'</span>,    </span><br><span class="line">      query: &#123; </span><br><span class="line">        redirect: router.currentRoute.fullPath </span><br><span class="line">      &#125;   </span><br><span class="line">   &#125;);   </span><br><span class="line">     &#125;, 1000);   </span><br><span class="line">     <span class="built_in">break</span>;</span><br><span class="line">  // 404请求不存在</span><br><span class="line">  <span class="keyword">case</span> 404:</span><br><span class="line">     Toast(&#123;</span><br><span class="line">   message: <span class="string">'网络请求不存在'</span>,</span><br><span class="line">   duration: 1500,</span><br><span class="line">   forbidClick: <span class="literal">true</span></span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">break</span>;</span><br><span class="line">  // 其他错误，直接抛出错误提示</span><br><span class="line">  default:</span><br><span class="line">     Toast(&#123;</span><br><span class="line">   message: error.response.data.message,</span><br><span class="line">   duration: 1500,</span><br><span class="line">   forbidClick: <span class="literal">true</span></span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> Promise.reject(error.response);</span><br><span class="line"> &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="封装请求方法"><a href="#封装请求方法" class="headerlink" title="封装请求方法"></a>封装请求方法</h4><ul><li>常用的<strong>ajax请求方法</strong>有<strong>get</strong>、<strong>post</strong>、<strong>put</strong>等方法，<code>axios</code>对应的也有很多类似的方法，具体可移步<a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios文档</a>查看。前面提到为了<strong>简化我们的代码</strong>和<strong>方便项目的后期维护</strong>，我们可以对<code>axios</code>的请求方法进行一个简单的封装。下面我们对<strong>get</strong>和<strong>post</strong>两个方法的封装进行举例。</li></ul><h5 id="get方法的封装"><a href="#get方法的封装" class="headerlink" title="get方法的封装"></a>get方法的封装</h5><ul><li>我们通过定义一个<strong>get</strong>函数：<ul><li><strong>get</strong>函数有两个参数，第一个参数表示我们要<strong>请求的url地址</strong>，第二个参数是我们要<strong>携带的请求参数</strong>。</li><li><strong>get</strong>函数返回一个<code>promise</code>对象，当<code>axios</code>请求成功时<code>resolve</code>服务器返回值，请求失败时<code>reject</code>错误。最后通过<code>export</code>暴露<strong>get</strong>函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * get方法，对应get请求</span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址]</span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数]</span><br><span class="line"> */</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> get(url, queryParams)&#123; </span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt;&#123; </span><br><span class="line"> axios.get(url, &#123;  </span><br><span class="line">    params: queryParams</span><br><span class="line"> &#125;).<span class="keyword">then</span>(response =&gt; &#123;</span><br><span class="line">    resolve(response.data);</span><br><span class="line"> &#125;).catch(error =&gt;&#123;</span><br><span class="line">    reject(error) </span><br><span class="line"> &#125;) </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="post方法的封装"><a href="#post方法的封装" class="headerlink" title="post方法的封装"></a>post方法的封装</h5><ul><li><p><strong>post</strong>的封装原理同<strong>get</strong>基本一样，但是要注意的是，<strong>post</strong>方法必须要使用<strong>对提交参数对象进行序列化</strong>的操作，所以这里我们通过<code>node</code>的<code>qs</code>模块来序列化我们的参数（如果没有序列化操作，后台是拿不到我们提交的数据的）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * post方法，对应post请求 </span><br><span class="line"> * @param &#123;String&#125; url [请求的url地址] </span><br><span class="line"> * @param &#123;Object&#125; params [请求时携带的参数] </span><br><span class="line"> */</span><br><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> post(url, postData) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    axios.post(url, QS.stringify(postData))</span><br><span class="line">  .<span class="keyword">then</span>(res =&gt; &#123;</span><br><span class="line">    resolve(res.data);</span><br><span class="line">  &#125;)</span><br><span class="line"> .catch(err =&gt;&#123;</span><br><span class="line">   reject(err.data)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意：<code>axios.get()</code>方法和<code>axios.post()</code>在提交数据时参数的书写方式还是有区别的，需要留意两者略微的区别：</p><ul><li>get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象。</li><li>post的第二个参数就是一个参数对象。</li></ul></li></ul><h3 id="项目中引入http-js"><a href="#项目中引入http-js" class="headerlink" title="项目中引入http.js"></a>项目中引入http.js</h3><ul><li><p>以vue项目为例，在项目的入口js文件<code>main.js</code>中引入封装好的<code>axios</code>文件（即<code>http.js</code>），以便在项目中使用已封装好的请求方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;post,fetch,patch,put&#125; from <span class="string">'./utils/http'</span></span><br><span class="line">//定义全局变量</span><br><span class="line">Vue.prototype.<span class="variable">$post</span>=post;</span><br><span class="line">Vue.prototype.<span class="variable">$get</span>=get;</span><br></pre></td></tr></table></figure></li><li><p>可以在组件里直接使用（以get方法为例）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span></span>()&#123;</span><br><span class="line">  this.<span class="variable">$get</span>(<span class="string">'/api/getMenuList'</span>, &#123;levels: 1&#125;)</span><br><span class="line">    .<span class="keyword">then</span>((response) =&gt; &#123;</span><br><span class="line">      console.log(response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然而，为了<strong>后期代码的可维护性</strong>，一般会新建一个<code>api.js</code>做统一的接口管理。把api统一集中起来，如果后期需要修改接口，我们就直接在<code>api.js</code>中找到对应的修改就好了，而不用去每一个页面都去查找我们的接口然后再修改。如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。</p></li></ul><h3 id="为何不使用vue-resource的原因"><a href="#为何不使用vue-resource的原因" class="headerlink" title="为何不使用vue-resource的原因"></a>为何不使用vue-resource的原因</h3><ul><li>Vue.js是<strong>数据驱动</strong>的，这使得我们并不需要直接操作DOM。jQuery主要用于<strong>简化dom操作</strong>，其中也封装了<code>ajax</code>方法，然而，如果我们不需要使用jQuery的DOM选择器，就没有必要引入jQuery。</li><li><code>vue-resource</code>是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，<code>$.ajax</code>能做的事情，<code>vue-resource</code>插件一样也能做到，而且<code>vue-resource</code>的API更为简洁。至于详细介绍请移步<code>vue-resource</code>文档。</li><li>虽然<code>vue-resource</code>体积小、也基于promise的形式实现了各种http请求，包括各个环境的兼容处理，也有拦截器方面的功能。然而，vue2.0之后，就不再对<code>vue-resource</code>更新，而是推荐使用<code>axios</code>，这大概就是现大多项目使用的<code>axios</code>来做<strong>数据请求</strong>真正的原因吧。</li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios官方文档</a></li><li><a href="https://www.jianshu.com/p/0229211ea679" target="_blank" rel="noopener">axios封装和使用</a></li><li><a href="https://www.cnblogs.com/pengfei-nie/p/9090033.html" target="_blank" rel="noopener">vue2.0 axios封装、vuex介绍</a></li><li><a href="https://www.cnblogs.com/ldlx-mars/p/7908950.html" target="_blank" rel="noopener">vue中axios的封装</a></li><li><a href="https://www.npmjs.com/package/vue-resource" target="_blank" rel="noopener">vue-resource官方文档</a> </li><li><a href="https://blog.csdn.net/oqqakun1/article/details/80842959" target="_blank" rel="noopener">vue-resource对比axios</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在vue项目中，和&lt;strong&gt;后台交互获取数据&lt;/strong&gt;这块，我们通常使用的是&lt;code&gt;axios&lt;/code&gt;库，它是基于&lt;code&gt;promise&lt;/code&gt;的http库，可运行在浏览器端和&lt;code&gt;node.js&lt;/code&gt;中。&lt;code&gt;axios&lt;/code&gt;有很多优秀的特性，例如&lt;strong&gt;拦截请求和响应&lt;/strong&gt;、&lt;strong&gt;取消请求&lt;/strong&gt;、&lt;strong&gt;转换json&lt;/strong&gt;、&lt;strong&gt;客户端防御XSRF&lt;/strong&gt;等。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="交互" scheme="https://chongtianhong.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="AJAX" scheme="https://chongtianhong.github.io/tags/AJAX/"/>
    
      <category term="Promise" scheme="https://chongtianhong.github.io/tags/Promise/"/>
    
      <category term="Vue.js" scheme="https://chongtianhong.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>细说后端模板渲染、客户端渲染、node 中间层、服务器端渲染（ssr）</title>
    <link href="https://chongtianhong.github.io/2018/07/05/developmentOfFEandBErenderingMethods/"/>
    <id>https://chongtianhong.github.io/2018/07/05/developmentOfFEandBErenderingMethods/</id>
    <published>2018-07-05T03:52:22.000Z</published>
    <updated>2018-10-18T04:55:16.389Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>前端与后端渲染方式的发展</strong>大致经历了这样几个阶段：后端模板渲染、客户端渲染、node 中间层、服务器端渲染（ssr）。<a id="more"></a></li></ul><h4 id="后端模板渲染"><a href="#后端模板渲染" class="headerlink" title="后端模板渲染"></a>后端模板渲染</h4><ul><li>前端与后端最初的渲染方式是<strong>后端模板渲染</strong>，就是由<strong>后端使用模板引擎渲染好 <code>html</code></strong> 后，返回给前端，<strong>前端再用 <code>js</code> 去操作 <code>dom</code> 或者渲染其他动态的部分</strong>。</li><li>这个过程大致分成以下几个步骤：<br><img src="/images/developmentOfFEandBErenderingMethods1.png" alt="后端模板渲染过程" width="600" style="border:none"><br>1.前端请求一个地址 <code>url</code><br>2.后端接收到这个请求，然后根据请求信息，从数据库或者其他地方获取相应的数据<br>3.使用模板引擎（如 <code>java &gt; jsp、php &gt; smarty</code>）将这些数据渲染成 <code>html</code><br>4.将 <code>html</code> 文本返回给前端</li><li>在这个过程中，前端的 <code>html</code> 代码需要嵌入到后端代码中（如 <code>java、php</code>），并且<strong>在很多情况下</strong>，<strong>前端源代码和后端源代码是在一个工程里的</strong>。</li><li>所以，不难看出，这种方式的有这样的几个不足：<br>1.前后端杂揉在一起，不方便本地开发、本地模拟调试，也不方便自动化测试。<br>2.前端被约束在后端开发的模式中，不能充分使用前端的构建生态，开发效率低下。<br>3.项目难以管理和维护，也可能会有前后端职责不清的问题。</li><li>尽管如此，但因为这种方式是最早出现的方式，并且这种渲染方式有一个<strong>好处</strong>，就是<strong>前端能够快速呈现服务器端渲染好的页面</strong>，而不用等客户端渲染，这<strong>能够提供很好的用户体验与 SEO 友好</strong>，所以当下很多比较早的网站或者需要快速响应的展示性网站仍然是使用这种方式。</li></ul><h4 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h4><ul><li>随着<strong>前端工程化</strong>与<strong>前后端分离</strong>的发展，以及<strong>前端组件化技术</strong>的出现，如 <code>react</code>、<code>vue</code> 等，<strong>客户端渲染</strong>已经慢慢变成了主要的开发方式了。</li><li>与后端模板渲染刚好相反，<strong>客户端渲染</strong>的<strong>页面渲染都是在客户端进行，后端不负责任何的渲染，只管数据交互</strong>。</li><li>这个过程大致分成以下几个步骤：<br><img src="/images/developmentOfFEandBErenderingMethods2.png" alt="客户端渲染过程" width="600" style="border:none"><br>1.前端请求一个地址 <code>url</code><br>2.后端接收到这个请求，然后把相应的 <code>html</code> 文件直接返回给前端<br>3.前端解析 <code>js</code> 后，然后通过 <code>ajax</code> 向后台获取相应的数据<br>4.然后由 <code>js</code> 将这些数据渲染成页面</li><li>这样一来，前端与后端将完全解耦，数据使用全 <code>ajax</code> 的方式进行交互，如此便可<strong>前后端分离</strong>了。</li><li>其实，不难看出，<strong>客户端渲染</strong>与<strong>前后端分离</strong>有很大的好处：<br>1.前端独立出来，可以充分使用前端生态的强大功能。<br>2.更好的管理代码，更有效率的开发、调试、测试。<br>3.前后端代码解耦之后，能更好的扩展、重构。</li><li>所以，客户端渲染与前后端分离现在已经是主流的开发方式了。但这种方式也有一些不足：<br>1.<strong>首屏加载缓慢</strong>，因为要等 js 加载完毕后，才能进行渲染。<br>2.<strong>SEO 不友好</strong>，因为 html 中几乎没有可用的信息。</li></ul><h4 id="node-中间层"><a href="#node-中间层" class="headerlink" title="node 中间层"></a>node 中间层</h4><ul><li>为了解决客户端渲染的不足，便出现了 node 中间层的理念。</li><li>传统的 B/S 架构中，是 <code>浏览器 -&gt; 后端服务器 -&gt; 浏览器</code>，上文所讲的都是这种架构。</li><li>而加入了 <strong>node 中间层</strong>之后，就变成 <code>浏览器 -&gt; node -&gt; 后端服务器 -&gt; node -&gt; 浏览器</code>。</li><li>这个过程大致分成以下几个步骤：<br><img src="/images/developmentOfFEandBErenderingMethods3.png" alt="加入node 中间层后的过程" width="600" style="border:none"><br>1.前端请求一个地址 <code>url</code><br>2.node 层接收到这个请求，然后根据请求信息，向后端服务器发起请求，获取数据<br>3.后端服务器接收到请求，然后根据请求信息，从数据库或者其他地方获取相应的数据，返回给 node 层<br>4.node 层根据这些数据渲染好首屏 <code>html</code><br>5.node 层将 <code>html</code> 文本返回给前端</li><li>一个<strong>典型的 node 中间层应用</strong>就是<strong>后端提供数据、node 层渲染模板、前端动态渲染</strong>。</li><li>这个过程中，node 层由前端开发人员掌控，页面中哪些页面在服务器上就渲染好，哪些页面在客户端渲染，由前端开发人员决定。这样做，达到了以下的目的：<br>1.保留<strong>后端模板渲染</strong>、<strong>首屏快速响应</strong>、<strong>SEO 友好</strong><br>2.保留<strong>前端后分离</strong>、<strong>客户端渲染</strong>的功能（首屏服务器端渲染、其他客户端渲染）</li><li>但这种方式也有一些不足：<br>1.增加了一个中间层，应用性能有所降低<br>2.增加了架构的复杂度、不稳定性，降低应用的安全性<br>3.对开发人员要求高了很多</li></ul><h4 id="服务器端渲染（ssr）"><a href="#服务器端渲染（ssr）" class="headerlink" title="服务器端渲染（ssr）"></a>服务器端渲染（ssr）</h4><ul><li><strong>大部分情况下</strong>，服务器端渲染（ssr）与 node 中间层是同一个概念。</li><li>服务器端渲染（ssr）一般特指，<strong>在 node 中间层基础上，加上前端组件化技术在服务器上的渲染</strong>，特别是 react 和 vue。</li><li>react、vue、angular 等框架的出现，让前端组件化技术深入人心，但<strong>在一些需要首屏快速加载与 SEO 友好的页面</strong>就陷入了两难的境地了。</li><li>因为<strong>前端组件化技术天生就是给客户端渲染用的</strong>，而在服务器端需要被渲染成<code>html</code> 文本，这确实不是一件很容易的事，所以<strong>服务器端渲染（ssr）</strong>就是为了解决这个问题。</li><li>好在社区一直在不断的探索中，<strong>让前端组件化能够在服务器端渲染</strong>，比如 next.js、nuxt.js、razzle、react-server、beidou 等。</li><li>一般这些框架都会有一些目录结构、书写方式、组件集成、项目构建的要求，自定义属性可能不是很强。</li><li>以 next.js 为例，整个应用中是没有 <code>html</code> 文件的，所有的响应 <code>html</code> 都是 node 动态渲染的，包括里面的元信息、<code>css</code>, <code>js</code> 路径等。<strong>渲染过程中</strong>，next.js 会<strong>根据路由，将首页所有的组件渲染成 <code>html</code>，余下的页面保留原生组件的格式，在客户端渲染</strong>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>不需要</strong>首屏快速加载、SEO 友好的（后端模板渲染的优势），用<strong>全客户端渲染</strong>。</li><li><strong>需要</strong>首屏快速加载、SEO 友好的，如果用了如 react、vue 等组件化技术，将不得不用 <strong>node 中间层与服务器端渲染</strong>。</li><li>如果技术团队不支持，<strong>不建议</strong>在需要首屏快速加载、SEO 友好的地方使用如 react、vue 等组件化技术。</li><li><strong>前后端分离之后也可以做后端模板渲染</strong>，这样前端的调试可以搭配 handlebars、ejs 等模板引擎进行本地调试，而后端的调试则需要到测试机了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端与后端渲染方式的发展&lt;/strong&gt;大致经历了这样几个阶段：后端模板渲染、客户端渲染、node 中间层、服务器端渲染（ssr）。
    
    </summary>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="后端模板渲染" scheme="https://chongtianhong.github.io/tags/%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/"/>
    
      <category term="客户端渲染" scheme="https://chongtianhong.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
      <category term="服务器端渲染（ssr）" scheme="https://chongtianhong.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%88ssr%EF%BC%89/"/>
    
      <category term="前后端分离" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>VScode中用sftp自动上传 | 服务端用pm2自动重启</title>
    <link href="https://chongtianhong.github.io/2018/07/04/sftpAndPM2/"/>
    <id>https://chongtianhong.github.io/2018/07/04/sftpAndPM2/</id>
    <published>2018-07-04T02:04:26.000Z</published>
    <updated>2018-10-12T08:38:39.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h4><h5 id="sftp-的安装和配置"><a href="#sftp-的安装和配置" class="headerlink" title="sftp 的安装和配置"></a>sftp 的安装和配置</h5><ul><li><p>在Visual Studio Code 中<strong>安装 sftp 扩展</strong>，安装完成后在<strong>工作空间</strong>中，按<code>Ctrl + Shift + P</code>并输入：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp config</span><br></pre></td></tr></table></figure></li><li><p>这个指令会在<code>.vscode</code>中添加<code>sftp.json</code>文件，按需求修改其中的项目，示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">""</span>,     // 服务器ip</span><br><span class="line">    <span class="string">"port"</span>: 22,     // 端口，sftp模式是22</span><br><span class="line">    <span class="string">"username"</span>: <span class="string">""</span>, // 用户名</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">""</span>, // 密码</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"sftp"</span>, // 模式</span><br><span class="line">    <span class="string">"agent"</span>: null,  </span><br><span class="line">    <span class="string">"privateKeyPath"</span>: null,</span><br><span class="line">    <span class="string">"passphrase"</span>: null,</span><br><span class="line">    <span class="string">"passive"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"interactiveAuth"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"remotePath"</span>: <span class="string">"/root/node/build/"</span>,  // 服务器上的文件地址</span><br><span class="line">    <span class="string">"context"</span>: <span class="string">"./server/build"</span>,        // 本地的文件地址</span><br><span class="line">    </span><br><span class="line">    <span class="string">"uploadOnSave"</span>: <span class="literal">true</span>,   // 监听保存并上传</span><br><span class="line">    <span class="string">"syncMode"</span>: <span class="string">"update"</span>,</span><br><span class="line">    <span class="string">"watcher"</span>: &#123;            // 监听外部文件</span><br><span class="line">        <span class="string">"files"</span>: <span class="literal">false</span>,     // 外部文件的绝对路径</span><br><span class="line">        <span class="string">"autoUpload"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"autoDelete"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"ignore"</span>: [             // 忽略项</span><br><span class="line">        <span class="string">"**/.vscode/**"</span>,</span><br><span class="line">        <span class="string">"**/.git/**"</span>,</span><br><span class="line">        <span class="string">"**/.DS_Store"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：其中的注释不能保留。</p></li></ul><h5 id="sftp-的使用"><a href="#sftp-的使用" class="headerlink" title="sftp 的使用"></a>sftp 的使用</h5><ul><li><p>按<code>Ctrl + Shift + P</code>并输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp Upload</span><br></pre></td></tr></table></figure></li><li><p>即可将项目上传到服务器中。类似的指令还有：</p></li></ul><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">SFTP Upload</td><td style="text-align:center">上传到服务器，没有则创建，有则覆盖，多则忽略</td></tr><tr><td style="text-align:center">SFTP Download</td><td style="text-align:center">下载到本地，规则同上</td></tr><tr><td style="text-align:center">SFTP Sync To Remote</td><td style="text-align:center">同步到服务器，多则删除</td></tr><tr><td style="text-align:center">SFTP Sync To Local</td><td style="text-align:center">同步到本地，多则删除</td></tr></tbody></table><ul><li>若想单独操作项目中的某个文件，则右键，选择以上指令即可。</li></ul><h4 id="pm2-自动重载"><a href="#pm2-自动重载" class="headerlink" title="pm2 自动重载"></a>pm2 自动重载</h4><h5 id="安装-pm2"><a href="#安装-pm2" class="headerlink" title="安装 pm2"></a>安装 pm2</h5><ul><li><p>登录服务器，输入以下指令安装pm2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g pm2</span><br></pre></td></tr></table></figure></li><li><p>检查是否安装成功，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 -v</span><br></pre></td></tr></table></figure></li><li><p>如果和下面一样出现版本信息，则安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_16_centos ~]<span class="comment"># pm2 -v</span></span><br><span class="line">2.9.1</span><br></pre></td></tr></table></figure></li><li><p>如果没有出现版本信息，而是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_16_centos ~]<span class="comment"># pm2 -v</span></span><br><span class="line">-bash: pm2: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure></li><li><p>则可能是<strong>npm的环境变量没有配置好</strong>，参考<a href="http://www.cnblogs.com/AmosLee94/p/8337956.html" target="_blank" rel="noopener">CentOS 中永久修改环境变量</a>。</p></li></ul><h5 id="通过pm2启动node-js服务并监听文件变化时自动重启"><a href="#通过pm2启动node-js服务并监听文件变化时自动重启" class="headerlink" title="通过pm2启动node.js服务并监听文件变化时自动重启"></a>通过pm2启动node.js服务并监听文件变化时自动重启</h5><ul><li><p>使用指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start server.js --watch</span><br></pre></td></tr></table></figure></li><li><p>成功则显示如下：<br><img src="/images/sftpAndPM2.png" alt="进程成功开启" width="600" style="border:none"></p></li><li>补充：执行<code>pm2 list</code>，可以看到node进程列表。如果要开启，执行<code>pm2 start + 对应id</code>，关闭则使用：<code>pm2 stop + 对应id</code>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>如果我们希望<strong>编写的代码保存后，自动上传</strong>、并且不<strong>用再切换到xshell中去操作远程端</strong>（使用<code>rz -bey</code>从本地win上传文件到远端linux、使用<code>sz –bey </code>从远端linux传输文件到本地win）。那么上面的方法已经实现了。</li><li>但是事情往往没有那么简单，<strong>sftp的保存并上传功能</strong>，<strong>只能监听到保存这一动作</strong>，而<strong>无法监听到构建工具构建出来的文件</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;sftp&quot;&gt;&lt;a href=&quot;#sftp&quot; class=&quot;headerlink&quot; title=&quot;sftp&quot;&gt;&lt;/a&gt;sftp&lt;/h4&gt;&lt;h5 id=&quot;sftp-的安装和配置&quot;&gt;&lt;a href=&quot;#sftp-的安装和配置&quot; class=&quot;headerlink&quot; title=&quot;sftp 的安装和配置&quot;&gt;&lt;/a&gt;sftp 的安装和配置&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Visual Studio Code 中&lt;strong&gt;安装 sftp 扩展&lt;/strong&gt;，安装完成后在&lt;strong&gt;工作空间&lt;/strong&gt;中，按&lt;code&gt;Ctrl + Shift + P&lt;/code&gt;并输入：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="工具使用" scheme="https://chongtianhong.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux cd命令</title>
    <link href="https://chongtianhong.github.io/2018/07/03/cdOfLinux/"/>
    <id>https://chongtianhong.github.io/2018/07/03/cdOfLinux/</id>
    <published>2018-07-03T06:54:59.000Z</published>
    <updated>2018-10-10T13:51:24.343Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Linux cd命令用于<strong>切换当前工作目录至 dirName(目录参数)</strong>。</li><li>其中 dirName 表示法可为<strong>绝对路径</strong>或<strong>相对路径</strong>。若<strong>目录名称省略</strong>，则<strong>变换至使用者的 home 目录</strong> (也就是<strong>刚 login 时所在的目录</strong>)。<a id="more"></a></li><li>另外，”~” 也表示为 <strong>home 目录</strong> 的意思，”.” 则是表示<strong>目前所在的目录</strong>，”..” 则表示<strong>目前目录位置的上一层目录</strong>。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [dirName]</span><br></pre></td></tr></table></figure></li><li><p>dirName为<strong>要切换的目标目录</strong>。</p></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li><p>跳到<code>/usr/bin/</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br></pre></td></tr></table></figure></li><li><p>跳到自己的<code>home 目录</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">或</span><br><span class="line"><span class="built_in">cd</span></span><br></pre></td></tr></table></figure></li><li><p>跳到<code>目前目录的上上两层</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux cd命令用于&lt;strong&gt;切换当前工作目录至 dirName(目录参数)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;其中 dirName 表示法可为&lt;strong&gt;绝对路径&lt;/strong&gt;或&lt;strong&gt;相对路径&lt;/strong&gt;。若&lt;strong&gt;目录名称省略&lt;/strong&gt;，则&lt;strong&gt;变换至使用者的 home 目录&lt;/strong&gt; (也就是&lt;strong&gt;刚 login 时所在的目录&lt;/strong&gt;)。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="linux" scheme="https://chongtianhong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>iframe的知识点</title>
    <link href="https://chongtianhong.github.io/2018/07/02/iframe/"/>
    <id>https://chongtianhong.github.io/2018/07/02/iframe/</id>
    <published>2018-07-02T07:34:10.000Z</published>
    <updated>2018-10-09T14:57:25.552Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>有人说，iframe是<strong>能耗最高</strong>的一个元素，<strong>尽量减少使用</strong>。也有人说，iframe的<strong>安全性太差</strong>，<strong>尽量减少使用</strong>。</li><li>尽管如此，但是<strong>iframe的强大功能是不容忽视的</strong>，而且现在不乏公司正在使用它。<a id="more"></a></li><li>&lt;iframe&gt;标签<strong>规定一个内联框架</strong>。一个内联框架被用来<strong>在当前 HTML 文档中嵌入另一个文档</strong>。</li><li>所有的主流浏览器都支持&lt;iframe&gt;标签。我们可以<strong>把提示的文字放到 &lt;iframe&gt; 和 &lt;/iframe&gt;里面</strong>，这样<strong>不支持 &lt;iframe&gt;的浏览器就会出现提示的文字</strong>。</li></ul><h4 id="iframe-的使用"><a href="#iframe-的使用" class="headerlink" title="iframe 的使用"></a>iframe 的使用</h4><ul><li><p>通常我们使用iframe可以直接<strong>在iframe标签指定src</strong>，规定想要<strong>嵌套的页面URL</strong>就可以了。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    &lt;iframe&gt; 标签规定一个内联框架</span><br><span class="line">    这里写p 标签是为了看align的效果</span><br><span class="line">--&gt;</span><br><span class="line">&lt;p style=<span class="string">"overflow: hidden;"</span>&gt;这是一些文本。 这是一些文本。 这是一些文本。这是一些文本。 这是一些文本。 这是一些文本。</span><br><span class="line">    &lt;iframe name=<span class="string">"myiframe"</span> id=<span class="string">"myrame"</span> src=<span class="string">"external_file.html"</span> frameborder=<span class="string">"0"</span> align=<span class="string">"left"</span> width=<span class="string">"200"</span> height=<span class="string">"200"</span> scrolling=<span class="string">"no"</span>&gt;</span><br><span class="line">        &lt;p&gt;你的浏览器不支持iframe标签&lt;/p&gt;</span><br><span class="line">    &lt;/iframe&gt;</span><br><span class="line">这是一些文本。 这是一些文本。 这是一些文本。这是一些文本。 这是一些文本。 这是一些文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>iframe 的常用属性：</p><ul><li><strong>name</strong>：规定 &lt;iframe&gt; 的名称。</li><li><strong>width</strong>：规定 &lt;iframe&gt; 的宽度。</li><li><strong>height</strong>：规定 &lt;iframe&gt; 的高度。</li><li><strong>src</strong>：规定在 &lt;iframe&gt; 中显示的文档的 URL。</li><li><strong>frameborder</strong>：规定是否显示 &lt;iframe&gt; 周围的边框。 (0为无边框，1位有边框)。</li><li><strong>align</strong>：规定如何根据周围的元素来对齐 &lt;iframe&gt;。　(left,right,top,middle,bottom)。</li><li><strong>scrolling</strong>：规定是否在 &lt;iframe&gt; 中显示滚动条。 (yes,no,auto)</li></ul></li><li>上面代码中将 iframe 的src属性设置为自己本地的一个html页面。</li></ul><h4 id="iframe里面的内容获取"><a href="#iframe里面的内容获取" class="headerlink" title="iframe里面的内容获取"></a>iframe里面的内容获取</h4><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var iframe = document.getElementById(<span class="string">"myrame"</span>); //获取iframe标签</span><br><span class="line">var iwindow = iframe.contentWindow; //获取iframe的window对象</span><br><span class="line">var idoc = iwindow.document; //获取iframe的document对象</span><br><span class="line">console.log(idoc.documentElement); //获取iframe的html</span><br><span class="line">console.log(<span class="string">"body"</span>, idoc.body);</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用iframe的优缺点"><a href="#使用iframe的优缺点" class="headerlink" title="使用iframe的优缺点"></a>使用iframe的优缺点</h4><ul><li>iframe的<strong>优点</strong>：<br>① iframe能够<strong>原封不动地把嵌入的网页展现出来</strong>。<br>② 如果有多个网页调用iframe，只需要修改iframe的内容，就可以<strong>实现对调用iframe的每一个页面内容的更改，方便快捷</strong>。<br>③ 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以<strong>增加代码的可重用性</strong>。<br>④ 如果<strong>遇到加载缓慢的第三方内容</strong>，如图标和广告等，<strong>可以用iframe来解决</strong>。</li><li>iframe的<strong>缺点</strong>：<br>① 会<strong>产生很多页面</strong>，不容易管理。<br>② 在几个框架中都出现上下、左右滚动条时，这些滚动条除了会<strong>挤占已经非常有限的页面空间</strong>外，还会<strong>分散访问者的注意力</strong>。<br>③ 使用框架结构时，必须保<strong>证正确设置所有的导航链接</strong>，否则会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下访问者便被陷住了，因为此时他没有其他地点可去，导致<strong>链接死循环</strong>。<br>④ 很多的移动设备（PDA手机）无法完全显示框架，设备兼容性差。<br>⑤ iframe框架页面会<strong>增加服务器的http请求</strong>，对于大型网站是不可取的。</li><li>注意：由于诸多的缺点，不符合标准网页设计的理念，已经被抛弃，目前的<strong>HTML5不再支持此标签</strong>。</li></ul><h4 id="为什么少用iframe"><a href="#为什么少用iframe" class="headerlink" title="为什么少用iframe"></a>为什么少用iframe</h4><ul><li>iframes 提供了一个简单的方式<strong>把一个网站的内容嵌入到另一个网站中</strong>。但我们需要<strong>慎重的使用iframe</strong>。iframe的创建比其它包括scripts和css的 DOM 元素的创建慢了 1-2 个数量级。</li><li>使用 iframe 的页面一般不会包含太多 iframe，所以创建 DOM 节点所花费的时间不会占很大的比重。但<strong>带来一些其它的问题</strong>：<strong>onload 事件</strong>以及<strong>连接池(connection pool)</strong>。</li></ul><h5 id="Iframes-阻塞页面加载"><a href="#Iframes-阻塞页面加载" class="headerlink" title="Iframes 阻塞页面加载"></a>Iframes 阻塞页面加载</h5><ul><li>及时触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload 事件加载延迟后，它给用户的感觉就是这个网页非常慢。</li><li>window 的 onload 事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发。在 Safari 和 Chrome 里，<strong>通过 JavaScript 动态设置 iframe 的 SRC 可以避免这种阻塞情况</strong>。</li></ul><h5 id="唯一的连接池"><a href="#唯一的连接池" class="headerlink" title="唯一的连接池"></a>唯一的连接池</h5><ul><li>浏览器只能开少量的连接到web服务器。比较老的浏览器，包含 Internet Explorer 6 &amp; 7 和 Firefox 2，只能对一个域名(hostname)同时打开两个连接。这个数量的限制在新版本的浏览器中有所提高。Safari 3+ 和 Opera 9+ 可同时对一个域名打开 4 个连接，Chrome 1+, IE 8 以及 Firefox 3 可以同时打开 6 个。你可以通过这篇文章查看具体的数据表：Roundup on Parallel Connections.</li><li>有人可能希望 iframe 会有自己独立的连接池，但不是这样的。<strong>绝大部分浏览器，主页面和其中的 iframe 是共享这些连接的</strong>。这意味着 iframe 在加载资源时可能用光了所有的可用连接，从而阻塞了主页面资源的加载。如果 iframe 中的内容比主页面的内容更重要，这当然是很好的。但通常情况下，iframe 里的内容是没有主页面的内容重要的。这时 iframe 中用光了可用的连接就是不值得的了。一种<strong>解决办法</strong>是，<strong>在主页面上重要的元素加载完毕后，再动态设置 iframe 的 SRC</strong>。</li><li>美国前 10 大网站都使用了 iframe。大部分情况下，他们用它来加载广告。这是可以理解的，也是一种符合逻辑的解决方案，用一种简单的办法来加载广告服务。但请记住，iframe 会给你的页面性能带来冲击。只要可能，不要使用 iframe。当确实需要时，谨慎的使用它们。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;有人说，iframe是&lt;strong&gt;能耗最高&lt;/strong&gt;的一个元素，&lt;strong&gt;尽量减少使用&lt;/strong&gt;。也有人说，iframe的&lt;strong&gt;安全性太差&lt;/strong&gt;，&lt;strong&gt;尽量减少使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;尽管如此，但是&lt;strong&gt;iframe的强大功能是不容忽视的&lt;/strong&gt;，而且现在不乏公司正在使用它。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
      <category term="iframe" scheme="https://chongtianhong.github.io/tags/iframe/"/>
    
  </entry>
  
  <entry>
    <title>linux常用指令学习记录</title>
    <link href="https://chongtianhong.github.io/2018/07/01/linux/"/>
    <id>https://chongtianhong.github.io/2018/07/01/linux/</id>
    <published>2018-07-01T12:17:26.000Z</published>
    <updated>2018-10-17T13:36:19.462Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文主要为学习贴，用来记录一些linux上的常用指令以供参考。<a id="more"></a></li></ul><h4 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h4><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><ul><li><p>cat命令常用来<strong>查看文件内容</strong>，命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat [-AbEnTv] FILENAME</span></span><br></pre></td></tr></table></figure></li><li><p>选项参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-A：相当于vTE的整合选项，可列出一些特殊字符而不是空白而已</span><br><span class="line">-b：列出行号，仅列出非空白行的行号，空白行不显示行号</span><br><span class="line">-E：将结尾的断行字符$显示出来</span><br><span class="line">-n：列出行号，连同空白行也显示行号，与-b选项不同</span><br><span class="line">-T：将[tab]按键以 ^I 显示出来</span><br><span class="line">-v：列出一些看不出来的特殊字符</span><br></pre></td></tr></table></figure></li></ul><h5 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h5><ul><li>tac命令与cat命令完全是<strong>相反</strong>的，表示<strong>由最后一行逆序显示文件内容</strong>，即<strong>从下往上阅读文件内容</strong>，用法同cat。</li></ul><h5 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h5><ul><li>nl命令在linux中用来<strong>计算文件中行号</strong>，nl在<strong>没有选项参数的情况</strong>下，<strong>默认给非空白行加上行号</strong>。</li><li>与<code>cat -b</code>有点类似，nl命令可以<strong>将行号做比较多的显示设计</strong>，包括位数与是否补齐0等功能。</li><li><p>nl命令的命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nl [-bnw] FILENAME</span></span><br></pre></td></tr></table></figure></li><li><p>选项参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-b：指定行号指定的方式，主要有两种：</span><br><span class="line"> -b a：表示不论是否为空行，都显示行号，类似 cat -n</span><br><span class="line"> -b t：如有有空行，则空的那行不显示行号，类似 cat -b</span><br><span class="line">-n：列出行号表示的方法，主要有三种：</span><br><span class="line">  -n ln：行号在屏幕的最左方显示</span><br><span class="line">  -n rn：行号在字段的最右侧显示，且不加0</span><br><span class="line">  -n rz：行号在字段的最右方显示，且加0</span><br><span class="line">-w：行号字段的占用的位数</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：<code>nl -b a -n rz</code>命令默认行号是6位数，调整位数就需要加 -w 3，表示调整为3位。</p></li></ul><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><ul><li><p>more命令是<strong>文本查看类命令</strong>，more命令查看文件可<strong>一页一页的显示文件内容</strong>，方便用户逐一阅读。<strong>启动时就加载整个文件内容</strong>。命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu] [-num] [+/pattern] [+linenum] [file ...]</span><br></pre></td></tr></table></figure></li><li><p>参数选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+n：从第n行开始显示</span><br><span class="line">-n：定义屏幕大小显示为n行</span><br><span class="line">+/STRING：在文件开始显示前搜索STRING，然后在该STRING的前两行开始显示</span><br><span class="line">-c：从顶部清屏，然后显示</span><br><span class="line">-d：提示[Press space to <span class="built_in">continue</span>, <span class="string">'q'</span> to quit.]，按空格继续，按q退出</span><br><span class="line">-l：忽略Ctrl+l（换页）字符</span><br><span class="line">-p：通过清楚窗口而不是滚屏来翻页，与-c选项类似</span><br><span class="line">-s：把连续的多个空行显示为一行</span><br><span class="line">-u：把文件内容中的下划线去掉</span><br></pre></td></tr></table></figure></li><li><p>常用操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enter       代表向下翻一行</span><br><span class="line">空格键      代表向下翻一页</span><br><span class="line">/字符串     代表在这个显示的内容当中，向下搜索“字符串”这个关键字</span><br><span class="line">:f          立刻显示文件名及目前的行数</span><br><span class="line">=           输出当前的行号</span><br><span class="line">v           调用vi编辑器</span><br><span class="line">q           代表立刻离开more，不再显示文件内容</span><br><span class="line">h           显示more的快捷键及说明</span><br><span class="line">!命令       调用shell，并执行命令</span><br><span class="line">b或Ctrl-B   代表往回翻页，这个动作只对文件有用，对管线无用</span><br></pre></td></tr></table></figure></li></ul><h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><ul><li><p>less命令也是linux系统中<strong>查看文件内容</strong>的工具，功能强大，比more命令更富有弹性，它可以通过Pageup和Pagedown向前、向后翻页。而且还具有向上向下的搜素功能。命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [option] [file ...]</span><br></pre></td></tr></table></figure></li><li><p>参数选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-b：&lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-e：当文件显示结束后，自动离开</span><br><span class="line">-f： 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g：只标志最后搜索的关键词</span><br><span class="line">-i：忽略搜索时的大小写</span><br><span class="line">-m：显示类似more命令的百分比</span><br><span class="line">-N：显示每行的行号</span><br><span class="line">-o：&lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q：不使用警告音</span><br><span class="line">-s：显示连续空行为一行</span><br><span class="line">-S：行过长时间将超出部分舍弃</span><br><span class="line">-x &lt;数字&gt;：将“tab”键显示为规定的数字空格</span><br></pre></td></tr></table></figure></li><li><p>常用操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Enter       代表向下滚动一行</span><br><span class="line">y           代表向上滚动一行</span><br><span class="line">空格键      代表向下翻一页</span><br><span class="line">[pageup]    代表向上翻一页</span><br><span class="line">[pagedown]  代表向下翻一页</span><br><span class="line">h           显示less的快捷键及说明</span><br><span class="line">/STRING     向下搜索STRING的功能</span><br><span class="line">?STRING     向上搜索STRING的功能</span><br><span class="line">n           重复前一个搜索（与 / 或 ? y有关）</span><br><span class="line">N           反向重复前一个搜索（与 / 或 ? y有关）</span><br><span class="line">u           代表向上翻半页</span><br><span class="line">d           代表向下翻半页</span><br><span class="line">q           退出</span><br></pre></td></tr></table></figure></li></ul><h5 id="head"><a href="#head" class="headerlink" title="head"></a>head</h5><ul><li><p>head命令用来显示<strong>文件开头</strong>的某个数量的行数至标准输出中。命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [-cnqv] [file ...]</span><br></pre></td></tr></table></figure></li><li><p>选项参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c <span class="comment">#：显示文件的前#个字节</span></span><br><span class="line">  例如：命令 head -c 200 /etc/inittab 用于显示/etc/inittab 前200个字符</span><br><span class="line">-n <span class="comment">#：显示文件的前#行</span></span><br><span class="line">  例1：命令 head -n 15 /etc/inittab 用于显示/etc/inittab 文件前15行内容</span><br><span class="line">  注意：head -<span class="comment"># 和 head -n # 命令是一样的</span></span><br><span class="line">  例2：命令 head -n -5 /etc/inittab 用于显示/etc/inittab 文件除最后5行的内容</span><br><span class="line">-q：不显示完整路径及文件名</span><br><span class="line">-v：显示完整路径及文件名</span><br></pre></td></tr></table></figure></li></ul><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><ul><li><p>tail命令<strong>显示文件的后N行</strong>，也就是说从<strong>指定点到文件尾行</strong>的输出结果。命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-cnfqsv] 文件</span><br></pre></td></tr></table></figure></li><li><p>选项参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c <span class="comment">#：显示文件的后#个字节的内容</span></span><br><span class="line">-n <span class="comment"># 或 -#：显示文件的后#行内容</span></span><br><span class="line">  例1：命令 tail -n 5 /etc/inittab 用于显示/etc/inittab文件的后5行内容</span><br><span class="line">  例2：命令 head +n 5 /etc/inittab 用于从第5行开始显示/etc/inittab文件的内容</span><br><span class="line">-f：查看文件至尾部内容结束后不退出，刷新并更新显示最新增加的行，按Ctrl+C退出显示</span><br><span class="line">-q：不显示完整路径及文件名</span><br><span class="line">-v：显示完整路径及文件名</span><br></pre></td></tr></table></figure></li></ul><h4 id="命令与文件查询"><a href="#命令与文件查询" class="headerlink" title="命令与文件查询"></a>命令与文件查询</h4><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><ul><li>寻找执行文件，查找命令的完整文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> [-a] <span class="built_in">command</span> <span class="comment"># -a会将所有在PATH目录中可以找到的命令均列出，而不只第一个被找到的指令</span></span><br><span class="line"><span class="built_in">which</span> ifconfig <span class="comment"># 在非root用户下会查找不到，因为ifconfig位于/sbin/ifconfig下，而非root用户的PATH中不包含该路径，所以找不到</span></span><br><span class="line"><span class="built_in">which</span> <span class="built_in">cd</span> <span class="comment"># 找不到，因为cd为bash的内置命令</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h5><ul><li>根据文件名寻找文件，查找文件的完整文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] 文件或目录名</span><br><span class="line">    -b 只找二进制文件</span><br><span class="line">    -m 只找在manual路径下的文件</span><br><span class="line">    -s 只找<span class="built_in">source</span>源文件</span><br><span class="line">    -u 查找不在上述选项中的其他特殊文件</span><br></pre></td></tr></table></figure></li></ul><h5 id="locate-updatedb"><a href="#locate-updatedb" class="headerlink" title="locate+updatedb"></a>locate+updatedb</h5><ul><li>locate会根据<code>/var/lib/mlocate</code>内的数据库记载，找出用户输入的关键字文件名，即<strong>所有包含该关键字的文件都将被输出</strong>。</li><li>但是因为数据库的更新一般为一天一次，所以<strong>如果需要查找新的内容，需要用updatedb指令更新数据库</strong>，updatedb会根据<code>/etc/updatedb.conf</code>去查找硬盘内的文件名，并更新数据库文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locate [-ir] keyword</span><br><span class="line">    -i 忽略大小写差异</span><br><span class="line">    -r keyword可以为正则表达式</span><br></pre></td></tr></table></figure></li></ul><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><ul><li>查找文件，磁盘查找，支持通配符：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line">find / -mtime 0 <span class="comment"># 查找24小时内被修改过的文件</span></span><br><span class="line">find /etc -mtime 3 <span class="comment"># 查找3天前的24小时内被修改的文件</span></span><br><span class="line">find / -mtime +3 <span class="comment"># 查找3天前（不含3天本身）被更改的文件</span></span><br><span class="line">find / -mtime -3 <span class="comment"># 查找3天内被更改的文件</span></span><br><span class="line">find / -user name <span class="comment"># 查找用户名为name的文件</span></span><br><span class="line">find / -group name <span class="comment"># 查找群组名为group的文件</span></span><br><span class="line">find / -nouser <span class="comment"># 查找不属于任何用户的文件，可能出现于网络文件，或是已经被删除的用户创建的文件</span></span><br><span class="line">find / -name filename <span class="comment"># 查找文件名为filename的文件</span></span><br><span class="line">find / -<span class="built_in">type</span> TYPE <span class="comment"># 查找某一类文件，f：正规文件，b：设备文件，d：目录，l：连接文件，s：socket，p：FIFO</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="压缩与打包"><a href="#压缩与打包" class="headerlink" title="压缩与打包"></a>压缩与打包</h4><ul><li>常见压缩扩展名有：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*.Z: compress程序压缩文件</span><br><span class="line">*.gz: gzip程序压缩文件</span><br><span class="line">*.bz2: bzip2程序压缩的文件</span><br><span class="line">*.tar: tar程序打包的文件，但没有被压缩</span><br><span class="line">*.tar.gz: tar程序打包的文件，其中经过gzip的压缩</span><br><span class="line">*.tar.bz2: tar程序打包的文件，其中经过bzip2压缩</span><br></pre></td></tr></table></figure></li></ul><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><ul><li>gzip可以解开compress、zip与gzip等软件所压缩的文件。</li><li>gzip还可以用来压缩文件，使用gzip压缩后，源文件会被删除，被替代为.gz的压缩文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gzip [-cdtv<span class="comment">#] 文件名</span></span><br><span class="line">    -c: 将压缩的数据输出到屏幕上，可通过数据流重定向来处理</span><br><span class="line">    -d: 解压缩的参数</span><br><span class="line">    -t: 可以用来校验一个压缩文件的一致性</span><br><span class="line">    -v: 显示压缩比等信息</span><br><span class="line">    -<span class="comment">#: 压缩等级，-1最快，-9最慢但压缩程度最高，默认-6</span></span><br><span class="line">gzip -d filename <span class="comment"># 会将压缩文件解压缩，并删除压缩文件</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar [-j|-z] [cv] [-f 新建的文件名] filename <span class="comment">#压缩</span></span><br><span class="line">tar [-j|-z] [xv] [-f 打包文件名] [-C 目录] <span class="comment">#解压缩</span></span><br><span class="line">-c: 新建打包文件，可配合v查看过程中被打包的文件名</span><br><span class="line">-x: 解打包或解压缩功能，可以搭配-C在特定目录中解开</span><br><span class="line">-j: 通过bzip2的支持进行压缩和解压缩</span><br><span class="line">-z: 通过gzip支持压缩和解压缩</span><br><span class="line">-v: 将正在处理的文件名显示出来</span><br><span class="line">-C: 在特定目录中解压缩</span><br><span class="line">-p: 保留备份数据的原本权限和属性</span><br><span class="line">-P: 保留绝对路径,一般情况下都是相对路径，防止数据覆盖</span><br><span class="line">--exclude=FILE: 在压缩过程中不要讲FILE打包进去</span><br><span class="line">--newer: 打包ctime和mtime在日期后面的文件</span><br><span class="line">--newer-mtime：打包mtime在日期后面的文件</span><br><span class="line">tar -zcv -f filename.tar.gz filename <span class="comment">#压缩打包为filename.tar.gz</span></span><br><span class="line">tar -zxv -f filename.tart.gz -C 欲解压缩的目录 filename</span><br></pre></td></tr></table></figure><h4 id="变量读取与声明"><a href="#变量读取与声明" class="headerlink" title="变量读取与声明"></a>变量读取与声明</h4><h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><ul><li>从控制台读取输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [-pt] variable</span><br><span class="line">-p: 可以加上提示符</span><br><span class="line">-t: 等待输入的秒数</span><br></pre></td></tr></table></figure></li></ul><h5 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span> [-aixr] variable</span><br><span class="line">-a: 声明为数组</span><br><span class="line">-i: 声明为整数</span><br><span class="line">-x: 声明为环境变量，用法同<span class="built_in">export</span></span><br><span class="line">-r: 声明为只读变量</span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> -i sum=100+200+300 <span class="comment">#如果不声明为整数，则会默认为字符串</span></span><br><span class="line"><span class="built_in">declare</span> +r sum <span class="comment">#等同于取消操作</span></span><br></pre></td></tr></table></figure><h4 id="选取命令"><a href="#选取命令" class="headerlink" title="选取命令"></a>选取命令</h4><h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cut -d <span class="string">'分隔符'</span> -f fields <span class="comment">#根据分隔符将每一行分割并取出下标为fields的值</span></span><br><span class="line">cur -c 字符范围 <span class="comment">#将每一行字符范围内的内容切割出来</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> | cut -c 12- <span class="comment">#将export文件的每一行从第12个字符开始以后所有内容切割出来</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> | cut -d <span class="string">':'</span> -f 3,5 <span class="comment">#将path内容按照：分割开来并取第三个和第五个值</span></span><br></pre></td></tr></table></figure><ul><li>cut在处理<strong>多空格分隔</strong>的行时会比较吃力：</li></ul><h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><ul><li>分析一行，当该行中有我们想要的信息，就将该行输出：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] <span class="string">'关键词'</span> 文件名</span><br><span class="line">    -a: 将binary文件以text文件的方式进行查找</span><br><span class="line">    -c: 打印出现的次数</span><br><span class="line">    -i: 忽略大小写</span><br><span class="line">    -n: 同时输出行号</span><br><span class="line">    -v: 反向选择，即选择不存在关键字的行</span><br><span class="line">    --color=auto： 将关键字加上颜色显示</span><br></pre></td></tr></table></figure></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort [-fbMnrtuk] file/stdin</span><br><span class="line">    -f: 忽略大小写</span><br><span class="line">    -b：忽略最前面的空格</span><br><span class="line">    -M：以月份来排序</span><br><span class="line">    -n：使用纯数字来排序，默认为文字类型</span><br><span class="line">    -r：倒序</span><br><span class="line">    -u：相同数据中，只显示一行</span><br><span class="line">    -t：分隔符，默认为tab</span><br><span class="line">    -k：第几段数据作为排序标准</span><br></pre></td></tr></table></figure><h5 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h5><ul><li>统计文件的行数和子树：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wc [-lwm] filename</span><br><span class="line">    -l: 仅列出行</span><br><span class="line">    -w：仅列出多少字</span><br><span class="line">    -m: 多少字</span><br></pre></td></tr></table></figure></li></ul><h5 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h5><ul><li>去重：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniq [-ic]</span><br><span class="line">    -i: 大小写无关</span><br><span class="line">    -c: 计数统计</span><br></pre></td></tr></table></figure></li></ul><h5 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h5><ul><li>双重重定向，将一份输出同时输出到文件和标准输出流：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tee [-a] filename</span><br><span class="line">    -a: 添加到文件后面</span><br></pre></td></tr></table></figure></li></ul><h5 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h5><ul><li>读入stdin数据，并且以某种分割字符将其分割成参数。该命令<strong>适合于不支持管道的命令</strong>来支持管道操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xargs [-0epn] <span class="built_in">command</span></span><br><span class="line">    -0: 将特殊字符还原成一般字符</span><br><span class="line">    -e: EOF，当xargs分析到这个参数时会停止解析</span><br><span class="line">    -p：在执行每个命令的参数时，都会询问用户</span><br><span class="line">    -n: 后面接次数，要使用几个参数的意思</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本文主要为学习贴，用来记录一些linux上的常用指令以供参考。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="linux" scheme="https://chongtianhong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>webSocket</title>
    <link href="https://chongtianhong.github.io/2018/06/30/webSocket/"/>
    <id>https://chongtianhong.github.io/2018/06/30/webSocket/</id>
    <published>2018-06-30T08:34:10.000Z</published>
    <updated>2018-10-06T09:58:55.755Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webSocket是什么"><a href="#webSocket是什么" class="headerlink" title="webSocket是什么"></a>webSocket是什么</h4><ul><li><strong>webSocket是HTML5新出的一种协议</strong>，底层是<strong>基于TCP/IP协议</strong>的。跟http没有关系，只是复用了http握手通道，用来升级协议。<a id="more"></a></li></ul><h4 id="webSocket的作用"><a href="#webSocket的作用" class="headerlink" title="webSocket的作用"></a>webSocket的作用</h4><ul><li>轮询：客户端<strong>以一定的时间间隔</strong>向服务端发出请求，以<strong>频繁请求</strong>的方式来<strong>保持客户端和服务器端的同步</strong>。缺点：<ul><li>浏览器需要不断的向服务器发出请求，然而<strong>HTTP请求可能包含较长的头部</strong>，其中<strong>真正有效的数据可能只是很小的一部分</strong>，显然这样会<strong>浪费很多的带宽等资源</strong>。</li></ul></li><li>长轮询：浏览器向服务器发送请求，<strong>服务器将请求保持打开一段时间</strong>。如果在该时间段内收到通知，则将包含该消息的响应发送到客户端。如果在设定的时间段内未收到通知，则服务器发送响应以终止打开的请求。缺点：<ul><li>当具有<strong>较高的消息量</strong>时，长轮询<strong>不会提供比传统轮询更大的性能改进</strong>；</li><li><strong>服务器端</strong>会<strong>阻塞请求</strong>直到<strong>有数据传递</strong>或<strong>超时</strong>才返回。</li></ul></li><li>使用webSocket<strong>浏览器和服务器只需要完成一次握手</strong>，两者之间就直接可以<strong>创建持久性的连接</strong>，并进行<strong>双向数据传输</strong>。优点：<ul><li>能更好的<strong>节省服务器资源和带宽</strong>；</li><li>支持<strong>双向通信</strong>，<strong>实时性更强</strong>；</li><li>可以发送<strong>文本</strong>，也可以发送<strong>二进制数据</strong>。</li></ul></li></ul><h4 id="webSocket的使用"><a href="#webSocket的使用" class="headerlink" title="webSocket的使用"></a>webSocket的使用</h4><blockquote>服务端</blockquote><ul><li>代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var app = require(<span class="string">'express'</span>)();</span><br><span class="line">var server = require(<span class="string">'http'</span>).Server(app);</span><br><span class="line">var WebSocket = require(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line">var wss = new WebSocket.Server(&#123; port: 8080 &#125;);</span><br><span class="line"></span><br><span class="line">// 当有新的连接请求到达时</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="keyword">function</span> connection(ws) &#123; </span><br><span class="line">    console.log(<span class="string">'server: receive connection.'</span>);</span><br><span class="line">    // 当收到到来自客户端的消息时</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="keyword">function</span> incoming(message) &#123;</span><br><span class="line">        console.log(<span class="string">'server: received: %s'</span>, message);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 向客户端发送消息</span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li></ul><blockquote>客户端</blockquote><ul><li><p>代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 向8080端口发起WebSocket连接</span><br><span class="line">    var ws = new WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">    // 连接建立后</span><br><span class="line">    ws.onopen = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">        ws.send(<span class="string">'from client: hello'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 接收到来自服务端的消息后</span><br><span class="line">    ws.onmessage = <span class="keyword">function</span> (e) &#123;</span><br><span class="line">        console.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">        console.log(<span class="string">'from server: '</span> + e.data);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>服务端</strong>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server: receive connection.</span><br><span class="line">server: received from client: hello</span><br></pre></td></tr></table></figure></li><li><p>客户端输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client: ws onopen</span><br><span class="line">client: ws onmessage</span><br><span class="line">client: received from server: world</span><br></pre></td></tr></table></figure></li></ul><h4 id="webSocket应用场景"><a href="#webSocket应用场景" class="headerlink" title="webSocket应用场景"></a>webSocket应用场景</h4><ul><li>社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要<strong>高实时</strong>的场景。</li></ul><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/" target="_blank" rel="noopener">Comet：基于 HTTP 长连接的“服务器推”技术</a></li><li><a href="https://juejin.im/post/5a4e6a43f265da3e303c4787" target="_blank" rel="noopener">WebSocket：5分钟从入门到精通</a></li><li>&lt;&lt;web性能优化权威指南&gt;&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;webSocket是什么&quot;&gt;&lt;a href=&quot;#webSocket是什么&quot; class=&quot;headerlink&quot; title=&quot;webSocket是什么&quot;&gt;&lt;/a&gt;webSocket是什么&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;webSocket是HTML5新出的一种协议&lt;/strong&gt;，底层是&lt;strong&gt;基于TCP/IP协议&lt;/strong&gt;的。跟http没有关系，只是复用了http握手通道，用来升级协议。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="webSocket" scheme="https://chongtianhong.github.io/tags/webSocket/"/>
    
      <category term="HTML5" scheme="https://chongtianhong.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>display:none与visibility:hidden的对比</title>
    <link href="https://chongtianhong.github.io/2018/06/29/displayAndVisibility/"/>
    <id>https://chongtianhong.github.io/2018/06/29/displayAndVisibility/</id>
    <published>2018-06-29T06:45:36.000Z</published>
    <updated>2018-10-04T14:12:16.391Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深入display-none"><a href="#深入display-none" class="headerlink" title="深入display:none"></a>深入display:none</h4><ul><li>我们都清楚当元素设置<code>display:none</code>后，<strong>界面上将不会显示该元素，并且该元素不占布局空间</strong>，但我们<strong>仍然可以通过JavaScript操作该元素</strong>。<a id="more"></a></li><li>这个涉及到<strong>浏览器的渲染原理</strong>：浏览器会<strong>解析HTML标签生成DOM Tree</strong>，<strong>解析CSS生成CSSOM</strong>，然后<strong>将DOM Tree和CSSOM合成生成Render Tree</strong>，元素在Render Tree中对应0或多个盒子，然后<strong>浏览器以盒子模型的信息布局和渲染界面</strong>。而<strong>设置为<code>display:none</code>的元素</strong>则在Render Tree中没有生成对应的盒子模型，因此<strong>后续的布局、渲染工作自然与它无关</strong>，至于<strong>DOM操作还是可以的</strong>。</li><li>但除了上面的知识点外，还有以下8个是我们需要注意的：</li></ul><blockquote>1、原生默认display:none的元素</blockquote><ul><li>其实<strong>浏览器原生元素</strong>中有不少自带<code>display:none</code>的元素，如<code>link</code>，<code>script</code>，<code>style</code>，<code>dialog</code>，<code>input[type=hidden]</code>等。</li></ul><blockquote>2、HTML5中新增<strong>hidden布尔属性</strong>，让开发者自定义元素的隐藏</blockquote><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 兼容原生不支持hidden属性的浏览器  */</span><br><span class="line">[hidden]&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span hidden&gt;Hide and Seek: You can<span class="string">'t see me!&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>3、父元素为display:none，后代元素都不可见</blockquote><ul><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.hidden&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">.visible&#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*** START ***</span><br><span class="line">&lt;div class=<span class="string">"hidden"</span>&gt;</span><br><span class="line">    I<span class="string">'m parent!</span></span><br><span class="line"><span class="string">    &lt;div class="visible"&gt; I'</span>m son! &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">*** END ***</span><br></pre></td></tr></table></figure></li><li><p>浏览器直接显示为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** START ***</span><br><span class="line">*** END ***</span><br></pre></td></tr></table></figure></li></ul><blockquote>4、无法获取焦点</blockquote><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span>&gt;</span><br><span class="line">&lt;div tabindex=<span class="string">"1"</span> style=<span class="string">"display:none"</span>&gt;hidden&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>5、无法响应任何事件，无论是捕获、命中目标和冒泡阶段均不可以</blockquote><ul><li>由于<strong><code>display:none</code>的元素根本不会在界面上渲染</strong>，就是连一个像素的都不占，因此自然<strong>无法通过鼠标点击命中</strong>，而<strong>元素也无法获取焦点</strong>，那么<strong>也不能成为键盘事件的命中目标</strong>。</li><li>当父元素的<code>display</code>为<code>none</code>时，子元素的<code>display</code>必定为<code>none</code>，因此元素也没有机会位于事件捕获或冒泡阶段的路径上，因此<strong><code>display:none</code>的元素无法响应事件</strong>。</li></ul><blockquote>6、不耽误form表单提交数据</blockquote><ul><li>虽然我们无法看到<code>display:none</code>的元素，但<strong>当表单提交时，依然会将隐藏的input元素的值提交上去</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"id"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"gguid"</span> style=<span class="string">"display:none"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>7、display变化时将触发reflow</blockquote><ul><li>撇开<code>display:none</code>，我们看看<strong><code>display:block</code>表示元素位于BFC中</strong>，而<strong><code>display:inline</code>则表示元素位于IFC中</strong>，也就是说<strong>display就是用于设置元素所属的布局上下文</strong>，若<strong>修改display值</strong>则表示<strong>元素采用的布局方式已发生变化</strong>，因此，<strong>display变化时将触发reflow</strong>。</li></ul><blockquote>8、display:none让transition失效</blockquote><ul><li>详情请参考<a href="https://www.cnblogs.com/fsjohnhuang/p/9143035.html" target="_blank" rel="noopener">CSS魔法堂：Transition就这么好玩</a></li></ul><h4 id="深入visibility"><a href="#深入visibility" class="headerlink" title="深入visibility"></a>深入visibility</h4><ul><li>visibility有两个不同的作用：<br>① 用于<strong>隐藏表格的行和列</strong><br>② 用于<strong>在不触发布局的情况下隐藏元素</strong></li><li>visibility有四个有效值：<br>① visible：在界面上显示元素。<br>② hidden：让元素在见面上不可视，但保留元素原来占有的位置。<br>③ collapse：用于表格子元素(如tr,tbody,col,colgroup)时效果和<code>display:none</code>一样，用于其他元素上时则效果与<code>visibility:hidden</code>一样。不过由于各浏览器实现效果均有出入，因此<strong>一般不会使用这个值</strong>。<br>④ inherit：继承父元素的visibility值。</li></ul><h4 id="visibility-hidden的注意事项"><a href="#visibility-hidden的注意事项" class="headerlink" title="visibility:hidden的注意事项"></a>visibility:hidden的注意事项</h4><ul><li>参照上面对<code>display:none</code>列出的8点注意事项，可对照列出<code>visibility:hidden</code>的注意事项：</li></ul><blockquote>1、父元素为visibility:hidden，而子元素可以设置为visibility:visible并且生效</blockquote><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border: solid 2px blue;</span><br><span class="line">&#125;</span><br><span class="line">.visible&#123;</span><br><span class="line">    visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">.hidden&#123;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=<span class="string">"hidden"</span>&gt;</span><br><span class="line">    I<span class="string">'m Parent.</span></span><br><span class="line"><span class="string">    &lt;div class="visible"&gt;</span></span><br><span class="line"><span class="string">        I'</span>m Son.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>2、和display:none一样无法获得焦点</blockquote><blockquote>3、可在冒泡阶段响应事件</blockquote><ul><li>由于设置为<code>visibility:hidden</code>的元素其子元素可以为<code>visibility:visible</code>，因此隐藏的元素有可能位于事件冒泡的路径上，因此下面代码中，将鼠标移至属性为<code>.visible</code>的元素时，<code>.hidden</code>会的元素响应hover事件显示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border: solid 2px blue;</span><br><span class="line">&#125;</span><br><span class="line">.visible&#123;</span><br><span class="line">    visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">.hidden&#123;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.hidden:hover&#123;</span><br><span class="line">    visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=<span class="string">"hidden"</span>&gt;</span><br><span class="line">    I<span class="string">'m Parent.</span></span><br><span class="line"><span class="string">    &lt;div class="visible"&gt;</span></span><br><span class="line"><span class="string">        I'</span>m Son.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>4、和display:none一样不妨碍form表单的提交</blockquote><blockquote>5、Transition对visibility的变化有效</blockquote><blockquote>6、visibility变化不会触发reflow</blockquote><ul><li>由于从<code>visible</code>设置为<code>hidden</code>时，<strong>不会改变元素布局相关的属性</strong>，因此<strong>不会触发reflow</strong>，只是静静地和其他渲染变化一起等待浏览器定时<strong>重绘</strong>界面。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;深入display-none&quot;&gt;&lt;a href=&quot;#深入display-none&quot; class=&quot;headerlink&quot; title=&quot;深入display:none&quot;&gt;&lt;/a&gt;深入display:none&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;我们都清楚当元素设置&lt;code&gt;display:none&lt;/code&gt;后，&lt;strong&gt;界面上将不会显示该元素，并且该元素不占布局空间&lt;/strong&gt;，但我们&lt;strong&gt;仍然可以通过JavaScript操作该元素&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="display" scheme="https://chongtianhong.github.io/tags/display/"/>
    
      <category term="visibility" scheme="https://chongtianhong.github.io/tags/visibility/"/>
    
  </entry>
  
  <entry>
    <title>关于jsonp实现跨域访问，以及存在的安全问题</title>
    <link href="https://chongtianhong.github.io/2018/06/28/josnpAndSecurity/"/>
    <id>https://chongtianhong.github.io/2018/06/28/josnpAndSecurity/</id>
    <published>2018-06-28T05:43:38.000Z</published>
    <updated>2018-10-01T14:46:17.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id="jsonp跨域访问的实现"><a href="#jsonp跨域访问的实现" class="headerlink" title="jsonp跨域访问的实现"></a>jsonp跨域访问的实现</h4><ul><li><strong>跨域的安全限制都是对浏览器端来说的</strong>，服务器端是不存在跨域安全限制的。</li><li><strong>浏览器的同源策略</strong>限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。</li><li>如果<strong>协议，端口和主机</strong>对于两个页面是<strong>相同</strong>的，<strong>则两个页面具有相同的源</strong>，否则就是不同源的。</li><li>如果要<strong>在脚本里发起跨域请求</strong>，则要进行一些特殊处理了。例如，可以采用<strong>后台代理</strong>的方式，把请求发到自己的服务端，再通过后台代码发起请求，再将数据返回前端。<a id="more"></a></li><li><a href="https://www.cnblogs.com/chiangchou/p/jsonp.html" target="_blank" rel="noopener">一篇博客</a>对<strong>使用jquery的jsonp如何发起跨域请求及其原理</strong>进行了详细地介绍。</li></ul><h4 id="jsonp可能导致的安全问题"><a href="#jsonp可能导致的安全问题" class="headerlink" title="jsonp可能导致的安全问题"></a>jsonp可能导致的安全问题</h4><ul><li>了解了jsonp之后，可以看到，<strong>jsonp主要就是用来实现跨域的数据获取</strong>。</li><li>如果跨域的接口是暴露在公网上的，如果跨域接口是public级别，则无所谓安全问题，如果跨域接口是private级别，则<strong>必须对访问者做校验验证来访的Request的合法性</strong>的。目前已知的有<strong>Referer校验</strong>和<strong>Token校验</strong>。</li></ul><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><div class="note info">HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。</div><ul><li>这里通过对header中的访问发起者的来源进行验证来保证安全性，但是这个<strong>Referer是存在被绕过的可能的</strong>，绕过的主要原理就是“不发送Referer” ，如<ul><li>使用data URI方案 </li><li>从HTTPS向HTTP发起请求</li></ul></li></ul><h5 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h5><div class="note info">主要是指能代表用户身份的标识</div><ul><li>这个部分破解的难度较高，但是通过在运行非同源跨域的网站植入恶意代码，间接依靠“白名单”站点来获取Token发起跨域访问，可以同时绕过Referer和Token的问题，但是植入恶意代码的难度较高。</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>总的来说<strong>Referer和Token校验是标准</strong>，必须要使用的，<strong>可以解决常规安全问题</strong>，<strong>最稳妥的是不使用jsonp</strong>，改用别的跨域方案（H5 提供的跨域方案postMessage、CORS、WebSocket）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;jsonp跨域访问的实现&quot;&gt;&lt;a href=&quot;#jsonp跨域访问的实现&quot; class=&quot;headerlink&quot; title=&quot;jsonp跨域访问的实现&quot;&gt;&lt;/a&gt;jsonp跨域访问的实现&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨域的安全限制都是对浏览器端来说的&lt;/strong&gt;，服务器端是不存在跨域安全限制的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器的同源策略&lt;/strong&gt;限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;协议，端口和主机&lt;/strong&gt;对于两个页面是&lt;strong&gt;相同&lt;/strong&gt;的，&lt;strong&gt;则两个页面具有相同的源&lt;/strong&gt;，否则就是不同源的。&lt;/li&gt;
&lt;li&gt;如果要&lt;strong&gt;在脚本里发起跨域请求&lt;/strong&gt;，则要进行一些特殊处理了。例如，可以采用&lt;strong&gt;后台代理&lt;/strong&gt;的方式，把请求发到自己的服务端，再通过后台代码发起请求，再将数据返回前端。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨域" scheme="https://chongtianhong.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="jsonp" scheme="https://chongtianhong.github.io/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>从NodeJS搭建中间层再谈前后端分离</title>
    <link href="https://chongtianhong.github.io/2018/06/27/frontEndSeparation2/"/>
    <id>https://chongtianhong.github.io/2018/06/27/frontEndSeparation2/</id>
    <published>2018-06-27T11:36:44.000Z</published>
    <updated>2018-09-29T14:14:12.634Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>后端</strong>出于性能和别的原因，<strong>提供的接口所返回的数据格式也许不太适合前端直接使用</strong>，前端所需的<strong>排序功能</strong>、<strong>筛选功能</strong>，以及到了<strong>视图层的页面展现</strong>，也许都<strong>需要对接口所提供的数据进行二次处理</strong>。</li><li>这些处理虽可以放在前端来进行，但也许<strong>数据量一大便会浪费浏览器性能</strong>。因而现今，<strong>增加node端</strong>便是一种良好的解决方案。<a id="more"></a></li><li>下面关于微信小程序demo的<strong>server端代码</strong>中，通过<strong>http模块</strong>对真实后台（网易云音乐API）发起http请求，然后通过<strong>express模块</strong>搭建后端服务。</li><li><p>发起请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// http.js</span><br><span class="line">var formatURL = require(<span class="string">'./formatURL.js'</span>);</span><br><span class="line">var http = require(<span class="string">'http'</span>);</span><br><span class="line">const POSThttp = <span class="keyword">function</span>(request)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="built_in">let</span> body = <span class="string">''</span>;</span><br><span class="line">        // http模块拿到真实后台api的数据</span><br><span class="line">        http.get(formatURL(request.body.musicname), <span class="keyword">function</span>(res)&#123;</span><br><span class="line">        res.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">            body += data;</span><br><span class="line">        &#125;).on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">            // 格式化</span><br><span class="line">            const &#123;</span><br><span class="line">            name,</span><br><span class="line">            audio: musicUrl,</span><br><span class="line">            page,</span><br><span class="line">            album: &#123;</span><br><span class="line">                name: musicName,</span><br><span class="line">                picUrl,</span><br><span class="line">            &#125;,</span><br><span class="line">            artists: [&#123;</span><br><span class="line">                name: singer,</span><br><span class="line">            &#125;],</span><br><span class="line">            &#125; = JSON.parse(body).result.songs[0];</span><br><span class="line">            const reply = &#123;</span><br><span class="line">            name,</span><br><span class="line">            picUrl,</span><br><span class="line">            musicUrl,</span><br><span class="line">            page,</span><br><span class="line">            singer,</span><br><span class="line">            &#125;;</span><br><span class="line">            resolve(reply);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = POSThttp;</span><br></pre></td></tr></table></figure></li><li><p>得到数据传回前端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var POSThttp = require(<span class="string">'./POSThttp.js'</span>);</span><br><span class="line">var bodyParser = require(<span class="string">'body-parser'</span>);</span><br><span class="line">// 使用body-parser解析post请求的参数，如果没有，req.body为undefined。</span><br><span class="line">var app = express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">    extended: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line">app.post(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    POSThttp(req).<span class="keyword">then</span>((data) =&gt; &#123;</span><br><span class="line">        res.send(data);</span><br><span class="line">    &#125;).catch((err) =&gt; &#123;</span><br><span class="line">        res.send(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'open wx-audio server successful!'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的几十行代码也就<strong>实现了一个简单的中间层的demo</strong>，并做到了<strong>在中间层格式化参数</strong>，<strong>便于前端进行使用</strong>的过程。</p></li></ul><h4 id="为什么需要中间层？"><a href="#为什么需要中间层？" class="headerlink" title="为什么需要中间层？"></a>为什么需要中间层？</h4><ul><li>其实这个问题，我认为跟面试常考的题：“为什么需要前后端分离？”是类似的，现今大公司的老项目（包括百度、搜狐等公司所采用的后端渲染等），或多或少都会存在这样的一些问题：<ul><li><strong>前端代码越来越复杂</strong></li><li><strong>前后端</strong>依旧<strong>高度耦合</strong></li><li>无法良好的支持<strong>跨终端</strong></li></ul></li></ul><h4 id="前辈们提出的解决方案"><a href="#前辈们提出的解决方案" class="headerlink" title="前辈们提出的解决方案"></a>前辈们提出的解决方案</h4><ul><li>前端代码越来越复杂，我们希望尽可能地减少工作量，开始使用类似<strong>MV*的分层结构</strong>，使前端后分离成为必要。</li><li>前端需要处理更多的工作，希望有权操控<code>View</code>，<code>Router</code>（如：SPA的尝试）</li><li><strong>各种终端设备的兴起</strong>，需要我们<strong>把页面适配到更多的地方</strong>。</li><li>开始：我们所尝试的<strong>CLIENT-SIDE MV* 框架</strong>，<strong>后端</strong>暴露数据接口、处理业务逻辑，<strong>前端</strong>接收数据、处理渲染逻辑。</li></ul><div class="note info">关于MVC的定义：<br>MVC是一种设计模式，它将应用划分为3个部分：数据（模型）、展现层（视图）和用户交互（控制器）。换句话说，一个事件的发生是这样的过程：<br>　　1. 用户和应用产生交互。<br>　　2. 控制器的事件处理器被触发。<br>　　3. 控制器从模型中请求数据，并将其交给视图。<br>　　4. 视图将数据呈现给用户。<br>我们不用类库或框架就可以实现这种MVC架构模式。关键是要将MVC的每部分按照职责进行划分，将代码清晰地分割为若干部分，并保持良好的解耦。这样可以对每个部分进行独立开发、测试和维护。</div><ul><li>如：<code>Backbone</code>，<code>EmberJS</code>，<code>KnockoutJS</code>，<code>AngularJS</code>等框架。</li><li>但这样的方式仍旧存在问题：</li></ul><h5 id="各层职责重叠"><a href="#各层职责重叠" class="headerlink" title="各层职责重叠"></a>各层职责重叠</h5><ul><li>Client-side Model 是 Server-side Model 的加工</li><li>Client-side View 跟 Server-side是 不同层次的东西</li><li>Client-side的Controller 跟 Sever-side的Controller 各搞各的</li><li>Client-side的Route 但是 Server-side 可能没有</li></ul><h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5><ul><li><strong>渲染，取值都在客户端进行</strong>，有性能的问题</li><li>需要等待资源到齐才能进行，会有<strong>短暂白屏与闪动</strong></li><li>在移动设备<strong>低速网路</strong>的体验奇差无比</li></ul><h5 id="重用问题"><a href="#重用问题" class="headerlink" title="重用问题"></a>重用问题</h5><ul><li><strong>模板</strong>无法重用，造成维护上的麻烦与不一致</li><li><strong>逻辑</strong>无法重用，前端的校验后端仍须再做一次</li><li><strong>路由</strong>无法重用，前端的路由在后端未必存在</li></ul><h5 id="跨终端问题"><a href="#跨终端问题" class="headerlink" title="跨终端问题"></a>跨终端问题</h5><ul><li>业务太靠前，导致不同端重复实现</li><li>逻辑太靠前，造成维护上的不易</li></ul><h5 id="渲染都在客户端，模板无法重用，SEO实现麻烦"><a href="#渲染都在客户端，模板无法重用，SEO实现麻烦" class="headerlink" title="渲染都在客户端，模板无法重用，SEO实现麻烦"></a>渲染都在客户端，模板无法重用，SEO实现麻烦</h5><h4 id="NodeJS作为中间层的全栈开发方案"><a href="#NodeJS作为中间层的全栈开发方案" class="headerlink" title="NodeJS作为中间层的全栈开发方案"></a>NodeJS作为中间层的全栈开发方案</h4><ul><li>参考<code>淘宝前后端分离解决方案</code>中的一张图：<br><img src="/images/frontEndSeparation.png" alt="淘宝前后端分离解决方案配图" width="600" style="border:none"></li><li>有了NodeJS之后，<strong>前端可以更加专注于视图层</strong>，而让<strong>更多的数据逻辑放在Node层处理</strong>。</li><li>除了上图列举的作用，我们使用Node层还可以有下面的好处：<ul><li>渲染页面，体验优化</li><li>中间层带来的性能问题，在异步ajax转成同步渲染过程中得到平衡</li></ul></li><li>NodeJS对于<strong>数据的运算、逻辑处理</strong>及<strong>数据库的操作</strong>不如java方便、快捷、稳定，因此，将NodeJS作为中间层，<strong>从底层java获取数据、对数据做简单的处理</strong>后返回给客户端。</li><li>对于前端来说，NodeJS的学习成本是相当低的：我们无需学习一门新的语言，就能做到以前开发帮我们做的事情，一切都显得那么自然。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;后端&lt;/strong&gt;出于性能和别的原因，&lt;strong&gt;提供的接口所返回的数据格式也许不太适合前端直接使用&lt;/strong&gt;，前端所需的&lt;strong&gt;排序功能&lt;/strong&gt;、&lt;strong&gt;筛选功能&lt;/strong&gt;，以及到了&lt;strong&gt;视图层的页面展现&lt;/strong&gt;，也许都&lt;strong&gt;需要对接口所提供的数据进行二次处理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;这些处理虽可以放在前端来进行，但也许&lt;strong&gt;数据量一大便会浪费浏览器性能&lt;/strong&gt;。因而现今，&lt;strong&gt;增加node端&lt;/strong&gt;便是一种良好的解决方案。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="前后端分离" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>jQuery ajax()使用serialize()提交form数据</title>
    <link href="https://chongtianhong.github.io/2018/06/27/serializeOfJQuery/"/>
    <id>https://chongtianhong.github.io/2018/06/27/serializeOfJQuery/</id>
    <published>2018-06-27T02:06:17.000Z</published>
    <updated>2018-09-28T13:55:08.805Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>jQuery的<code>serialize()</code>方法通过<strong>序列化表单值</strong>，<strong>创建URL编码文本字符串</strong>，我们就可以选择一个或多个表单元素，也可以直接选择form将其序列化，如：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">""</span>&gt;</span><br><span class="line">First name: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"FirstName"</span> value=<span class="string">"Bill"</span> /&gt;&lt;br /&gt;</span><br><span class="line">Last name: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"LastName"</span> value=<span class="string">"Gates"</span> /&gt;&lt;br /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log($(<span class="string">"form"</span>).serialize()); // FirstName=Bill&amp;LastName=Gates</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样，我们就可以把序列化的值传给<code>ajax()</code>作为url的参数，轻松使用<code>ajax()</code>提交form表单了，而不需要一个一个获取表单中的值然后传给<code>ajax()</code>，举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'your url'</span>,</span><br><span class="line">    data: $(<span class="string">"form"</span>).serialize(),</span><br><span class="line">    success: <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>$.post()</code>、<code>$.get()</code>和<code>$.getJSON()</code>也是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.getJSON(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;jQuery的&lt;code&gt;serialize()&lt;/code&gt;方法通过&lt;strong&gt;序列化表单值&lt;/strong&gt;，&lt;strong&gt;创建URL编码文本字符串&lt;/strong&gt;，我们就可以选择一个或多个表单元素，也可以直接选择form将其序列化，如：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="jQuery" scheme="https://chongtianhong.github.io/tags/jQuery/"/>
    
      <category term="ajax" scheme="https://chongtianhong.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>DOM插入操作优化：DocumentFragment</title>
    <link href="https://chongtianhong.github.io/2018/06/26/documentFragment/"/>
    <id>https://chongtianhong.github.io/2018/06/26/documentFragment/</id>
    <published>2018-06-26T02:58:35.000Z</published>
    <updated>2018-09-28T13:55:09.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>在进行<strong>DOM操作</strong>中，我们经常使用<strong>新建元素</strong>然后<strong>将其插入到文档中</strong>的操作。</li><li><p>若是非常小（对页面的改动很小）的插入操作或许在性能上没有什么，但是<strong>若需要很多的插入操作和改动</strong>，继续使用类似于下面的代码则会很有问题。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(<span class="string">"ul"</span>);</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    var li = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于<strong>每一次对文档的插入都会引起重新渲染</strong>（计算元素的尺寸，显示背景，内容等），所以<strong>进行多次插入操作使得浏览器发生了很多次渲染，效率是比较低的</strong>。这是我们提倡<strong>通过减少页面的渲染来提高DOM操作的效率</strong>的原因。</p></li><li>一个优化的方法是<strong>将要创建的元素写到一个字符串上</strong>，然后<strong>一次性写到innerHTML上</strong>，这种利用浏览器对innerHTML的解析确实是相比上面的多次插入快了很多。但是<strong>构造字符串灵活性上面比较差，很难符合创建各种各样的DOM元素的需求</strong>。</li><li>利用<code>DocumentFragment</code>，可以弥补这两个方法的不足。</li><li><code>DocumentFragment</code>是<strong>没有父节点</strong>的<strong>最小的文档对象</strong>，用于存储HTML和XML片段。<code>DocumentFragment</code>对象继承Node，所以它<strong>有Node的所有属性方法</strong>，完全可以操作Node(NodeList)那样操作<code>DocumentFragment</code>。此外<strong>W3C对<code>DocumentFragment</code>也定义了一些另外的属性和方法</strong>，但是由于多数浏览器都没有实现，<strong>从兼容性上来说不推荐使用这些属性</strong>。具体有哪些属性方法可以参考MDN说明。</li><li>创建<code>DocumentFragment</code>的方法有两种，<code>document.createDocumentFragment()</code>和<code>new Fragment()</code>。对于<code>document.createDocumentFragment()</code>，所有浏览器都支持（包括IE6），而构造函数方法就不是所有浏览器都有效了（IE没有实现该方法）。所以<strong>从兼容性上来说推荐使用<code>document.createDocumentFragment()</code></strong>。</li><li>上面也提到，使用<code>DocumentFragment</code>与一般的Node无异，可以当作是DOM对象一样操作。在使用<code>appendChild</code>，<code>insertBefore</code>等方法时，<strong>被添加（插入）的是片段的所有子节点</strong>，而非本身。</li><li><p>因为<strong>文档片段存在于内存中</strong>，并不在DOM中，所以<strong>将子元素插入到文档片段中时不会引起页面回流</strong>（对元素位置和几何上的计算），因此使用<code>DocumentFragment</code>可以起到<strong>性能优化</strong>的作用。例如上面的代码就可以改成下面的片段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    var li = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>由于<code>DocumentFragment</code>的优势，很多JavaScript库都是用它来创建HTML的，包括jQuery。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>DocumentFragment</code>节点不属于文档树，继承的<code>parentNode</code>属性总是 <code>null</code>。</li><li><code>DocumentFragment</code>节点有一种特殊的行为，该行为使得它非常有用，即<strong>当请求把一个<code>DocumentFragment</code>节点插入文档树时，插入的不是<code>DocumentFragment</code>自身，而是它的所有子孙节点</strong>。这使得<code>DocumentFragment</code>成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。</li><li>重点就在于<strong><code>DocumentFragment</code>节点不属于文档树</strong>。因此<strong>当把创建的节点添加到该对象时，并不会导致页面的回流</strong>，因此性能就自然上去了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在进行&lt;strong&gt;DOM操作&lt;/strong&gt;中，我们经常使用&lt;strong&gt;新建元素&lt;/strong&gt;然后&lt;strong&gt;将其插入到文档中&lt;/strong&gt;的操作。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若是非常小（对页面的改动很小）的插入操作或许在性能上没有什么，但是&lt;strong&gt;若需要很多的插入操作和改动&lt;/strong&gt;，继续使用类似于下面的代码则会很有问题。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="DOM" scheme="https://chongtianhong.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>页面添加锚点的三种方式</title>
    <link href="https://chongtianhong.github.io/2018/06/25/methodOfAddingAnchorPoints/"/>
    <id>https://chongtianhong.github.io/2018/06/25/methodOfAddingAnchorPoints/</id>
    <published>2018-06-25T02:15:36.000Z</published>
    <updated>2018-09-27T15:01:56.883Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>HTML中的链接</strong>，正确的说法应该称作”<strong>锚点</strong>“。</li><li>锚点链接（也叫书签链接）常常用于那些内容庞大繁琐的网页，通过<strong>点击命名锚点</strong>，不仅让我们能<strong>指向文档</strong>，还能<strong>指向页面里的特定段落</strong>，更能当作<strong>“精准链接”的便利工</strong>具，让链接对象接近焦点。便于浏览者查看网页内容。类似于我们阅读书籍时的目录页码或章回提示。</li><li>在需要<strong>指定到页面的特定部分</strong>时，<strong>标记锚点</strong>是最佳的方法。　<a id="more"></a></li></ul><h4 id="锚点链接对SEO的作用"><a href="#锚点链接对SEO的作用" class="headerlink" title="锚点链接对SEO的作用"></a>锚点链接对SEO的作用</h4><ul><li>锚链接是一个非常重要的概念，在网页中增加恰当的锚链接，会让所在网页和所指向网页的重要程度有所提升，从而影响到关键词排名。<strong>锚链接对SEO的作用</strong>主要体现在以下几个方面：</li></ul><p><blockquote>对锚链接所在的页面的作用</blockquote>　　</p><ul><li>正常来讲，<strong>页面中增加的锚链接都和页面本身有一定的关系</strong>，因此，<strong>锚文本可以作为锚链接所在的页面的内容的评估</strong>。例如：本篇文章中含有“SEO”的链接，那么，说明本篇文章和SEO有一定关系。</li></ul><p><blockquote>对锚链接所指向页面的作用</blockquote>　　</p><ul><li>锚链接能精确的描述所指向页面的内容，因此，<strong>锚链接能可以对所指向页面的评估</strong>。</li></ul><p><blockquote>锚链接对关键词排名的影响</blockquote>　　</p><ul><li><strong>锚链接对于关键字排名的意义</strong>在于它可以<strong>让内容页随机链接在一起</strong>，<strong>让蜘蛛可以很好的抓取更多页面</strong>，<strong>权重</strong>也能<strong>均匀的传递</strong>，同时<strong>增强页面的相关性</strong>，<strong>最终提升网站的关键词排名</strong>。</li></ul><h4 id="锚点的添加方式"><a href="#锚点的添加方式" class="headerlink" title="锚点的添加方式"></a>锚点的添加方式</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><ul><li><p>给锚点文本标签添加id，使用&lt;a href=”#”&gt;&lt;/a&gt;来定位，当单击a链接时，就会跳到id为a01的p标签处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#a01"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">"a01"</span>&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>这样的定位<strong>可以针对任何标签来定位</strong>。</p></li></ul><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><ul><li><p>给a标签的文本添加锚点，单击链接可跳到name为a01的a标签处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#a01"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;a name=<span class="string">"a01"</span> href=“<span class="comment">#”&gt;练习&lt;/a&gt;</span></span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用name属性<strong>只能针对a标签来定位</strong>，而对div等其他标签就不能起到定位作用。</p></li></ul><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><ul><li>使用JS中<strong>与页面（容器）滚动相关的API</strong> <code>scrollIntoView</code>，可让当前的元素滚动到浏览器窗口的可视区域内。</li><li>调用方法为<code>element.scrollIntoView()</code>，参数默认为true。<ul><li>参数为true时调用该函数，页面（或容器）发生滚动，使element的顶部与视图（容器）顶部对齐；</li><li>参数为false时，使element的底部与视图（容器）底部对齐。</li></ul></li><li><strong>注意</strong>：只有当页面（容器）可滚动时此API才能起作用。</li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li onclick=<span class="string">"javascript:document.getElementById('here').scrollIntoView()"</span>&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTML中的链接&lt;/strong&gt;，正确的说法应该称作”&lt;strong&gt;锚点&lt;/strong&gt;“。&lt;/li&gt;
&lt;li&gt;锚点链接（也叫书签链接）常常用于那些内容庞大繁琐的网页，通过&lt;strong&gt;点击命名锚点&lt;/strong&gt;，不仅让我们能&lt;strong&gt;指向文档&lt;/strong&gt;，还能&lt;strong&gt;指向页面里的特定段落&lt;/strong&gt;，更能当作&lt;strong&gt;“精准链接”的便利工&lt;/strong&gt;具，让链接对象接近焦点。便于浏览者查看网页内容。类似于我们阅读书籍时的目录页码或章回提示。&lt;/li&gt;
&lt;li&gt;在需要&lt;strong&gt;指定到页面的特定部分&lt;/strong&gt;时，&lt;strong&gt;标记锚点&lt;/strong&gt;是最佳的方法。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
      <category term="锚点" scheme="https://chongtianhong.github.io/tags/%E9%94%9A%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用CDN可以加快网络速度</title>
    <link href="https://chongtianhong.github.io/2018/06/24/CDN/"/>
    <id>https://chongtianhong.github.io/2018/06/24/CDN/</id>
    <published>2018-06-24T10:26:12.000Z</published>
    <updated>2018-09-20T16:08:17.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>大多数人都知道，一个用户在打开一个新网站的时候，如果网站打开的速度过慢，用户是很难继续浏览的。</li><li>因此，很多网站的运营人员想方设法的<strong>提高网站的加载速度</strong>。网站的加载速度是一个成功网站的必备要素之一，速度不够快，会<strong>降低转化率</strong>。<a id="more"></a></li><li>本文将简单地介绍下CDN，<strong>CDN是帮助一个网站能够快速打开的有效和实用方法</strong>。</li></ul><h4 id="网站打开速度慢的原因"><a href="#网站打开速度慢的原因" class="headerlink" title="网站打开速度慢的原因"></a>网站打开速度慢的原因</h4><ul><li><strong>网站打开速度慢</strong>受很多因素的影响，简单归纳下常见的几个原因：<ul><li><strong>共享主机服务器</strong>不堪重负，<strong>响应速度慢</strong>；</li><li><strong>网站的图片和内容太大</strong>，需要花费很多时间下载；</li><li>网站使用了太多不同的脚本和图片，这些<strong>脚本和图片没有针对快速加载网站进行优化，加载时间长</strong>；</li><li>网站的服务器位置与网站的访问者<strong>位于不同的地理位置</strong>。</li></ul></li><li>其实还有许多其他的原因，但这些以上列举的几点是最主要的。</li></ul><h4 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h4><ul><li>CDN指的是<strong>内容分发网络</strong>。其基本思路是<strong>尽可能的避开互联网上</strong>有可能影响<strong>数据传输速度</strong>和<strong>稳定性</strong>的瓶颈和环节，使内容传输的更快、更稳定。</li><li>CDN是通过<strong>在网络各处放置节点服务器</strong>所构成的在现有的互联网基础之上的一层<strong>智能虚拟网络</strong>，它能够实<strong>时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间</strong>等综合信息<strong>将用户的请求重新导向离用户最近的服务节点上</strong>。</li><li>CDN系统的目的是使用户可就<strong>近取得所需内容</strong>，<strong>解决Internet网络拥挤</strong>的状况，<strong>提高用户访问网站的响应速度</strong>。</li><li>CDN起到<strong>内容分发</strong>的作用，就是<strong>网站的内容是被复制到各个地区的不同服务器上面</strong>，这个距离离访问者所在地越近越好。</li><li>下图就展示了未使用CDN和使用CDN的区别图，显而易见，<strong>使用CDN可以提高访问速度</strong>：<br><img src="/images/CDN.png" alt="未使用CDN和使用CDN的区别图" width="600" style="border:none"></li></ul><h4 id="网站使用CDN加速的好处"><a href="#网站使用CDN加速的好处" class="headerlink" title="网站使用CDN加速的好处"></a>网站使用CDN加速的好处</h4><ul><li><strong>网站加速，利于Google的排名</strong>：Google 把网站的打开速度当做一个比较重要的指标，所以网站打开的速度会影响Google排名。使用CDN之后，网站打开速度变快，就可以减少跳出率，也可以增加用户对网站的友好体验。</li><li><strong>有利于提高网站的转化率</strong>：毫无疑问，用户的访问网站的时间提高了，跳出率减少了，当然会利于网站的转化率和销售量。现在大环境下的人们都比较浮躁，我想谁都没有耐心去等一个需要10秒才能打开的网站，这样的网站一开始就不友好，更别想提高网站的转化率了。</li><li><strong>提升网站的稳定性和安全性</strong>：CDN因为节点分散，攻击者比较难下手，攻击一个节点仅仅是影响一个节点的缓存访问而已，并且CDN的“内容路由”会自动的启用另一个节点，如果CDN服务节点数量够多，那么攻击者需要的流量包就会呈几何级的增加，这样攻击成本自然就高了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;大多数人都知道，一个用户在打开一个新网站的时候，如果网站打开的速度过慢，用户是很难继续浏览的。&lt;/li&gt;
&lt;li&gt;因此，很多网站的运营人员想方设法的&lt;strong&gt;提高网站的加载速度&lt;/strong&gt;。网站的加载速度是一个成功网站的必备要素之一，速度不够快，会&lt;strong&gt;降低转化率&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CDN加速" scheme="https://chongtianhong.github.io/tags/CDN%E5%8A%A0%E9%80%9F/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>大流量的下兜底容灾方案（转）</title>
    <link href="https://chongtianhong.github.io/2018/06/23/frontEndDisasterRecoveryPlan/"/>
    <id>https://chongtianhong.github.io/2018/06/23/frontEndDisasterRecoveryPlan/</id>
    <published>2018-06-23T08:55:16.000Z</published>
    <updated>2018-09-20T14:40:25.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>随着网络的普及，上网的成本和门槛越来越低，很多网站的流量也是蹭蹭蹭的往上涨，而<strong>页面上的数据来源也不确定</strong>，可能<strong>来自多个平台</strong>，也可能是有<strong>专门的人员在手动维护</strong>。由于<strong>数据来源众多，出错的概率</strong>也会<strong>增加</strong>，为了<strong>降低页面在大流量下的维护成本</strong>，本文做了一些阐述。<a id="more"></a></li></ul><h4 id="兜底容灾的必要性"><a href="#兜底容灾的必要性" class="headerlink" title="兜底容灾的必要性"></a>兜底容灾的必要性</h4><ul><li>一个日均承载几千万上亿流量的网页，会经常出现以下问题：<br>① 某个<strong>接口挂了</strong>，前端拿不到数据或者拿到的数据不够，<strong>页面展示就会出问题</strong>，出现空白或者某个模块直接出错。<br>② <strong>用户因为网络问题</strong>或者<strong>安装了某些插件</strong>，导致页面广告、接口请求挂掉，从而页面出现问题。</li><li><strong>前者的概率不是很大</strong>，因为<strong>网页上的请求 QPS 都是预先评估过的</strong>，只要前端请求没有成倍激增，并且后端压力都在系统监控范围内，不会出太大的岔子。但是一旦出问题，页面上就有可能空白一大块，<strong>如果后端排查和处理问题不及时</strong>，很可能从<strong>小问题演变成故障</strong>。</li><li>而<strong>第二个问题比较严峻</strong>，据统计，不管网站做的多简洁，总是会有千分之一的<strong>用户因为网络或者浏览器插件问题导致页面访问失败</strong>或者<strong>部分接口请求失败</strong>，比如一个 pv 一亿的网站，按照千分之一计算，一个接口每天会有 10w 左右的 pv 请求失败，而请求接口一多，页面上整体的请求失败量就很高了，这个数据会达到几百万。</li></ul><h4 id="如何兜底，如何容灾"><a href="#如何兜底，如何容灾" class="headerlink" title="如何兜底，如何容灾"></a>如何兜底，如何容灾</h4><ul><li><strong>兜底容灾的方案</strong>有很多，<strong>目的</strong>就是让<strong>请求失败而页面展示依然正常</strong>。下面说一说常用的几个方案：</li></ul><h5 id="再请求一次"><a href="#再请求一次" class="headerlink" title="再请求一次"></a>再请求一次</h5><ul><li><p>照顾到用户体验，同时也<strong>考虑到一个请求的正常发送、接受时间</strong>，我们<strong>把超时时间设置为 5s</strong>，<strong>超过 5s 或者请求的结果状态为 failed ，则重新请求一次</strong>。所以我们可以重新封装下 Ajax 模块，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 设置请求次数</span><br><span class="line">var tryTimes = 2;</span><br><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    timeout: 5000,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    // try</span><br><span class="line">    tryTimes: tryTimes</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这种处理方案<strong>对于提交订单、选中商品到购物车的页面比较合适</strong>，因为操作流是确定的，提交一次不成功，很自然的想到再提交一次，只是<strong>用户等待的不同阶段应该用不同的文案来提醒</strong>。</p></li><li>而<strong>对于展示类的数据请求，不太适合多次失败尝试</strong>。所以首页未采用这种方案。</li></ul><h5 id="缓存每一次请求到本地"><a href="#缓存每一次请求到本地" class="headerlink" title="缓存每一次请求到本地"></a>缓存每一次请求到本地</h5><ul><li><p>现在的<strong>浏览器都支持本地储存</strong>（无论使用 userData 还是 localStorage），<strong>当每次请求到达用户浏览器的时候，把请求的数据缓存一份到本地储存</strong>，那么下次请求失败就可以使用上次缓存的数据了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    success: <span class="keyword">function</span>(data)&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">        cache(DATAKEY, data);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 请求失败，获取本地缓存数据</span><br><span class="line">        var data = cache(DATAKEY);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这种方式是比较常用的，<strong>每次请求成功都会缓存最新的数据</strong>。不过这里存在两个问题：<br>① 如果<strong>用户第一次访问就失败了</strong>，假设新用户是比较多的。<br>② <strong>缓存的数据是否具有时效性</strong>，如果缓存的数据过期了：比如是一个推荐接口，推荐的商品用户已经购买过了，但是访问的时候接口挂掉，依然显示用户购买过的商品，这个逻辑是不太能接受的。</p></li><li>对<strong>于第一次访问</strong>的情况，这个概率是相当低的，但是要提出另外的解决方案来避免新用户访问页面显示空白的情况发生。</li><li>而对于第二个问题，<strong>有缓存总比没有数据的好</strong>，就算数据过期，但是依然是正确的链接，所以<strong>基本可以接受</strong>。</li></ul><h5 id="备用接口（硬兜底）"><a href="#备用接口（硬兜底）" class="headerlink" title="备用接口（硬兜底）"></a>备用接口（硬兜底）</h5><ul><li>当<strong>后端接口返回失败，用户本地也没有数据缓存</strong>的时候，则可以<strong>采用备用接口</strong>的方式（通过<strong>访问CDN对应地址</strong>拉取数据渲染）。</li><li><p>当<strong>后端为网页接口准备一个备用接口</strong>后，前端请求时可以做个包装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    // 备份接口</span><br><span class="line">    backUrl: backUrl</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>一旦请求失败，<strong>进入备用数据接口请求备份数据</strong>。</p></li><li>同样的，这里也存在一个问题：如果接口是个性化的，则每个用户访问这个接口拿到的数据都不一样，那么这个备份接口该如何推数据？如果备用接口的数据跟正常接口一样，那还不如直接去请求两次。所以这里提到的备用接口，主要是<strong>数据的硬兜底</strong>，硬兜底的来源有两个：<br>① <strong>运营</strong>维护一份数据，推送到 CDN，每一份数据都有一个固定的地址；<br>② <strong>后端</strong>向 CDN push 一份通用数据。我们知道<strong>个性化都是使用 cookie 去识别用户的</strong>，对于没有浏览器记录的新用户就没有 cookie，此时会推一份通用的数据，这个<strong>通用的数据可以作为接口的备份源</strong>。</li></ul><h4 id="兜底容错实践"><a href="#兜底容错实践" class="headerlink" title="兜底容错实践"></a>兜底容错实践</h4><ul><li>我们很容易得到如下的操作流程：<br><img src="/images/frontEndDisasterRecoveryPlan1.png" alt="兜底容错实践操作流程1" width="600" style="border:none"></li><li>而这里存在的问题是：<br>① 获取缓存数据后，不好对数据格式进行判断，一般来说，<strong>只有有效的数据才能存到本地储存中</strong>，而判断是否有效往往存在误差；<br>② <strong>兜底数据没有及时更新</strong>；<br>③ <strong>程序只会报警</strong>，但是<strong>不会自动修复</strong>。</li><li>存在的隐患是：<br>① <strong>前端每次改版</strong>，如更换接口、更换人员，<strong>兜底数据没有及时更新</strong>；<br>② 如果<strong>兜底数据也存在错误</strong>，则页面一定出现空白天窗。</li><li>所以对整个流程做了一些改进：<br><img src="/images/frontEndDisasterRecoveryPlan2.png" alt="兜底容错实践操作流程2" width="600" style="border:none"></li><li>数据经过统一平台输出，在输出之前，我们将数据推一份到 CDN 作为备份，产生另一个接口，一旦原始接口请求失败，则直接请求备份的接口，这个在<strong>规则对应</strong>和<strong>即时更新</strong>上可以做到很好！那么基本的流程就是这样：<br><img src="/images/frontEndDisasterRecoveryPlan3.png" alt="兜底容错实践操作流程2的基本流程" width="200" style="border:none"></li><li>不过为了确保无误，我的建议是，<strong>页面上每个接口必须对应一个运营手填的数据</strong>，这个<strong>作为最后的硬兜底</strong>，而<strong>这个硬兜底也会被缓存到本地</strong>，整个流程就形成一个闭环。那么，剩下的工作就只有监控和警报了。</li><li><p>下面是一串伪代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var url = interfaceURL;</span><br><span class="line">var backUrl = interfaceBackURL;</span><br><span class="line">var hardBackUrl = hardDataURL;</span><br><span class="line">var cacheTime = 10day;</span><br><span class="line"></span><br><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    backurl: backUrl,</span><br><span class="line">    success: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">        cache(DATAKEY, data, cacheTime);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 请求失败，获取本地缓存数据</span><br><span class="line">        var data = cache(DATAKEY);</span><br><span class="line">        <span class="keyword">if</span>(data) &#123;</span><br><span class="line">            Reporter.send(/*WARN*/);</span><br><span class="line">            show(data); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Reporter.send(/*ERROR*/);</span><br><span class="line">            _failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 请求硬兜底</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_failed</span></span>() &#123;</span><br><span class="line">    Ajax(&#123;</span><br><span class="line">        url: hadrBackUrl,</span><br><span class="line">        success: <span class="keyword">function</span>(data)&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">            cache(DATAKEY, data, cacheTime);</span><br><span class="line">            show(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            Reporter.send(/*SUPER_ERROR*/);</span><br><span class="line">            show(data); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意到，我们在上面使用了缓存失效时间，考虑到数据的及时性，设置为 10 天。backUrl 是 url 的备份地址，hardBackUrl 是运营填写的备份数据，整个流程都在闭环之中，所以出问题的概率就大大降低了，即便是后端接口出错，我们也可以看着监控信息，放心的给后端开发打个电话，告知下等待修复，而不是急急忙忙，担惊受怕。</p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>本文提供的都是伪代码，而这些伪代码的实现并不复杂，也没必要写成组件，主要是提供思路，如何<strong>处理大流量高并发下的异步数据接口的兜底容灾</strong>。</li></ul><div class="note info">原文出处：<a href="https://www.barretlee.com/blog/2015/09/16/backup-solution-at-big-traffic/" target="_blank" rel="noopener">大流量的下兜底容灾方案</a></div>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;随着网络的普及，上网的成本和门槛越来越低，很多网站的流量也是蹭蹭蹭的往上涨，而&lt;strong&gt;页面上的数据来源也不确定&lt;/strong&gt;，可能&lt;strong&gt;来自多个平台&lt;/strong&gt;，也可能是有&lt;strong&gt;专门的人员在手动维护&lt;/strong&gt;。由于&lt;strong&gt;数据来源众多，出错的概率&lt;/strong&gt;也会&lt;strong&gt;增加&lt;/strong&gt;，为了&lt;strong&gt;降低页面在大流量下的维护成本&lt;/strong&gt;，本文做了一些阐述。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="兜底" scheme="https://chongtianhong.github.io/tags/%E5%85%9C%E5%BA%95/"/>
    
      <category term="容灾" scheme="https://chongtianhong.github.io/tags/%E5%AE%B9%E7%81%BE/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之WXS模块</title>
    <link href="https://chongtianhong.github.io/2018/06/22/wxsOfMiniProgram/"/>
    <id>https://chongtianhong.github.io/2018/06/22/wxsOfMiniProgram/</id>
    <published>2018-06-22T02:37:08.000Z</published>
    <updated>2018-09-19T14:17:03.756Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>WXS（WeiXin Script）是<strong>小程序</strong>的一套<strong>脚本语言</strong>，<strong>与 wxml 结合</strong>，可以构建出页面的结构。</li><li>WXS 代码可以编写在wxml文件中的 &lt;wxs&gt; 标签内，或以 <code>.wxs</code> 为后缀名的文件内。<a id="more"></a></li></ul><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><ul><li>每一个 <code>.wxs</code> 文件和 &lt;wxs&gt; 标签都是一个<strong>单独的模块</strong>。</li><li><strong>每个模块</strong>都有自己<strong>独立的作用域</strong>。即在一个模块里面定义的变量与函数，<strong>默认为私有的</strong>，<strong>对其他模块不可见</strong>。</li><li>一个模块要想<strong>对外暴露其内部的私有变量与函数</strong>，只能<strong>通过 <code>module.exports</code> 实现</strong>。</li></ul><h5 id="wxs-文件"><a href="#wxs-文件" class="headerlink" title=".wxs 文件"></a>.wxs 文件</h5><ul><li><p>在微信开发者工具里面，右键可以直接创建 <code>.wxs</code> 文件，在其中直接编写 WXS 脚本。示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/comm.wxs</span><br><span class="line">*/ </span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from comm.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span>(d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    foo: foo,</span><br><span class="line">    bar: bar</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上述例子在 <code>/pages/comm.wxs</code> 的文件里面编写了 WXS 代码。该 <code>.wxs</code> 文件<strong>可以被其他的 <code>.wxs</code> 文件 或 WXML 中的 <wxs> 标签引用</wxs></strong>。</p></li></ul><h5 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h5><ul><li>每个 wxs 模块均有一个<strong>内置的 module 对象</strong>。</li><li>module 对象有一个<code>exports</code>属性。 通过该属性，可以<strong>对外共享</strong>本模块的<strong>私有变量与函数</strong>。</li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/tools.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from tools.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span> (d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    FOO: foo,</span><br><span class="line">    bar: bar,</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.msg = <span class="string">"some msg"</span>;</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- page/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../tools.wxs"</span> module=<span class="string">"tools"</span> /&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.msg&#125;&#125; &lt;/view&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.bar(tools.FOO)&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some msg</span><br><span class="line"><span class="string">'hello world'</span> from tools.wxs</span><br></pre></td></tr></table></figure></li></ul><h5 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h5><ul><li>在<code>.wxs</code>模块中<strong>引用其他 wxs 文件模块</strong>，可以<strong>使用 <code>require</code>函数</strong>。</li><li>引用的时候，要注意如下几点：<ul><li>只能引用<code>.wxs</code>文件模块，且<strong>必须使用相对路径</strong>。</li><li>wxs 模块均为<strong>单例</strong>，wxs 模块在第一次被引用时，会自动初始化为单例对象。<strong>多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象</strong>。</li><li>如果一个 <strong>wxs 模块在定义之后，一直没有被引用</strong>，则该模块<strong>不会被解析与运行</strong>。</li></ul></li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/tools.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from tools.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span> (d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    FOO: foo,</span><br><span class="line">    bar: bar,</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.msg = <span class="string">"some msg"</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>logic.wxs</code>模块中引用<code>tools.wxs</code>文件模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/logic.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var tools = require(<span class="string">"./tools.wxs"</span>);</span><br><span class="line"></span><br><span class="line">console.log(tools.FOO);</span><br><span class="line">console.log(tools.bar(<span class="string">"logic.wxs"</span>));</span><br><span class="line">console.log(tools.msg);</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- /page/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../logic.wxs"</span> module=<span class="string">"logic"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>控制台输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span> from tools.wxs</span><br><span class="line">logic.wxs</span><br><span class="line">some msg</span><br></pre></td></tr></table></figure></li></ul><h5 id="wxs标签"><a href="#wxs标签" class="headerlink" title="wxs标签"></a>wxs标签</h5><ul><li>&lt;wxs&gt;标签有两个属性，如下表所示：</li></ul><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">module</td><td style="text-align:center">String</td><td style="text-align:center">当前 &lt;wxs&gt; 标签的模块名。必填字段</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">String</td><td style="text-align:center">引用 .wxs 文件的相对路径。仅当本标签为<strong>单闭合标签</strong>或<strong>标签的内容为空</strong>时有效</td></tr></tbody></table><blockquote>module 属性</blockquote><ul><li>module 属性是<strong>当前 &lt;wxs&gt; 标签的模块名</strong>。在单个 wxml 文件内，<strong>建议其值唯一</strong>。有重复模块名则<strong>按照先后顺序覆盖</strong>（后者覆盖前者）。<strong>不同文件之间的 wxs 模块名不会相互覆盖</strong>。</li><li>module 属性值的命名必须符合下面两个规则：<ul><li>首字符必须是：字母（a-zA-Z），下划线（_）</li><li>剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）</li></ul></li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--wxml--&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs module=<span class="string">"foo"</span>&gt;</span><br><span class="line">    var some_msg = <span class="string">"hello world"</span>;</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        msg : some_msg,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;foo.msg&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></li><li><p>上面例子声明了一个名字为<code>foo</code>的模块，将<code>some_msg</code>变量暴露出来，供当前页面使用。</p></li></ul><blockquote>src 属性</blockquote><ul><li>src 属性可以用来<strong>引用其他的 wxs 文件模块</strong>。</li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/index/index.js</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">"'hello wrold' from js"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- /pages/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../comm.wxs"</span> module=<span class="string">"some_comms"</span>&gt;&lt;/wxs&gt;</span><br><span class="line">&lt;!-- 也可以直接使用单标签闭合的写法</span><br><span class="line">    &lt;wxs src=<span class="string">"./../comm.wxs"</span> module=<span class="string">"some_comms"</span> /&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 some_comms 模块里面的 foo --&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;some_comms.bar(some_comms.foo)&#125;&#125; &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 page/index/index.js 里面的 msg --&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;some_comms.bar(msg)&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span> from comm.wxs</span><br><span class="line"><span class="string">'hello wrold'</span> from js</span><br></pre></td></tr></table></figure></li><li><p>上述例子在文件<code>/page/index/index.wxml</code>中通过 &lt;wxs&gt; 标签引用了<code>/page/comm.wxs</code>模块。</p></li><li>注意：<ul><li>&lt;wxs&gt; 模块只能在<strong>定义模块的 WXML 文件</strong>中被访问到。使用 &lt;include&gt; 或 &lt;import&gt; 时，&lt;wxs&gt; 模块不会被引入到对应的 WXML 文件中。</li><li>&lt;template&gt; 标签中，只能使用定义该 &lt;template&gt; 的 WXML 文件中定义的 &lt;wxs&gt; 模块。</li></ul></li></ul><h4 id="微信小程序，用js还是wxs？"><a href="#微信小程序，用js还是wxs？" class="headerlink" title="微信小程序，用js还是wxs？"></a>微信小程序，用js还是wxs？</h4><ul><li>在开发微信小程序的时候，应该<strong>根据情况</strong>，选择使用js或wxs。</li><li>wxs是专门用于wxml页面的，如果我们有<strong>在页面中使用js脚本</strong>的需求可以使用wxs来实现。</li><li>wxs和js<strong>不能互相直接调用</strong>。</li><li>wxs其实就是封装后的js，用法跟js一模一样。有些功能，用wxs和js都能实现，但是有时会发现用wxs<strong>更方便、直接</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;WXS（WeiXin Script）是&lt;strong&gt;小程序&lt;/strong&gt;的一套&lt;strong&gt;脚本语言&lt;/strong&gt;，&lt;strong&gt;与 wxml 结合&lt;/strong&gt;，可以构建出页面的结构。&lt;/li&gt;
&lt;li&gt;WXS 代码可以编写在wxml文件中的 &amp;lt;wxs&amp;gt; 标签内，或以 &lt;code&gt;.wxs&lt;/code&gt; 为后缀名的文件内。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="https://chongtianhong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="WXS" scheme="https://chongtianhong.github.io/tags/WXS/"/>
    
  </entry>
  
  <entry>
    <title>使用moment.js轻松管理日期和时间</title>
    <link href="https://chongtianhong.github.io/2018/06/21/momentJS/"/>
    <id>https://chongtianhong.github.io/2018/06/21/momentJS/</id>
    <published>2018-06-21T02:33:16.000Z</published>
    <updated>2018-09-19T14:09:06.287Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>moment.js</strong>是一个非常好用的时间处理插件，对js中的date对象进行了一层封装，使之具有更加强大日期处理能力。</li><li><strong>moment.js</strong>里面包含了非常多而且有用的<strong>对时间进行操作</strong>的方法，例如：时间加减法、比较大小/差值计算、isBefore/isAfter，还支持非常多的时间格式及语言。<a id="more"></a></li></ul><h4 id="moment-js"><a href="#moment-js" class="headerlink" title="moment.js"></a>moment.js</h4><ul><li>Momentjs<strong>支持多个环境</strong>，既可以<strong>在浏览器中使用</strong>，也可以<strong>脱离浏览器的环境在nodejs中使用</strong>。</li></ul><h5 id="node"><a href="#node" class="headerlink" title="node"></a>node</h5><ul><li>在Node.js中使用momentjs的话需要<strong>安装moment模块</strong>，然后<strong>加载模块</strong>就行了。命令如下: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install moment </span><br><span class="line">var moment = require(<span class="string">'moment'</span>);</span><br><span class="line">moment().format();</span><br></pre></td></tr></table></figure></li></ul><h5 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h5><ul><li>在浏览器中使用，则用下面方法引入momentjs文件即可，使用的时候在Node.js和浏览器中并没有什么区别。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"moment.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    moment().format();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>下面将对一些常用方法进行介绍，更多内容可到<a href="http://momentjs.cn/" target="_blank" rel="noopener">Moment.js 中文网</a>获取。</li></ul><blockquote>日期格式化</blockquote><ul><li><p>当前时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>); // 2018-06-14 23:36:09</span><br></pre></td></tr></table></figure></li><li><p>今天是星期几：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'d'</span>); // 4</span><br></pre></td></tr></table></figure></li><li><p>转换当前时间的Unix时间戳：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'X'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote>字符串转日期</blockquote><ul><li>代码示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'2018-06-14'</span>).toDate();</span><br><span class="line">moment(<span class="string">'2018-06-14 10:20:15'</span>).toDate();</span><br></pre></td></tr></table></figure></li></ul><blockquote>时间戳转日期</blockquote><ul><li>代码示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(1448896064621).toDate();</span><br></pre></td></tr></table></figure></li></ul><blockquote>相对时间</blockquote><ul><li><p>时间加减：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'years'</span>);       // 加7年</span><br><span class="line">moment().add(7, <span class="string">'month'</span>);       // 加7个月</span><br><span class="line">moment().add(7, <span class="string">'days'</span>);        // 加7天</span><br><span class="line">moment().add(7, <span class="string">'hours'</span>);       // 加7小时</span><br><span class="line">moment().add(7, <span class="string">'minutes'</span>);     // 加7分钟</span><br><span class="line">moment().add(7, <span class="string">'seconds'</span>);     // 加7秒钟</span><br><span class="line"> </span><br><span class="line">moment().subtract(7, <span class="string">'years'</span>);  // 减7年</span><br><span class="line">moment().subtract(7, <span class="string">'month'</span>);  // 减7个月</span><br><span class="line">moment().subtract(7, <span class="string">'days'</span>);   // 减7天</span><br><span class="line">moment().subtract(7, <span class="string">'hours'</span>);  // 减7小时</span><br><span class="line">moment().subtract(7, <span class="string">'minutes'</span>);// 减7分钟</span><br><span class="line">moment().subtract(7, <span class="string">'seconds'</span>);// 减7秒钟</span><br><span class="line"></span><br><span class="line">moment().subtract(7, <span class="string">'days'</span>).format(<span class="string">'YYYY年MM月DD日'</span>); // 7天前的日期</span><br><span class="line">moment().add(7, <span class="string">'days'</span>).format(<span class="string">'YYYY年MM月DD日'</span>); // 7天后的日期</span><br><span class="line">moment().subtract(7, <span class="string">'hours'</span>).format(<span class="string">'HH:mm:ss'</span>); // 7小时前的时间</span><br><span class="line">moment().add(7, <span class="string">'hours'</span>).format(<span class="string">'HH:mm:ss'</span>); // 7小时后的时间</span><br></pre></td></tr></table></figure></li><li><p>moment.js的函数<strong>支持链式写法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'days'</span>).add(1, <span class="string">'months'</span>);</span><br></pre></td></tr></table></figure></li><li><p>20160601相对当前日期是2年前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">"20160601"</span>, <span class="string">"YYYYMMDD"</span>).fromNow(); // 2 years ago</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h4><ul><li>moment.js提供了丰富的说明文档，使用它还可以<strong>创建日历项目</strong>等复杂的日期时间应用。</li><li>在日常开发中最常用的是<strong>格式化时间</strong>，下面将常用的格式制作成表格说明：</li></ul><table><thead><tr><th style="text-align:center">格式代码</th><th style="text-align:center">说明</th><th style="text-align:center">返回值例子</th></tr></thead><tbody><tr><td style="text-align:center">M</td><td style="text-align:center">数字表示的月份，没有前导零</td><td style="text-align:center">1到12</td></tr><tr><td style="text-align:center">MM</td><td style="text-align:center">数字表示的月份，有前导零</td><td style="text-align:center">01到12</td></tr><tr><td style="text-align:center">MMM</td><td style="text-align:center">三个字母缩写表示的月份</td><td style="text-align:center">Jan到Dec</td></tr><tr><td style="text-align:center">MMMM</td><td style="text-align:center">月份，完整的文本格式</td><td style="text-align:center">January到December</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">季度</td><td style="text-align:center">1到4</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">月份中的第几天，没有前导零</td><td style="text-align:center">1到31</td></tr><tr><td style="text-align:center">DD</td><td style="text-align:center">月份中的第几天，有前导零</td><td style="text-align:center">01到31</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">星期中的第几天，数字表示</td><td style="text-align:center">0到6，0表示周日，6表示周六</td></tr><tr><td style="text-align:center">ddd</td><td style="text-align:center">三个字母缩写表示星期中的第几天</td><td style="text-align:center">Sun到Sat</td></tr><tr><td style="text-align:center">dddd</td><td style="text-align:center">星期几，完整的星期文本</td><td style="text-align:center">从Sunday到Saturday</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">年份中的第几周</td><td style="text-align:center">如42：表示第42周</td></tr><tr><td style="text-align:center">YYYY</td><td style="text-align:center">四位数字完整表示的年份</td><td style="text-align:center">如：2014 或 2000</td></tr><tr><td style="text-align:center">YY</td><td style="text-align:center">两位数字表示的年份</td><td style="text-align:center">如：14 或 98</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">大写的AM PM</td><td style="text-align:center">AM PM</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">小写的am pm</td><td style="text-align:center">am pm</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">小时，24小时制，无前导零</td><td style="text-align:center">0到23</td></tr><tr><td style="text-align:center">HH</td><td style="text-align:center">小时，24小时制，有前导零</td><td style="text-align:center">00到23</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">小时，12小时制，无前导零</td><td style="text-align:center">0到12</td></tr><tr><td style="text-align:center">hh</td><td style="text-align:center">小时，12小时制，有前导零</td><td style="text-align:center">00到12</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">没有前导零的分钟数</td><td style="text-align:center">0到59</td></tr><tr><td style="text-align:center">mm</td><td style="text-align:center">有前导零的分钟数</td><td style="text-align:center">00到59</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">没有前导零的秒数</td><td style="text-align:center">0到59</td></tr><tr><td style="text-align:center">ss</td><td style="text-align:center">有前导零的描述</td><td style="text-align:center">00到59</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">Unix时间戳</td><td style="text-align:center">1411572969</td></tr></tbody></table><h4 id="写法示例"><a href="#写法示例" class="headerlink" title="写法示例"></a>写法示例</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment() // 当前时间</span><br><span class="line">moment(<span class="string">"1995-12-25"</span>) // 1995-12-25</span><br><span class="line">moment(<span class="string">"12-25-1995"</span>, <span class="string">"MM-DD-YYYY"</span>) // 1995-12-25</span><br><span class="line">moment(&#123; year :2010, month :3, day :5, hour :15, minute :10, second :3, millisecond :123&#125;)</span><br><span class="line">moment(Date.now() - 24 * 60 * 60 * 1000) // 昨天</span><br><span class="line">moment(new Date(2011, 9, 16)) // 2011-10-16</span><br></pre></td></tr></table></figure><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'YYYY年MM月DD日 HH:mm:ss'</span>) // 2016年11月11日 22:05:19</span><br><span class="line">moment().format(<span class="string">'hh:m:ss'</span>) // 10:5:19</span><br><span class="line">moment().format(<span class="string">'[YYYY]'</span>) // <span class="string">"YYYY"</span>。[] 里的会原样输出。</span><br></pre></td></tr></table></figure><h5 id="转化成-Date-对象"><a href="#转化成-Date-对象" class="headerlink" title="转化成 Date 对象"></a>转化成 Date 对象</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().toDate()</span><br></pre></td></tr></table></figure><h5 id="获取-设置时间信息"><a href="#获取-设置时间信息" class="headerlink" title="获取/设置时间信息"></a>获取/设置时间信息</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">moment().second() //获得 秒</span><br><span class="line">moment().second(Number) //设置 秒。0 到 59</span><br><span class="line">moment().minute() //获得 分</span><br><span class="line">moment().minute(Number) //设置 分。0 到 59</span><br><span class="line">// 类似的用法</span><br><span class="line">moment().hour() // 小时</span><br><span class="line">moment().date() // 一个月里的第几天</span><br><span class="line">moment().day() // 星期几</span><br><span class="line">moment().dayOfYear() // 一年里的第几天</span><br><span class="line">moment().week() // 一年里的第几周</span><br><span class="line">moment().month() // 第几个月</span><br><span class="line">moment().quarter() // 一年里的第几个季度</span><br><span class="line">moment().year() // 年</span><br><span class="line">moment().daysInMonth() // 当前月有多少天</span><br></pre></td></tr></table></figure><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'days'</span>) // 之后的第7天。第2个参数还可以是 <span class="string">'months'</span>, <span class="string">'years'</span> 等。注意是复数。</span><br><span class="line">moment().add(7, <span class="string">'d'</span>）// 与上面一行代码的运行结果一样。</span><br><span class="line">moment().subtract(1, <span class="string">'months'</span>) // 上个月</span><br><span class="line"></span><br><span class="line">moment().startOf(<span class="string">'week'</span>) // 这周的第一天</span><br><span class="line">moment().startOf(<span class="string">'hour'</span>) // 与 moment().minutes(0).seconds(0).milliseconds(0)等效。</span><br><span class="line">// 还支持 <span class="string">'year'</span>，<span class="string">'month'</span> 等</span><br><span class="line"></span><br><span class="line">moment().endOf(<span class="string">'week'</span>) // 这周的最后一天</span><br></pre></td></tr></table></figure><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 早于</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2010-10-21'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2010-12-31'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 是否相等</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2010-10-20'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2009-12-31'</span>, <span class="string">'year'</span>)  // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2010-01-01'</span>, <span class="string">'year'</span>)  // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 晚于</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2010-10-19'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2010-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2009-12-31'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 是否在时间范围内</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-10-19'</span>, <span class="string">'2010-10-25'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-01-01'</span>, <span class="string">'2012-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2009-12-31'</span>, <span class="string">'2012-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">moment().isLeapYear() // 是否是闰年</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;moment.js&lt;/strong&gt;是一个非常好用的时间处理插件，对js中的date对象进行了一层封装，使之具有更加强大日期处理能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;moment.js&lt;/strong&gt;里面包含了非常多而且有用的&lt;strong&gt;对时间进行操作&lt;/strong&gt;的方法，例如：时间加减法、比较大小/差值计算、isBefore/isAfter，还支持非常多的时间格式及语言。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="moment.js" scheme="https://chongtianhong.github.io/tags/moment-js/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序动态修改页面标题</title>
    <link href="https://chongtianhong.github.io/2018/06/20/setNavigationBarTitle/"/>
    <id>https://chongtianhong.github.io/2018/06/20/setNavigationBarTitle/</id>
    <published>2018-06-20T02:55:36.000Z</published>
    <updated>2018-09-19T14:16:25.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在微信小程序的开发中，如果页面的状态改变，需要<strong>动态的修改微信小程序的页面的标题</strong>，可以通过<strong>微信小程序提供的API</strong>，<code>wx.setNavigationBarTitle</code>来实现动态的修改微信小程序的页面标题。<a id="more"></a></li></ul><h4 id="静态设置页面标题"><a href="#静态设置页面标题" class="headerlink" title="静态设置页面标题"></a>静态设置页面标题</h4><ul><li>在<strong>对应页面的json文件</strong>里面加入下面代码就可以<strong>实现页面标题的设置</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"当前页标题"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="动态设置页面标题"><a href="#动态设置页面标题" class="headerlink" title="动态设置页面标题"></a>动态设置页面标题</h4><ul><li><p>下面是动态修改微信小程序的页面标题的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var sign = 1;</span><br><span class="line">    var <span class="built_in">times</span> = setInterval(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(sign &gt; 10 )</span><br><span class="line">        &#123;</span><br><span class="line">            clearInterval(<span class="built_in">times</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            var tmpTitle = <span class="string">'微信小程序的页面标题'</span> + sign++;</span><br><span class="line">            wx.setNavigationBarTitle(&#123;</span><br><span class="line">            title: tmpTitle,</span><br><span class="line">            success: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"当前微信小程序的页面标题为\""</span> + tmpTitle + <span class="string">"\""</span> );</span><br><span class="line">            &#125;,</span><br><span class="line">            complete: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"动态修改微信小程序的页面标题-complete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>关键的操作是<code>wx.setNavigationBarTitle({ title: tmpTitle })</code>。</p></li><li><code>wx.setNavigationBarTitle</code>的API也<strong>支持</strong>在执行修改小程序页面标题的成功、失败和完成的状态的<strong>回调事件</strong>。</li><li>注意<code>wx.setNavigationBarTitle</code>要在onready之后设置<br>（onload也是在onready）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在微信小程序的开发中，如果页面的状态改变，需要&lt;strong&gt;动态的修改微信小程序的页面的标题&lt;/strong&gt;，可以通过&lt;strong&gt;微信小程序提供的API&lt;/strong&gt;，&lt;code&gt;wx.setNavigationBarTitle&lt;/code&gt;来实现动态的修改微信小程序的页面标题。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="https://chongtianhong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="setNavigationBarTitle" scheme="https://chongtianhong.github.io/tags/setNavigationBarTitle/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（五）事件类型之鼠标事件</title>
    <link href="https://chongtianhong.github.io/2018/06/19/mouseEventOfEventType/"/>
    <id>https://chongtianhong.github.io/2018/06/19/mouseEventOfEventType/</id>
    <published>2018-06-19T11:46:45.000Z</published>
    <updated>2018-09-19T14:09:10.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><ul><li>DOM3级事件中定义了9个鼠标事件：<ul><li><code>mousedown</code>：<strong>鼠标按钮被按下（左键或者右键）</strong>时触发。不能通过键盘触发。</li><li><code>mouseup</code>：<strong>鼠标按钮被释放弹起</strong>时触发。不能通过键盘触发。</li><li><code>click</code>：<strong>单击鼠标左键</strong>或者<strong>按下回车键</strong>时触发。这点对确保易访问性很重要，意味着<code>onclick</code>事件处理程序<strong>既可以通过键盘也可以通过鼠标执行</strong>。</li><li><code>dblclick</code>：<strong>双击鼠标左键</strong>时触发。</li><li><code>mouseover</code>：鼠标移入目标元素上方。鼠标移到其后代元素上时会触发。</li><li><code>mouseout</code>：鼠标移出目标元素上方。</li><li><code>mouseenter</code>：鼠标移入元素范围内触发，该事件<strong>不冒泡</strong>，即<strong>鼠标移到其后代元素上时不会触发</strong>。</li><li><code>mouseleave</code>：鼠标移出元素范围时触发，该事件<strong>不冒泡</strong>，即<strong>鼠标移到其后代元素时不会触发</strong>。</li><li><code>mousemove</code>：<strong>鼠标在元素内部移动</strong>时不断触发。不能通过键盘触发。</li></ul></li></ul><h5 id="事件触发的顺序"><a href="#事件触发的顺序" class="headerlink" title="事件触发的顺序"></a>事件触发的顺序</h5><ul><li><p>举例：通过双击按钮，看一下所触发的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"mousedown"</span>, <span class="keyword">function</span>(event) &#123;</span><br><span class="line">            console.log(<span class="string">"mousedown"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"mouseup"</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">"mouseup"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            console.log(<span class="string">"click"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"dblclick"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            console.log(<span class="string">"dblclick"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>事件触发的顺序如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mousedown</span><br><span class="line">mouseup</span><br><span class="line">click</span><br><span class="line">mousedown</span><br><span class="line">mouseup</span><br><span class="line">click</span><br><span class="line">dbclick</span><br></pre></td></tr></table></figure></li></ul><h5 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h5><ul><li><code>mouseover</code>事件<strong>会冒泡</strong>，这意味着，鼠标移到其后代元素上时会触发。</li><li><code>mouseenter</code>事件<strong>不冒泡</strong>，这意味着，鼠标移到其后代元素上时不会触发。</li><li><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="comment">#outer&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                top:0;</span><br><span class="line">                left: 0;</span><br><span class="line">                bottom:0;</span><br><span class="line">                right: 0;</span><br><span class="line">                margin: auto;</span><br><span class="line">                background-color: pink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#inner&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height:100px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left:50%;</span><br><span class="line">                margin-left: -50px;</span><br><span class="line">                margin-top: -50px;;</span><br><span class="line">                background-color: orange;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#outer,#inner&#123;</span></span><br><span class="line">                border-radius:50%;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">"inner"</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var parentDiv = document.getElementById(<span class="string">"outer"</span>);</span><br><span class="line">            parentDiv.addEventListener(<span class="string">"mouseover"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                console.log(<span class="string">"父div的mouseover事件被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseenter"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseenter事件被触发"</span>);</span><br><span class="line">            //&#125;,<span class="literal">false</span>);</span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseout"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseout事件被触发"</span>);</span><br><span class="line">            //&#125;, <span class="literal">false</span>);</span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseleave"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseleave事件被触发"</span>);</span><br><span class="line">            //&#125;, <span class="literal">false</span>);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>当<strong>鼠标从外面移入圆心</strong>，外面圆的<code>mouseover</code>事件被触发2次，第二次是<strong>里面圆的<code>mouseover</code>事件冒泡到外面圆</strong>而触发的。</p></li><li>当鼠标从外面移入圆心，外面圆的<code>mouseenter</code>事件被触发一次，因为<strong><code>mouseenter</code>事件不冒泡</strong>，鼠标移到后代元素不会触发。</li><li>另外，<code>mouseover</code>对应<code>mouseout</code>，<code>mouseenter</code>对应<code>mouseleave</code>。效果可以取消上面代码的注释来看。</li></ul><h5 id="鼠标左键和右键"><a href="#鼠标左键和右键" class="headerlink" title="鼠标左键和右键"></a>鼠标左键和右键</h5><ul><li>IE下鼠标的左键是1，右键是2。</li><li>ff和chrome下，鼠标左键是0，右键是2。</li><li>示例代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">document.onmousedown = <span class="keyword">function</span> (ev) &#123;</span><br><span class="line">    var oEvent = ev || event; //IE浏览器直接使用event或者window.event得到事件本身。</span><br><span class="line">    alert(oEvent.button); // IE下鼠标的 左键是1 ，  右键是2   ff和chrome下 鼠标左键是0  右键是2</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="mouseover和mousemove的区别"><a href="#mouseover和mousemove的区别" class="headerlink" title="mouseover和mousemove的区别"></a>mouseover和mousemove的区别</h5><ul><li><code>mousemove</code>事件通过鼠标在元素上移动来触发。事件处理函数会被传递一个事件对象event，<code>event.clientX</code>和 <code>event.clientY</code>属性代表鼠标的坐标。</li><li><code>mouseover</code>事件会在<strong>鼠标移入对象</strong>时触发。</li><li>一般情况下<code>mouseover</code>即可，特殊情况才用<code>mousemove</code>，因为<strong><code>mousemove</code>更耗资源</strong>，比如要<strong>监控鼠标坐标的变化</strong>等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;鼠标事件&quot;&gt;&lt;a href=&quot;#鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;鼠标事件&quot;&gt;&lt;/a&gt;鼠标事件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;DOM3级事件中定义了9个鼠标事件：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mousedown&lt;/code&gt;：&lt;stron
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
</feed>
