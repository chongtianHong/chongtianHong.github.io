<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-07-23T14:59:47.399Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步、异步和事件循环(Event Loop)</title>
    <link href="https://chongtianhong.github.io/2018/03/28/eventLoop/"/>
    <id>https://chongtianhong.github.io/2018/03/28/eventLoop/</id>
    <published>2018-03-28T14:44:05.000Z</published>
    <updated>2018-07-23T14:59:47.399Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单线程的JavaScript"><a href="#单线程的JavaScript" class="headerlink" title="单线程的JavaScript"></a>单线程的JavaScript</h4><ul><li>JavaScript是单线程的，指在<strong>JS引擎</strong>中负责<strong>解析和执行JavaScript代码</strong>的线程（<strong>主线程</strong>）<strong>只有一个</strong>。</li><li><strong>实际上还存在其他的线程（工作线程）</strong>。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。<a id="more"></a><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4></li><li><strong>同步交互</strong>：指<strong>发送一个请求</strong>，<strong>需要</strong>等待返回，然后<strong>才能够发送下一个请求</strong>，<strong>有个等待过程</strong>。</li><li><strong>异步交互</strong>：指<strong>发送一个请求</strong>，<strong>不需要</strong>等待返回，<strong>随时可以再发送下一个请求</strong>，即<strong>不需要等待</strong>。</li><li><strong>同步可以保证顺序一致</strong>，但是容易导致<strong>阻塞</strong>；<strong>异步可以解决阻塞问题</strong>，但是<strong>会改变顺序性</strong>。</li><li>正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以<strong>在JavaScript中对于耗时的操作或者时间不确定的操作</strong>，<strong>使用异步</strong>就成了必然的选择。</li></ul><h4 id="异步过程的构成要素"><a href="#异步过程的构成要素" class="headerlink" title="异步过程的构成要素"></a>异步过程的构成要素</h4><ul><li><strong>异步函数</strong>实际上很快就调用完成了。但是后面还有<strong>工作线程执行异步任务</strong>、<strong>通知主线程</strong>、<strong>主线程调用回调函数</strong>等很多步骤。我们把整个过程叫做<strong>异步过程</strong>。<strong>异步函数的调用在整个异步过程中，只是一小部分</strong>。</li><li>一个<strong>异步过程</strong>通常是这样的：<ul><li>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；</li><li><strong>主线程可以继续执行后面的（同步）代码</strong>，同时<strong>工作线程执行异步任务</strong>；</li><li><strong>工作线程完成工作后，通知主线程</strong>；</li><li><strong>主线程收到通知后，执行一定的动作(调用回调函数)</strong>。</li></ul></li></ul><h4 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h4><ul><li>异步过程中，<strong>工作线程</strong>在<strong>异步操作完成后</strong>需要<strong>通知主线程</strong>。那么这个<strong>通知机制</strong>是利用<strong>消息队列</strong>和<strong>事件循环（EventLoop）</strong>。</li><li>即：<strong>工作线程将消息放到消息队列，主线程通过事件循环过程去获取消息</strong>。<br>• <strong>消息队列</strong>：消息队列是一个<strong>先进先出</strong>的队列，它里面存放着各种消息。<br>• <strong>事件循环</strong>：事件循环是指<strong>主线程重复从消息队列中取消息、执行</strong>的过程。</li><li>实际上，<strong>主线程只会做一件事情</strong>，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且<strong>主线程只有在将当前的消息执行完成后，才会去取下一个消息</strong>。这种机制就叫做<strong>事件循环机制</strong>，<strong>取一个消息并执行的过程</strong>叫做<strong>一次循环</strong>。</li><li><strong>浏览器有一个内部大消息循环Event Loop（事件循环），会轮询事件队列并处理事件</strong>。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：input onchange），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了才能执行下一个。</li><li><strong>异步过程的回调函数，一定不在当前这一轮事件循环中执行</strong>。</li></ul><h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><ul><li><strong>工作线程</strong>是<strong>生产者</strong>，主线程是<strong>消费者</strong>(只有一个消费者)。</li><li><strong>工作线程执行异步任务</strong>，执行完成后<strong>把对应的回调函数封装成一条消息</strong>放到消息队列中；</li><li><strong>主线程</strong>不断地<strong>从消息队列中取消息并执行</strong>，当<strong>消息队列空时主线程阻塞</strong>，<strong>直到消息队列再次非空</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;单线程的JavaScript&quot;&gt;&lt;a href=&quot;#单线程的JavaScript&quot; class=&quot;headerlink&quot; title=&quot;单线程的JavaScript&quot;&gt;&lt;/a&gt;单线程的JavaScript&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JavaScript是单线程的，指在&lt;strong&gt;JS引擎&lt;/strong&gt;中负责&lt;strong&gt;解析和执行JavaScript代码&lt;/strong&gt;的线程（&lt;strong&gt;主线程&lt;/strong&gt;）&lt;strong&gt;只有一个&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实际上还存在其他的线程（工作线程）&lt;/strong&gt;。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="同步" scheme="https://chongtianhong.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="异步" scheme="https://chongtianhong.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="事件循环" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP知识点总结</title>
    <link href="https://chongtianhong.github.io/2018/03/27/http/"/>
    <id>https://chongtianhong.github.io/2018/03/27/http/</id>
    <published>2018-03-27T15:45:24.000Z</published>
    <updated>2018-07-23T14:42:53.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><ul><li>超文本传输协议（Hyper Text Transfer Protocol, HTTP）是用于从万维网（WWW:World Wide Web）<strong>服务器传输超文本到本地浏览器</strong>的<strong>应用层传送协议</strong>。它被设计用于<strong>Web浏览器</strong>和<strong>Web服务器</strong>之间的<strong>通信</strong>，但它也可以用于其他目的。 </li><li>HTTP是一个<strong>基于TCP/IP通信协议</strong>来传递数据（HTML 文件, 图片文件, 查询结果等）。一个完整的web文档是由不同的子文档重新组建而成的，例如文本、布局描述、图片、视频、脚本等。</li><li>HTTP是一个属于<strong>应用层的面向对象的协议</strong>，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<a id="more"></a></li><li>HTTP遵循经典的<strong>客户端-服务端模型</strong>。浏览器作为<strong>HTTP客户端</strong>通过URL向<strong>HTTP服务端即WEB服务器</strong>发送所有请求。<strong>Web服务器</strong>根据接收到的请求后，向<strong>客户端</strong>发送响应信息。（请求通常是由像浏览器这样的接受方发起的。）</li><li>客户端和服务端通过交换各自的消息（与数据流正好相反）来进行交互。通常由像浏览器这样的<strong>客户端发出的消息叫做requests</strong>，那么<strong>被服务端回应的消息就叫做 responses</strong>。<br><img src="/images/csModel.jpg" width="600" alt="http请求-响应模型" style="border:none"></li><li>HTTP是<strong>无状态</strong>协议，意味着<strong>服务器不会在两个请求之间保留任何数据（状态）</strong>。</li><li>它是<strong>应用层</strong>的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过<strong>TCP</strong>，或者是TLS－加密的TCP连接来发送。（由于UDP不可靠，不使用UDP）</li><li>要渲染出一个网页，浏览器首先要发送第一个请求来获取这个页面的HTML文档，再解析它并根据文档中的资源信息发送其他的请求来获取脚本信息，或者CSS来进行页面布局渲染，还有一些其它的页面资源（如图片和视频等）。然后，它把这些资源结合到一起，展现出来一个完整的文档，也就是网页。打开一个网页后，浏览器还可以根据脚本内容来获取更多的资源来更新网页。</li></ul><h3 id="HTTP-的基本性质"><a href="#HTTP-的基本性质" class="headerlink" title="HTTP 的基本性质"></a>HTTP 的基本性质</h3><h4 id="1-简单快速："><a href="#1-简单快速：" class="headerlink" title="1. 简单快速："></a>1. 简单快速：</h4><ul><li>客户向服务器<strong>请求服务时，只需传送请求方法和路径</strong>。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于<strong>HTTP协议简单</strong>，使得<strong>HTTP服务器的程序规模小</strong>，因而<strong>通信速度很快</strong>。</li></ul><h4 id="2-可扩展："><a href="#2-可扩展：" class="headerlink" title="2. 可扩展："></a>2. 可扩展：</h4><ul><li>在 HTTP/1.0 中出现的<strong>HTTP headers让协议扩展变得非常容易</strong>。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。</li></ul><h4 id="3-灵活："><a href="#3-灵活：" class="headerlink" title="3. 灵活："></a>3. 灵活：</h4><ul><li>HTTP允许<strong>传输任意类型的数据对象</strong>。正在传输的类型由Content-Type加以标记。</li></ul><h4 id="4-无状态，有会话："><a href="#4-无状态，有会话：" class="headerlink" title="4. 无状态，有会话："></a>4. 无状态，有会话：</h4><ul><li>HTTP协议本质是无状态协议，使用Cookies可以创建有状态的会话。<ul><li>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>使用<strong>HTTP的头部扩展</strong>，HTTP Cookies就可以解决HTTP无状态的问题。<strong>把Cookies添加到头部</strong>中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</li></ul></li></ul><h4 id="5-无连接："><a href="#5-无连接：" class="headerlink" title="5. 无连接："></a>5. 无连接：</h4><ul><li>无连接的含义是<strong>限制每次连接只处理一个请求</strong>。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li></ul><h3 id="HTTP-URL"><a href="#HTTP-URL" class="headerlink" title="HTTP URL"></a>HTTP URL</h3><ul><li>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</li><li>统一资源定位符（Uniform Resource Locator, URL）是互联网上用来标识某一处资源的地址。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。</li><li>以下面这个URL为例，介绍下普通URL的各部分组成：<br><code><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></code></li><li>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.<code><strong>协议</strong>部分</code>：该URL的协议部分为“http:”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。<br>2.<code><strong>域名</strong>部分</code>：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。<br>3.<code><strong>端口</strong>部分</code>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口<br>4.<code><strong>虚拟目录</strong>部分</code>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。<br>5.<code><strong>文件名</strong>部</code>分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。<br>6.<code><strong>参数</strong>部分</code>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。<br>7.<code><strong>锚</strong>部分</code>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。</li></ul><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><blockquote>统一资源标识符（URI）用来唯一的标识一个资源。</blockquote><ul><li>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的。</li><li>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源</li></ul><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><blockquote>统一资源定位器（URL）是一种具体的URI，可以用来标识一个资源，而且指明了如何定位这个资源。</blockquote><ul><li>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</li><li>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</li></ul><h4 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h4><blockquote>统一资源命名（uniform resource name，URN）通过名字来标识资源，比如mailto:java-net@java.sun.com。</blockquote><ul><li>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。</li><li>每个 URL 都是 URI，但不一定每个 URI 都是 URL。因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</li></ul><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><ul><li>有两种HTTP报文的类型，<strong>请求报文</strong>与<strong>响应报文</strong>，每种都有其特定的格式。</li></ul><h4 id="HTTP-请求消息Request"><a href="#HTTP-请求消息Request" class="headerlink" title="HTTP 请求消息Request"></a>HTTP 请求消息Request</h4><ul><li>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<br><code>请求行（request line）</code>、<code>请求头部（header）</code>、<code>空行</code>和<code>请求数据</code>四个部分组成。<br><img src="/images/request.png" width="400" alt="Http请求消息结构" style="border:none"></li><li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</li></ul><blockquote>Get请求例子，使用Charles抓取的request：</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br><span class="line"></span><br><span class="line">//请求数据为空</span><br></pre></td></tr></table></figure><ul><li>第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本。<ul><li>GET说明请求类型为GET，[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</li></ul></li><li>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。<ul><li>从第二行起为请求头部，HOST将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送等等。</li></ul></li><li>第三部分：空行，请求头部后面的空行是必须的。<ul><li>即使第四部分的请求数据为空，也必须有空行。</li></ul></li><li>第四部分：请求数据也叫主体，可以添加任意的其他数据。<ul><li>这个例子的请求数据为空。</li></ul></li></ul><blockquote>POST请求例子，使用Charles抓取的request：</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><ul><li>第一部分：请求行，第一行指明了是post请求，以及http1.1版本。</li><li>第二部分：请求头部，第二行至第六行。</li><li>第三部分：空行，第七行的空行。</li><li>第四部分：请求数据，第八行。</li></ul><h4 id="HTTP-响应消息Response"><a href="#HTTP-响应消息Response" class="headerlink" title="HTTP 响应消息Response"></a>HTTP 响应消息Response</h4><ul><li>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</li><li>HTTP响应也由四个部分组成，分别是：<code>状态行</code>、<code>消息报头</code>、<code>空行</code>和<code>响应正文</code>。<br><img src="/images/respond.jpg" width="600" alt="http响应消息格式" style="border:none"></li></ul><blockquote>响应消息例子：</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<ul><li>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</li></ul></li><li>第二部分：消息报头，用来说明客户端要使用的一些附加信息。<ul><li>第二行和第三行为消息报头</li><li>Date:生成响应的日期和时间；Content-Type：指定了MIME类型的HTML(text/html)，编码类型是UTF-8</li></ul></li><li>第三部分：空行，消息报头后面的空行是必须的。</li><li>第四部分：响应正文，服务器返回给客户端的文本信息。<ul><li>空行后面的html部分为响应正文。</li></ul></li></ul><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><ul><li>状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br><code>1xx：指示信息–表示请求已接收，继续处理</code><br><code>2xx：成功–表示请求已被成功接收、理解、接受</code><br><code>3xx：重定向–要完成请求必须进行更进一步的操作</code><br><code>4xx：客户端错误–请求有语法错误或请求无法实现</code><br><code>5xx：服务器端错误–服务器未能实现合法的请求</code></li><li>常见状态码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><ul><li>根据HTTP标准，HTTP请求可以使用多种请求方法。</li><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET       //请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD      //类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST      //向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。</span><br><span class="line">PUT       //从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE    //请求服务器删除指定的页面。</span><br><span class="line">CONNECT   //HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS   //允许客户端查看服务器的性能。</span><br><span class="line">TRACE     //回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><ul><li>HTTP协议定义<strong>Web客户端如何从Web服务器请求Web页面</strong>，以及<strong>服务器如何把Web页面传送给客户端</strong>。HTTP协议采用了请求/响应模型。</li><li><strong>客户端</strong>向服务器发送一个<strong>请求报文</strong>，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。</li><li><strong>服务器</strong>以一个<strong>状态行作为响应</strong>，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</li><li><p>以下是 HTTP 请求/响应的步骤：</p><blockquote><strong>1、客户端连接到Web服务器</strong></blockquote><ul><li>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn。" target="_blank" rel="noopener">http://www.oakcms.cn。</a></li></ul><blockquote><strong>2、发送HTTP请求</strong></blockquote><ul><li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li></ul><blockquote><strong>3、服务器接受请求并返回HTTP响应</strong></blockquote><ul><li>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li></ul><blockquote><strong>4、释放连接TCP连接</strong></blockquote><ul><li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li></ul><blockquote><strong>5、客户端浏览器解析HTML内容</strong></blockquote><ul><li>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li></ul></li><li>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：<br>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5、释放 TCP连接;<br>6、浏览器对该 html 文本进行解析，根据文档中的资源信息请求资源，完成资源整合后显示页面内容。</li></ul><h3 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h3><ul><li>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET，POST，PUT，DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</li></ul><blockquote>GET请求</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">//请求数据为空，最后一行为空行</span><br></pre></td></tr></table></figure><blockquote>POST请求</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><ul><li><strong>GET请求</strong>和<strong>POST请求</strong>的区别：</li></ul><ol><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456，即数据会在地址栏中显示出来，而POST提交是把提交的数据放在HTTP包的Body中，地址栏不会改变。</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.<ul><li>首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：</li><li>GET：<strong>特定浏览器和服务器对URL长度有限制</strong>，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。</li><li>POST：由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</li></ul></li><li>安全性：<strong>POST的安全性</strong>要比GET的安全性<strong>高</strong>。<ul><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</li></ul></li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP简介&quot;&gt;&lt;a href=&quot;#HTTP简介&quot; class=&quot;headerlink&quot; title=&quot;HTTP简介&quot;&gt;&lt;/a&gt;HTTP简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;超文本传输协议（Hyper Text Transfer Protocol, HTTP）是用于从万维网（WWW:World Wide Web）&lt;strong&gt;服务器传输超文本到本地浏览器&lt;/strong&gt;的&lt;strong&gt;应用层传送协议&lt;/strong&gt;。它被设计用于&lt;strong&gt;Web浏览器&lt;/strong&gt;和&lt;strong&gt;Web服务器&lt;/strong&gt;之间的&lt;strong&gt;通信&lt;/strong&gt;，但它也可以用于其他目的。 &lt;/li&gt;
&lt;li&gt;HTTP是一个&lt;strong&gt;基于TCP/IP通信协议&lt;/strong&gt;来传递数据（HTML 文件, 图片文件, 查询结果等）。一个完整的web文档是由不同的子文档重新组建而成的，例如文本、布局描述、图片、视频、脚本等。&lt;/li&gt;
&lt;li&gt;HTTP是一个属于&lt;strong&gt;应用层的面向对象的协议&lt;/strong&gt;，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>数组去重的多重方法</title>
    <link href="https://chongtianhong.github.io/2018/03/26/distinctArray/"/>
    <id>https://chongtianhong.github.io/2018/03/26/distinctArray/</id>
    <published>2018-03-26T03:15:15.000Z</published>
    <updated>2018-07-23T14:26:57.177Z</updated>
    
    <content type="html"><![CDATA[<ul><li>数组去重有多种方法，分别是：<ul><li>利用数组的<strong>splice方法</strong>直接在原数组进行操作</li><li>利用<strong>对象的属性不能相同</strong>的特点进行去重</li><li>利用数组的<strong>indexOf下标属性</strong>来查询</li><li>利用数组原型对象上的 <strong>lastIndexOf 方法</strong></li><li>利用 ES6的<strong>set 方法</strong></li><li>利用数组原型对象上的<strong>includes方法</strong><a id="more"></a></li></ul></li><li>接下来将对这几种方法进行具体介绍。</li></ul><blockquote>方法一：利用splice直接在原数组进行操作</blockquote><ul><li><strong>思路</strong>：双层循环，外层循环元素，内层循环时<strong>比较相邻元素值</strong>。值相同时，则删去这个值。</li><li><strong>注意</strong>:删除元素之后，需要将数组的长度也减1。</li><li><strong>优点</strong>：简单易懂。</li><li><strong>缺点</strong>：占用内存高，速度慢。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> distinct(arr) &#123;</span><br><span class="line">  <span class="built_in">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">        arr.splice(j, 1);</span><br><span class="line">        len--;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5, 6, 5, 3, 2, 4, 56, 4, 1, 2, 1, 1, 1, 1, 1, 1, ];</span><br><span class="line"><span class="built_in">let</span> b = distinct(arr); //1,2,3,4,5,6,56</span><br></pre></td></tr></table></figure></li></ul><blockquote>方法二：利用对象的属性不能相同的特点进行去重</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">distinct</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="built_in">let</span> result = [];</span><br><span class="line">  <span class="built_in">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i]]) &#123; //如果能查找到，证明数组元素重复了</span><br><span class="line">      obj[arr[i]] = 1;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [1, 2, 3, 4, 5, 6, 5, 3, 2, 4, 56, 4, 1, 2, 1, 1, 1, 1, 1, 1, ];</span><br><span class="line"><span class="built_in">let</span> b = distinct(arr); //1,2,3,4,5,6,56</span><br></pre></td></tr></table></figure><blockquote>方法三: 利用数组的indexOf下标属性来查询</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> distinct(arr)&#123;</span><br><span class="line">  var res = [];</span><br><span class="line">  <span class="keyword">for</span>(var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.indexOf(arr[i]) == -1)&#123; // 如果res新数组不包含当前循环item</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote>方法四: 利用数组原型对象上的 lastIndexOf 方法</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> distinct(arr) &#123;</span><br><span class="line">  var res = [];</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    res.lastIndexOf(arr[i]) !== -1 ? <span class="string">''</span> : res.push(arr[i]); // 如果res新数组不包含当前循环item</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote>方法五: 利用 ES6的set 方法</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> distinct(arr) &#123;</span><br><span class="line">  //Set数据结构，它类似于数组，其成员的值都是唯一的</span><br><span class="line">  <span class="built_in">return</span> Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote>方法六: 利用数组原型对象上的includes方法</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> distinct(arr) &#123;</span><br><span class="line">  var res = [];</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.includes(arr[i])) &#123; // 如果res新数组不包含当前循环item</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;数组去重有多种方法，分别是：&lt;ul&gt;
&lt;li&gt;利用数组的&lt;strong&gt;splice方法&lt;/strong&gt;直接在原数组进行操作&lt;/li&gt;
&lt;li&gt;利用&lt;strong&gt;对象的属性不能相同&lt;/strong&gt;的特点进行去重&lt;/li&gt;
&lt;li&gt;利用数组的&lt;strong&gt;indexOf下标属性&lt;/strong&gt;来查询&lt;/li&gt;
&lt;li&gt;利用数组原型对象上的 &lt;strong&gt;lastIndexOf 方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;利用 ES6的&lt;strong&gt;set 方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;利用数组原型对象上的&lt;strong&gt;includes方法&lt;/strong&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Array" scheme="https://chongtianhong.github.io/tags/Array/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>对Vue生命周期的理解</title>
    <link href="https://chongtianhong.github.io/2018/03/25/vue/"/>
    <id>https://chongtianhong.github.io/2018/03/25/vue/</id>
    <published>2018-03-25T14:38:09.000Z</published>
    <updated>2018-07-23T14:27:45.527Z</updated>
    
    <content type="html"><![CDATA[<ul><li>每个<strong>Vue实例</strong>在<strong>被创建之前</strong>都要经过一系列的<strong>初始化</strong>过程，这个过程就是vue的生命周期。</li><li><strong>Vue的生命周期</strong>中有多个<strong>事件钩子</strong>，让我们在控制整个Vue实例的过程时<strong>更容易形成好的逻辑</strong>，它总共可以分为<strong>8个阶段</strong>：<code>beforeCreate（创建前）</code>，<code>created（创建后）</code>，<code>beforeMount(载入前)</code>，<code>mounted（载入后）</code>，<code>beforeUpdate（更新前）</code>，<code>updated（更新后）</code>，<code>beforeDestroy（销毁前）</code>，<code>destroyed（销毁后）</code>。<a id="more"></a></li></ul><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><ul><li>先看Vue官网提供的图片：<br><img src="/images/vue.png" width="316" alt="vue的生命周期" style="border:none"></li><li><p>通过以下代码，更好地理解Vue的生命周期：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;vue生命周期学习&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.bootcss.com/vue/2.4.2/vue.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">      &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">          message: <span class="string">'Vue的生命周期'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.group(<span class="string">'------beforeCreate创建前状态------'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + this.<span class="variable">$el</span>); //undefined</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); //undefined </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message) </span><br><span class="line">        &#125;,</span><br><span class="line">        created: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.group(<span class="string">'------created创建完毕状态------'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + this.<span class="variable">$el</span>); //undefined</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); //已被初始化 </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message); //已被初始化</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.group(<span class="string">'------beforeMount挂载前状态------'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + (this.<span class="variable">$el</span>)); //已被初始化</span><br><span class="line">          console.log(this.<span class="variable">$el</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); //已被初始化  </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message); //已被初始化  </span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">          console.group(<span class="string">'------mounted 挂载结束状态------'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + this.<span class="variable">$el</span>); //已被初始化</span><br><span class="line">          console.log(this.<span class="variable">$el</span>);    </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); //已被初始化</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message); //已被初始化 </span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">          console.group(<span class="string">'beforeUpdate 更新前状态===============》'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">          console.log(this.<span class="variable">$el</span>);   </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message); </span><br><span class="line">        &#125;,</span><br><span class="line">        updated: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">          console.group(<span class="string">'updated 更新完成状态===============》'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">          console.log(this.<span class="variable">$el</span>); </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message); </span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">          console.group(<span class="string">'beforeDestroy 销毁前状态===============》'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">          console.log(this.<span class="variable">$el</span>);    </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message); </span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">          console.group(<span class="string">'destroyed 销毁完成状态===============》'</span>);</span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"el     : "</span> + this.<span class="variable">$el</span>);</span><br><span class="line">          console.log(this.<span class="variable">$el</span>);  </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"data   : "</span> + this.<span class="variable">$data</span>); </span><br><span class="line">          console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>, <span class="string">"message: "</span> + this.message)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行后打开console可以看到打印出来内容如下:<br><img src="/images/vueconsole.png" width="654" alt="vue的生命周期console结果" style="border:none"></p></li><li>可以看到一个vue实例在创建过程中调用的几个生命周期钩子。</li></ul><h4 id="在beforeCreate和created钩子函数之间的生命周期"><a href="#在beforeCreate和created钩子函数之间的生命周期" class="headerlink" title="在beforeCreate和created钩子函数之间的生命周期"></a>在beforeCreate和created钩子函数之间的生命周期</h4><ul><li>在<strong>beforeCreated</strong>阶段，vue实例的挂载元素<strong>$el</strong>和数据对象<strong>data</strong>都为undefined，还未初始化。</li><li>在<strong>created</strong>阶段，vue实例的数据对象<strong>data</strong>有了，<strong>$el</strong>还没有。<ul><li>在这个生命周期之间，进行<strong>初始化事件</strong>，进行<strong>数据</strong>的<strong>观测</strong>，可以看到在<strong>created</strong>的时候数据已经和<strong>data属性</strong>进行绑定（放在<strong>data</strong>中的属性，当其值发生改变的同时，视图也会改变）。注意看下：此时还是没有<strong>el</strong>选项。</li></ul></li></ul><h4 id="created钩子函数和beforeMount间的生命周期"><a href="#created钩子函数和beforeMount间的生命周期" class="headerlink" title="created钩子函数和beforeMount间的生命周期"></a>created钩子函数和beforeMount间的生命周期</h4><p><img src="/images/createdToBeforeMount.png" width="654" alt="created钩子函数和beforeMount间的生命周期" style="border:none"></p><ul><li><p>首先会判断对象是否有<strong>el选项</strong>。如果<strong>有的话就继续向下编译</strong>，<strong>如果没有el选项</strong>，则<strong>停止编译</strong>，也就意味着<strong>停止了生命周期，直到在该vue实例上调用<code>vm.$mount(el)</code></strong>。此时注释掉代码中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el: <span class="string">'#app'</span></span><br></pre></td></tr></table></figure></li><li><p>运行可以看到，到<strong>created</strong>的时候就停止了，不会再执行后面的钩子函数。</p></li><li>如果我们在后面继续调用<code>vm.$mount(el)</code>,可以发现代码继续向下执行了。这个<strong>el</strong>参数就是挂载Vue实例的DOM节点。</li><li>然后，我们往下看，template参数选项的有无对生命周期的影响。<br>（1）.如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。<br>（2）.如果没有template选项，则将外部HTML作为模板编译。<br>（3）.可以看到template中的模板优先级要高于outer HTML的优先级。</li><li>所以综合排名优先级：render函数选项 &gt; template选项 &gt; outer HTML。</li></ul><h4 id="beforeMount和mounted-钩子函数间的生命周期"><a href="#beforeMount和mounted-钩子函数间的生命周期" class="headerlink" title="beforeMount和mounted 钩子函数间的生命周期"></a>beforeMount和mounted 钩子函数间的生命周期</h4><p><img src="/images/beforeMountToMounted.png" width="451" alt="beforeMount和mounted 钩子函数间的生命周期" style="border:none"></p><ul><li>可以看到此时是给vue实例对象添加<strong>$el成员</strong>，并且替换掉挂载的DOM元素。因为在之前console中打印的结果可以看到<strong>beforeMount</strong>之前<strong>el</strong>上还是undefined。</li><li>在<strong>beforeMount</strong>阶段，vue实例的<strong>$el</strong>和<strong>data</strong>都初始化了，但还是挂载之前为虚拟的DOM节点，data.message还未替换。 <ul><li>Virtual DOM是一个映射真实DOM的javascript对象，如果需要改变任何元素的状态，则先在virtual DOM上改变，而不是直接改变真实的DOM。当有变化产生时，一个新的虚拟节点便会被创建，同时计算新旧虚拟结点之间的差别，最后映射真实的dom节点。</li></ul></li></ul><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><p><img src="/images/mounted.png" width="424" alt="mounted" style="border:none"></p><ul><li>在<strong>mounted</strong>阶段，vue实例挂载完成，<strong>data.message</strong>成功渲染。<strong>this.$el</strong>是挂载的DOM结构。</li></ul><h4 id="beforeUpdate钩子函数和updated钩子函数间的生命周期"><a href="#beforeUpdate钩子函数和updated钩子函数间的生命周期" class="headerlink" title="beforeUpdate钩子函数和updated钩子函数间的生命周期"></a>beforeUpdate钩子函数和updated钩子函数间的生命周期</h4><ul><li>当vue发现<strong>data</strong>中的数据发生了改变，会触发对应组件的重新渲染，先后调用<strong>beforeUpdate</strong>和<strong>updated</strong>钩子函数。</li></ul><h4 id="beforeDestroy和destroyed钩子函数间的生命周期"><a href="#beforeDestroy和destroyed钩子函数间的生命周期" class="headerlink" title="beforeDestroy和destroyed钩子函数间的生命周期"></a>beforeDestroy和destroyed钩子函数间的生命周期</h4><ul><li><strong>beforeDestroy</strong>钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。</li><li><strong>destroyed</strong>钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;每个&lt;strong&gt;Vue实例&lt;/strong&gt;在&lt;strong&gt;被创建之前&lt;/strong&gt;都要经过一系列的&lt;strong&gt;初始化&lt;/strong&gt;过程，这个过程就是vue的生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vue的生命周期&lt;/strong&gt;中有多个&lt;strong&gt;事件钩子&lt;/strong&gt;，让我们在控制整个Vue实例的过程时&lt;strong&gt;更容易形成好的逻辑&lt;/strong&gt;，它总共可以分为&lt;strong&gt;8个阶段&lt;/strong&gt;：&lt;code&gt;beforeCreate（创建前）&lt;/code&gt;，&lt;code&gt;created（创建后）&lt;/code&gt;，&lt;code&gt;beforeMount(载入前)&lt;/code&gt;，&lt;code&gt;mounted（载入后）&lt;/code&gt;，&lt;code&gt;beforeUpdate（更新前）&lt;/code&gt;，&lt;code&gt;updated（更新后）&lt;/code&gt;，&lt;code&gt;beforeDestroy（销毁前）&lt;/code&gt;，&lt;code&gt;destroyed（销毁后）&lt;/code&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="Vue.js" scheme="https://chongtianhong.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs的模块系统以及require的机制</title>
    <link href="https://chongtianhong.github.io/2018/03/24/require/"/>
    <id>https://chongtianhong.github.io/2018/03/24/require/</id>
    <published>2018-03-24T08:37:08.000Z</published>
    <updated>2018-07-21T09:15:42.676Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Nodejs 有一个简单的<strong>模块加载系统</strong>。在 Nodejs 中，文件和模块是一一对应的（<strong>每个文件被视为一个独立的模块</strong>），这个文件可能是<strong> JavaScript 代码</strong>，<strong>JSON</strong> 或<strong>编译过的C/C++ 扩展</strong>。<a id="more"></a></li><li><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *foo.js</span><br><span class="line"> *将这个js文件导出为模块</span><br><span class="line"> */</span><br><span class="line">exports.hello = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"hello Nodejs!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *main.js</span><br><span class="line"> *main.js和foo.js在同一目录下</span><br><span class="line"> *在控制台中将会输出：hello Nodejs！</span><br><span class="line"> */</span><br><span class="line">var foo = require(<span class="string">"./foo.js"</span>);</span><br><span class="line"></span><br><span class="line">foo.hello();</span><br></pre></td></tr></table></figure></li></ul><h4 id="如何将模块导出-module-exports-与-exports-的区别"><a href="#如何将模块导出-module-exports-与-exports-的区别" class="headerlink" title="如何将模块导出(module.exports 与 exports 的区别)"></a>如何将模块导出(module.exports 与 exports 的区别)</h4><ul><li><p>Nodejs 中的每一个模块（node.js执行文件）都会<strong>自动创建</strong>一个 module 对象，同时 module 对象会创建一个叫 exports 的属性，初始化的值为<code>{}</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Node.js为了方便地导出功能函数，node.js会<strong>自动地实现</strong>以下这个语句:</p></li></ul><blockquote>foo.js</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.a = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">exports.a = 1</span><br></pre></td></tr></table></figure><blockquote>test.js</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = require(<span class="string">'./foo'</span>);</span><br><span class="line"></span><br><span class="line">console.log(x.a) // a</span><br></pre></td></tr></table></figure><ul><li>可以看到，<strong>exports是引用 module.exports的值</strong>。module.exports 被改变的时候，exports不会被改变，而<strong>模块导出的时候，真正导出的执行是module.exports</strong>，而不是exports。</li><li>再看看下面例子：</li></ul><blockquote>foo.js</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.a = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  console.log(<span class="string">'a'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;a: 2&#125;</span><br><span class="line">exports.a = 1</span><br></pre></td></tr></table></figure><blockquote>test.js</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = require(<span class="string">'./foo'</span>);</span><br><span class="line"></span><br><span class="line">console.log(x.a) // 2</span><br></pre></td></tr></table></figure><ul><li>可见，exports在module.exports 被改变后，失效。</li><li>因此，我们可以将某个类的实例赋值给 module.exports，从而导出这个类的实例。在模块被执行前，Nodejs 会将 module.exports 的值赋于全局变量 exports ，以便 module.exports.f = …  可以更简洁的写成 exports.f = …  。</li><li>注意：就像所有变量一样，如果重新给 exports 赋值，它就不再绑定到 module.exports 了，也不会导出指定模块。</li><li>exports失效以后，可通过exports = module.exports的方法，让其恢复exports 与 module.exports 的引用关系。</li></ul><h5 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h5><ul><li>exports对象是当前模块的导出对象，它引用了 module.exports的值，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时，得到的就是当前模块的module.exports对象。以下例子中导出了一个公有方法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h5><ul><li>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是<strong>替换当前模块的导出对象</strong>。例如<strong>模块导出对象默认是一个普通对象</strong>，如果想改成一个函数的话，可以使用以下方式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="require的机制"><a href="#require的机制" class="headerlink" title="require的机制"></a>require的机制</h4><ul><li>假设Y是<strong>路径</strong>，X是<strong>文件名或目录名</strong>，当 Nodejs 遇到 require(Y+X) 时，按照下面的顺序处理：<ul><li>1.如果 X 是<strong>核心(内置)模块</strong>（例如：require(“http”)）<br>a.返回该模块<br>b.不再继续执行</li><li>2.如果Y是<strong>以“./”、“/”或“../”开头</strong><br>a.把X当成<strong>文件名</strong>，从指定路径开始，依次查找下面文件：<strong>X、X.js、X.json、X.node</strong>，只要其中一个存在，就返回该文件，不再继续执行<br>b.把X当成<strong>目录名</strong>，从指定路径开始，依次查找下面文件：X/package.json(main字段)、<strong>X/index.js、X/index.json、X/index.node</strong>，只要其中一个存在，就返回该文件，不再继续执行</li><li>3.如果 X 不是核心(内置)模块，也没有以“./”、“/”或“../”开头，则Nodejs会<strong>从当前模块的父目录开始</strong>，尝试从它的 <strong>/node_module 目录</strong>里加载模块，如果还是没有找到，则移动到再<strong>上一层父目录</strong>，直到<strong>文件系统的根目录</strong></li><li>4.抛出“not found”</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Nodejs 有一个简单的&lt;strong&gt;模块加载系统&lt;/strong&gt;。在 Nodejs 中，文件和模块是一一对应的（&lt;strong&gt;每个文件被视为一个独立的模块&lt;/strong&gt;），这个文件可能是&lt;strong&gt; JavaScript 代码&lt;/strong&gt;，&lt;strong&gt;JSON&lt;/strong&gt; 或&lt;strong&gt;编译过的C/C++ 扩展&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="require" scheme="https://chongtianhong.github.io/tags/require/"/>
    
  </entry>
  
  <entry>
    <title>认识单点登录</title>
    <link href="https://chongtianhong.github.io/2018/03/23/singleSighOn/"/>
    <id>https://chongtianhong.github.io/2018/03/23/singleSighOn/</id>
    <published>2018-03-23T01:41:16.000Z</published>
    <updated>2018-07-21T08:12:47.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单点登录的概念"><a href="#单点登录的概念" class="headerlink" title="单点登录的概念"></a>单点登录的概念</h4><ul><li>单点登录（Single Sign On），简称为 SSO，用以解决<strong>同一公司不同子产品之间身份认证问题</strong>，也就是说，a.baidu.com与b.baidu.com两个站点之间<strong>只需要登录一次</strong>即可。</li><li>例子：上豆瓣，要登录豆瓣FM、豆瓣读书、豆瓣电影、豆瓣日记，如果我们访问豆瓣读书、豆瓣电影、豆瓣日记都需要进行一次登录认证，那么用户体验是非常不好的，所以使用了单点登录，<strong>在多个应用系统中，用户只要一次登录就可以访问所有相互信任的应用系统</strong>。<a id="more"></a></li><li>一般来说<strong>单点登录</strong>实现原理为，<strong>首次访问</strong>一个站点时会<strong>被引导至登录页</strong>，用户登录验证通过，<strong>浏览器</strong>会<strong>存储一个关键key（一般采用cookie）</strong>，用户访问其他系统时会带着这个key，<strong>服务器系统发现具有key标志后</strong>，会<strong>对其进行验证</strong>，如果<strong>通过便不需要再次登录了</strong>。</li><li>这里的关键为二，第一是<strong>key</strong>，其二为<strong>系统统一的认证机制</strong>，这当中<strong>key会有一系列规则保证登录的安全性</strong>，而<strong>统一的认证机制是单点登录的前提</strong>，key是由统一的验证平台提供出去，每次用户又以这个给出的key来这里验证，判断其有效性，这里的<strong>统一的验证平台</strong>便是<strong>passport</strong>，它负责着<strong>制作通行令牌，并且对其进行验证</strong>。</li></ul><h4 id="单点登录的实现方式"><a href="#单点登录的实现方式" class="headerlink" title="单点登录的实现方式"></a>单点登录的实现方式</h4><ul><li>使用cookie进行单点登录的实现如下图所示：<br><img src="/images/singlesignon.png" width="600" alt="单点登录" style="border:none"></li><li><strong>客户端持有ID，服务端持有session，两者一起用来保持登录状态</strong>。<strong>客户端</strong>需要<strong>用ID来作为凭证</strong>，而<strong>服务端</strong>需要<strong>用session来验证ID的有效性</strong>。</li><li>但<strong>session</strong>这东西<strong>一开始是每个server自己独有的</strong>，豆瓣FM有自己的session、豆瓣读书有自己的session，而<strong>记录ID的cookie又是不能跨域的</strong>。</li><li>所以，要实现一次登录一次退出，只需要想办法<strong>让各个server共用一个session的信息</strong>，<strong>让客户端在各个域名下都能持有这个ID</strong>就好了。</li><li>再进一步讲，<strong>只要各个server拿到同一个ID</strong>，都能有办法<strong>检验出ID的有效性</strong>、并且能<strong>得到ID对应的用户信息</strong>就行了，也就是<strong>能检验ID</strong>。</li></ul><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><h5 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h5><ul><li>以server群如何<strong>生成、验证ID</strong>的方式大致分为两种：<ul><li><strong>“共享Cookie”方式</strong>。这个就是上面提到的共享session的方式，本质上<strong>cookie只是存储session-id的介质</strong>，<strong>session-id也可以放在每一次请求的url里（不一定要存在cookid中）</strong>。session这项机制一开始就是<strong>一个server独有一个session</strong>的，<strong>把session拿出来让所有server共享</strong>有点奇怪且<strong>不安全</strong>。</li><li><strong>SSO-Token方式</strong>。因为<strong>共享session的方式不安全</strong>，所以我们<strong>不再以session-id作为身份的标识</strong>。我们<strong>另外生成一种标识</strong>，把它取名<strong>SSO-Token(或Ticket)</strong>，这种标识是<strong>整个server群唯一的</strong>，并且<strong>所有server群都能验证这个token</strong>，同时<strong>能拿到token背后代表的用户的信息</strong>。</li></ul></li></ul><h5 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h5><ul><li>浏览器端采用<strong>共享cookie的方式</strong>。无论server端采用的是“共享session”的方式还是现在的“token”方式，身份标识到了浏览器端都要面临这样的一个问题：用户登录成功拿到token(或者是session-id)后应该如何让浏览器存储和分享到其它域名下。同域名很简单，我们可以<strong>把token存在cookie里，把cookie的路径设置成顶级域名</strong>，这样<strong>所有子域都能读取cookie中的token</strong>。前提是<strong>web应用群中所有子系统的域名统一在一个顶级域名下</strong>。</li></ul><h5 id="技术实现机制"><a href="#技术实现机制" class="headerlink" title="技术实现机制"></a>技术实现机制</h5><ul><li>当用户<strong>第一次访问应用系统</strong>的时候，因为<strong>还没有登录</strong>，会<strong>被引导到认证系统中进行登录</strong>；<strong>根据用户提供的登录信息</strong>，<strong>认证系统进行身份校验</strong>；</li><li>如果<strong>通过校验</strong>，<strong>认证系统</strong>应该<strong>返回给用户一个认证的凭据－－ticket（SSO-Token）</strong>；</li><li><strong>用户再访问别的应用的时候</strong>，就会<strong>将</strong>这个<strong>ticket（SSO-Token）带上，作为自己认证的凭据</strong>，<strong>应用系统接受到请求之后</strong>会<strong>把ticket送到认证系统进行校验，检查ticket的合法性</strong>。</li><li>如果通过校验，用户就可以<strong>在不用再次登录的情况下访问应用系统2和应用系统3</strong>了。<br><img src="/images/singlesignon1.png" width="600" alt="单点登录技术实现机制" style="border:none"></li><li>要实现SSO，需要以下主要的功能：<br>1.<strong>所有应用系统共享一个身份认证系统</strong>。统一的认证系统是SSO的前提之一，认证系统的主要功能是<strong>将用户的登录信息和用户信息库相比较，对用户进行登录认证</strong>；<strong>认证成功后</strong>，认证系统应该<strong>生成统一的认证标志（ticket），返还给用户</strong>。另外，认证系统还应该<strong>对ticket进行效验，判断其有效性</strong>。<br>2.<strong>所有应用系统能够识别和提取ticket（SSO-Token）信息</strong>。要实现SSO的功能，<strong>让用户只登录一次</strong>，就必须<strong>让应用系统能够识别已经登录过的用户</strong>。应用系统应该能<strong>对ticket（SSO-Token）进行识别和提取</strong>，通过<strong>与认证系统的通讯</strong>，能<strong>自动判断当前用户是否登录过</strong>，从而完成单点登录的功能。</li></ul><h4 id="单点登录的优缺点"><a href="#单点登录的优缺点" class="headerlink" title="单点登录的优缺点"></a>单点登录的优缺点</h4><blockquote>优点</blockquote><ul><li><strong>提高用户的效率</strong>。用户不再被多次登录困扰，也不需要记住多个 ID 和密码。另外，用户忘记密码并求助于支持人员的情况也会减少。</li><li><strong>提高开发人员的效率</strong>。SSO 为开发人员提供了一个通用的身份验证框架。实际上，如果 SSO 机制是独立的，那么<strong>开发人员就完全不需要为身份验证操心</strong>。他们可以假设，只要对应用程序的请求附带一个用户名，身份验证就已经完成了。</li><li><strong>简化管理</strong>。如果应用程序加入了单点登录协议，管理用户帐号的负担就会减轻。简化的程度取决于应用程序，因为 <strong>SSO 只处理身份验证</strong>，所以应用程序可能仍然需要设置用户的属性（比如访问特权）。</li></ul><blockquote>缺点</blockquote><ul><li><strong>不利于重构</strong>。因为涉及到的系统很多，要重构必须要兼容所有的系统，可能很耗时。</li><li><strong>无人看守桌面</strong>。因为只需要登录一次，所有的授权的应用系统都可以访问，可能导致一些很重要的信息泄露。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;单点登录的概念&quot;&gt;&lt;a href=&quot;#单点登录的概念&quot; class=&quot;headerlink&quot; title=&quot;单点登录的概念&quot;&gt;&lt;/a&gt;单点登录的概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;单点登录（Single Sign On），简称为 SSO，用以解决&lt;strong&gt;同一公司不同子产品之间身份认证问题&lt;/strong&gt;，也就是说，a.baidu.com与b.baidu.com两个站点之间&lt;strong&gt;只需要登录一次&lt;/strong&gt;即可。&lt;/li&gt;
&lt;li&gt;例子：上豆瓣，要登录豆瓣FM、豆瓣读书、豆瓣电影、豆瓣日记，如果我们访问豆瓣读书、豆瓣电影、豆瓣日记都需要进行一次登录认证，那么用户体验是非常不好的，所以使用了单点登录，&lt;strong&gt;在多个应用系统中，用户只要一次登录就可以访问所有相互信任的应用系统&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="Cookie" scheme="https://chongtianhong.github.io/tags/Cookie/"/>
    
      <category term="Session" scheme="https://chongtianhong.github.io/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>npm知识点整理</title>
    <link href="https://chongtianhong.github.io/2018/03/22/npm/"/>
    <id>https://chongtianhong.github.io/2018/03/22/npm/</id>
    <published>2018-03-22T06:36:43.000Z</published>
    <updated>2018-07-20T14:36:11.289Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Node 开发离不开 <code>npm</code>，而脚本功能是 <code>npm</code> 最强大、最常用的功能之一。<a id="more"></a></li></ul><h4 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h4><blockquote>命令的别名</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i // npm install</span><br><span class="line">npm i -D // npm install --save-dev</span><br><span class="line">npm t // npm <span class="built_in">test</span></span><br><span class="line">npm it // npm install &amp;&amp; npm <span class="built_in">test</span></span><br><span class="line">npm r // npm uninstall</span><br></pre></td></tr></table></figure><blockquote>运行脚本</blockquote><ul><li><code>npm</code> 允许在<code>package.json</code>文件里面，使用<code>scripts</code>字段定义脚本命令，然后使用<code>npm run &lt;script-name&gt;</code>来运行脚本。</li></ul><blockquote>变量</blockquote><ul><li><p><code>npm</code> 脚本有一个非常强大的功能，就是可以使用 <code>npm</code> 的内部变量。首先，通过<code>npm_package_前缀</code>，<code>npm</code> 脚本可以拿到<code>package.json</code>里面的字段（所有<code>PACKAG.JSON</code>属性都作为环境变量公开）。比如，下面是一个<code>package.json</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"foo"</span>, </span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.2.5"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"view"</span>: <span class="string">"node view.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么，变量<code>npm_package_name</code>返回foo，变量<code>npm_package_version</code>返回1.2.5。</p></li><li><p>可以通过环境变量<code>process.env</code>对象，拿到<code>package.json</code>的字段值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.npm_package_name); // foo</span><br><span class="line">console.log(process.env.npm_package_version); // 1.2.5</span><br></pre></td></tr></table></figure></li><li><p><code>npm_package_前缀</code>也支持嵌套的<code>package.json</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"repository"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"xxx"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  scripts: &#123;</span><br><span class="line">    <span class="string">"view"</span>: <span class="string">"echo <span class="variable">$npm_package_repository_type</span>"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，<code>repository</code>字段的<code>type</code>属性，可以通过<code>npm_package_repository_type</code>取到。</p></li></ul><blockquote>发布代码</blockquote><ul><li>在<code>package.json</code>文件中需要定义发布包名称（name），当前版本号、第三方依赖、入口模块位置、命令行程序名和主模块位置等字段。然后使用<code>npm publish</code>进行发布，当然，之前还需要有<code>npm</code>帐号，即用<code>npm adduser</code>进行登录。</li></ul><blockquote>执行顺序</blockquote><ul><li><p>如果 <code>npm</code> 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。</p><ul><li><p>如果是并行执行（即同时的平行执行），可以使用&amp;符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run script1.js &amp; npm run script2.js</span><br></pre></td></tr></table></figure></li><li><p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run script1.js &amp;&amp; npm run script2.js</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote>简写形式</blockquote><ul><li>四个常用的 <code>npm</code> 脚本的简写形式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm start // npm run start的简写</span><br><span class="line">npm stop // npm run stop的简写</span><br><span class="line">npm <span class="built_in">test</span> // npm run <span class="built_in">test</span>的简写</span><br><span class="line">npm restart //npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写</span><br></pre></td></tr></table></figure></li></ul><h4 id="npm-install、npm-install-–save与npm-install-–save-dev区别"><a href="#npm-install、npm-install-–save与npm-install-–save-dev区别" class="headerlink" title="npm install、npm install –save与npm install –save-dev区别"></a>npm install、npm install –save与npm install –save-dev区别</h4><h5 id="npm-install-X"><a href="#npm-install-X" class="headerlink" title="npm install X"></a>npm install X</h5><ul><li>会把X包安装到<code>node_modules</code>目录中。</li><li>不会修改<code>package.json</code>。</li><li>之后运行<code>npm install</code>命令时，不会自动安装X。</li></ul><h5 id="npm-install-X-–save"><a href="#npm-install-X-–save" class="headerlink" title="npm install X –save"></a>npm install X –save</h5><ul><li>会把X包安装到<code>node_modules</code>目录中。</li><li>会在<code>package.json的<code>dependencies</code>属性下添加X。</code></li><li>之后运行<code>npm install</code>命令时，会自动安装X到<code>node_modules</code>目录中。</li><li>之后运行<code>npm install –production</code>或者注明<code>NODE_ENV</code>变量值为<code>production</code>时，会自动安装msbuild到<code>node_modules</code>目录中。</li></ul><h5 id="npm-install-X-–save-dev"><a href="#npm-install-X-–save-dev" class="headerlink" title="npm install X –save-dev"></a>npm install X –save-dev</h5><ul><li>会把X包安装到<code>node_modules</code>目录中。</li><li>会在<code>package.json</code>的<code>devDependencies</code>属性下添加X。</li><li>之后运行<code>npm install</code>命令时，会自动安装X到<code>node_modules</code>目录中。</li><li>之后运行<code>npm install –production</code>或者注明<code>NODE_ENV</code>变量值为<code>production</code>时，不会自动安装X到<code>node_modules</code>目录中。</li></ul><h5 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h5><ul><li>运行时需要用到的包使用<code>–save</code>，否则使用<code>–save-dev</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Node 开发离不开 &lt;code&gt;npm&lt;/code&gt;，而脚本功能是 &lt;code&gt;npm&lt;/code&gt; 最强大、最常用的功能之一。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="npm" scheme="https://chongtianhong.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Express入门</title>
    <link href="https://chongtianhong.github.io/2018/03/21/express/"/>
    <id>https://chongtianhong.github.io/2018/03/21/express/</id>
    <published>2018-03-21T05:37:12.000Z</published>
    <updated>2018-07-20T14:21:20.981Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Express 是一个<strong>基于 Node.js 平台</strong>的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助我们创建各种 Web 和移动设备应用。</li><li>选择Express而不是koa，因为这两个框架来自同一团队，在绝大多数的用法上其实是很相似的，koa有更多的ECMAscript6的语法，而<strong>Express更适合初学者学习</strong>。<a id="more"></a></li><li>Express解决的是<strong>快速创建服务器和路由</strong>的问题。</li><li><strong>ejs模板，jade模板</strong>等解决的是<strong>动态显示网页</strong>的问题。</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>首先需要安装 <strong>Node.js</strong>，然后为express应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myapp</span><br><span class="line"><span class="built_in">cd</span> myapp</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>npm init</code> 命令为应用创建一个 <code>package.json</code> 文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li><li><p>此命令将要求我们输入几个参数，例如此应用的名称和版本。 可以直接按“回车”键接受默认设置即可，下面这个除外：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry point: (index.js)</span><br></pre></td></tr></table></figure></li><li><p>键入 <code>app.js</code> 或者希望的名称，作为当前应用的入口文件。如果希望采用默认的 index.js 文件名，只需按“回车”键即可。</p></li><li><p>接下来安装 Express 并将其保存到依赖列表中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure></li><li><p>如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></li></ul><blockquote>注意：安装 Node 模块时，如果指定了 <code>–save</code> 参数，那么此模块将被添加到 <code>package.json</code> 文件中 <code>dependencies</code> 依赖列表中。 然后通过 <code>npm install</code> 命令即可自动安装依赖列表中所列出的所有模块。</blockquote><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><ul><li>接下来，我们一起创建一个基本的 <code>Express</code> 应用。</li></ul><blockquote>注意：这里所创建是一个最最简单的 Express 应用，并且<strong>仅仅只有一个文件</strong>，和通过 <strong>Express 应用生成器</strong> 所创建的应用<em>完全不一样</em>，Express 应用生成器所创建的应用框架包含多个 JavaScript 文件、Jade 模板和针对不同用途的子目录。</blockquote><ul><li><p>进入 <code>myapp</code> 目录，创建一个名为 <code>app.js</code> 的文件，然后写入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var server = app.listen(3000, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var host = server.address().address;</span><br><span class="line">  var port = server.address().port;</span><br><span class="line"></span><br><span class="line">  console.log(<span class="string">'Example app listening at http://%s:%s'</span>, host, port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 <code>404 Not Found</code>。</p></li><li><p>通过如下命令启动此应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></li><li><p>然后在浏览器中打开 <code><a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></code> 并查看输出结果。</p></li></ul><h4 id="Express-应用生成器"><a href="#Express-应用生成器" class="headerlink" title="Express 应用生成器"></a>Express 应用生成器</h4><ul><li>通过<strong>应用生成器工具</strong> express 可以快速创建一个应用的骨架。</li><li><p>通过如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-generator -g</span><br></pre></td></tr></table></figure></li><li><p>-h 选项可以列出所有可用的命令行选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">express -h</span><br><span class="line"></span><br><span class="line">  Usage: express [options] [dir]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --<span class="built_in">help</span>          output usage information</span><br><span class="line">    -V, --version       output the version number</span><br><span class="line">    -e, --ejs           add ejs engine support (defaults to jade)</span><br><span class="line">        --hbs           add handlebars engine support</span><br><span class="line">    -H, --hogan         add hogan.js engine support</span><br><span class="line">    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)</span><br><span class="line">        --git           add .gitignore</span><br><span class="line">    -f, --force         force on non-empty directory</span><br></pre></td></tr></table></figure></li><li><p>例如，下面的示例就是在当前工作目录下创建一个命名为 myapp 的应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">express myapp</span><br><span class="line"></span><br><span class="line">   create : myapp</span><br><span class="line">   create : myapp/package.json</span><br><span class="line">   create : myapp/app.js</span><br><span class="line">   create : myapp/public</span><br><span class="line">   create : myapp/public/javascripts</span><br><span class="line">   create : myapp/public/images</span><br><span class="line">   create : myapp/routes</span><br><span class="line">   create : myapp/routes/index.js</span><br><span class="line">   create : myapp/routes/users.js</span><br><span class="line">   create : myapp/public/stylesheets</span><br><span class="line">   create : myapp/public/stylesheets/style.css</span><br><span class="line">   create : myapp/views</span><br><span class="line">   create : myapp/views/index.jade</span><br><span class="line">   create : myapp/views/layout.jade</span><br><span class="line">   create : myapp/views/error.jade</span><br><span class="line">   create : myapp/bin</span><br><span class="line">   create : myapp/bin/www</span><br></pre></td></tr></table></figure></li><li><p>然后安装所有依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myapp </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>Windows 平台使用如下命令启动这个应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> DEBUG=myapp &amp; npm start</span><br></pre></td></tr></table></figure></li><li><p>然后在浏览器中打开 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 网址就可以看到这个应用了。</p></li><li>通过 Express 应用生成器创建的应用一般都有如下目录结构：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.jade</span><br><span class="line">    ├── index.jade</span><br><span class="line">    └── layout.jade</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure></li></ul><blockquote>通过 Express 应用生长期创建应用只是众多方法中的一种。你可以不使用它，也可以修改它让它符合你的需求。</blockquote><h4 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h4><ul><li>路由（Routing）是由一个 <strong>URI</strong>（或者叫路径）和一个<strong>特定的 HTTP 方法</strong>（GET、POST 等）组成的，涉及到应用如何<strong>响应客户端对某个网站节点的访问</strong>。</li><li>每一个路由都可以有<strong>一个或者多个</strong>处理器函数，当<strong>匹配到路由</strong>时，<strong>这些函数将被执行</strong>。</li><li><p>路由的定义由如下结构组成：<code>app.METHOD(PATH, HANDLER)</code>。其中</p><ul><li>app 是一个 express 实例；</li><li>METHOD 是某个 HTTP 请求方式中的一个；</li><li>PATH 是服务器端的路径；</li><li>HANDLER 是当路由匹配到时需要执行的函数。</li></ul></li><li><p>下面的代码展示了几个路由实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 对网站首页的访问返回 <span class="string">"Hello World!"</span> 字样</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 网站首页接受 POST 请求</span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Got a POST request'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// /user 节点接受 PUT 请求</span><br><span class="line">app.put(<span class="string">'/user'</span>, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Got a PUT request at /user'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// /user 节点接受 DELETE 请求</span><br><span class="line">app.delete(<span class="string">'/user'</span>, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">  res.send(<span class="string">'Got a DELETE request at /user'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h4><ul><li>通过 Express 内置的 <code>express.static</code>中间件则可以方便地<strong>托管静态文件</strong>，例如图片、CSS、JavaScript 文件等。</li><li><p>将静态资源文件所在的目录<strong>作为参数传递</strong>给 express.static 中间件就可以提供静态资源文件的访问了。例如，假设在 public 目录放置了图片、CSS 和 JavaScript 文件，可以设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure></li><li><p>现在，public 目录下面的文件就可以访问了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3000/images/kitten.jpg</span><br><span class="line">http://localhost:3000/css/style.css</span><br><span class="line">http://localhost:3000/js/app.js</span><br><span class="line">http://localhost:3000/images/bg.png</span><br><span class="line">http://localhost:3000/hello.html</span><br></pre></td></tr></table></figure></li></ul><blockquote>所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。</blockquote><ul><li><p>如果我们的静态资源存放在多个目录下面，可以多次调用 express.static 中间件,访问静态资源文件时，express.static 中间件会<strong>根据目录添加的顺序</strong>查找所需的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line">app.use(express.static(<span class="string">'files'</span>));</span><br></pre></td></tr></table></figure></li><li><p>如果希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过<strong>为静态资源目录指定一个挂载路径</strong>的方式来实现，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/static'</span>, express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure></li><li><p>现在，你就可以通过带有 “/static” 前缀的地址来访问 public 目录下面的文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3000/static/images/kitten.jpg</span><br><span class="line">http://localhost:3000/static/css/style.css</span><br><span class="line">http://localhost:3000/static/js/app.js</span><br><span class="line">http://localhost:3000/static/images/bg.png</span><br><span class="line">http://localhost:3000/static/hello.html</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Express 是一个&lt;strong&gt;基于 Node.js 平台&lt;/strong&gt;的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助我们创建各种 Web 和移动设备应用。&lt;/li&gt;
&lt;li&gt;选择Express而不是koa，因为这两个框架来自同一团队，在绝大多数的用法上其实是很相似的，koa有更多的ECMAscript6的语法，而&lt;strong&gt;Express更适合初学者学习&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://chongtianhong.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>数组遍历方法forEach 和 map 的区别</title>
    <link href="https://chongtianhong.github.io/2018/03/20/arrayMethods/"/>
    <id>https://chongtianhong.github.io/2018/03/20/arrayMethods/</id>
    <published>2018-03-20T01:57:19.000Z</published>
    <updated>2018-07-20T14:14:53.141Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JavaScript中的 forEach() 和 map() 方法都是 ES5 为处理数组而新增的迭代方法，最主要的区别在于 <strong>map 方法返回一个新数组</strong>，而 <strong>forEach 方法没有返回值</strong>。</li></ul><a id="more"></a><ul><li>forEach()和map()都是遍历数组的方法，用法类似，但是还是有很大区别。</li></ul><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><ol><li>都是<strong>按照顺序</strong>循环遍历数组中的每一项；</li><li>在遍历中执行匿名函数都可以接收三个参数，分别为：<strong>item</strong>（当前每一项）、<strong>index</strong>（索引值）、<strong>arr</strong>（原数组）；</li><li>执行的<strong>匿名函数中的this都指向Window对象</strong>；</li><li>只能遍历数组。</li></ol><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ol><li><p>map()是根据遍历执行的匿名函数，对于原数组中的每个值产生一个对应的值，并<strong>返回一个新的数组</strong>，数组中的元素为原始数组调用函数处理后的值，存在一个映射关系，并且<strong>不会改变原数组</strong>，<strong>不会对空数组进行检测</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0,1,2,3,4];</span><br><span class="line">var str = arr.map(<span class="keyword">function</span>(i,index,arr)&#123;</span><br><span class="line">    console.log(this); // Window</span><br><span class="line">    <span class="built_in">return</span> ++i;</span><br><span class="line">&#125;,this);</span><br><span class="line">console.log(str);  //结果为 [1,2,3,4,5]</span><br></pre></td></tr></table></figure></li><li><p>forEach()只是<strong>按照顺序</strong>把数组中的元素传递给forEach中的匿名函数使用，<strong>对于空数组则不会调用到匿名函数</strong>（对空数组进行检测）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0,1,2,3,4];</span><br><span class="line">var sum = 0;</span><br><span class="line">var str = arr.forEach(<span class="keyword">function</span>(i,index,arr)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    console.log(<span class="string">"sum的值为："</span>,sum); </span><br><span class="line">&#125;)   //执行5次，最终结果 10</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;JavaScript中的 forEach() 和 map() 方法都是 ES5 为处理数组而新增的迭代方法，最主要的区别在于 &lt;strong&gt;map 方法返回一个新数组&lt;/strong&gt;，而 &lt;strong&gt;forEach 方法没有返回值&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Array" scheme="https://chongtianhong.github.io/tags/Array/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端优化方法（全）</title>
    <link href="https://chongtianhong.github.io/2018/03/19/frontEndOptimization/"/>
    <id>https://chongtianhong.github.io/2018/03/19/frontEndOptimization/</id>
    <published>2018-03-19T15:08:51.000Z</published>
    <updated>2018-07-19T15:57:24.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote>1.Minimize HTTP Requests 减少HTTP请求</blockquote><ul><li>图片、css、script、flash等资源的获取都会增加http请求数，减少这些元素的数量就能减少响应时间。</li><li>把多个JS、CSS在可能的情况下写进一个文件（使用打包工具进行合并）。<a id="more"></a></li><li>页面里直接插入图片也是不好的做法，应该在CSS中设置成背景图，利用 CSS sprites 将小图拼合后利用background-position来定位。</li></ul><blockquote>Use a Content Delivery Network 利用CDN技术</blockquote><ul><li>利用 CDN <strong>将静态资源分发</strong>到各个<strong>主要服务器节点</strong>，可以<strong>加快用户的请求速度</strong>。</li></ul><blockquote>3.Add an Expires or a Cache-Control Header 设置头文件过期或者静态缓存</blockquote><ul><li>浏览器会<strong>使用缓存来减少http请求数</strong>，从而<strong>加快页面加载的时间</strong>，如果页面头部加一个很长的过期时间，浏览器就会一直缓存页面里的元素。</li></ul><blockquote>4.Gzip Components Gzip压缩</blockquote><ul><li>Gzip格式是一种很普遍的压缩技术，几乎所有的浏览器都具有解压Gzip格式的能力，而且它可以压缩的比例非常大，一般压缩率为85%。</li></ul><blockquote>5.Put Stylesheets at the Top 把CSS放页面顶部</blockquote><ul><li>与浏览器的渲染机制有关，减少页面的白屏和无样式内容闪烁。让浏览者能尽早的看到网站的完整样式，优化用户体验。</li></ul><blockquote>6.Put Scripts at the Bottom 把JS放文档底部</blockquote><ul><li>网站呈现完毕后再进行功能设置，当然这些JS要在你的加载过程中不影响内容表现。</li></ul><blockquote>7.Avoid CSS Expressions 避免CSS 表达式</blockquote><blockquote>8.Make JavaScript and CSS External 将JS和CSS外链</blockquote><ul><li>前面讲到了缓存这个事情，一些较为公用的JS和CSS，我们可以使用外链的形式，譬如我使用了从Google外链来的Jquery文件，如果我的浏览者在浏览别的使用了这个外链文件的网站时已经下载并缓存了这个文件，那么他在浏览我的网站的时候就不需要再进行下载了。</li></ul><blockquote>Reduce DNS Lookups 减少DNS查找</blockquote><ul><li><strong>减少DNS查询次数</strong>需要<strong>减少来自不同domain的请求的数量</strong>，如尽量将外部域的对象下载到本地服务器上等。</li></ul><blockquote>10.Minify JavaScript and CSS 减小JS和CSS的体积</blockquote><ul><li>写JS和CSS都是有技巧的，用最少的代码实现同样的功能，减少空白，增强逻辑性，用缩写方式等等，当然也有不少工具也能够帮我们实现文件压缩功能。</li></ul><blockquote>11.Avoid Redirects 避免重定向</blockquote><ul><li>再写入链接时，虽然<code><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></code>和<code><a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a></code> 仅有一个最后的”/”只差，但是结果是不同的，服务器需要花时间<strong>把前者重定向为后者</strong>然后进行跳转。</li></ul><blockquote>12. Remove Duplicate Scripts 删除重复脚本</blockquote><ul><li>重复调用的代码浏览器并不会被识别忽略，而是会再次运算一遍，这当然是大大的浪费。</li></ul><blockquote>13. Configure ETags 配置ETags</blockquote><ul><li>利用了浏览器的协商缓存。</li></ul><blockquote>14. Make Ajax Cacheable 缓存Ajax</blockquote><ul><li>Ajax是实时响应的，在浏览器接收到新的数据前，旧的数据被缓存，这样能够更好的提高效率。</li></ul><blockquote>15. Use GET for AJAX Requests 用GET方式进行AJAX请求</blockquote><ul><li>Get 方法和服务器只有一次交互（发送数据），而 Post 要两次（发送头部再发送数据）。</li></ul><blockquote>16. Post-load Components 延迟加载组件</blockquote><ul><li>在进行页面初始化时最先加载必须的组件，然后再加载其他。</li></ul><blockquote>17. Preload components 预加载组件</blockquote><ul><li>提前加载以后可能用到的东西，和延迟加载并不冲突，它的目的是为后续请求提供更快的响应。</li></ul><blockquote>18. Reduce the Number of DOM Elements 减少DOM元素数量</blockquote><ul><li>复杂的页面结构意味着<strong>更长的下载及响应时间</strong>，更合理更高效的使用语义化标签来架构页面，是好的前端的必备条件。</li></ul><blockquote>19. Split Components Across Domains 跨域分离组件</blockquote><ul><li>页面组件<strong>使用多个来源</strong>可以<strong>增大浏览器的并行下载量</strong>，但注意不要过多，超过2-4个域名会引起上面说到的<strong>DNS查找浪费</strong>。</li></ul><blockquote>20. No 404s 不要出现404页面</blockquote><ul><li>站点本身里（非搜索结果）出现404页面，<strong>无意义的404页面会影响用户体验并且会消耗服务器资源</strong>。</li></ul><blockquote>21.Reduce Cookie Size 减小Cookie体积</blockquote><ul><li>Cookie在服务器及浏览器之间的通过文件头进行交换，尽可能减小Cookie体积，设置合理的过期时间，能够很好的提高效率。</li></ul><blockquote>22. Use Cookie-free Domains for Components 对组件使用无Cookie的域名</blockquote><ul><li>对静态组件的Cookie读取是一种浪费，使用另一个无Cookie的域名来存放静态组件是一个好方法（cookie有域的限制，可进行cookie隔离）。</li></ul><blockquote>23. Minimize DOM Access 减少DOM的访问次数</blockquote><ul><li>JS访问DOM是很慢的，尽量不要用JS来设置页面布局。</li></ul><blockquote>24. Optimize Images 优化图片</blockquote><ul><li>将GIF转为PNG8会是个减小体积的好办法，另外有很多方法处理的JPG及PNG图片以达到优化效果。</li></ul><blockquote>25. Optimize CSS Sprites 优化CSS Sprites</blockquote><ul><li>在CSS Sprites中竖直并尽量紧凑的排列图片，尽量将颜色相似的图片排在一起，会减小图片本身的大小及提高页面图片显示速度。</li></ul><blockquote>26. Don’t Scale Images in HTML 不要在HTML中缩放图片</blockquote><ul><li>图片要用多大的就用多大的，1000X1000的图片被设置样式为<code>width=”100” height=”100”</code>以后，本身的KB数是不会减少的。</li></ul><blockquote>27. 使用base64编码代替图片</blockquote><ul><li>适用于图片小于2KB，页面引用图片不多的情况。将图片转换为base64编码字符串嵌入到CSS或页面中，<strong>减少http的请求次数</strong>。</li></ul><blockquote>28. 合并图片sprite（雪碧图）</blockquote><ul><li>任何用到页面图片的场景。将多个页面用到的背景图片合并成一个大的图片在页面中引用，可以有效地减少请求个数。</li></ul><blockquote>29. 使用canvas代替图片</blockquote><ul><li>需要高性能的图片或动画，使用HTML5的canvas元素绘制图片，页面渲染性能较高。</li></ul><blockquote>30. 图片压缩</blockquote><ul><li>在不得不加载图片的前提下，进一步提高优化效果，通过有损或无损压缩所见图片的大小。减少图片加载流量，效果明显。</li></ul><blockquote>31. 更好的图片格式</blockquote><ul><li>webp、bpg、sharpP等新图片格式具有更好的压缩比。webp能让图片平均大小减小70%。</li></ul><blockquote>32. 使用矢量图代替位图</blockquote><ul><li>对于绝大多数图案、图标等，<strong>矢量图更小</strong>，且<strong>可缩放</strong>而<strong>无需生成多套图</strong>。现在主流浏览器都支持SVG了，所以可放心使用。</li></ul><blockquote>33. 按需加载</blockquote><ul><li>用户看不到的可以先不用加载，在需要用到的时候再加载。可以按需加载的有图片、CSS、JS。</li></ul><blockquote>34. 预加载</blockquote><ul><li>提前加载图片，当用户需要查看时可直接从本地缓存中渲染。预加载是<strong>牺牲服务器性能</strong>来<strong>换取用户更好的用户体验</strong>。</li><li>不过需要注意的是和懒加载的区别，两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<strong>懒加载对服务器前端有一定的缓解压力作用</strong>，<strong>预加载则会增加服务器前端压力</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;1.Minimize HTTP Requests 减少HTTP请求&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;图片、css、script、flash等资源的获取都会增加http请求数，减少这些元素的数量就能减少响应时间。&lt;/li&gt;
&lt;li&gt;把多个JS、CSS在可能的情况下写进一个文件（使用打包工具进行合并）。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Hosts文件的作用</title>
    <link href="https://chongtianhong.github.io/2018/03/18/hosts/"/>
    <id>https://chongtianhong.github.io/2018/03/18/hosts/</id>
    <published>2018-03-18T04:39:49.000Z</published>
    <updated>2018-07-19T15:07:48.035Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Hosts是一个没有扩展名的系统文件，其基本作用就是将一些常用的<strong>网址域名</strong>与其对应的<strong>IP地址</strong>建立一个关联“数据库”。</li><li>当用户在浏览器中输入一个需要解析的域名时，系统会<strong>首先</strong>自动<strong>从Hosts文件中寻找对应的IP地址</strong>。<ul><li>一旦<strong>找到</strong>，系统会<strong>立即打开对应网页</strong>；</li><li>如果<strong>没有找到</strong>，则系统则会<strong>将域名提交DNS域名解析服务器进行IP地址的解析</strong>。</li><li>如果发现是<strong>被屏蔽的IP或域名</strong>，就会<strong>禁止打开此网页</strong>。<a id="more"></a></li></ul></li></ul><h4 id="hosts文件位置"><a href="#hosts文件位置" class="headerlink" title="hosts文件位置"></a>hosts文件位置</h4><ul><li>在XP 、win7系统中，HOST文件位于系统盘<code>C:\Windows\System32\drivers\etc</code>中，如果进去没有看到Hosts文件，是因为某些系统将Host文件隐藏了。</li></ul><h4 id="hosts文件作用"><a href="#hosts文件作用" class="headerlink" title="hosts文件作用"></a>hosts文件作用</h4><h5 id="加快域名解析"><a href="#加快域名解析" class="headerlink" title="加快域名解析"></a>加快域名解析</h5><ul><li>对于要经常访问的网站，我们可以通过<strong>在Hosts中配置域名和IP的映射关系</strong>，<strong>提高域名解析速度</strong>。由于有了映射关系，当我们输入域名,计算机就能很快解析出IP，而不用请求网络上的DNS服务器。</li><li>例如：Host文件中添加一条：<code>222.73.44.198 blog.itful.com</code> ，IP与域名中间要有空格，IP地址一定要输入正确，不然就访问不了该网站。</li><li>可以通过运行CMD，输入“ping 网站域名” 来获得网站的IP地址，<strong>不需要经过DNS域名服务器进行IP地址的解析</strong>。</li></ul><h5 id="方便局域网用户"><a href="#方便局域网用户" class="headerlink" title="方便局域网用户"></a>方便局域网用户</h5><ul><li>在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务器时，要输入难记的IP地址。这对不少人来说相当麻烦。现在可以分别<strong>给这些服务器</strong>取个容易记住的名字，然后<strong>在Hosts中建立IP映射</strong>，这样以后访问的时候，只要输入这个服务器的名字就行了。</li></ul><h5 id="屏蔽网站"><a href="#屏蔽网站" class="headerlink" title="屏蔽网站"></a>屏蔽网站</h5><ul><li>现在有很多网站不经过用户同意就将各种各样的插件安装到我们的计算机中，其中不乏有病毒木马。</li><li>对于这些网站我们可以<strong>利用Hosts把该网站的域名映射到一个错误的IP或本地计算机的IP</strong>，这样<strong>就不用访问这些网站</strong>了。</li><li><p>在Windows系统中，约定 <code>127.0.0.1</code>为本地计算机的IP地址, <code>0.0.0.0</code>是错误的IP地址。 例如，我们在Hosts中，输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 www.xxx.com</span><br></pre></td></tr></table></figure></li><li><p>这样，计算机解析域名 <code>www.xxx.com</code> 时，就解析到本机IP或错误的IP，达到了<strong>屏蔽不健康网站</strong>的目的。</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>现在某些病毒、恶意程序会修改我们的hosts文件，导致我们无法访问某些网站，当发现某些网站不能访问时，我们可以进入Hosts文件进行观察，如果是因为Hosts文件造成的网站无法访问，删除病毒添加的语句，就可以对网站进行正常访问。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Hosts是一个没有扩展名的系统文件，其基本作用就是将一些常用的&lt;strong&gt;网址域名&lt;/strong&gt;与其对应的&lt;strong&gt;IP地址&lt;/strong&gt;建立一个关联“数据库”。&lt;/li&gt;
&lt;li&gt;当用户在浏览器中输入一个需要解析的域名时，系统会&lt;strong&gt;首先&lt;/strong&gt;自动&lt;strong&gt;从Hosts文件中寻找对应的IP地址&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;一旦&lt;strong&gt;找到&lt;/strong&gt;，系统会&lt;strong&gt;立即打开对应网页&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;没有找到&lt;/strong&gt;，则系统则会&lt;strong&gt;将域名提交DNS域名解析服务器进行IP地址的解析&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果发现是&lt;strong&gt;被屏蔽的IP或域名&lt;/strong&gt;，就会&lt;strong&gt;禁止打开此网页&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="hosts" scheme="https://chongtianhong.github.io/tags/hosts/"/>
    
  </entry>
  
  <entry>
    <title>XSS和CSRF攻击的学习</title>
    <link href="https://chongtianhong.github.io/2018/03/17/webSecurity/"/>
    <id>https://chongtianhong.github.io/2018/03/17/webSecurity/</id>
    <published>2018-03-17T14:59:38.000Z</published>
    <updated>2018-07-18T15:58:40.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>在 Web 安全领域中，XSS 和 CSRF 是最常见的攻击方式。本文将会对 XSS 和 CSRF 的攻防问题进行介绍。<a id="more"></a></li></ul><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul><li>XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。</li><li>XSS 攻击是指攻击者<strong>在网站上注入恶意的客户端代码</strong>，通过恶意脚本<strong>对客户端网页进行篡改</strong>，从而在用户浏览网页时，<strong>对用户浏览器进行控制</strong>或者<strong>获取用户隐私数据</strong>的一种攻击方式。</li><li>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的<strong>共同点</strong>为：<strong>将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作</strong>。</li><li>XSS攻击可以分为3类：<strong>反射型（非持久型）</strong>、<strong>存储型（持久型）</strong>、<strong>基于DOM</strong>。</li></ul><h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5><ul><li>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要<strong>攻击者诱使用户点击一个恶意链接</strong>，或者<strong>提交一个表单</strong>，或者<strong>进入一个恶意网站</strong>时，<strong>注入脚本进入被攻击者的网站</strong>。</li><li>攻击者可以注入任意的恶意脚本进行攻击，可能注入<strong>恶作剧脚本</strong>，或者注入<strong>能获取用户隐私数据(如cookie)的脚本</strong>，这取决于攻击者的目的。</li></ul><h5 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h5><ul><li>存储型 XSS 会<strong>把用户输入的数据 “存储” 在服务器端</strong>，当<strong>浏览器请求数据时</strong>，<strong>脚本从服务器上传回并执行</strong>。这种 XSS 攻击具有<strong>很强的稳定性</strong>。</li><li>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</li></ul><h5 id="基于DOM"><a href="#基于DOM" class="headerlink" title="基于DOM"></a>基于DOM</h5><ul><li>基于 DOM 的 XSS 攻击是指<strong>通过恶意脚本修改页面的 DOM 结构</strong>，是纯粹<strong>发生在客户端的攻击</strong>。</li><li><p>看如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;XSS: &lt;/h2&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"input"</span>&gt;</span><br><span class="line">&lt;button id=<span class="string">"btn"</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;div id=<span class="string">"div"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const input = document.getElementById(<span class="string">'input'</span>);</span><br><span class="line">    const btn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">    const div = document.getElementById(<span class="string">'div'</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">let</span> val;</span><br><span class="line">    </span><br><span class="line">    input.addEventListener(<span class="string">'change'</span>, (e) =&gt; &#123;</span><br><span class="line">        val = e.target.value;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">        div.innerHTML = `&lt;a href=<span class="variable">$&#123;val&#125;</span>&gt;testLink&lt;/a&gt;`</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span> onclick=alert(/xss/)</span><br></pre></td></tr></table></figure></li><li><p>用户提交之后，页面代码就变成了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href onlick=<span class="string">"alert(/xss/)"</span>&gt;testLink&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>此时，用户点击生成的链接，就会执行对应的脚本。</p></li></ul><h4 id="XSS-攻击的防范"><a href="#XSS-攻击的防范" class="headerlink" title="XSS 攻击的防范"></a>XSS 攻击的防范</h4><ul><li>现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。<h5 id="HttpOnly-防止劫取-Cookie"><a href="#HttpOnly-防止劫取-Cookie" class="headerlink" title="HttpOnly 防止劫取 Cookie"></a>HttpOnly 防止劫取 Cookie</h5></li><li>HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将<strong>禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie</strong>。</li><li>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，<strong>HttpOnly</strong> 并非阻止 XSS 攻击，而是<strong>能阻止 XSS 攻击后的 Cookie 劫持攻击</strong>。</li></ul><h5 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h5><ul><li><strong>不要相信用户的任何输入</strong>。 对于用户的<strong>任何输入</strong>要进行<strong>检查、过滤和转义</strong>。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</li><li>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则<strong>对特殊字符进行过滤或编码</strong>，这种方式也称为 XSS Filter。</li></ul><h5 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h5><ul><li>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。</li></ul><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><ul><li>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种<strong>劫持受信任用户向服务器发送非预期请求</strong>的攻击方式。</li><li>通常情况下，CSRF 攻击是攻击者<strong>借助受害者的 Cookie 骗取服务器的信任</strong>，可以在受害者毫不知情的情况下<strong>以受害者名义伪造请求发送给受攻击服务器</strong>，从而<strong>在并未授权的情况下</strong>执行在<strong>权限保护之下</strong>的操作。</li><li>在举例子之前，先说说浏览器的 Cookie 策略。</li></ul><h5 id="浏览器的-Cookie-策略"><a href="#浏览器的-Cookie-策略" class="headerlink" title="浏览器的 Cookie 策略"></a>浏览器的 Cookie 策略</h5><ul><li>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li><p>浏览器所持有的 Cookie 分为两种：</p><ul><li><strong>Session Cookie(会话期 Cookie)</strong>：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它<strong>仅在会话期内有效</strong>，浏览器关闭之后它会被自动删除。</li><li><strong>Permanent Cookie(持久性 Cookie)</strong>：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Set-Cookie'</span>, [<span class="string">'mycookie=222'</span>, <span class="string">'test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;'</span>]);</span><br></pre></td></tr></table></figure></li><li><p>上述代码创建了两个 Cookie：mycookie 和 test，<strong>前者属于会话期 Cookie</strong>，<strong>后者则属于持久性 Cookie</strong>。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样。</p></li><li>此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。<ul><li>如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为<strong>第一方 Cookie（first-party cookie）</strong>；</li><li>如果 Cookie 的域和页面的域不同，则称之为<strong>第三方 Cookie（third-party cookie）</strong>。</li></ul></li><li>一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。因为Cookie有域的限制，不能跨域提交请求。</li></ul><h5 id="通过-Cookie-进行-CSRF-攻击"><a href="#通过-Cookie-进行-CSRF-攻击" class="headerlink" title="通过 Cookie 进行 CSRF 攻击"></a>通过 Cookie 进行 CSRF 攻击</h5><ul><li><p>假设有一个 bbs 站点：<code><a href="http://www.c.com" target="_blank" rel="noopener">http://www.c.com</a></code>，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.c.com:8002/content/delete/:id</span><br></pre></td></tr></table></figure></li><li><p>如发起<code><a href="http://www.c.com:8002/content/delete/87343" target="_blank" rel="noopener">http://www.c.com:8002/content/delete/87343</a></code>请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Set-Cookie'</span>, [<span class="string">'user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;'</span>]);</span><br></pre></td></tr></table></figure></li><li><p>user 对应的值是用户 ID。然后构造一个页面 A（CSRF 攻击者准备的网站）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;</span><br><span class="line">&lt;img src=<span class="string">"http://www.c.com:8002/content/delete/87343"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接。可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。</p></li><li>由于 Cookie 中包含了用户的认证信息，当<strong>用户访问攻击者准备的攻击环境</strong>时，<strong>攻击者就可以对服务器发起 CSRF 攻击</strong>。<ul><li>在这个攻击过程中，攻击者<strong>借助受害者的 Cookie</strong> 骗取服务器的信任，但<strong>并不能拿到 Cookie</strong>，也<strong>看不到 Cookie 的内容</strong>。</li><li>而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。</li><li>因此，攻击者<strong>无法从返回的结果中得到任何东西</strong>，他所能做的就是<strong>给服务器发送请求</strong>，以执行请求中所描述的命令，<strong>在服务器端直接改变数据的值</strong>，而非窃取服务器中的数据。</li></ul></li><li>但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。</li></ul><h4 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h4><ul><li>对 CSRF 攻击的防范措施主要有如下三种方式。</li></ul><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><ul><li>验证码被认为是对抗 CSRF 攻击<strong>最简洁而有效</strong>的防御方法。</li><li>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而<strong>验证码会强制用户必须与应用进行交互，才能完成最终请求</strong>。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</li><li>但验证码并不是万能的，因为出于用户考虑（影响用户体验），不能给网站所有的操作都加上验证码。因此，验证码<strong>只能作为防御 CSRF 的一种辅助手段</strong>，而不能作为最主要的解决方案。</li></ul><h5 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h5><ul><li>根据 HTTP 协议，在 HTTP 头中有一个字段叫 <strong>Referer</strong>，它记录了该<strong>HTTP请求的来源地址</strong>。<strong>通过 Referer Check，可以检查请求是否来自合法的”源”</strong>。比如：<ul><li>如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 <a href="http://www.c.com；当请求是从" target="_blank" rel="noopener">http://www.c.com；当请求是从</a> www.a.com 发起时，Referer 的值是 <a href="http://www.a.com" target="_blank" rel="noopener">http://www.a.com</a> 了。</li><li>因此，要防御 CSRF 攻击，只需要<strong>对于每一个删帖请求验证其 Referer 值</strong>，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</li></ul></li><li>针对上文的例子，可以在服务端增加如下代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.headers.referer !== <span class="string">'http://www.c.com:8002/'</span>) &#123;</span><br><span class="line">    res.write(<span class="string">'csrf 攻击'</span>);</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h5><ul><li>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中<strong>所有的用户验证信息都是存在于 Cookie 中</strong>，因此攻击者可以在不知道这些验证信息的情况下直接<strong>利用用户自己的 Cookie 来通过安全验证</strong>。要抵御 CSRF，关键在于<strong>在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中</strong>。</li><li>因此，可以<strong>在 HTTP 请求中以参数的形式加入一个随机产生的 token</strong>，并<strong>在服务器端建立一个拦截器来验证这个 token</strong>，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li><li>token的生成是通过前端和服务器协商好算法（摘要算法），浏览器生成，随着请求发送给服务器，服务端进行算法解密验证。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>在 Web 安全领域，除了这两种常见的攻击方式，也存在着 SQL 注入等其它攻击方式。接下来对本文提到的 XSS 攻击和 CSRF 攻击的常见防御措施进行总结：</p><p>1.防御 XSS 攻击</p><ul><li>HttpOnly 防止劫取 Cookie</li><li>用户的输入检查</li><li>服务端的输出检查</li></ul><p>2.防御 CSRF 攻击</p><ul><li>验证码</li><li>Referer Check</li><li>Token 验证</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在 Web 安全领域中，XSS 和 CSRF 是最常见的攻击方式。本文将会对 XSS 和 CSRF 的攻防问题进行介绍。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="XSS" scheme="https://chongtianhong.github.io/tags/XSS/"/>
    
      <category term="CSRF" scheme="https://chongtianhong.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0父子组件以及非父子组件如何通信</title>
    <link href="https://chongtianhong.github.io/2018/03/16/vueComponents/"/>
    <id>https://chongtianhong.github.io/2018/03/16/vueComponents/</id>
    <published>2018-03-16T01:40:13.000Z</published>
    <updated>2018-07-18T15:08:01.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>在vue组件通信中最常见通信方式就是<strong>父子组件之中的通信</strong>，而父子组件的设定方式在不同情况下又各有不同。</li><li>最常见的就是父组件为<strong>控制组件</strong>，子组件为<strong>视图组件</strong>。</li><li>父组件传递数据给子组件使用，遇到业务逻辑操作时子组件触发父组件的自定义事件。</li><li>在通信中，无论是<strong>子组件向父组件传值</strong>还是<strong>父组件向子组件传值</strong>，他们都有一个共同点就是有<strong>中间介质</strong>，<strong>子向父的介质是自定义事件</strong>，<strong>父向子的介质是props中的属性</strong>。</li><li><strong>非父子组件</strong>可以通过<strong>eventHub</strong>来实现通信。eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。<a id="more"></a></li><li>vue提倡单项数据流，因此在通常情况下都是<strong>父组件传递数据给子组件</strong>使用，<strong>子组件触发父组件的事件</strong>，并<strong>传递给父组件所需要的参数</strong>。</li></ul><h4 id="父组件到子组件的通信"><a href="#父组件到子组件的通信" class="headerlink" title="父组件到子组件的通信"></a>父组件到子组件的通信</h4><ul><li>父组件到子组件的通信主要为：<strong>子组件接受使用父组件的数据</strong>，这里的数据包括属性和方法（String, Number, Boolean, Object, Array, Function）。</li></ul><h5 id="通过props传递数据"><a href="#通过props传递数据" class="headerlink" title="通过props传递数据"></a>通过props传递数据</h5><ul><li><p>父子通讯中最常见的数据传递方式就是通过props传递数据，就好像方法的传参一样，父组件<strong>调用子组件</strong>并<strong>通过v-bind传入数据</strong>，子组件接受到父组件传递的数据进行验证使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;父组件&lt;/h2&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;Child-one :parentMessage=<span class="string">"parentMessage"</span>&gt;&lt;/Child-one&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import ChildOne from <span class="string">'./ChildOne'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> default&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      ChildOne,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> &#123;</span><br><span class="line">        parentMessage: <span class="string">'我是来自父组件的消息'</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;我是子组件一&lt;/h3&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;parentMessage&#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default&#123;</span><br><span class="line">    &lt;!--方式1--&gt;</span><br><span class="line">    props: [<span class="string">'parentMessage'</span>],</span><br><span class="line">    &lt;!--方式2--&gt;</span><br><span class="line">    props: &#123;</span><br><span class="line">        parentMessage: String //这样可以指定传入的类型，如果类型不对，会警告</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;!--方式3--&gt;</span><br><span class="line">    props: &#123;</span><br><span class="line">        parentMessage: &#123;</span><br><span class="line">            <span class="built_in">type</span>: String,</span><br><span class="line">            default: <span class="string">'hello world'</span> //这样可以指定默认的值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>props可以接受function</strong>，所以function也可以以这种方式传递到子组件使用。</p></li></ul><h5 id="通过-on传递父组件方法"><a href="#通过-on传递父组件方法" class="headerlink" title="通过$on传递父组件方法"></a>通过$on传递父组件方法</h5><ul><li>通过<strong>$on</strong>传递父组件方法是组件通信中常用的<strong>方法传递方式</strong>。</li><li>它能达到和<strong>通过props传递方法</strong>相同的效果。</li><li><p>相比于props传递function，它<strong>更加的直观和显示的表现</strong>出了调用关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;父组件&lt;/h2&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;Child-one @childEvent=<span class="string">"parentMethod"</span>&gt;&lt;/Child-one&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import ChildOne from <span class="string">'./ChildOne'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> default&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      ChildOne,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> &#123;</span><br><span class="line">        parentMessage: <span class="string">'我是来自父组件的消息'</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">parentMethod</span></span>() &#123;</span><br><span class="line">        alert(this.parentMessage);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;我是子组件一&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default&#123;</span><br><span class="line">    <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">'childEvent'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="获取父组件然后使用父组件中的数据（不推荐）"><a href="#获取父组件然后使用父组件中的数据（不推荐）" class="headerlink" title="获取父组件然后使用父组件中的数据（不推荐）"></a>获取父组件然后使用父组件中的数据（不推荐）</h5><ul><li>准确来说这种方式并<strong>不属于数据的传递</strong>，而是一种<strong>主动的查找</strong>。</li><li>父组件并没有主动的传递数据给子组件，而是子组件通过与父组件的关联关系，获取了父组件的数据。</li><li>该方法虽然<strong>能实现获取父组件中的数据</strong>但是<strong>不推荐</strong>这种方式，因为<strong>vue提倡单向数据流</strong>，只有<strong>父组件交给子组件的数据子组件才有使用的权限</strong>，<strong>不允许子组件私自获取父组件的数据进行使用</strong>。在父与子的关系中子应当是处于一种<strong>被动关系</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$parent</span> // 此处的this为子组件实例</span><br></pre></td></tr></table></figure></li></ul><h4 id="子组件到父组件通信"><a href="#子组件到父组件通信" class="headerlink" title="子组件到父组件通信"></a>子组件到父组件通信</h4><ul><li>子组件到父组件的通信主要为父组件如何接受子组件之中的数据。这里的数据包括属性和方法（String, Number, Boolean, Object, Array, Function）。</li></ul><h5 id="通过-emit传递给父组件数据"><a href="#通过-emit传递给父组件数据" class="headerlink" title="通过$emit传递给父组件数据"></a>通过$emit传递给父组件数据</h5><ul><li><p>与<strong>父组件到子组件通信</strong>中的<strong>$on</strong>配套使用，可以<strong>向父组件中触发的方法传递参数</strong>供父组件使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;父组件&lt;/h2&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;Child-one @childEvent=<span class="string">"parentMethod"</span>&gt;&lt;/Child-one&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import ChildOne from <span class="string">'./ChildOne'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> default&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      ChildOne,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> &#123;</span><br><span class="line">        parentMessage: <span class="string">'我是来自父组件的消息'</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      parentMethod(&#123; name, age &#125;) &#123;</span><br><span class="line">        console.log(this.parentMessage, name, age);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;我是子组件一&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">export</span> default&#123;</span><br><span class="line">    <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">      this.<span class="variable">$emit</span>(<span class="string">'childEvent'</span>, &#123; name: <span class="string">'zhangsan'</span>, age:  10 &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="refs获取"><a href="#refs获取" class="headerlink" title="refs获取"></a>refs获取</h5><ul><li>可以通过<strong>在使用子组件时为其添加ref属性</strong>，然后<strong>父组件可以通过ref属性名称获取到子组件的实例</strong>。</li><li>准确来说这种方式和this.$parent一样并<strong>不属于数据的传递</strong>而是一种<strong>主动的查找</strong>。</li><li>尽量避免使用这种方式。因为在父子组件通信的过程中。<strong>父组件</strong>是处于高位，<strong>拥有控制权</strong>，而<strong>子组件</strong>在多数情况下应该为<strong>纯视图组件</strong>，<strong>只负责视图的展示和自身视图的逻辑操作</strong>。<strong>对外交互</strong>的权利应该由<strong>父组件</strong>来控制。</li><li><p>所以应当<strong>由父组件传递视图数据给子组件</strong>，<strong>子组件负责展示</strong>。而<strong>子组件的对外交互通过$emit触发父组件中相应的方法</strong>，再<strong>由父组件处理相应逻辑</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;父组件&lt;/h2&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;Child-one ref=<span class="string">"child"</span>&gt;&lt;/Child-one&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import ChildOne from <span class="string">'./ChildOne'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> default&#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">      ChildOne,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span></span>()&#123;</span><br><span class="line">      console.log(this.<span class="variable">$refs</span>[<span class="string">'child'</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$refs</span>.child</span><br></pre></td></tr></table></figure></li></ul><h4 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h4><ul><li>如果2个组件不是父子组件则可以通过eventHub来实现通信。</li><li><p>eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> Hub = new Vue(); //创建事件中心</span><br></pre></td></tr></table></figure></li><li><p>组件1触发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=<span class="string">"eve"</span>&gt;&lt;/div&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">eve</span></span>() &#123;</span><br><span class="line">        Hub.<span class="variable">$emit</span>(<span class="string">'change'</span>,<span class="string">'hehe'</span>); //Hub触发事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件2接收:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="title">created</span></span>() &#123;</span><br><span class="line">    Hub.<span class="variable">$on</span>(<span class="string">'change'</span>, str =&gt; &#123; //Hub接收事件</span><br><span class="line">        this.msg = str;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样就实现了非父子组件之间的通信。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>父组件可以使用 props 把数据传给子组件（props属性定义在子组件中）。</li><li>子组件可以使用 $emit 触发父组件的自定义事件。</li><li>子组件可以用this.$parent访问父组件，this.$root访问祖根实例。</li><li>每个父组件都有一个数组this.$children来包含所有子元素。</li><li>父组件可以通过子组件设置的ref属性名称获取到子组件的实例。</li><li>如果组件间不是父子组件的关系则可以通过eventHub来实现通信。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在vue组件通信中最常见通信方式就是&lt;strong&gt;父子组件之中的通信&lt;/strong&gt;，而父子组件的设定方式在不同情况下又各有不同。&lt;/li&gt;
&lt;li&gt;最常见的就是父组件为&lt;strong&gt;控制组件&lt;/strong&gt;，子组件为&lt;strong&gt;视图组件&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;父组件传递数据给子组件使用，遇到业务逻辑操作时子组件触发父组件的自定义事件。&lt;/li&gt;
&lt;li&gt;在通信中，无论是&lt;strong&gt;子组件向父组件传值&lt;/strong&gt;还是&lt;strong&gt;父组件向子组件传值&lt;/strong&gt;，他们都有一个共同点就是有&lt;strong&gt;中间介质&lt;/strong&gt;，&lt;strong&gt;子向父的介质是自定义事件&lt;/strong&gt;，&lt;strong&gt;父向子的介质是props中的属性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非父子组件&lt;/strong&gt;可以通过&lt;strong&gt;eventHub&lt;/strong&gt;来实现通信。eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="Vue.js" scheme="https://chongtianhong.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Promise、Generator及async的笔记整理</title>
    <link href="https://chongtianhong.github.io/2018/03/15/asyncProgram/"/>
    <id>https://chongtianhong.github.io/2018/03/15/asyncProgram/</id>
    <published>2018-03-15T01:56:30.000Z</published>
    <updated>2018-07-18T15:07:58.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>ES6诞生以前，异步编程的方法，大概有如下四种：<strong>回调函数</strong>、<strong>事件监听</strong>、<strong>发布/订阅</strong>、<strong>Promise对象</strong>；</li><li>ES6中，引入了<strong>Generator函数</strong>；</li><li>ES7中，<strong>async</strong>更是将异步编程带入了一个全新的阶段。<a id="more"></a></li></ul><h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><ul><li>Promise，就是一个对象，用来<strong>传递异步操作的消息</strong>，避免了层层嵌套的回调函数。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。<br>（1）对象的状态不受外界影响。有三种状态：<strong>Pending（进行中）</strong>、<strong>Resolved（已完成，又称Fulfilled）</strong>和<strong>Rejected（已失败）</strong>。<br>（2）一旦<strong>状态改变，就不会再变</strong>，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：<strong>从Pending变为Resolve</strong>d和<strong>从Pending变为Rejected</strong>。只要这两种情况发生，<strong>状态</strong>就<strong>凝固</strong>了，<strong>不会再变</strong>了，会一直保持这个结果。</li></ul><blockquote>生成Promise对象</blockquote><ul><li><p>可通过new Promise来生成Promise对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  // 异步操作的代码</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p></li><li>resolve会将Promise对象的状态从pending变为resolved，reject则是将Promise对象的状态从pending变为rejected。</li><li>Promise构造函数接受一个函数后会立即执行这个函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">// Hello World</span><br></pre></td></tr></table></figure></li></ul><blockquote>then和catch回调</blockquote><ul><li><p>Promise对象生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<strong>then方法可以接受两个回调函数作为参数</strong>。</p><ul><li>第一个回调函数是Promise对象的状态变为resolved时调用，称之为成功回调。成功回调接收异步操作成功的结果为参数。</li><li>第二个回调函数是可选的，是Promise对象的状态变为rejected时调用，称之为失败回调。失败回调接收异步操作失败报出的错误作为参数。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        resolve(<span class="string">'成功'</span>)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="keyword">function</span> (data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">// 3s后打印<span class="string">'成功'</span></span><br></pre></td></tr></table></figure></li><li><p>catch方法是then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        reject(<span class="string">'失败'</span>)</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="keyword">function</span> (data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">// 3s后打印<span class="string">'失败'</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>Promise.all()</blockquote><ul><li><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.all([p1, p2, p3])</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但<strong>必须具有Iterator接口</strong>，且<strong>返回的每个成员都是Promise实例</strong>。）</p></li><li>p的状态由p1、p2、p3决定，分成两种情况:<br>（1）只有p1、p2、p3的状态<strong>都变成resolved</strong>，p的状态才会变成resolved，此时<strong>p1、p2、p3的返回值组成一个数组(按数组元素的顺序)，传递给p的回调函数</strong>。<br>（2）只要p1、p2、p3之中<strong>有一个被Rejected，p的状态就变成Rejected</strong>，此时<strong>第一个被reject的实例的返回值，会传递给p的回调函数</strong>。</li><li>Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到<strong>发送多个请求并根据请求顺序获取和使用数据的场景</strong>，使用Promise.all毫无疑问可以解决这个问题。</li></ul><blockquote>Promise.race()</blockquote><ul><li>与Promise.all()类似，不过是只要有一个Promise实例先改变了状态，p的状态就是先改变状态的Promise实例的状态，传递给回调函数的结果也是它的结果。所以很形象地叫做赛跑。</li></ul><blockquote>Promise.resolve()和Promise.reject()</blockquote><ul><li><p>有时需要将现有对象转为Promise对象，可以使用这两个方法。</p></li><li><p>Promise的缺点：</p><ul><li>无法取消Promise，<strong>一旦新建则立即执行</strong>，<strong>无法中途取消</strong>。</li><li>如果不设置catch回调函数，Promise内部抛出的错误，不会反映到外部。</li><li>当处于Pending状态时，<strong>无法得知目前进展到哪一个阶段</strong>（刚刚开始还是即将完成）。</li></ul></li></ul><h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><ul><li>从计算机角度看，生成器是一种类协程或半协程，它提供了一种可以<strong>通过特定语句或方法使其执行对象暂停</strong>的功能。 </li><li>Generator函数，<strong>返回</strong>一个部署了Iterator接口的<strong>遍历器对象</strong>，用来<strong>操作内部指针</strong>。以后，每次调用遍历器对象的next方法，就会<strong>返回</strong>一个有着<strong>value和done两个属性</strong>的<strong>对象</strong>。<ul><li><strong>value属性</strong>表示<strong>当前的内部状态的值</strong>，是yield语句后面那个表达式的值；</li><li><strong>done属性</strong>是一个<strong>布尔值</strong>，表示<strong>是否遍历结束</strong>。</li></ul></li></ul><blockquote>yield [[expression]]</blockquote><ul><li>yield 关键字<strong>使生成器函数暂停执行</strong>，并<strong>返回</strong>跟在它后面的<strong>表达式的当前值</strong>。可以把它想成是<strong>return关键字</strong>的一个<strong>基于生成器的版本</strong>，但其并非退出函数体，而是<strong>切出当前函数的运行时</strong>，与此同时可以<strong>将一个值带到主线程中</strong>。</li><li><strong>yield语句</strong>是<strong>暂停执行</strong>的标记，而<strong>next方法</strong>可以<strong>恢复执行</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  yield <span class="string">'hello'</span>;</span><br><span class="line">  yield <span class="string">'world'</span>;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">'!'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">g.next(); // &#123;value: <span class="string">'hello'</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">g.next(); // &#123;value: <span class="string">'world'</span>, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">g.next(); // &#123;value: <span class="string">'!'</span>, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（1）遇到yield语句，就<strong>暂停执行</strong>后面语句的操作，并<strong>将紧跟在yield后面的表达式的值</strong>，<strong>作为返回的对象的value属性值</strong>；<br>（2）下一次<strong>调用next方法</strong>时，再<strong>继续往下执行</strong>，<strong>直到遇到下一个yield语句</strong>；<br>（3）如果<strong>没有再遇到新的yield语句</strong>，就一直<strong>运行到函数结束</strong>，<strong>直到return语句为止</strong>，并<strong>将return语句后面的表达式的值，作为返回的对象的value属性值</strong>；<br>（4）如果该函数<strong>没有return语句</strong>，则<strong>返回的对象的value属性值为undefined</strong>。 </p><ul><li><p>需要注意的是，<strong>yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行</strong>，因此等于为JavaScript提供了手动的<strong>“惰性求值”（Lazy Evaluation）</strong>的语法功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>() &#123;</span><br><span class="line">  yield 123 + 456;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上述示例中，<strong>yield后面的表达式123 + 456，不会立即求值</strong>，只会<strong>在next方法将指针移到这一句时，才会求值</strong>。</p></li><li>Generator函数也可以不用yield语句，这时就变成了一个单纯的<strong>暂缓执行函数</strong>。</li></ul><blockquote>next方法的参数</blockquote><ul><li><p><strong>注意</strong>：<strong> yield句本身没有返回值</strong>（返回undefined）。<strong>next方法可以带一个参数</strong>，该参数就会被<strong>当作上一个yield语句的返回值</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* foo(x) &#123;</span><br><span class="line">  var y = 2 * (yield (x + 1));</span><br><span class="line">  var z = yield (y / 3);</span><br><span class="line">  <span class="built_in">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = foo(5);</span><br><span class="line">a.next();  // Object&#123;value:6, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next();  // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next();  // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">var b = foo(5);</span><br><span class="line">b.next();   // &#123; value:6, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(12); // &#123; value:8, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(13); // &#123; value:42, <span class="keyword">done</span>:<span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>next方法不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN；</p></li><li>next方法提供参数，第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y/3的值8。第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，返回x + y + z的结果为5 + 24 + 13 = 42。</li><li><strong>注意</strong>：这个功能有很重要的语法意义。Generator函数<strong>从暂停状态到恢复运行</strong>，它的<strong>上下文状态（context）是不变的</strong>。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，<strong>可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> i = 0; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> reset = yield i;</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123; </span><br><span class="line">      i = -1; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> g = f();</span><br><span class="line">g.next() // &#123; value: 0, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next() // &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next(<span class="literal">true</span>) // &#123; value: 0, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>for…of循环</blockquote><ul><li><code>for…of</code>循环可以<strong>自动遍历</strong>Generator函数时生成的Iterator对象，且此时<strong>不再需要调用next方法</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  <span class="built_in">return</span> 3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> v of foo()) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>yield* [[expression]]</blockquote><ul><li><code>yield* 一个可迭代对象</code>，就相当于把这个可迭代对象的所有迭代值分次 yield 出去。表达式本身的值就是当前可迭代对象迭代完毕（当done为true时）时的返回值。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">gen</span></span>()&#123;</span><br><span class="line">  yield [1, 2];</span><br><span class="line">  yield* [3, 4];</span><br><span class="line">&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">g.next(); // &#123;value: Array[2], <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">g.next(); // &#123;value: 3, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">g.next(); // &#123;value: 4, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">g.next(); // &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><ul><li>async函数可以理解为<strong>Generator函数的语法糖</strong>，使用async内置了<strong>自动执行器</strong>，无需调用next方法进行逐步调用。且其<strong>返回值为Promise</strong>。</li><li>大部分情况async/await都要结合promise一起使用。</li></ul><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><ul><li><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> gen(x)&#123;</span><br><span class="line">  var y = await x + 2;</span><br><span class="line">  var z = await y + 2;</span><br><span class="line">  <span class="built_in">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">gen(1).<span class="keyword">then</span>(result =&gt; console.log(result), error =&gt; console.log(error));</span><br><span class="line">gen(1).<span class="keyword">then</span>(result =&gt; console.log(result)).catch(error =&gt; console.log(error));</span><br></pre></td></tr></table></figure></li><li><p>用三种异步编程方式实现5秒以后，输出hello world：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*回调方式*/</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(callback) &#123;</span><br><span class="line">  setTimeout(() =&gt; callback(<span class="string">'hello world'</span>), 5000);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>((value) =&gt; console.log(value));</span><br><span class="line"></span><br><span class="line">/*Promise方式*/</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="built_in">return</span> resolve(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;, 5000)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>().<span class="keyword">then</span>((value) =&gt; console.log(value));</span><br><span class="line"></span><br><span class="line">/*async方式*/</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> await new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="built_in">return</span> resolve(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;, 5000)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>().<span class="keyword">then</span>((value) =&gt; console.log(value));</span><br></pre></td></tr></table></figure></li></ul><h5 id="await命令"><a href="#await命令" class="headerlink" title="await命令"></a>await命令</h5><ul><li>正常情况下，<strong>await命令后是一个Promise对象</strong>。如果<strong>不是，会被转成一个立即resolve的Promise对象</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*成功情况*/</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> await 123;</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(value =&gt; console.log(value));  // 123</span><br><span class="line"></span><br><span class="line">/*失败情况*/</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> Promise.reject(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().catch(e =&gt; console.error(e));   // error</span><br></pre></td></tr></table></figure></li></ul><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  await new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    throw new Error(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v))</span><br><span class="line">  .catch(e =&gt; console.error(e));  // Error: 出错了</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li><p>await只能用在async函数中，不能用在普通函数中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* 错误处理 */</span><br><span class="line"><span class="keyword">function</span> f(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [1, 2, 3];</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> doc of docs) &#123;</span><br><span class="line">    await db.push(doc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> db; // Uncaught SyntaxError: Unexpected identifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 正确处理(顺序执行) */</span><br><span class="line">async <span class="keyword">function</span> f(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [1, 2, 3];</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> doc of docs) &#123;</span><br><span class="line">    await db.push(doc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> db;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> ary = [];</span><br><span class="line">f(ary);</span><br><span class="line">console.log(ary); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">/* 正确处理(并发执行) */</span><br><span class="line">async <span class="keyword">function</span> f(db) &#123;</span><br><span class="line">  <span class="built_in">let</span> docs = [1, 2, 3];</span><br><span class="line">  <span class="built_in">let</span> promises = docs.map(doc =&gt; db.push(doc));</span><br><span class="line">  db = await Promise.all(promises);</span><br><span class="line">  <span class="built_in">return</span> db;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> ary = [];</span><br><span class="line">f(ary);</span><br><span class="line">console.log(ary); // [1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p>await后面可能存在reject，需要包在try…catch代码块中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await Promise.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; catch(e) &#123;</span><br><span class="line">    console.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> Promise.resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f().<span class="keyword">then</span>(v =&gt; console.log(v));   // 出错了 hello</span><br></pre></td></tr></table></figure></li><li><p>多个异步操作，如果没有继承关系，最好同时触发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line">  <span class="built_in">return</span> [foo, bar];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ES6诞生以前，异步编程的方法，大概有如下四种：&lt;strong&gt;回调函数&lt;/strong&gt;、&lt;strong&gt;事件监听&lt;/strong&gt;、&lt;strong&gt;发布/订阅&lt;/strong&gt;、&lt;strong&gt;Promise对象&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;ES6中，引入了&lt;strong&gt;Generator函数&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;ES7中，&lt;strong&gt;async&lt;/strong&gt;更是将异步编程带入了一个全新的阶段。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Promise" scheme="https://chongtianhong.github.io/tags/Promise/"/>
    
      <category term="Genorator" scheme="https://chongtianhong.github.io/tags/Genorator/"/>
    
      <category term="async" scheme="https://chongtianhong.github.io/tags/async/"/>
    
  </entry>
  
  <entry>
    <title>Node.js中的多进程</title>
    <link href="https://chongtianhong.github.io/2018/03/14/multiprocessing/"/>
    <id>https://chongtianhong.github.io/2018/03/14/multiprocessing/</id>
    <published>2018-03-14T02:32:22.000Z</published>
    <updated>2018-07-22T03:12:32.378Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Node.js 是以<strong>单进程单线程</strong>的模式运行的，并且使用<strong>驱动模式</strong>来<strong>处理并发</strong>，对于多核CPU，如果仅仅使用单进程，其实是很浪费资源的，因此Node.js提供了<strong>cluster模块</strong>和<strong>child_process模块</strong>来创建多个子进程，从而<strong>提高cpu的利用率</strong>。<br>注意：Node.js 是一门单线程、异步、非阻塞语言!<a id="more"></a></li></ul><h4 id="使用cluster模块创建多个子进程"><a href="#使用cluster模块创建多个子进程" class="headerlink" title="使用cluster模块创建多个子进程"></a>使用cluster模块创建多个子进程</h4><ul><li>nodejs提供了cluster集群（支持端口共享的多进程），cluster基于child_process，process二次封装，方便我们使用该功能实现单机nodejs的web集群。</li><li>通过cluster启动工作进程，可以直接实现<strong>端口复用</strong>，因此所有工作进程只需要监听同一个端口，当主进程终止还需要关闭所有的工作进程。</li><li><p>先看以下的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var cluster = require(<span class="string">'cluster'</span>);</span><br><span class="line">var os = require(<span class="string">'os'</span>);</span><br><span class="line">// 获取CPU 的数量</span><br><span class="line">var numCPUs = os.cpus().length;</span><br><span class="line">var workers = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    // 主进程分支</span><br><span class="line">    cluster.on(<span class="string">'death'</span>, <span class="keyword">function</span> (worker) &#123;</span><br><span class="line">    // 当一个工作进程结束时，重启工作进程</span><br><span class="line">        delete workers[worker.pid];</span><br><span class="line">        worker = cluster.fork();</span><br><span class="line">        workers[worker.pid] = worker;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 初始开启与CPU 数量相同的工作进程</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">        var worker = cluster.fork();</span><br><span class="line">        workers[worker.pid] = worker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // 工作进程分支，启动服务器</span><br><span class="line">    var app = require(<span class="string">'./app'</span>);</span><br><span class="line">    app.listen(3000);</span><br><span class="line">&#125;</span><br><span class="line">// 当主进程被终止时，关闭所有工作进程</span><br><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="keyword">for</span> (var pid <span class="keyword">in</span> workers) &#123;</span><br><span class="line">        process.kill(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    process.exit(0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这段代码的核心是<strong>创建与CPU核心个数相同的服务器进程</strong>，以确保<strong>充分利用多核CPU的资源</strong>。</p></li><li>主进程生成若干个工作进程，并监听工作进程结束事件，当工作进程结束时，重新启动一个工作进程，分支进程会自顶向下重新当前程序（也就是在子进程中，如果新开了子进程，也会执行这段代码），并通过分支判断进入工作进程分支，在其中读取模块并启动服务器。</li></ul><h4 id="使用child-process模块创建多个子进程"><a href="#使用child-process模块创建多个子进程" class="headerlink" title="使用child_process模块创建多个子进程"></a>使用child_process模块创建多个子进程</h4><ul><li>方法有下面三种：<ul><li>（1）exec</li><li>（2）spawn</li><li>（3）fork</li></ul></li><li>并且每一个子进程总是带有3个流对象，<code>child_stdin</code>，<code>child_stdout</code>，<code>child_stderr</code>。它们会共享父进程的stdio流。</li><li><p>举一个exec创建子进程的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(<span class="string">'fs'</span>);</span><br><span class="line">const child_process = require(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">   var workerProcess = child_process.exec(<span class="string">'node support.js '</span> + i,</span><br><span class="line">      <span class="keyword">function</span> (error, stdout, stderr) &#123;</span><br><span class="line">         <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            console.log(error.stack);</span><br><span class="line">            console.log(<span class="string">'Error code: '</span>+error.code);</span><br><span class="line">            console.log(<span class="string">'Signal received: '</span>+error.signal);</span><br><span class="line">         &#125;</span><br><span class="line">         console.log(<span class="string">'stdout: '</span> + stdout);</span><br><span class="line">         console.log(<span class="string">'stderr: '</span> + stderr);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      workerProcess.on(<span class="string">'exit'</span>, <span class="keyword">function</span> (code) &#123;</span><br><span class="line">      console.log(<span class="string">'子进程已退出，退出码 '</span>+ code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上述代码的输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子进程已退出，退出码 0</span><br><span class="line">stdout: 进程 1 执行。</span><br><span class="line"></span><br><span class="line">stderr: </span><br><span class="line">子进程已退出，退出码 0</span><br><span class="line">stdout: 进程 0 执行。</span><br><span class="line"></span><br><span class="line">stderr: </span><br><span class="line">子进程已退出，退出码 0</span><br><span class="line">stdout: 进程 2 执行。</span><br><span class="line"></span><br><span class="line">stderr:</span><br></pre></td></tr></table></figure></li></ul><h4 id="cluster和child-process之间的区别"><a href="#cluster和child-process之间的区别" class="headerlink" title="cluster和child_process之间的区别"></a>cluster和child_process之间的区别</h4><ul><li>最大区别在于<strong>cluster允许跨进程端口复用</strong>，给我们的网络服务器带来很大的方便，也就是可以在<strong>同一个服务器端口</strong>，利用cluster<strong>实现多进程</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Node.js 是以&lt;strong&gt;单进程单线程&lt;/strong&gt;的模式运行的，并且使用&lt;strong&gt;驱动模式&lt;/strong&gt;来&lt;strong&gt;处理并发&lt;/strong&gt;，对于多核CPU，如果仅仅使用单进程，其实是很浪费资源的，因此Node.js提供了&lt;strong&gt;cluster模块&lt;/strong&gt;和&lt;strong&gt;child_process模块&lt;/strong&gt;来创建多个子进程，从而&lt;strong&gt;提高cpu的利用率&lt;/strong&gt;。&lt;br&gt;注意：Node.js 是一门单线程、异步、非阻塞语言!
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="多进程" scheme="https://chongtianhong.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="多核" scheme="https://chongtianhong.github.io/tags/%E5%A4%9A%E6%A0%B8/"/>
    
      <category term="并发" scheme="https://chongtianhong.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="cpu" scheme="https://chongtianhong.github.io/tags/cpu/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的循环数组遍历</title>
    <link href="https://chongtianhong.github.io/2018/03/13/array1/"/>
    <id>https://chongtianhong.github.io/2018/03/13/array1/</id>
    <published>2018-03-13T15:25:36.000Z</published>
    <updated>2018-07-23T14:42:38.022Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在 JavaScript 中提供了如下四种循环遍历数组元素的方式：<ul><li><code>for</code>：循环遍历数组元素最简单的方式。</li><li><code>for-in</code>：循环遍历对象的<strong>属性</strong>。</li><li><code>forEach</code>：调用数组的每个元素，并将元素传递给回调函数。</li><li><code>for-of</code>：循环遍历集合对象的<strong>属性值</strong>。<a id="more"></a></li></ul></li></ul><blockquote>for</blockquote><ul><li>这是循环遍历数组元素最简单的方式。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>for-in</blockquote><ul><li><p>for-in 语句以任意顺序（即显示顺序不是可控的）<strong>遍历一个对象的</strong>可枚举<strong>属性</strong>:</p><ul><li>对于<strong>数组</strong>即是<strong>数组下标</strong>，对于<strong>对象</strong>即是<strong>对象的 key 值</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">    console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不推荐</strong>使用 for-in 语句。</p></li><li><p>注意：for-in 遍历返回的对象属性都是<strong>字符串类型</strong>，即使是数组下标，也是字符串 “0”, “1”, “2” 等等。如果使用字符串的 index 去参与某些运算（”2” + 1 == “21”），运算结果可能会不符合预期。例如以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myArray=[1,2,3,4,5];</span><br><span class="line"><span class="keyword">for</span> (var index <span class="keyword">in</span> myArray) &#123; </span><br><span class="line">    console.log(index+1); // 01 11 21 31 41</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有一个缺点是不仅数组本身的元素将被遍历到，用户自己为数组添加的一些属性也会被遍历到，甚至数组原型链上的属性也可能被遍历到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myArray=new Array(1,2,3,4,5);</span><br><span class="line">myArray.name=<span class="string">"hello"</span>;</span><br><span class="line">Array.prototype.method=<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (var index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">    console.log(index); // 0 1 2 3 4 name method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>for-in 设计的目的是用于<strong>遍历包含键值对的对象</strong>，对数组并不是那么友好。 </p></li><li>遍历数组的话还是用es6的for-of循环遍历比较好。</li></ul><blockquote>for-of</blockquote><ul><li><p>for-of 语句为各种 collection 集合对象专门定制的，遍历集合对象的<strong>属性值</strong>，注意和 for-in 的区别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var value of myArray) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>for-of和for-in的区别：</p><ul><li>推荐在循环<strong>对象属性</strong>的时候，使用<code>for…in</code>，在<strong>遍历数组</strong>的时候的时候使用<code>for…of</code>。</li><li><code>for…in</code>循环出的是<code>key</code>，<code>for…of</code>循环出的是<code>value</code>。</li><li>注意，<code>for…of</code>是ES6新引入的特性。修复了ES5引入的<code>for…in</code>的不足。</li><li><code>for…of</code>不能循环普通的对象，需要通过和<code>Object.keys()</code>搭配使用。</li></ul></li></ul><blockquote>forEach</blockquote><ul><li>forEach 方法用于<strong>调用数组的每个元素</strong>，并<strong>将元素传递给回调函数</strong>；</li><li>注意：在回调函数中<strong>无法使用 break 跳出当前循环</strong>，也<strong>无法使用 return 返回值</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(<span class="keyword">function</span> (value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在 JavaScript 中提供了如下四种循环遍历数组元素的方式：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt;：循环遍历数组元素最简单的方式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for-in&lt;/code&gt;：循环遍历对象的&lt;strong&gt;属性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forEach&lt;/code&gt;：调用数组的每个元素，并将元素传递给回调函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for-of&lt;/code&gt;：循环遍历集合对象的&lt;strong&gt;属性值&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Array" scheme="https://chongtianhong.github.io/tags/Array/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS 与 ES6 Modules的区别</title>
    <link href="https://chongtianhong.github.io/2018/03/12/commonjs/"/>
    <id>https://chongtianhong.github.io/2018/03/12/commonjs/</id>
    <published>2018-03-12T06:37:28.000Z</published>
    <updated>2018-07-15T13:27:10.557Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>摘自阮一峰ES6<br><blockquote>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 <strong>CommonJS</strong> 和 <strong>AMD</strong> 两种。前者用于<strong>服务器</strong>，后者用于<strong>浏览器</strong>。<strong>ES6</strong> 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，<strong>成为浏览器和服务器通用的模块解决方案</strong>。<br><strong>ES6</strong> 模块的设计思想是尽量的<strong>静态化</strong>，使得<strong>编译时</strong>就能<strong>确定模块的依赖关系</strong>，以及输入和输出的变量。<strong>CommonJS</strong> 和 <strong>AMD</strong> 模块，都只能在<strong>运行时确定</strong>这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</blockquote></p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS模块</span><br><span class="line"><span class="built_in">let</span> &#123; <span class="built_in">stat</span>, exists, readFile &#125; = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"><span class="built_in">let</span> _fs = require(<span class="string">'fs'</span>);</span><br><span class="line"><span class="built_in">let</span> <span class="built_in">stat</span> = _fs.stat;</span><br><span class="line"><span class="built_in">let</span> exists = _fs.exists;</span><br><span class="line"><span class="built_in">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure></li><li><p>上面代码的实质是<strong>整体加载</strong>fs模块（即加载fs的<strong>所有方法</strong>），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有<strong>运行时</strong>才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p></li></ul><h4 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h4><ul><li><p>ES6 模块不是对象，而是通过<strong>export命令</strong>显式指定输出的代码，再通过<strong>import命令</strong>输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES6模块</span><br><span class="line">import &#123; <span class="built_in">stat</span>, exists, readFile &#125; from <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure></li><li><p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为<strong>“编译时加载”</strong>或者<strong>静态加载</strong>，即 ES6 可以<strong>在编译时就完成模块加载</strong>，效率要比 CommonJS 模块的加载方式高。当然，这也导致了<strong>没法引用 ES6 模块本身</strong>，因为它不是对象。</p></li><li><p>由于 ES6 模块是<strong>编译时加载</strong>，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p></li><li><p>除了静态加载带来的各种好处，ES6 模块还有以下好处：</p><ul><li>不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。<br>不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。</li></ul></li><li><p>ES6 模块的特点：</p><ul><li>静态化，必须在顶部，不能使用条件语句，自动采用严格模式</li><li>treeshaking和编译优化，以及webpack3中的作用域提升</li><li>外部可以拿到实时值，而非缓存值(是引用而不是copy)</li></ul></li><li><p>简单来说</p><ul><li>CommonJS是在内存中的对象，运行时才加载。</li><li>ES6 Modules是编译时就加载的代码。</li></ul></li></ul><h4 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h4><ul><li>讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</li><li>它们有两个重大差异：<ul><li>CommonJS 模块输出的是一个<strong>值的拷贝</strong>，ES6 模块输出的是<strong>值的引用</strong>。</li><li>CommonJS 模块是<strong>运行时</strong>加载，ES6 模块是<strong>编译时</strong>输出接口。</li></ul></li></ul><h4 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h4><ul><li><p>现在有三个模块：<br><blockquote>m1.mjs</blockquote></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> a1 = 1;</span><br></pre></td></tr></table></figure><p><blockquote>m2.mjs</blockquote></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> a2 = 2;</span><br></pre></td></tr></table></figure><p><blockquote>m3.mjs</blockquote></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> a3 = 3;</span><br></pre></td></tr></table></figure></li><li><p>1、基本使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//index.mjs</span><br><span class="line"></span><br><span class="line">import &#123; a1 &#125; from <span class="string">'./m1'</span>;</span><br><span class="line">import &#123; a2 &#125; from <span class="string">'./m2'</span>;</span><br><span class="line">import &#123; a3 &#125; from <span class="string">'./m3'</span>;</span><br><span class="line"></span><br><span class="line">console.log(a1, a2, a3);</span><br></pre></td></tr></table></figure></li><li><p>结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(node:18435) ExperimentalWarning: The ESM module loader is experimental.</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure></li><li><p>2、验证ES6 module的静态特性和接口特性：</p><ul><li>将m1改成</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> a1= 1;</span><br><span class="line">setTimeout(()=&gt;a1=2,500);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//index.mjs</span><br><span class="line">import &#123; a1 &#125; from <span class="string">'./m1'</span>;</span><br><span class="line">import &#123; a2 &#125; from <span class="string">'./m2'</span>;</span><br><span class="line">import &#123; a3 &#125; from <span class="string">'./m3'</span>;</span><br><span class="line"></span><br><span class="line">console.log(a1, a2, a3);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(a1, a2, a3);</span><br><span class="line">&#125;,1000)</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(node:18994) ExperimentalWarning: The ESM module loader is experimental.</span><br><span class="line">1 2 3</span><br><span class="line">2 2 3</span><br></pre></td></tr></table></figure></li><li><p>体现了接口性。</p></li></ul><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><h5 id="ES6-Module和CommonJS模块的区别："><a href="#ES6-Module和CommonJS模块的区别：" class="headerlink" title="ES6 Module和CommonJS模块的区别："></a>ES6 Module和CommonJS模块的区别：</h5><ul><li>CommonJS是对模块的浅拷贝，ES6 Module是对模块的引用。<ul><li>即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const</li></ul></li><li>import的接口是read-only（只读状态），不能修改其变量值。<ul><li>即不能修改其变量的指针指向，但可以改变变量内部指针指向。</li></ul></li><li>可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。<h5 id="ES6-Module和CommonJS模块的共同点："><a href="#ES6-Module和CommonJS模块的共同点：" class="headerlink" title="ES6 Module和CommonJS模块的共同点："></a>ES6 Module和CommonJS模块的共同点：</h5></li><li>CommonJS和ES6 Module都可以对引入的对象进行赋值，即对对象内部属性的值进行改变。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘自阮一峰ES6&lt;br&gt;&lt;blockquote&gt;在 ES6 之前，社区制定了一些模块加载方案，最主要的有 &lt;strong&gt;CommonJS&lt;/strong&gt; 和 &lt;strong&gt;AMD&lt;/strong&gt; 两种。前者用于&lt;strong&gt;服务器&lt;/strong&gt;，后者用于&lt;strong&gt;浏览器&lt;/strong&gt;。&lt;strong&gt;ES6&lt;/strong&gt; 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，&lt;strong&gt;成为浏览器和服务器通用的模块解决方案&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;ES6&lt;/strong&gt; 模块的设计思想是尽量的&lt;strong&gt;静态化&lt;/strong&gt;，使得&lt;strong&gt;编译时&lt;/strong&gt;就能&lt;strong&gt;确定模块的依赖关系&lt;/strong&gt;，以及输入和输出的变量。&lt;strong&gt;CommonJS&lt;/strong&gt; 和 &lt;strong&gt;AMD&lt;/strong&gt; 模块，都只能在&lt;strong&gt;运行时确定&lt;/strong&gt;这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。&lt;/blockquote&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="CommonJS" scheme="https://chongtianhong.github.io/tags/CommonJS/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 对象复制(深浅拷贝)</title>
    <link href="https://chongtianhong.github.io/2018/03/11/objectcopy/"/>
    <id>https://chongtianhong.github.io/2018/03/11/objectcopy/</id>
    <published>2018-03-11T12:31:51.000Z</published>
    <updated>2018-07-15T12:54:46.749Z</updated>
    
    <content type="html"><![CDATA[<ul><li>要弄懂<strong>深浅拷贝</strong>的概念，着实不易。这里举个不恰当例子便于理解：<ul><li>浅拷贝是双胞胎</li><li>深拷贝是单独克隆自己<a id="more"></a></li></ul></li></ul><h4 id="数据类型分类："><a href="#数据类型分类：" class="headerlink" title="数据类型分类："></a>数据类型分类：</h4><p><img src="/images/dataType.png" width="600" alt="数据类型分类" style="border:none"></p><h4 id="指针指向"><a href="#指针指向" class="headerlink" title="指针指向"></a>指针指向</h4><ul><li>栈内存、堆内存、指针指向（如下红圈圈的斜线）。<br><img src="/images/storage.png" width="600" alt="数据类型存放位置" style="border:none"></li></ul><h4 id="赋值、拷贝、引用区别"><a href="#赋值、拷贝、引用区别" class="headerlink" title="赋值、拷贝、引用区别"></a>赋值、拷贝、引用区别</h4><ul><li>赋值指<strong>给一个变量赋予某个值</strong>，包含两种方式，一种是<strong>直接量</strong>，另一种，是<strong>将另一个变量的值传递给这个变量</strong>。拷贝和引用都属于后者。</li><li>引用的目的是<strong>将指针指向<em>相同堆内存</em>中的某一位置</strong>。</li><li><p>拷贝的目的是<strong>改变指针的指向</strong>，并且<strong>内部属性或者元素的值相等</strong>。</p><ul><li>基础数据类型在赋值过程就改变了指针指向，所以通常说，<strong>基础类型的引用只存在只读状态</strong>。</li><li>复杂数据类型的指针指向包含两种：一种是指针指向栈内存，另一种是指针指向堆内存，前者只需赋值即可，可后者没那么容易。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person =  &#123;</span><br><span class="line">    name: <span class="string">'lc'</span>,</span><br><span class="line">    friends: [<span class="string">'xm'</span>,<span class="string">'xm'</span>,<span class="string">'xl'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从这段代码，我们很清楚知道<code>person.name</code>、<code>person.friends</code>中的每个元素的指针指向栈内存，<code>person</code>和<code>person.friends</code>的指针指向堆内存，由此我们可以得出两点：</p><ul><li>拷贝改变复杂数据类型的指针指向，必须是<strong>先改变指向堆内存的指针指向</strong>，如<code>person</code>的指针指向。</li><li>拷贝改变指针指向，可以只改<code>person</code>的指针指向，这类叫做浅拷贝（浅复制）；也可以改变<code>person</code>、<code>person.friends</code>等全部指针指向，这类通常叫做深拷贝（深复制）。</li></ul></li></ul><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ul><li>在上面，我已描叙了浅拷贝和深拷贝，在这里再严谨的总结一下：<ul><li><strong>浅拷贝</strong>只改变复杂数据类型内<strong>部分</strong>的指针指向，也就是<strong>不完全改变</strong>；</li><li><strong>深拷贝彻头彻底地改变所有指针指向</strong>，也就是<strong>完全改变</strong>。</li></ul></li></ul><blockquote>浅拷贝</blockquote><ul><li>以上例代码为例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var shallow_copy = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(var i <span class="keyword">in</span> person) &#123;</span><br><span class="line">    shollow_copy[i] = person[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>或者 es6 的 <code>Object.assign()</code>。</p><blockquote>深拷贝</blockquote><ul><li>实现的方法也是多种，大致上可以分为两类： 一类是json，另一类是递归循环遍历赋值。</li><li>其中最常见的是JQuery中<code>$.extend()</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;要弄懂&lt;strong&gt;深浅拷贝&lt;/strong&gt;的概念，着实不易。这里举个不恰当例子便于理解：&lt;ul&gt;
&lt;li&gt;浅拷贝是双胞胎&lt;/li&gt;
&lt;li&gt;深拷贝是单独克隆自己
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Cookies的封装</title>
    <link href="https://chongtianhong.github.io/2018/03/10/Cookies/"/>
    <id>https://chongtianhong.github.io/2018/03/10/Cookies/</id>
    <published>2018-03-10T11:36:02.000Z</published>
    <updated>2018-07-15T11:48:07.292Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Cookie是一小段文本信息，用户请求页面的时候，在浏览器和服务器之间传递。用户每次访问的时候都会记录cookie，cookie里可以包含用户信息，浏览的历史记录等等；</li><li>Cookie是由服务器端生成，但是它是属于客户端的，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。<a id="more"></a></li></ul><h4 id="Cookie的组成"><a href="#Cookie的组成" class="headerlink" title="Cookie的组成"></a>Cookie的组成</h4><ul><li><p>基本组成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“key=value; expires=date; [path=path; domain=domain; secure]”</span><br><span class="line">  键=值；过期时间； 【可访问路径； 域名； 是否使用安全连接】【可选项】</span><br></pre></td></tr></table></figure></li><li><p>设置Cookie的封装方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> setCookies(key,value,expires,path,domain,secure) &#123;</span><br><span class="line">    var cookies=<span class="string">''</span>;</span><br><span class="line">    cookies = encodeURI(key)+<span class="string">'='</span>+encodeURI(value);</span><br><span class="line">    <span class="keyword">if</span>(expires instanceof Date)&#123;</span><br><span class="line">        cookies+=<span class="string">"; expires="</span>+expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(path)&#123;</span><br><span class="line">        cookies+=<span class="string">"; path="</span>+path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(domain)&#123;</span><br><span class="line">        cookies+=<span class="string">"; domain"</span>+domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(secure)&#123;</span><br><span class="line">        cookies+=<span class="string">"; secure"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    document.cookie=cookies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日期函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> setCookieDate(day) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof day === <span class="string">"number"</span>)&#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    date.setDate(date.getDate()+day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这个cookie会在当前日期的七天之后过期</span><br><span class="line">//设置的cookie: Kinds : animals</span><br><span class="line">setCookies(<span class="string">'Kinds'</span>,<span class="string">'animals'</span>,setCookieDate(7));</span><br></pre></td></tr></table></figure></li><li><p>删除实例：将当前Cookie的过期日期参数设置为负值就可以删除这个Cookie </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setCookies(‘Kinds’,’animals’,setCookieDate(-1));</span><br></pre></td></tr></table></figure></li><li><p>获取某个值的封装方法（value）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getCookies(value) &#123;</span><br><span class="line">    var cookie = document.cookie;</span><br><span class="line">    var start = cookie.indexOf(<span class="string">'='</span>,cookie.indexOf(value));</span><br><span class="line">    var end = cookie.indexOf(<span class="string">';'</span>,cookie.indexOf(value));</span><br><span class="line">    <span class="keyword">if</span>(end === -1)&#123;</span><br><span class="line">        <span class="built_in">return</span> decodeURI(cookie.substring(start+1,cookie.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> decodeURI(cookie.substring(start+1,end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Cookie是一小段文本信息，用户请求页面的时候，在浏览器和服务器之间传递。用户每次访问的时候都会记录cookie，cookie里可以包含用户信息，浏览的历史记录等等；&lt;/li&gt;
&lt;li&gt;Cookie是由服务器端生成，但是它是属于客户端的，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="Cookie" scheme="https://chongtianhong.github.io/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>DNS学习笔记</title>
    <link href="https://chongtianhong.github.io/2018/03/09/dns/"/>
    <id>https://chongtianhong.github.io/2018/03/09/dns/</id>
    <published>2018-03-08T16:23:15.000Z</published>
    <updated>2018-03-09T07:22:04.965Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/06/dns.html</a></p><h3 id="DNS的定义"><a href="#DNS的定义" class="headerlink" title="DNS的定义"></a>DNS的定义</h3><ul><li>域名系统（Domain Name System）是一种带层级的分布式系统，能进行域名到IP地址转换的目录服务，DNS协议运行在UDP之上，使用端口53。</li><li>域名系统的组成：<ol><li><strong>域名服务器</strong>（服务端），提供域名解析服务的软件，一般监听UDP，TCP的53端口。</li><li><strong>域名解析器</strong>（客户端），访问域名服务器的客户端。负责解析从域名服务器获取的响应，向调用它的应用响应返回IP地址或者别名等信息。<a id="more"></a></li></ol></li><li>域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，域名虽然便于人们记忆，但<strong>机器之间只能互相认识IP地址</strong>，它们之间的<strong>转换工作称为域名解析</strong>，域名解析<strong>需要由专门的域名解析服务器</strong>来完成，<strong>DNS就是进行域名解析的服务器</strong>。<ul><li>举例来说，如果我们要访问域名<code>math.stackexchange.com</code>，首先要通过DNS查出它的IP地址是<code>151.101.129.69</code>。</li></ul></li><li>DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。DNS是因特网的一项核心服务,它作为可以<strong>将域名和IP地址相互映射</strong>的一个<strong>分布式数据库</strong>。</li><li>域名的最终指向是IP地址。简单的说DNS的作用就是，将<strong>域名翻译为IP地址</strong>的过程，就是DNS解析。<ul><li>当用户在应用程序中输入 DNS 名称时，DNS 服务可以将此名称解析为与之相关的其他信息，如 IP 地址。因为，我们在上网时输入的网址，是通过<strong>域名解析系统</strong>解析找到了相对应的<strong>IP地址</strong>，这样才能上网。</li></ul></li></ul><h3 id="DNS服务器的分类"><a href="#DNS服务器的分类" class="headerlink" title="DNS服务器的分类"></a>DNS服务器的分类</h3><ul><li>DNS采用分布式设计方案，DNS服务器分为四类：<br>• <strong>根域名</strong>DNS服务器：最上层权威域名服务器，负责对<code>.com</code>,<code>.cn</code>,<code>.org</code> 等顶级域名的向下授权。<br>• <strong>顶级域名</strong>DNS服务器。这些服务器负责<strong>通用顶级域名</strong>，如<code>.com</code>，<code>.org</code>，<code>.net</code>，<code>.edu</code>和<code>.gov</code>以及<strong>国家的顶级域名</strong>，如<code>.uk</code>，<code>.fr</code>，<code>.ca</code>，<code>jp</code>。<br>• <strong>权威</strong>DNS服务器。这些服务器记录了主机名到IP地址的映射关系。<br>• <strong>本地</strong>DNS服务器（local DNS server）。</li></ul><h3 id="DNS查询方式"><a href="#DNS查询方式" class="headerlink" title="DNS查询方式"></a>DNS查询方式</h3><ul><li>DNS查询有两种方式：<br>• 递归查询：依次向根域名服务器，顶级域名服务器，二级域名服务器，获取DNS的解析条目。<br>• 迭代查询：域名服务器并不直接代替解析器进行依次查询，而是返回一个参考列表，这个列表指出了解析DNS请求的服务器，由解析器向该列表的服务器进行DNS查询。</li><li>从<strong>请求主机到本地DNS服务器的查询</strong>是<strong>递归</strong>的，其余的查询是迭代的。</li><li><strong>迭代查询方式</strong>与递归查询方式相比<strong>响应速度快</strong>。</li><li>DNS广泛的使用了DNS缓存，类似于HTTP缓存服务器。使用本地存储器作为DNS缓存服务器，每当本地服务器从某个DNS服务器接收到一个回答，它能够缓存包含在该回答中的任何信息。</li></ul><h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><ul><li>虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。</li><li>首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。<br><img src="/images/dns.jpg" width="400" alt="dns" style="border:none"></li><li>DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。</li></ul><h4 id="域名的层级"><a href="#域名的层级" class="headerlink" title="域名的层级"></a>域名的层级</h4><ul><li><p>域名的层级结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line"><span class="comment"># 即</span></span><br><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure></li><li><p>例如：<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名.root对于所有域名都是一样的，所以<strong>平时是省略的</strong>。</p></li><li>根域名的下一级，叫做”顶级域名”（<code>top-level domain</code>，缩写为TLD），比如<code>.com</code>、<code>.net</code>；</li><li>“顶级域名”的下一级叫做”次级域名”（<code>second-level domain</code>，缩写为SLD），比如<code>www.example.com</code>里面的.example，这一级域名是用户可以注册的；</li><li>“次级域名”的下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</li></ul><h4 id="分级查询"><a href="#分级查询" class="headerlink" title="分级查询"></a>分级查询</h4><ul><li>DNS服务器根据域名的层级，进行分级查询，最终查询到域名的IP地址。</li><li>需要明确的是，每一级域名都有自己的<strong>NS（域名服务器）记录</strong>，NS记录<strong>指向该级域名的域名服务器</strong>。这些服务器<strong>知道下一级域名的各种记录</strong>。该记录只能设置为域名，不能设置为IP地址。</li><li>所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下： </li></ul><ol><li>“根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。</li><li>从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址）。</li><li>从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址）。</li><li>从”次级域名服务器”查出”主机名”的IP地址。</li></ol><h4 id="分级查询的实例"><a href="#分级查询的实例" class="headerlink" title="分级查询的实例"></a>分级查询的实例</h4><ul><li>本次实例以<code>math.stackexchange.com</code>为例。</li></ul><h5 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h5><ul><li>根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问<code>math.stackexchange.com</code>的顶级域名服务器<code>com.</code>的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。</li><li>得到<code>.com</code>顶级域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。</li></ul><h5 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h5><ul><li>DNS服务器向第一阶段得到的顶级域名服务器发出查询请求，询问<code>math.stackexchange.com</code>的次级域名<code>stackexchange.com</code>的NS记录。</li><li>结果显示<code>stackexchange.com</code>有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。</li></ul><h5 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h5><ul><li>DNS服务器向第二阶段得到的四台NS服务器查询<code>math.stackexchange.com</code>的主机名。</li><li>结果显示，<code>math.stackexchange.com</code>有4条A记录，即<strong>这四个IP地址都可以访问到网站</strong>。并且还能显示，最先返回结果的NS服务器是<code>ns-463.awsdns-57.com</code>，IP地址为<code>205.251.193.207</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/06/dns.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2016/06/dns.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;DNS的定义&quot;&gt;&lt;a href=&quot;#DNS的定义&quot; class=&quot;headerlink&quot; title=&quot;DNS的定义&quot;&gt;&lt;/a&gt;DNS的定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;域名系统（Domain Name System）是一种带层级的分布式系统，能进行域名到IP地址转换的目录服务，DNS协议运行在UDP之上，使用端口53。&lt;/li&gt;
&lt;li&gt;域名系统的组成：&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;域名服务器&lt;/strong&gt;（服务端），提供域名解析服务的软件，一般监听UDP，TCP的53端口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;域名解析器&lt;/strong&gt;（客户端），访问域名服务器的客户端。负责解析从域名服务器获取的响应，向调用它的应用响应返回IP地址或者别名等信息。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="DNS" scheme="https://chongtianhong.github.io/tags/DNS/"/>
    
  </entry>
  
</feed>
