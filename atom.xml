<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-08-17T14:58:09.644Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise 的链式调用与中止</title>
    <link href="https://chongtianhong.github.io/2018/05/14/promiseChain/"/>
    <id>https://chongtianhong.github.io/2018/05/14/promiseChain/</id>
    <published>2018-05-14T07:04:43.000Z</published>
    <updated>2018-08-17T14:58:09.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文主要讲的是如何<strong>实现 Promise 的链式调用</strong>，也就是<code>promise().then().then().catch()</code>的形式，然后讨论如何<strong>在某一个 then() 里面中止 Promise</strong>。<a id="more"></a></li><li>在程序中，只要<strong>返回了一个 promise 对象</strong>，只要<strong>该 promise 对象不是 Rejected 或 Fulfilled 状态，then 方法就会继续调用</strong>。利用这个特性，可以<strong>处理多个异步逻辑</strong>。</li><li>但有时候某个 then 方法的执行结果可能会决定是否需要执行下一个 then，这个时候就需中止 promise，主要思想就是<strong>使用 reject 来中止 promise 的 then 继续执行</strong>。</li></ul><h4 id="回顾Promise知识点"><a href="#回顾Promise知识点" class="headerlink" title="回顾Promise知识点"></a>回顾Promise知识点</h4><ul><li><p><strong>Promise</strong>其实很简单，就<strong>是一个处理异步的方法</strong>。一般可以通过 new 方法来调用 Promise 的构造器实例化一个 promise 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步处理</span><br><span class="line">    // 处理结束后，调用 resolve 或 reject</span><br><span class="line">    //      成功时就调用 resolve</span><br><span class="line">    //      失败时就调用 reject</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>用<code>new Promise</code>实例化的 promise 对象有以下三个状态：</p><ul><li>“has-resolution” - <strong>Fulfilled</strong>。resolve(成功)时，此时会调用 onFulfilled;</li><li>“has-rejection” - <strong>Rejected</strong>。reject(失败)时，此时会调用 onRejected;</li><li>“unresolved” - <strong>Pending</strong>。既不是resolve也不是reject的状态，也就是promise对象刚被创建后的初始化状态等。</li></ul></li><li>状态变化只能有两种，只能<strong>从Pending变成Fulfilled</strong>或<strong>从Pending变成Rejected</strong>。<strong>状态一旦发生变化，则不会再改变</strong>。<br><img src="/images/promiseProcess.png" alt="promise的状态变化示意图" width="600" style="border:none"></li></ul><h4 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h4><ul><li><code>then()</code>方法的作用是<strong>为Promise实例添加解决（fulfillment）和拒绝（rejection）状态的回调函数</strong>。</li><li><code>then()</code>方法会<strong>返回一个新的Promise实例</strong>，所以<strong><code>then()</code>方法后面可以继续跟另一个<code>then()</code>方法进行链式调用</strong>。</li><li><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// promise start</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">        resolve(<span class="string">'start'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p1</span><br><span class="line"><span class="keyword">function</span> p1(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p2</span><br><span class="line"><span class="keyword">function</span> p2(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((reject)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        reject(2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p3</span><br><span class="line"><span class="keyword">function</span> p3(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        resolve(3);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p4</span><br><span class="line"><span class="keyword">function</span> p4(ex)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        resolve(4);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(p1)</span><br><span class="line">    .<span class="keyword">then</span>(p2)</span><br><span class="line">    .<span class="keyword">then</span>(p3)</span><br><span class="line">    .catch(p4)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // end</span><br><span class="line">        console.log(<span class="string">'result of p4: '</span>, data);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的代码最终会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result of start:  start</span><br><span class="line">result of p1:  1</span><br><span class="line">ex:  2</span><br><span class="line">result of p4:  4</span><br></pre></td></tr></table></figure></li><li><p>可以看到，代码的执行逻辑是<code>promise start –&gt; promise p1 –&gt; promise p3 –&gt; promise p4 –&gt; end</code>。所以可总结出以下几点：</p><ul><li>promise 的 <strong>then 方法里面</strong>可以<strong>继续返回一个新的 promise 对象</strong>;</li><li>下一个 <strong>then 方法的参数</strong>是<strong>上一个 promise 对象的 resolve 参数</strong>;</li><li><strong>catch 方法的参数</strong>是其<strong>之前某个 promise 对象的 rejecte 参数</strong>;</li><li>一旦某个 then 方法里面的 <strong>promise 状态改变为了 rejected</strong>，则promise 方法连会<strong>跳过后面的 then 直接执行 catch</strong>;</li><li><strong>catch 方法</strong>里面依旧<strong>可以返回一个新的 promise 对象</strong>。</li></ul></li></ul><h4 id="如何中指promise的链式调用"><a href="#如何中指promise的链式调用" class="headerlink" title="如何中指promise的链式调用"></a>如何中指promise的链式调用</h4><ul><li>通过上面的例子，我们可以知道<strong> promise 的状态改变为 rejected 后，promise 就会跳过后面的 then 方法</strong>。</li><li>也就是说，当<strong>某个 then 里面发生异常后</strong>，就会<strong>跳过 then 方法</strong>，<strong>直接执行 catch</strong>。</li><li><p>所以，当在构造的 promise 方法链中，如果<strong>在某个 then 后面，不需要再执行 then 方法了，就可以把它当作一个异常来处理</strong>，返回一个异常信息给 catch，其参数可自定义，比如该异常的参数信息为 { notRealPromiseException: true}，然后在 catch 里面判断一下 notRealPromiseException 是否为 true，如果为 true，就说明不是程序出现异常，而是在正常逻辑里面中止 then 方法的执行。代码示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise start</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(1); // p1</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p1</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.reject(&#123;</span><br><span class="line">            notRealPromiseException: <span class="literal">true</span>,</span><br><span class="line">        &#125;); // p2</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p2</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(3); // p3</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(ex =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        <span class="keyword">if</span> (ex.notRealPromiseException) &#123;</span><br><span class="line">            // 一切正常，只是通过 catch 方法来中止 promise chain</span><br><span class="line">            // 也就是中止 promise p2 的执行</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // 真正发生异常</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样的做法可能不符合<code>catch</code>的语义。不过从某种意义上来说，promise 方法链没有继续执行，也可以算是一种“异常”。</p></li></ul><h4 id="Promise-all-与-Promise-race"><a href="#Promise-all-与-Promise-race" class="headerlink" title="Promise.all 与 Promise.race"></a>Promise.all 与 Promise.race</h4><ul><li>其实 promise 方法链更好用的一点是，当<strong>下一个操作依赖于上一个操作的结果</strong>的时候，可以很方便地<strong>通过 then 方法的参数来传递数据</strong>。</li><li>前面也提到过，<strong>下一个 then 方法的参数就是上一个 then 方法里面 resolve 的参数</strong>，所以当然就可以<strong>把上一个 then 方法的执行结果作为参数传递给下一个 then 方法</strong>。</li><li><p>还有些时候，可能 then 方法的执行顺序也没有太多要求，只需要 promise 方法链中的两个或多个 promise 全部都执行正确。这时，如果依旧一个一个去写 then 可能就比较麻烦，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p2</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p3</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在<strong>只需要<code>p1</code>、<code>p2</code>、<code>p3</code>这三个 promise 都执行</strong>，并且 <strong>promise 最终状态都是 Fulfilled</strong>，那么如果还是使用链式调用，这时这样调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p1()</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p2();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p3();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>代码貌似就不那么精炼了。这个时候就有了 <code>Promise.all</code> 这个方法。</p></li><li><code>Promise.all</code> 接收一个<strong>promise对象的数组</strong>作为参数，当这个数组里的所有 promise 对象<strong>全部变为 resolve</strong> 或 <strong>reject 状态</strong>的时候，它才会去调用 then 方法。</li><li><p>于是，调用这几个 promise 的代码就可以这样写了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([p1, p2, p3]).<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;).catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>对于 <code>Promise.race</code>，其<strong>参数</strong>也跟 <code>Promise.all</code> 一样<strong>*是一个数组</strong>。只是<strong>数组中的任何一个 promise 对象如果变为 resolve 或者reject 的话，该函数就会返回</strong>，并<strong>使用这个 promise 对象的值进行 resolve 或者 reject</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本文主要讲的是如何&lt;strong&gt;实现 Promise 的链式调用&lt;/strong&gt;，也就是&lt;code&gt;promise().then().then().catch()&lt;/code&gt;的形式，然后讨论如何&lt;strong&gt;在某一个 then() 里面中止 Promise&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Promise" scheme="https://chongtianhong.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Ajax中返回数据的格式和处理方法分析</title>
    <link href="https://chongtianhong.github.io/2018/05/13/ajaxDataType/"/>
    <id>https://chongtianhong.github.io/2018/05/13/ajaxDataType/</id>
    <published>2018-05-13T05:51:23.000Z</published>
    <updated>2018-08-18T12:35:57.196Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Ajax中常见的<strong>返回数据的格式</strong>有三种：分别为<strong>文本</strong>，<strong>XML</strong>和<strong>JSON</strong>。<a id="more"></a></li></ul><h4 id="Text-HTML格式"><a href="#Text-HTML格式" class="headerlink" title="Text/HTML格式"></a>Text/HTML格式</h4><ul><li>通过Ajax对象的<code>responseText</code>属性就可以获取到返回的文本信息。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxText(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(oAjax.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="XML格式"><a href="#XML格式" class="headerlink" title="XML格式"></a>XML格式</h4><ul><li>通过Ajax对象的<code>responseXML</code>属性就可以获取到返回的<strong>XML DOM</strong>对象。</li><li><p>解析<strong>XML DOM</strong>的数据就类似于HTML DOM 编程. 比如<strong>通过TagName获取标签对象</strong>(数组形式)，再从该数组中获取需要的标签对象，再从标签对象中获取文本值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(XML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param tagName  要获取值的标签名</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxXML(url, jsonData, tagName, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   //拼 装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var oXml =  oAjax.responseXML; //返 回的是一个XML DOM对象</span><br><span class="line">            var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">            var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(tagValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>XML文件具有的几大特点：</p><ul><li>标签没有预定义，开发者根据自己的需求发明标签</li><li>结构清晰，具有自我描述性。从XML文档就可以看出数据的内容</li><li>都是双标签</li><li>和HTML相似，同样也具有树结构</li></ul></li></ul><h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><ul><li>由于JSON格式相比XML更小，传输更快，所以现在Ajax返回json数据格式的情况更多。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)，但是返回的是Json类型的文本数据</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据,利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxJson(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>); // 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var json = JSON.parse(oAjax.responseText);// 把传回来的字符串解析成json对象</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三种格式的函数封装"><a href="#三种格式的函数封装" class="headerlink" title="三种格式的函数封装"></a>三种格式的函数封装</h4><ul><li>为了方便使用，可以把三个函数合并，合并后的函数如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @<span class="keyword">function</span> 利用ajax动态交换数据</span><br><span class="line"> * @param url   要提交请求的页面</span><br><span class="line"> * @param jsonData  要提交的数据,利用Json传递</span><br><span class="line"> * @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line"> * @param <span class="built_in">type</span>    接受的数据类型,text/xml/json</span><br><span class="line"> * @param tagName <span class="built_in">type</span> = xml 的时候这个参数设置为要获取的文本的标签名</span><br><span class="line"> * @<span class="built_in">return</span> 无</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> ajax(url,jsonData,getMsg,<span class="built_in">type</span>,tagName)&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'text'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(oAjax.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'json'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var json = JSON.parse(oAjax.responseText); // 把传回来的字符串解析成json对象</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'xml'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var oXml =  oAjax.responseXML; // 返回的是一个XML DOM对象</span><br><span class="line">                var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">                var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(tagValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Ajax中常见的&lt;strong&gt;返回数据的格式&lt;/strong&gt;有三种：分别为&lt;strong&gt;文本&lt;/strong&gt;，&lt;strong&gt;XML&lt;/strong&gt;和&lt;strong&gt;JSON&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Ajax" scheme="https://chongtianhong.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>浅谈arguments与arguments的妙用</title>
    <link href="https://chongtianhong.github.io/2018/05/12/arguments/"/>
    <id>https://chongtianhong.github.io/2018/05/12/arguments/</id>
    <published>2018-05-12T12:41:53.000Z</published>
    <updated>2018-08-18T12:38:49.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>每个函数都有一个<strong>arguments属性</strong>，表示函数的<strong>实参集合</strong>，这里的实参是重点，就是<strong>执行函数时实际传入的参数的集合</strong>。<a id="more"></a></li><li><strong>arguments</strong>不是数组而是一个<strong>对象</strong>，但它和数组很相似，所以通常称为<strong>类数组对象</strong>，以后看到类数组其实就表示<strong>arguments</strong>。</li><li><p><strong>arguments有length属性</strong>，表示函数实参个数，可以用<code>arguments[index]</code>显式调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(var i=0; i&lt; arguments.length; i++)&#123;</span><br><span class="line">        console.log(arguments[i]);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">"a"</span>, 17, [1, 2, 3], &#123;name:<span class="string">"javascript"</span>, <span class="built_in">type</span>:<span class="string">"language"</span>&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">a</span><br><span class="line">17</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&#123;name: <span class="string">"javascript"</span>, <span class="built_in">type</span>: <span class="string">"language"</span>&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><strong>arguments</strong>还有一个叫做<code>callee</code>的属性，这个属性是表示的是<strong>当前函数的一个引用</strong>，简单点说，这个属性里面存储的我们调用的这个函数的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showcallee</span></span>() &#123;</span><br><span class="line">    var a = <span class="string">'这里是代码'</span>;</span><br><span class="line">    var b = <span class="string">'这是另一段代码'</span>;</span><br><span class="line">    var c = a + b;</span><br><span class="line"></span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">showcallee();</span><br><span class="line">// arguments.callee将完整地把这个函数的所有代码返回。</span><br></pre></td></tr></table></figure></li></ul><h4 id="arguments的妙用"><a href="#arguments的妙用" class="headerlink" title="arguments的妙用"></a>arguments的妙用</h4><h5 id="利用arguments实现方法的重载"><a href="#利用arguments实现方法的重载" class="headerlink" title="利用arguments实现方法的重载"></a>利用arguments实现方法的重载</h5><ul><li><p>由于<strong>Javascript</strong>是一种<strong>弱类型</strong>的语言，<strong>没有重载机制</strong>，当我们重写函数时，会将原来的函数直接覆盖，这里我们能<strong>利用arguments</strong>，来<strong>判断传入的实参类型与数量进行不同的操作</strong>，然后<strong>返回不同的数值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">doAdd</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(arguments.length == 1) &#123;</span><br><span class="line">        alert(arguments[0] + 5);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arguments.length == 2) &#123;</span><br><span class="line">        alert(arguments[0] + arguments[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(10);//输出 <span class="string">"15"</span></span><br><span class="line">doAdd(40, 20);//输出 <span class="string">"60"</span></span><br></pre></td></tr></table></figure></li><li><p>当只有一个参数时，<code>doAdd()</code>函数给参数加 5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，<code>doAdd(10)</code>输出的是 “15”，而<code>doAdd(40, 20)</code>输出的是 “60”。</p></li></ul><h5 id="利用arguments-callee实现递归"><a href="#利用arguments-callee实现递归" class="headerlink" title="利用arguments.callee实现递归"></a>利用arguments.callee实现递归</h5><ul><li><p>用之前的方法来实现一个<strong>计算阶乘</strong>的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * factorial(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是当这个函数变成了一个匿名函数时，我们就可以利用<code>callee</code>来递归这个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * arguments.callee(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：在<strong>严格模式</strong>中<code>arguments.callee</code>这个属性被<strong>禁止使用</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个函数都有一个&lt;strong&gt;arguments属性&lt;/strong&gt;，表示函数的&lt;strong&gt;实参集合&lt;/strong&gt;，这里的实参是重点，就是&lt;strong&gt;执行函数时实际传入的参数的集合&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="arguments" scheme="https://chongtianhong.github.io/tags/arguments/"/>
    
  </entry>
  
  <entry>
    <title>for循环、forEach、map、filter区别及效率分析</title>
    <link href="https://chongtianhong.github.io/2018/05/11/arrayMethodsComparation/"/>
    <id>https://chongtianhong.github.io/2018/05/11/arrayMethodsComparation/</id>
    <published>2018-05-11T11:55:57.000Z</published>
    <updated>2018-08-18T14:22:25.708Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>遍历数组</strong>最常用到的for循环，是最为熟知的一种方法，在ES5中定义了一些新的遍历方法，更加适用于函数式编程。</li><li>本文对各种数组遍历方法的区别和效率进行分析记录。<a id="more"></a></li><li><p>首先，写入以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var testData = []; // 数组初始化</span><br><span class="line">var x = 9999;</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; x; i++)&#123;</span><br><span class="line">    testData[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在每个遍历开始前和结束后取时间戳的差值，每个测试10次取平均值查看结果。<strong>以下测试结果基于Google浏览器</strong>。</p></li></ul><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><ul><li><p>对于普通的for循环来说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; testData.length; i++)&#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是7.3ms。</p></li><li><p>重新对for循环进行优化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0, len = testData.length; i &lt; len; i++)&#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是2.7ms。</p></li><li>但是当x = 99999，到达10^5级时，遍历时间分别是7ms和7.1ms，二者几乎没有差别；当 x = 999999时，遍历时间分别是，14.1ms和14.6ms，前者循环耗时比后者要少，即<strong>遍历数据从10^5级别开始，普通for循环相比优化的for循环效率更高</strong>。</li></ul><h5 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h5><ul><li><p>当使用forEach方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testData.forEach(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是2.1ms，x = 99999时，取值8.9ms，x = 999999时，取值39ms，由此可见，<strong>在10^4级别及以下forEach的效率占有绝对优势</strong>，但从10^5级别开始就走下坡了了。然而用<strong>火狐</strong>测过以后，结果却<strong>截然不同</strong>（见页底）。</p></li></ul><h5 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h5><ul><li><p>当使用map方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.map(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>传递给map()函数的调用方式和传递给forEach()函数的调用方式一样，但传递给map()函数应该有返回值。在<strong>Google浏览器</strong>环境下，<strong>耗时是forEach方法的基础上相应增加的</strong>。</p></li></ul><h5 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h5><ul><li><p>当使用filter方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.filter(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>filter()方法返回的数组元素是调用的数组的一个子集，传递的函数用来进行逻辑判定的，该函数返回true或false，同样的的式子，在<strong>Google浏览器</strong>环境下，<strong>耗时相比较是map方法的40%左右</strong>。</p></li></ul><h5 id="不同浏览器的结果对比"><a href="#不同浏览器的结果对比" class="headerlink" title="不同浏览器的结果对比"></a>不同浏览器的结果对比</h5><ul><li>Google环境下的测试结果：<br><img src="/images/Google.jpg" alt="Google环境下的测试结果" width="600" style="border:none"></li><li>Firefox环境下的测试结果：<br><img src="/images/Firefox.jpg" alt="Firefox环境下的测试结果" width="600" style="border:none"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;最常用到的for循环，是最为熟知的一种方法，在ES5中定义了一些新的遍历方法，更加适用于函数式编程。&lt;/li&gt;
&lt;li&gt;本文对各种数组遍历方法的区别和效率进行分析记录。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Array" scheme="https://chongtianhong.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>30个你“不可能全部会做”的JavaScript题目及解析</title>
    <link href="https://chongtianhong.github.io/2018/05/10/30JSproblems/"/>
    <id>https://chongtianhong.github.io/2018/05/10/30JSproblems/</id>
    <published>2018-05-10T06:32:18.000Z</published>
    <updated>2018-08-16T14:40:07.486Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文记录了30个<code>你“不可能全部会做”的JavaScript题目</code>，并对各个答案进行分析。<a id="more"></a></li></ul><blockquote>题目1</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line"></span><br><span class="line">　　B.[1,2,3]</span><br><span class="line"></span><br><span class="line">　　C.[0,1,2]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">map对数组的每个元素调用定义的回调函数并返回包含结果的数组。</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)对于数组中每个元素调用paresInt。</span><br><span class="line">map中回调函数的语法：<span class="keyword">function</span> callbackfn(value, index, array1)，可使用最多三个参数来声明回调函数。第一参数value，数组元素的值；第二个参数index，数组元素的数组所以；array1，包含该元素的数组对象。</span><br><span class="line">map在作用parseInt函数时，其实传入了元素的值(作为需要转化为十进制的字符串)，以及所对应的索引(作为转化的基数)。</span><br><span class="line">因此，题目等同于[parseInt(1,0), parseInt(2,1), parseInt(3,2)]</span><br><span class="line">最终返回[1, NaN, NaN]</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目2</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[typeof null, null instanceof Object]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"object"</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　B.[null,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="string">"object"</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">typeof用以获取一个变量或者表达式的类型。null是个特殊的Object类型的值 ，表示空引用的意思。</span><br><span class="line">instanceof 表示某个变量是否是某个对象的实例。</span><br><span class="line">typeof null ==== <span class="string">'object'</span></span><br><span class="line">null instanceof Object === <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>题目3</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[3,2,1].reduce(Math.pow),[].reduce(Math.pow)]</span><br><span class="line"></span><br><span class="line">　　A.报错</span><br><span class="line"></span><br><span class="line">　　B.[9,0]</span><br><span class="line"></span><br><span class="line">　　C.[9,NaN]</span><br><span class="line"></span><br><span class="line">　　D.[9,undefined]</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。其效果就是：</span><br><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br><span class="line">pow() 方法可返回 x 的 y 次幂的值。[3,2,1].reduce(Math.pow);等同于：</span><br><span class="line"><span class="keyword">function</span> testFuc(x,y)&#123;</span><br><span class="line">    console.info(x +<span class="string">" : "</span>+y);</span><br><span class="line">    <span class="built_in">return</span> Math.pow(x,y);</span><br><span class="line">&#125;</span><br><span class="line">console.info([3,2,1].reduce(testFuc));</span><br><span class="line">3 : 2  =&gt; Math.pow(3,2) == 9</span><br><span class="line">9 : 1  =&gt; Math.pow(9,1) == 9</span><br><span class="line">9 ==&gt; 最终结果</span><br><span class="line"></span><br><span class="line">但是要注意：Array的reduce()不能作用在空数组上，会报 Uncaught TypeError: Reduce of empty array with no initial value 错误。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目4</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var val = <span class="string">'value'</span>;</span><br><span class="line">console.info(<span class="string">'Value id '</span> + (val === <span class="string">'value'</span>)?<span class="string">'Something'</span>:<span class="string">'Nothing'</span>);</span><br><span class="line"></span><br><span class="line">　　A.Something</span><br><span class="line"></span><br><span class="line">　　B.Nothing</span><br><span class="line"></span><br><span class="line">　　C.NaN</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">先执行字符串拼接，再执行三元表达式判断</span><br><span class="line"><span class="string">'Value id '</span> + <span class="literal">true</span> 结果为 <span class="string">'Value id true'</span></span><br><span class="line">字符串不为空，因此为<span class="literal">true</span>，所以返回<span class="string">'Something'</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>题目5</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">'World'</span>;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　<span class="keyword">if</span>(typeof name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">　　　　var name = <span class="string">"Jack"</span>;</span><br><span class="line">　　　　console.info(<span class="string">'Goodbye '</span>+ name);</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Hello '</span> + name);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">　　A.Goodbye Jack</span><br><span class="line"></span><br><span class="line">　　B.Hello Jack</span><br><span class="line"></span><br><span class="line">　　C.Goodbye undefined</span><br><span class="line"></span><br><span class="line">　　D.Hello undefined</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">判断语句被包裹在立即调用函数里，函数中声明了一个局部变量name，变量在函数内部进行变量提升，在进行判断时，name已经声明但尚未初始化，因此，进入了<span class="keyword">if</span>(<span class="literal">true</span>)的语句块中，name被初始化为<span class="string">"Jack"</span>，最终输出Goodbye Jack。</span><br><span class="line">与C系语言不同的是，JavaScript是函数级作用域(<span class="keyword">function</span>-level scope)，只有函数才会创建新的作用域。 </span><br><span class="line">。在<span class="keyword">if</span>语句块中，声明新的变量，这些变量会影响到外部作用域。</span><br><span class="line">如：</span><br><span class="line">var x = 1; </span><br><span class="line">console.log(x); // 1 </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">var x = 2; </span><br><span class="line">console.log(x); //2 </span><br><span class="line">&#125; </span><br><span class="line">console.log(x);// 2 </span><br><span class="line">若将题目改成：</span><br><span class="line">var name = <span class="string">'World'</span>;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　<span class="keyword">if</span>(typeof name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Goodbye '</span>+ name);</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Hello '</span> + name);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">将得到Hello World的结果</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目6</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var END = 9007199254740992;</span><br><span class="line">var START = END -100;</span><br><span class="line">var count = 0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var i = START ; i &lt;= END ; i++)&#123;</span><br><span class="line">　　count ++;</span><br><span class="line">&#125;</span><br><span class="line">console.info(count);</span><br><span class="line"></span><br><span class="line">　　A.0</span><br><span class="line"></span><br><span class="line">　　B.100</span><br><span class="line"></span><br><span class="line">　　C.101</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">10进制的整数的精确表达范围是-9007199254740992(-2^53)到9007199254740992(2^53)</span><br><span class="line">END = 9007199254740992 ,START = 9007199254740892目的是计算的END和START之间的差。但是2的53次方计算出的结果由于精度问题使得i++失效。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目7</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0,1,2];</span><br><span class="line">arr[10] = 10;</span><br><span class="line">arr.filter(<span class="keyword">function</span>(x)&#123;<span class="built_in">return</span> x === undefined&#125;);</span><br><span class="line"></span><br><span class="line">　　A.[undefined x 7]</span><br><span class="line"></span><br><span class="line">　　B.[0,1,2,10]</span><br><span class="line"></span><br><span class="line">　　C.[]</span><br><span class="line"></span><br><span class="line">　　D.[undefined]</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">filter不会接触到没有被赋值的元素，即在arr中，长度为11但实际数值元素列表为[0, 1, 2, 10]，因此，最终返回一个空的数组[]</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目8</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var two = 0.2;</span><br><span class="line">var one = 0.1;</span><br><span class="line">var eight = 0.8;</span><br><span class="line">var six = 0.6;</span><br><span class="line">[two - one == one,eight - six == two];</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">false</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">两个浮点数相加或者相减，将会导致一定的正常的数据转换造成的精度丢失问题eight - six = 0.20000000000000007。</span><br><span class="line">更严谨的做法是(eight - six ).totoFiexd(1)或者用用Math.round方法回归整数运算。判断两个浮点数是否相等，还是建议用逼近的比较，比如<span class="keyword">if</span>((a-b) &lt; 1E-10)</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目9</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showCase(value)&#123;</span><br><span class="line"></span><br><span class="line">　　switch(value)&#123;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case A'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case B'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> undefined :</span><br><span class="line">　　　　　　console.info(<span class="string">'undefined'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　default:</span><br><span class="line">　　　　　　console.info(<span class="string">'Do not know!'</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(new String(<span class="string">'A'</span>));</span><br><span class="line"></span><br><span class="line">　　A.Case A</span><br><span class="line"></span><br><span class="line">　　B.Case B</span><br><span class="line"></span><br><span class="line">　　C.Do not know</span><br><span class="line"></span><br><span class="line">　　D.undefined</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">使用new String()使用构造函数调用将一个全新的对象作为this变量的值，并且隐式返回这个新对象作为调用的结果，因此showCase()接收的参数为String &#123;0: “A”&#125;而不是我们所认为的“A”，为一个对象。</span><br><span class="line">switch是进行绝对等于判断，new String(<span class="string">'A'</span>) !== <span class="string">'A'</span> 而 new String(<span class="string">'A'</span>) == <span class="string">'A'</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>题目10</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showCase(value)&#123;</span><br><span class="line"></span><br><span class="line">　　switch(value)&#123;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case A'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case B'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> undefined :</span><br><span class="line">　　　　　　console.info(<span class="string">'undefined'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　default:</span><br><span class="line">　　　　　　console.info(<span class="string">'Do not know!'</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(String(<span class="string">'A'</span>));</span><br><span class="line"></span><br><span class="line">　　A.Case A</span><br><span class="line"></span><br><span class="line">　　B.Case B</span><br><span class="line"></span><br><span class="line">　　C.Do not know</span><br><span class="line"></span><br><span class="line">　　D.undefined</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">直接调用String(“A”)创建的变量和”A”无异。</span><br><span class="line">例子：</span><br><span class="line">var a=<span class="string">"123"</span>; // 只是设置变量</span><br><span class="line">b=new String(<span class="string">'123'</span>); // 设置一个成员</span><br><span class="line"></span><br><span class="line">var a=<span class="string">"123"</span>;</span><br><span class="line">a.sex=1;</span><br><span class="line">alert(a.sex); // 输出未定义，因为不是成员，没有这属性</span><br><span class="line"></span><br><span class="line">b=new String(<span class="string">'123'</span>);</span><br><span class="line">b.sex=1;</span><br><span class="line">alert(b.sex); // 输出1，成员的属性</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目11</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isOdd(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> num % 2 == 1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> isEven(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> num % 2 == 0; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> isSane(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> isEven(num)||isOdd(num);</span><br><span class="line">&#125;</span><br><span class="line">var values = [7, 4, <span class="string">'13'</span>, -9, Infinity];</span><br><span class="line">values.map(isSane);</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　D.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">该函数判断num是否为正整数，<span class="string">'13'</span>被强制转换为数值13，-9%2结果为-1，Infinity%2为NaN。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目12</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[parseInt(3,8),parseInt(3,2),parseInt(3,0)]</span><br><span class="line"></span><br><span class="line">　　A.[3,3,3]</span><br><span class="line"></span><br><span class="line">　　B.[3,3,NaN]</span><br><span class="line"></span><br><span class="line">　　C.[3,NaN,NaN]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">最终结果为[3, NaN, 3]； </span><br><span class="line">parseInt() 函数可解析一个字符串，并返回一个整数。当参数 radix 的值为 0，或没有设置该参数时，则数字将以 10 为基础来解析。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目13</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(Array.prototype)</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Array.prototype为[]，因此Array.isArray(Array.prototype)为<span class="literal">true</span></span><br><span class="line">Array.isArray(a)是一个判断a是否为数组的方法。</span><br><span class="line">判断对象是否为数组的方法： </span><br><span class="line">1）ES5函数isArray()，该函数测试对象的内部[[Class]]属性是否为Array:</span><br><span class="line">Arrray.isArray(a);</span><br><span class="line">2）判断对象的构造函数是否为Array:</span><br><span class="line">a.constructor === Array</span><br><span class="line">3）使用对象内部[[Class]]属性创建结果字符串：</span><br><span class="line">Object.prototype.toString.call(a)</span><br><span class="line">4）使用instanceof操作符测试对象是否继承自Array： </span><br><span class="line">（但由于，一个页面的iframe不会继承自另外一个页面的iframe，该方法不可靠）</span><br><span class="line">a instanceof Array</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目14</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [0];</span><br><span class="line"><span class="keyword">if</span>([0])&#123;</span><br><span class="line">　　console.info(a == <span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　console.info(<span class="string">"else"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.<span class="string">"else"</span></span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">由于Boolean([0]) === <span class="literal">true</span></span><br><span class="line">因此进入<span class="keyword">if</span>为<span class="literal">true</span>的语句块中，由于a为数组(对象)，与布尔值进行相对等于比较，需要两边都转化为数值后在进行判断。</span><br><span class="line">左边[0]先转化为字符串<span class="string">"0"</span>，接着转化为数值0，而右边<span class="literal">true</span>转化为数值1。</span><br><span class="line">因此a == <span class="literal">true</span>最终返回为<span class="literal">false</span>。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目15</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[]==[]</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">数组在Javascript中是对象，对象使用 == 比较都是对引用（存放在栈内存的指针）的比较。简单的说，就是，如果是同一个对象，就相等，如果不是同一个对象，就不等。</span><br><span class="line">每次使用 [] 都是新建一个数组对象，所以 [] == [] 这个语句里建了两个数据对象，所以它们不等。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目16</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'5'</span> + 3), (<span class="string">'5'</span>- 3)]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"53"</span>, 2]</span><br><span class="line"></span><br><span class="line">　　B.[8, 2]</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">执行<span class="string">'5'</span> + 3，加号具备拼接字符串功能，会将3强制转换为字符串<span class="string">'3'</span>和<span class="string">'5'</span>拼接。 </span><br><span class="line">执行<span class="string">'5'</span> - 3，减号只具备数值运算的功能，因此会将<span class="string">'5'</span>转化为数值，进行5-3的数值运算</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目17</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1+-+++-+1</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目18</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array(3);</span><br><span class="line">arr[0] = 2</span><br><span class="line">arr.map(<span class="keyword">function</span>(elem)&#123;<span class="built_in">return</span> <span class="string">'1'</span>;&#125;);</span><br><span class="line"></span><br><span class="line">　　A.[2,1,1]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line"></span><br><span class="line">　　C.[2,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">区分赋值和声明。</span><br><span class="line">虽然var arr = Array(3);创建一个长度为3的数组，但是实际只有一个元素被赋值，因此arr的实际长度为1，即最终参与map的只有一个元素，返回[1]</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目19</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sidEffecting(arr)&#123;</span><br><span class="line">　　arr[0] = arr[2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> bar(a, b, c)&#123;</span><br><span class="line">　　c = 10;</span><br><span class="line">    // arguments = [1, 1, 10]</span><br><span class="line">　　sidEffecting(arguments);</span><br><span class="line">　　<span class="built_in">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">bar(1,1,1);</span><br><span class="line"></span><br><span class="line">　　A.3</span><br><span class="line"></span><br><span class="line">　　B.12</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">按照执行步骤，无需多疑，最终结果为10+1+10=21</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目20</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 111111111111111110000;</span><br><span class="line">b = 1111;</span><br><span class="line">console.info(a+b);</span><br><span class="line"></span><br><span class="line">　　A.111111111111111111111</span><br><span class="line"></span><br><span class="line">　　B.111111111111111110000</span><br><span class="line"></span><br><span class="line">　　C.NaN</span><br><span class="line"></span><br><span class="line">　　D.Infinity</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">js的精确整数最大为：Math.pow(2,53) - 1 = 9007199254740991. </span><br><span class="line">var a = 111111111111111110000, </span><br><span class="line">max = 9007199254740992; </span><br><span class="line">a的值大于JavaScript所能表示的最大整数精度，因此和任何数值相加将会导致失真。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目21</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var x = [].reverse;</span><br><span class="line">x();</span><br><span class="line"></span><br><span class="line">　　A.[]</span><br><span class="line"></span><br><span class="line">　　B.undefined</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.window</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">正确调用方式为x.call(arr) =&gt; x.call([])</span><br><span class="line">Array.prototype为[]，[].reverse相当于Array.prototype.reverse，</span><br><span class="line">将它call(arr)之后，Array.prototype.reverse中的this就指向了arr对象了。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目22</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.MIN_VALUE &gt; 0</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Number.MIN_VALUE表示的最小值为5e-324，</span><br><span class="line">Number.MIN_VALUE代表的并不是负最小，而是最接近0的一个数，因此Number.MIN_VALUE&gt;0。 </span><br><span class="line">负最小值可以使用-Number.MAX_VALUE表示，为1.7976931348623157e+308。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目23</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1&lt;2&lt;3,3&lt;2&lt;1]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">1&lt;2，返回<span class="literal">true</span>，执行<span class="literal">true</span>&lt;3，会强制将<span class="literal">true</span>转换为1，1&lt;3，最终返回<span class="literal">true</span>。 </span><br><span class="line">3&lt;2，返回<span class="literal">false</span>，执行<span class="literal">false</span>&lt;1,会强制将<span class="literal">false</span>转换为0，0&lt;1，最终返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目23</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1&lt;2&lt;3,3&lt;2&lt;1]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">1&lt;2，返回<span class="literal">true</span>，执行<span class="literal">true</span>&lt;3，会强制将<span class="literal">true</span>转换为1，1&lt;3，最终返回<span class="literal">true</span>。 </span><br><span class="line">3&lt;2，返回<span class="literal">false</span>，执行<span class="literal">false</span>&lt;1,会强制将<span class="literal">false</span>转换为0，0&lt;1，最终返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目24</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 == [[[2]]]</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.undefined</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">使用a==b判断a和b对象是否相等，可以会将b对象强制转换为a对象的类型，即执行2 == [[[2]]]，会隐式调用parseInt([[[2]]])将[[[2]]]强制转化为数字基本量，即2，2==2，最终返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目25</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[3.toString(),3..toString(),3...toString()]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"3"</span>,error,error]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="string">"3"</span>,<span class="string">"3.0"</span>,error]</span><br><span class="line"></span><br><span class="line">　　C.[error,<span class="string">"3"</span>,error]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">Number中的toString(a)，能够将数值转化成为a进制的值。但a缺省时，默认转化为十进制。 </span><br><span class="line">一般使用方法为：var n = 3; (3).toString(); </span><br><span class="line">执行3.toString()，因为3只是为数值型变量，为非Number实例，因此对于3不能直接调用toString方法。</span><br><span class="line">而执行3..toString()，会强制将3转化为数字实例，因此能够被解释，输出3，同样可以使用(3).toString()达到一样的效果。</span><br><span class="line">3...toString()会报<span class="string">"Unexpected token ."</span>的错。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目26</blockquote><ul><li><p>以下表达式的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　var x1 = y1 = 1;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.info(y1);</span><br><span class="line">console.info(x1);</span><br><span class="line"></span><br><span class="line">　　A.1，1</span><br><span class="line"></span><br><span class="line">　　B.error，error</span><br><span class="line"></span><br><span class="line">　　C.1，error</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">在立即调用函数内执行，var x1 = y1 =1; 创建局部变量x1和全局变量y1。</span><br><span class="line">函数外部试图访问函数内部的变量x1，将会导致错误。可以访问全局变量y1。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目27</blockquote><ul><li>列举IE和FF脚本兼容性的问题。</li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">列举IE和FF脚本兼容性的问题 </span><br><span class="line">（1）window.event </span><br><span class="line">表示当前的事件对象，IE有这个对象，FF没有 </span><br><span class="line">（2）获取事件源 </span><br><span class="line">IE用srcElement获取事件源，而FF用target获取事件源 </span><br><span class="line">（3）添加、移除事件</span><br><span class="line">IE：</span><br><span class="line">element.attachEvent(<span class="string">"onclick"</span>,<span class="keyword">function</span>)</span><br><span class="line">element.detachEvent(<span class="string">"onclick"</span>,<span class="keyword">function</span>)</span><br><span class="line">FF:</span><br><span class="line">element.addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>,<span class="literal">true</span>)</span><br><span class="line">element.removeEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>,<span class="literal">true</span>)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;题目28&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">+ 以下函数有什么问题？如何改进？</span><br><span class="line">``` bash</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">initButtons</span></span>()&#123;</span><br><span class="line">    var body = document.body, button;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0;i &lt; 5; i++)&#123;</span><br><span class="line">        button = document.createElement(<span class="string">"button"</span>);</span><br><span class="line">        button.innerHTML = <span class="string">"Button"</span> + i;</span><br><span class="line">        button.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        body.appendChild(button);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">initButtons();</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">解析：</span><br><span class="line">题目所给出的代码，除了有addEventListener不兼容IE浏览器的问题之外，最突出的一个问题是： </span><br><span class="line">虽然在页面上会显示五个按钮，但是点击任意一个按钮，最终都会显示5。</span><br><span class="line">要想点击相关按钮，弹出相应的1，2，3，4，5的值，需要理解闭包原理实现和使用立即回调函数。修改后的代码如下：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">initButtons</span></span>()&#123; </span><br><span class="line">    var body = document.body, button; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; 5; i++)&#123; </span><br><span class="line">        (<span class="keyword">function</span>(j)&#123; </span><br><span class="line">            button = document.createElement(<span class="string">"button"</span>); </span><br><span class="line">            button.innerHTML = <span class="string">"Button"</span> + j; </span><br><span class="line">            button.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(e)&#123; </span><br><span class="line">                alert(j); </span><br><span class="line">            &#125;, <span class="literal">false</span>); </span><br><span class="line">            body.appendChild(button); </span><br><span class="line">        &#125;)(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">initButtons();</span><br><span class="line">闭包存储的是外部变量的引用而非值。 </span><br><span class="line">立即调用的函数表达式，是一种不可或缺的解决javascript缺少块级作用域的方法。</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目29</blockquote><ul><li>写一段代码，判断一个字符串中出现次数最多的字符，并统计出现的次数。</li><li>解析：可使用常规方法和正则表达式匹配两种算法来求解。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toGetTheMostCharsByArray(s)&#123; </span><br><span class="line">    var r = &#123;&#125;; </span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; s.length; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!r[s[i]])&#123; </span><br><span class="line">            r[s[i]] = 1; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            r[s[i]]++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    var max = &#123; </span><br><span class="line">        <span class="string">"value"</span> : s[0], </span><br><span class="line">        <span class="string">"num"</span> : r[s[0]] </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var n <span class="keyword">in</span> r)&#123;//对象使用<span class="keyword">in</span>关键字，因为没有length </span><br><span class="line">        <span class="keyword">if</span>(r[n]&gt;max.num)&#123; </span><br><span class="line">            max.num = r[n]; </span><br><span class="line">            max.value = n;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">return</span> max; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> toGetTheMostCharsByRegex(s)&#123; </span><br><span class="line">    var a = s.split(<span class="string">''</span>); </span><br><span class="line">    a.sort(); </span><br><span class="line">    s = a.join(<span class="string">''</span>); </span><br><span class="line"></span><br><span class="line">    var regex = /(\w)\1+/g ;//\1代表重复的 </span><br><span class="line"></span><br><span class="line">    var max = &#123; </span><br><span class="line">        <span class="string">"value "</span>　:s[0], </span><br><span class="line">        <span class="string">"num"</span> :  0 </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    s.replace(regex, <span class="keyword">function</span>(a, b)&#123; </span><br><span class="line">        // a为重复的字符串</span><br><span class="line">        // b为重复字符</span><br><span class="line">        <span class="keyword">if</span>(max.num &lt; a.length)&#123; </span><br><span class="line">            max.num = a.length; </span><br><span class="line">            max.value= b; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="built_in">return</span> max; </span><br><span class="line">&#125; </span><br><span class="line">var <span class="built_in">test</span> = <span class="string">"efdfssssfrhth"</span>; </span><br><span class="line">console.info(<span class="string">"使用常规方法　，出现最多的字符串为："</span>+toGetTheMostCharsByArray(<span class="built_in">test</span>).value+<span class="string">" ，出现次数："</span>+toGetTheMostCharsByArray(<span class="built_in">test</span>).num); </span><br><span class="line">console.info(<span class="string">"使用字符串匹配，出现最多的字符串为："</span>+toGetTheMostCharsByRegex(<span class="built_in">test</span>).value+<span class="string">" ，出现次数："</span>+toGetTheMostCharsByRegex(<span class="built_in">test</span>).num);</span><br></pre></td></tr></table></figure></li></ul><blockquote>题目30</blockquote><ul><li><p>请问一下两段代码有什么不同？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代码一</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>()&#123;        </span><br><span class="line">    /*代码块*/        </span><br><span class="line">    setTimeout(arguments.callee, 10);    </span><br><span class="line">&#125;, 10);   </span><br><span class="line"></span><br><span class="line">// 代码二</span><br><span class="line">setInterval(<span class="function"><span class="title">function</span></span>()&#123;        </span><br><span class="line">　　/*代码块*/    </span><br><span class="line">&#125;, 10);</span><br></pre></td></tr></table></figure></li><li><p>解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript的引擎是单线程的，且是基于事件驱动的。</span><br><span class="line">setTimeout和setInterval都是往事件队列中增加一个待处理时间而已，setTimeout只触发一次，而setInterval是循环触发。</span><br><span class="line">代码一可使得setTimeout循环触发。但是，执行完这段代码块才挂起时间，所以两次执行时间会大于10毫秒。</span><br><span class="line">代码二是自动在10的时候挂上这个事件，所以两次事件的相隔会小于等于10毫秒。 </span><br><span class="line">当线程阻塞在一个事件的时候，不管是使用setInterval还是setTimeout都需要等待当前事件处理完才能执行。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文记录了30个&lt;code&gt;你“不可能全部会做”的JavaScript题目&lt;/code&gt;，并对各个答案进行分析。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="习题" scheme="https://chongtianhong.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的三种类型检测的比较</title>
    <link href="https://chongtianhong.github.io/2018/05/09/typeChecking/"/>
    <id>https://chongtianhong.github.io/2018/05/09/typeChecking/</id>
    <published>2018-05-09T09:37:13.000Z</published>
    <updated>2018-08-15T13:38:34.545Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在JavaScript中，可使用<code>typeof</code>、<code>instanceof</code>、<code>Object.prototype.toString</code>对变量类型进行检测，接下来将对它们进行比较。<a id="more"></a></li></ul><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><ul><li><code>typeof</code>是JavaScript的一个<strong>一元运算符</strong>，放在一个运算数之前，运算数可以是任意类型。</li><li><code>typeof</code>返回一个<strong>用来表示表达式的数据类型的字符串</strong>，返回结果为JavaScript中的<strong>基本数据类型</strong>，包括：<code>number</code>、<code>boolean</code>、<code>string</code>、<code>object</code>、<code>undefined</code>、<code>function</code>等6种数据类型。</li><li>也就是说，<code>typeof</code>只能返回这几种类型，而<strong>对于</strong>我们的<strong>自定义对象</strong>，它<strong>只会返回object</strong>，在实际应用中作用约等于零。</li><li>此外，<code>typeof</code>在不同浏览器中<strong>可能存在一些兼容性的问题</strong>，如将function类型认作是object等。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof <span class="string">''</span>);//string</span><br><span class="line">console.log(typeof []);//object</span><br><span class="line">console.log(typeof &#123;&#125;);//object</span><br><span class="line">console.log(typeof 1);//number</span><br><span class="line">console.log(typeof null);//object</span><br><span class="line">console.log(typeof undefined);//undefined</span><br><span class="line">console.log(typeof <span class="literal">true</span>);//boolean</span><br><span class="line">console.log(typeof <span class="function"><span class="title">function</span></span>()&#123;&#125;);//<span class="keyword">function</span></span><br><span class="line">console.log(typeof /\d/);//object</span><br></pre></td></tr></table></figure></li></ul><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul><li>在使用<code>typeof</code>运算符对<strong>引用类型变量</strong>进行类型判断时，会出现一个问题，无论引用的是什么类型的对象，它<strong>都返回 “object”</strong>。这就需要用到<code>instanceof</code>来<strong>检测某个对象是不是另一个对象的实例</strong>。</li><li><code>instanceof</code>主要的目的是用来检测<strong>引用类型</strong>，如判断Array、RegExp、日期对象等。</li><li><code>instanceof</code>操作符采用了<strong>原型链方式</strong>来判断对象类型。</li><li><p>如 a instanceof b只要能在a对象的原型链上找到b，则认为a是b类型的一个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=new Array();</span><br><span class="line">alert(a instanceof Array); // <span class="literal">true</span>，</span><br><span class="line">// 同时 </span><br><span class="line">alert(a instanceof Object) // 也会返回 <span class="literal">true</span>;</span><br><span class="line">// 因为 Array 是 object 的子类。</span><br></pre></td></tr></table></figure></li><li><p>再如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;&#125;;</span><br><span class="line">var a = new <span class="built_in">test</span>();</span><br><span class="line">alert(a instanceof <span class="built_in">test</span>) // 会返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>关于null的类型判断</blockquote><ul><li><strong>null是个特殊的Object类型的值</strong>，表示空引用的意思 。但<code>typeof null</code>返回<strong>“object”</strong>这个其实是最初JavaScript的实现的一个错误，然后被ECMAScript沿用了，成为了现在的标准，不过我们可以<strong>把null理解为尚未存在的对象的占位符</strong>。</li><li>注意：<code>null instanceof Object</code>会返回<strong>false</strong>。</li></ul><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><ul><li><code>Object.prototype.toString</code>是对象的一个原生原型扩展函数，用来<strong>精确的区分数据类型</strong>。</li><li>使用<code>Object.prototype.toString.call(value)</code>方法去调用对象，可得到对象的构造函数名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">type</span>=Object.prototype.toString</span><br><span class="line">console.log(type.call(<span class="string">''</span>));//object String</span><br><span class="line">console.log(type.call([]));//object Array</span><br><span class="line">console.log(type.call(&#123;&#125;));//object Object</span><br><span class="line">console.log(type.call(<span class="literal">false</span>));//object Boolean</span><br><span class="line">console.log(type.call(null));//object Null</span><br><span class="line">console.log(type.call(undefined));//object Undefined</span><br><span class="line">console.log(type.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;));//object Function</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在JavaScript中，可使用&lt;code&gt;typeof&lt;/code&gt;、&lt;code&gt;instanceof&lt;/code&gt;、&lt;code&gt;Object.prototype.toString&lt;/code&gt;对变量类型进行检测，接下来将对它们进行比较。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="类型检测" scheme="https://chongtianhong.github.io/tags/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议入门</title>
    <link href="https://chongtianhong.github.io/2018/05/08/httpProtocol/"/>
    <id>https://chongtianhong.github.io/2018/05/08/httpProtocol/</id>
    <published>2018-05-08T05:42:51.000Z</published>
    <updated>2018-08-17T15:02:23.890Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>HTTP 协议是互联网的基础协议</strong>，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。 </li><li>本文介绍 HTTP 协议的历史演变和设计思路。<a id="more"></a><img src="/images/httpProtocol.jpg" alt="http图示" width="600" style="border:none"></li></ul><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h4><ul><li>HTTP 是<strong>基于 TCP/IP 协议</strong>的<strong>应用层协议</strong>。它<strong>不涉及数据包（packet）传输</strong>，主要规定了客户端和服务器之间的通信格式，<strong>默认使用80端口</strong>。 </li><li><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p></li><li><p>协议规定，服务器<strong>只能回应HTML格式的字符串</strong>，不能回应别的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务器发送完毕，就关闭TCP连接。</p></li></ul><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul><li>1996年5月，HTTP/1.0 版本发布，内容大大增加。</li><li>首先，<strong>任何格式的内容都可以发送</strong>。这使得互联网不仅可以<strong>传输文字</strong>，还能<strong>传输图像、视频、二进制文件</strong>。这为互联网的大发展奠定了基础。</li><li>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</li><li>再次，<strong>HTTP请求和回应的格式</strong>也变了。除了数据部分，<strong>每次通信都必须包括头信息（HTTP header）</strong>，用来描述一些元数据。</li><li>其他的新增功能还包括<strong>状态码（status code）</strong>、<strong>多字符集支持</strong>、<strong>多部分发送（multi-part type）</strong>、<strong>权限（authorization）</strong>、<strong>缓存（cache）</strong>、<strong>内容编码（content encoding）</strong>等。</li></ul><h5 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h5><ul><li><p>下面是一个1.0版的HTTP请求的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></li><li><p>可以看到，这个格式与0.9版有很大变化。</p></li><li>第一行是请求命令，<strong>必须在尾部添加协议版本（HTTP/1.0）</strong>。后面就是多行<strong>头信息</strong>，<strong>描述客户端的情况</strong>。</li></ul><h5 id="回应格式"><a href="#回应格式" class="headerlink" title="回应格式"></a>回应格式</h5><ul><li><p>服务器的回应如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>回应的格式是<strong>“头信息 + 一个空行（<code>\r\n</code>） + 数据”</strong>。</p></li><li>其中，第一行是<strong>状态行</strong>，包含<strong>“协议版本 + 状态码（status code） + 状态描述”</strong>。</li></ul><h5 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h5><ul><li>关于字符的编码，1.0版规定，<strong>头信息必须是 ASCII 码</strong>，后面的<strong>数据可以是任何格式</strong>。</li><li>因此，<strong>服务器回应的时候，必须告诉客户端，数据是什么格式</strong>，这就是<strong>Content-Type字段的作用</strong>。</li><li><p>下面是一些常见的<code>Content-Type</code>字段的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">text/plain</span><br><span class="line">text/html</span><br><span class="line">text/css</span><br><span class="line">image/jpeg</span><br><span class="line">image/png</span><br><span class="line">image/svg+xml</span><br><span class="line">audio/mp4</span><br><span class="line">video/mp4</span><br><span class="line">application/javascript</span><br><span class="line">application/pdf</span><br><span class="line">application/zip</span><br><span class="line">application/atom+xml</span><br></pre></td></tr></table></figure></li><li><p>这些数据类型总称为<code>MIME type</code>，每个值包括<strong>一级类型</strong>和<strong>二级类型</strong>，<strong>之间用斜杠分隔</strong>。</p></li><li><p>除了预定义的类型，厂商也可以自定义类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure></li><li><p>上面的类型表明，发送的是Debian系统的二进制数据包。</p></li><li><p><code>MIME type</code>还可以在尾部使用分号，添加参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></li><li><p>上面的类型表明，<strong>发送的是网页</strong>，而且<strong>编码方式是UTF-8</strong>。</p></li><li><p><strong>客户端请求</strong>的时候，可以使用<code>Accept</code>字段<strong>声明自己可以接受哪些数据格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p></li><li><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h5><ul><li><p>由于<strong>服务端发送的数据可以是任何格式</strong>，因此<strong>可以把数据压缩后再发送</strong>。<code>Content-Encoding</code>字段<strong>说明数据的压缩方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端在请求时</strong>，用<code>Accept-Encoding</code>字段<strong>说明自己可以接受哪些压缩方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>HTTP/1.0 版的<strong>主要缺</strong>点是，<strong>每个TCP连接只能发送一个请求</strong>。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li><li><strong>TCP连接的新建成本很高</strong>，因为需要客户端和服务器<strong>三次握手</strong>，并且<strong>开始时发送速率较慢（slow start）</strong>。所以，<strong>HTTP 1.0版本的性能比较差</strong>。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</li><li><p>为了解决这个问题，有些<strong>浏览器在请求时</strong>，用了一个非标准的<code>Connection</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></li><li><p>这个字段<strong>要求服务器不要关闭TCP连接</strong>，以便其他请求复用。<strong>服务器同样回应这个字段</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></li><li><p>一个<strong>可以复用的TCP连接</strong>就建立了，<strong>直到客户端或服务器主动关闭连接</strong>。但是，这<strong>不是标准字段，不同实现的行为可能不一致</strong>，因此<strong>不是根本的解决办法</strong>。</p></li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><ul><li>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</li></ul><h5 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h5><ul><li>1.1 版的<strong>最大变化</strong>，就是<strong>引入了持久连接（persistent connection）</strong>，即<strong>TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code></strong>。</li><li><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，<strong>规范的做法</strong>是，<strong>客户端</strong>在<strong>最后一个请求</strong>时，<strong>发送<code>Connection: close</code></strong>，明确要求服务器关闭TCP连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></li><li><p>目前，对于<strong>同一个域名</strong>，大多数浏览器<strong>允许同时建立6个持久连接</strong>。</p></li></ul><h5 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h5><ul><li>1.1 版还引入了<strong>管道机制（pipelining）</strong>，即<strong>在同一个TCP连接里面，客户端可以同时发送多个请求</strong>。这样就进一步<strong>改进了HTTP协议的效率</strong>。</li><li>举例来说，客户端需要请求两个资源：<ul><li>以前的做法是，在<strong>同一个TCP连接里面</strong>，<strong>先发送A请求，然后等待服务器做出回应，收到后再发出B请求</strong>。</li><li><strong>管道机制</strong>则是<strong>允许浏览器同时发出A请求和B请求</strong>，但是<strong>服务器还是按照顺序，先回应A请求，完成后再回应B请求</strong>。</li></ul></li></ul><h5 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h5><ul><li><p><strong>一个TCP连接现在可以传送多个回应</strong>，势必就要有一种<strong>机制</strong>，<strong>区分数据包是属于哪一个回应的</strong>。这就是<code>Content-length</code>字段的作用，<strong>声明本次回应的数据长度</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure></li><li><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p></li><li><strong>在1.0版中</strong>，<code>Content-length</code>字段<strong>不是必需</strong>的，因为<strong>浏览器发现服务器关闭了TCP连接</strong>，就<strong>表明收到的数据包已经全了</strong>。</li></ul><h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><ul><li>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</li><li><p>另外，<strong>客户端请求的头信息新增了Host字段</strong>，用来<strong>指定服务器的域名</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure></li><li><p>有了<code>Host字段</code>，就可以<strong>将请求发往同一台服务器上的不同网站</strong>，为虚拟主机的兴起打下了基础。</p></li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>虽然<strong>1.1版允许复用TCP连接</strong>，但是<strong>同一个TCP连接里面，所有的数据通信是按次序进行的</strong>。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<strong>“队头堵塞”（Head-of-line blocking）</strong>。</li><li>为了避免这个问题，只有两种方法：<ul><li>一是减少请求数</li><li>二是同时多开持久连接</li></ul></li><li>这导致了很多的<strong>网页优化技巧</strong>，比如<strong>合并脚本和样式表</strong>、<strong>将图片嵌入CSS代码</strong>、<strong>域名分片（domain sharding）</strong>等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><ul><li>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</li></ul><h5 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h5><ul><li>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。</li><li><strong>HTTP/2</strong>则是一个彻底的<strong>二进制协议</strong>，<strong>头信息和数据体都是二进制</strong>，并且统称为”帧”（frame）：<strong>头信息帧</strong>和<strong>数据帧</strong>。</li><li><strong>二进制协议</strong>的一个<strong>好处</strong>是，<strong>可以定义额外的帧</strong>。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</li></ul><h5 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h5><ul><li>HTTP/2 复用TCP连接，在一个连接里，<strong>客户端和浏览器</strong>都可以<strong>同时发送多个请求或回应</strong>，而且<strong>不用按照顺序一一对应</strong>，这样就<strong>避免了”队头堵塞”</strong>。</li><li>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</li><li>这样<strong>双向的、实时</strong>的通信，就叫做<strong>多工（Multiplexing）</strong>。</li></ul><h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><ul><li>因为 <strong>HTTP/2 的数据包是不按顺序发送的</strong>，<strong>同一个连接</strong>里面<strong>连续的数据包，可能属于不同的回应</strong>。因此，必<strong>须要对数据包做标记</strong>，指出它属于哪个回应。</li><li>HTTP/2 将<strong>每个</strong>请求或回应的<strong>所有数据包</strong>，称为一个<strong>数据流（stream）</strong>。<ul><li><strong>每个数据流(同个请求或回应的数据包)都有一个独一无二的编号</strong>。</li><li><strong>数据包发送的时候，都必须标记数据流ID</strong>，用来区分它属于哪个数据流。</li><li>另外还规定，<strong>客户端发出的数据流</strong>，<strong>ID</strong>一律为<strong>奇数</strong>，<strong>服务器发出的ID</strong>为<strong>偶数</strong>。</li></ul></li><li><strong>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流</strong>。<ul><li><strong>1.1版取消数据流</strong>的<strong>唯一方法</strong>，就是<strong>关闭TCP连接</strong>。</li><li>这就是说，<strong>HTTP/2 可以取消某一次请求</strong>，同时<strong>保证TCP连接还打开着</strong>，<strong>可以被其他请求使用</strong>。</li></ul></li><li><strong>客户端</strong>还可以<strong>指定数据流的优先级</strong>。<strong>优先级越高</strong>，<strong>服务器</strong>就会<strong>越早回应</strong>。</li></ul><h5 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h5><ul><li>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</li><li>HTTP/2 对这一点做了优化，引入了<strong>头信息压缩机制（header compression）</strong>。<ul><li>一方面，<strong>头信息</strong>使用<code>gzip</code>或<code>compress</code><strong>压缩后再发送</strong>；</li><li>另一方面，<strong>客户端和服务器同时维护一张头信息表</strong>，<strong>所有字段都会存入这个表，生成一个索引号</strong>，以后就不发送同样字段了，<strong>只发送索引号</strong>，这样就<strong>提高速度</strong>了。</li></ul></li></ul><h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><ul><li>HTTP/2 <strong>允许服务器未经请求，主动向客户端发送资源</strong>，这叫做<strong>服务器推送（server push）</strong>。</li><li>常见场景是<strong>客户端请求一个网页，这个网页里面包含很多静态资源</strong>。<ul><li>正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。</li><li>其实，<strong>服务器</strong>可以预期到客户端请求网页后，很可能会再请求静态资源，所以就<strong>主动把这些静态资源随着网页一起发给客户端</strong>了。</li></ul></li></ul><div class="note info">声明：本文转载自 <a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></div>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP 协议是互联网的基础协议&lt;/strong&gt;，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。 &lt;/li&gt;
&lt;li&gt;本文介绍 HTTP 协议的历史演变和设计思路。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="HTTP" scheme="https://chongtianhong.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JS中parseInt()和map()用法分析</title>
    <link href="https://chongtianhong.github.io/2018/05/07/paseIntAndMap/"/>
    <id>https://chongtianhong.github.io/2018/05/07/paseIntAndMap/</id>
    <published>2018-05-07T08:10:35.000Z</published>
    <updated>2018-08-14T13:20:31.772Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文对<code>[“1”, “2”, “3”].map(parseInt)</code>得到的结果答案是<code>[1, NaN, NaN]</code>的原因进行具体分析。<a id="more"></a></li></ul><blockquote>parseInt(string, radix)</blockquote><ul><li><code>parseInt(string, radix)<code>用来<strong>解析字符串</strong>，返回<strong>整数</strong>。<ul><li><strong>参数<code>string</code></strong><code>必需。要被解析的字符串。</code></li><li><strong>参数<code>radix</code></strong><code>可选，<strong>其值必须介于2~36之间</strong>；如果<strong>省略该参数</strong>或<strong>其值为 0</strong>，则<strong>数字将以 10 为基础来解析</strong>。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。<strong>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN</strong>。</code></li></ul></code></code></li></ul><blockquote>parseInt(string, radix)</blockquote><ul><li><code>map()<code>是<strong>对数组的每一个元素调用回调函数</strong>并<strong>返回一个包含结果的数组</strong>。</code></code></li><li><code>map()<code>的callback回调<strong>最多可传递3个参数</strong>，分别为<strong>数组中当前被传递的元素</strong>item、<strong>数组中当前被传递的元素的索引</strong>index、<strong>调用 map 方法的数组</strong>array。</code></code></li></ul><blockquote>例子分析</blockquote><ul><li>前面提到，<code>parseInt(string, radix)<code>接收的是两个参数，<code>map()<code>回调传递的是3个参数。</code></code></code></code></li><li><p>因此，<code>[“1”, “2”, “3”].map(parseInt)</code>等于<code>[parseInt(1,0),parseInt(2,1),parseInt(3,2)]</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)</span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span> testFuc(item, index)&#123;</span><br><span class="line">    <span class="built_in">return</span> parseInt(item, index);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(testFuc)</span><br><span class="line"></span><br><span class="line">parseInt(1,0) // radix为0，数字将以 10 为基础来解，1转化为十进制后结果为1</span><br><span class="line">parseInt(2,1) // radix小于2，返回NaN</span><br><span class="line">parseInt(3,2) // radix为2, 无法将3用二进制解析，结果为NaN</span><br></pre></td></tr></table></figure></li><li><p>再看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>,<span class="string">"5"</span>,6,7,8,9,10,11,12,13,14,15];</span><br><span class="line">a.map(parseInt);</span><br><span class="line">// 返回结果为：[1,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,9,11,13,15,17,19]</span><br></pre></td></tr></table></figure></li><li><p>由于<code>map()<code>的回调函数的参数index索引值作了<code>parseInt(string, radix)<code>的基数radix，导致出现<strong>超范围的radix赋值</strong>和<strong>不合法的进制解析</strong>，才会返回NaN。</code></code></code></code></p></li><li><p>重新定义parseInt函数，再来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> parseInt(str, radix) &#123; </span><br><span class="line">    <span class="built_in">return</span> str+<span class="string">'-'</span>+radix; </span><br><span class="line">&#125;;</span><br><span class="line">var a=[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>,<span class="string">"5"</span>,6,7,8,9,10,11,12,13,14,15];</span><br><span class="line">a.map(parseInt);</span><br><span class="line">// 输出结果为：[<span class="string">"1-0"</span>,<span class="string">"2-1"</span>,<span class="string">"3-2"</span>,<span class="string">"4-3"</span>,<span class="string">"5-4"</span>,<span class="string">"6-5"</span>,<span class="string">"7-6"</span>,<span class="string">"8-7"</span>,<span class="string">"9-8"</span>,<span class="string">"10-9"</span>,<span class="string">"11-10"</span>,<span class="string">"12-11"</span>,<span class="string">"13-12"</span>,<span class="string">"14-13"</span>,<span class="string">"15-14"</span>]</span><br></pre></td></tr></table></figure></li><li><p>因此，如果要得到正确的整数数组，正确的代码应该为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>];</span><br><span class="line">arr.map((item)=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> parseInt(item);</span><br><span class="line">&#125;)</span><br><span class="line">// 结果为[1, 2, 3]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文对&lt;code&gt;[“1”, “2”, “3”].map(parseInt)&lt;/code&gt;得到的结果答案是&lt;code&gt;[1, NaN, NaN]&lt;/code&gt;的原因进行具体分析。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="高阶函数" scheme="https://chongtianhong.github.io/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
      <category term="parseInt" scheme="https://chongtianhong.github.io/tags/parseInt/"/>
    
      <category term="map" scheme="https://chongtianhong.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>高阶函数：map/reduce/filter/sort</title>
    <link href="https://chongtianhong.github.io/2018/05/06/highOrderFunction/"/>
    <id>https://chongtianhong.github.io/2018/05/06/highOrderFunction/</id>
    <published>2018-05-06T15:18:40.000Z</published>
    <updated>2018-08-15T13:36:28.850Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>JavaScript的<strong>函数</strong>其实都<strong>指向某个变量</strong>。既然<strong>变量可以指向函数</strong>，<strong>函数的参数能接收变量</strong>，那么<strong>一个函数就可以接收另一个函数作为参数</strong>，这种函数就称之为<strong>高阶函数(Higher-order function)</strong>。<a id="more"></a></li><li><p>一个最简单的<strong>高阶函数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(x, y, f) &#123;</span><br><span class="line">    <span class="built_in">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(-5, 6, Math.abs); // 11</span><br></pre></td></tr></table></figure></li><li><p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = -5;</span><br><span class="line">y = 6;</span><br><span class="line">f = Math.abs;</span><br><span class="line">f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;</span><br><span class="line"><span class="built_in">return</span> 11;</span><br></pre></td></tr></table></figure></li><li><p>编写高阶函数，就是<strong>让函数的参数能够接收别的函数</strong>。</p></li></ul><h4 id="高阶函数介绍"><a href="#高阶函数介绍" class="headerlink" title="高阶函数介绍"></a>高阶函数介绍</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ul><li><p>由于<code>map()</code>方法定义在JavaScript的Array中，我们<strong>调用Array的map()方法</strong>，<strong>参数传入自定义函数</strong>，就<strong>得到了一个新的Array</strong>作为结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> pow(x) &#123;</span><br><span class="line">    <span class="built_in">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure></li><li><p><code>map()</code>传入的参数是<code>pow</code>，即函数对象本身。</p></li><li><p><code>map()</code>作为高阶函数，事实上它<strong>把运算规则抽象</strong>了，因此，我们还可以计算任意复杂的函数，比如，<strong>把Array的所有数字转为字符串</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">arr.map(String); // [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br></pre></td></tr></table></figure></li><li><p>把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。</p><ul><li>输入：[‘adam’, ‘LISA’, ‘barT’]</li><li>输出：[‘Adam’, ‘Lisa’, ‘Bart’]</li></ul></li><li><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> normalize(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.map(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">        //x[0]等效于x.substring(0,1)</span><br><span class="line">        <span class="built_in">return</span> x[0].toUpperCase() + x.substring(1).toLowerCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line"><span class="keyword">if</span> (normalize([<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]).toString() === [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>].toString()) &#123;</span><br><span class="line">    alert(<span class="string">'测试通过!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'测试失败!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>小明希望利用<code>map()</code>把字符串变成整数，他写的代码很简洁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">var arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">var r;</span><br><span class="line">r = arr.map(parseInt);</span><br><span class="line">alert(<span class="string">'['</span> + r[0] + <span class="string">', '</span> + r[1] + <span class="string">', '</span> + r[2] + <span class="string">']'</span>);</span><br></pre></td></tr></table></figure></li><li><p>结果竟然是<code>[1, NaN, NaN]</code>，小明百思不得其解，请帮他找到原因并修正代码。</p></li><li>我们先看下<code>map()</code>的语法：<code>array1.map(callbackfn[, thisArg])</code></li><li>callbackfn参数是一个回调函数，最多接受三个值：<strong>value</strong>(数组元素的值)，<strong>index</strong>(数组元素的数字索引)，<strong>array1</strong>(数组对象本身)。</li><li>所以<strong>map在作用parseInt函数时</strong>，其实<strong>传入了元素的值</strong>，<strong>以及所对应的索引</strong>。这样就得到了这样的结果。</li><li>因此，我们只需要元素的值，不需要索引，修改代码为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">var arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">var r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> returnInt(element)&#123; </span><br><span class="line">    <span class="built_in">return</span> parseInt(element);</span><br><span class="line">&#125;</span><br><span class="line">r = arr.map(returnInt);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'['</span> + r[0] + <span class="string">', '</span> + r[1] + <span class="string">', '</span> + r[2] + <span class="string">']'</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><ul><li><p>Array的<code>reduce()</code>把一个函数作用在这个Array的[x1, x2, x3…]上，这个<strong>函数必须接收两个参数</strong>，<code>reduce()</code><strong>把结果</strong>继续<strong>和序列的下一个元素做累积计算</strong>，其效果就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure></li><li><p>比方说对一个Array求和，就可以用reduce实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;); // 25</span><br></pre></td></tr></table></figure></li><li><p>已知<code>pow()</code>方法可返回x的y次幂的值。看下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[3, 2, 1].reduce(Math.pow)</span><br><span class="line">// 可以看成</span><br><span class="line"><span class="keyword">function</span> testFunc(x, y)&#123;</span><br><span class="line">    console.info(x + <span class="string">"："</span> + y);</span><br><span class="line">    <span class="built_in">return</span> Math.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line">// 执行Math.pow(3, 2)和Math.pow(9, 1)，最终返回9和9</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：空数组不能使用<code>reduce()</code>方法，否则会报错。</p></li><li><p>利用<code>reduce()</code>求积：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> product(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.reduce(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">        <span class="built_in">return</span> x * y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line"><span class="keyword">if</span> (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123;</span><br><span class="line">    alert(<span class="string">'测试通过!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'测试失败!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要把[1, 3, 5, 7, 9]变换成整数13579，<code>reduce()</code>也能派上用场：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x * 10 + y;</span><br><span class="line">&#125;); // 13579</span><br></pre></td></tr></table></figure></li><li><p>如果我们继续改进这个例子，想办法把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，再利用<code>reduce()</code>就可以写出一个<strong>把字符串转换为Number</strong>的函数。</p></li><li>不要使用JavaScript内置的<code>parseInt()</code>函数，<strong>利用map和reduce操作实现</strong>一个string2int()函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> string2int(s) &#123;</span><br><span class="line">    <span class="built_in">return</span> s.split(<span class="string">''</span>).map(<span class="keyword">function</span>(x)&#123;</span><br><span class="line">        <span class="built_in">return</span> x - 0;</span><br><span class="line">    &#125;).reduce(<span class="keyword">function</span> (x,y)&#123;</span><br><span class="line">        <span class="built_in">return</span> x * 10 + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><ul><li><code>filter()</code>也是一个常用的操作，它用于<strong>把Array的某些元素过滤掉</strong>，然后<strong>返回剩下的元素</strong>。</li><li>和<code>map()</code>类似，Array的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后<strong>根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素</strong>。</li><li><p>例如，在一个Array中，<strong>删掉偶数，只保留奇数</strong>，可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 4, 5, 6, 9, 10, 15];</span><br><span class="line">var r = arr.filter(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">    <span class="built_in">return</span> x % 2 !== 0;</span><br><span class="line">&#125;);</span><br><span class="line">r; // [1, 5, 9, 15]</span><br></pre></td></tr></table></figure></li><li><p>把一个Array中的<strong>空(无效)字符串删掉</strong>，可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, null, undefined, <span class="string">'C'</span>, <span class="string">'  '</span>];</span><br><span class="line">var r = arr.filter(<span class="keyword">function</span> (s) &#123;</span><br><span class="line">    <span class="built_in">return</span> s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法</span><br><span class="line">&#125;);</span><br><span class="line">r; // [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>filter()</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p></li></ul><blockquote>回调函数</blockquote><ul><li><p><code>filter()</code>接收的回调函数，其实<strong>可以有多个参数</strong>。通常我们仅使用第一个参数，表示<strong>Array的某个元素</strong>。回调函数还可以接收另外两个参数，表示<strong>元素的位置</strong>和<strong>数组本身</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">var r = arr.filter(<span class="keyword">function</span> (element, index, self) &#123;</span><br><span class="line">    console.log(element); // 依次打印<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span></span><br><span class="line">    console.log(index); // 依次打印0, 1, 2</span><br><span class="line">    console.log(self); // self就是变量arr</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>利用filter，可以巧妙地<strong>去除Array的重复元素</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">var r;</span><br><span class="line">var arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line"></span><br><span class="line">r = arr.filter(<span class="keyword">function</span> (element, index, self) &#123;</span><br><span class="line">    <span class="built_in">return</span> self.indexOf(element) === index;//判断元素是不是第一次出现</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(r.toString());</span><br></pre></td></tr></table></figure></li><li><p><strong>去除重复元素</strong>依靠的是<strong>indexOf总是返回第一个元素的位置</strong>，<strong>后续的重复元素位置与indexOf返回的位置不相等</strong>，因此被filter滤掉了。</p></li></ul><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><ul><li>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是<strong>比较两个元素的大小</strong>。</li><li>如果是数字，我们可以直接比较。但如果是<strong>字符串</strong>或者两个<strong>对象</strong>，<strong>直接比较数学上的大小是没有意义的</strong>，因此，<strong>比较的过程必须通过函数抽象出来</strong>。</li><li>通常规定，对于两个元素x和y，如果认为<code>x &lt; y</code>，则返回<code>-1</code>，如果认为<code>x == y</code>，则返回<code>0</code>，如果认为<code>x &gt; y</code>，则返回<code>1</code>，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</li><li><p>JavaScript的Array的<code>sort()</code>方法就是用于排序的，先看下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 看上去正常的结果:</span><br><span class="line">[<span class="string">'Google'</span>, <span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>].sort(); // [<span class="string">'Apple'</span>, <span class="string">'Google'</span>, <span class="string">'Microsoft'</span>];</span><br><span class="line"></span><br><span class="line">// apple排在了最后:</span><br><span class="line">[<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>].sort(); // [<span class="string">'Google'</span>, <span class="string">'Microsoft", '</span>apple<span class="string">']</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 出乎意料的结果:</span></span><br><span class="line"><span class="string">[10, 20, 1, 2].sort(); // [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure></li><li><p>第二个排序把apple排在了最后，是因为<strong>字符串根据ASCII码进行排序</strong>，而<strong>小写字母a的ASCII码在大写字母之后</strong>。</p></li><li>第三个排序结果是因为<strong>Array的<code>sort()</code>方法默认把所有元素先转换为String再排序</strong>，结果’10’排在了’2’的前面，因为<strong>字符’1’比字符’2’的ASCII码小</strong>。</li><li><code>sort()</code>方法也是一个高阶函数，它还<strong>可以接收一个比较函数</strong>来<strong>实现自定义的排序</strong>。</li><li><p>要按数字<strong>从小到大排序</strong>，我们可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x - y; </span><br><span class="line">&#125;);</span><br><span class="line">// 等价于</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123; // 不交换</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123; // 交换</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; // 不交换</span><br><span class="line">&#125;); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure></li><li><p>如果要<strong>倒序排序</strong>，我们可以把大的数放前面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> y - x; </span><br><span class="line">&#125;);</span><br><span class="line">// 等价于</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="built_in">return</span> 1; // 交换</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="built_in">return</span> -1; // 不交换</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; // 不交换</span><br><span class="line">&#125;); // [20, 10, 2, 1]</span><br></pre></td></tr></table></figure></li><li><p><strong>默认情况下，对字符串排序，是按照ASCII的大小比较的</strong>，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>];</span><br><span class="line">arr.sort(<span class="keyword">function</span> (s1, s2) &#123;</span><br><span class="line">    x1 = s1.toUpperCase(); //转大写 toLowerCase() 转小写</span><br><span class="line">    x2 = s2.toUpperCase();</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) &#123;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2) &#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;); // [<span class="string">'apple'</span>, <span class="string">'Google'</span>, <span class="string">'Microsoft'</span>]</span><br></pre></td></tr></table></figure></li><li><p>忽略大小写来比较两个字符串，实际上就是<strong>先把字符串都变成大写（或者都变成小写），再比较</strong>。</p></li><li>从上述例子可以看出，<strong>高阶函数的抽象能力</strong>是<strong>非常强大</strong>的，而且，<strong>核心代码可以保持得非常简洁</strong>。</li><li><strong>特别的是</strong>：与前面提到的高阶函数不同，<strong><code>sort()</code>方法会直接对Array进行修改</strong>，它返回的结果仍是当前Array：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a1 = [<span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>];</span><br><span class="line">var a2 = a1.sort();//直接对a1进行修改了</span><br><span class="line">a1; // [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">a2; // [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">a1 === a2; // <span class="literal">true</span>, a1和a2是同一对象</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JavaScript的&lt;strong&gt;函数&lt;/strong&gt;其实都&lt;strong&gt;指向某个变量&lt;/strong&gt;。既然&lt;strong&gt;变量可以指向函数&lt;/strong&gt;，&lt;strong&gt;函数的参数能接收变量&lt;/strong&gt;，那么&lt;strong&gt;一个函数就可以接收另一个函数作为参数&lt;/strong&gt;，这种函数就称之为&lt;strong&gt;高阶函数(Higher-order function)&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="高阶函数" scheme="https://chongtianhong.github.io/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>事件循环中microtask和macrotask的优先级比较</title>
    <link href="https://chongtianhong.github.io/2018/05/05/eventLoop2/"/>
    <id>https://chongtianhong.github.io/2018/05/05/eventLoop2/</id>
    <published>2018-05-05T11:36:47.000Z</published>
    <updated>2018-08-13T15:07:54.299Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>JavaScript是<strong>单线程语言</strong>，也就是说<strong>一次就只能做一件事情</strong>。如果有<strong>多个任务</strong>，则<strong>需要进行排队</strong>，因此有了<strong>同步任务</strong>和<strong>异步任务</strong>之分。</li><li><strong>同步任务</strong>：在<strong>主线程上</strong>排队执行的任务，前一个任务执行完毕，才能执行后一个任务。</li><li><strong>异步任务</strong>：不进入主线程、而<strong>进入“任务队列”（task queue）</strong>的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li><li><strong>只要主线程空了，就会去读取“任务队列”</strong>，这就是<strong>JavaScript的运行机制</strong>。<a id="more"></a></li></ul><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul><li>浏览器中的<strong>队列</strong>不止一种，且<strong>优先级也不同</strong>。基本上可以分为如下两种：<ul><li><code>macro-task</code>: script（整体代码），setTimeout，setInterval，setImmediate，I/O，UI渲染</li><li><code>micro-task</code>: process.nextTick，原生Promise，Object.observe，MutationObserver</li></ul></li><li>我们之前说的<strong>异步任务队列</strong>，指的是<code>macro-task</code>。而<code>micro-task</code>的执行顺序，与之不同。<ul><li>一个<strong>事件循环(event loop)</strong>会有一个或多个<strong>任务队列(task queue)</strong>。<strong>任务队列(task queue)</strong>就是<code>macro-task queue</code>。</li><li>每一个<strong>事件循环(event loop)</strong>都有一个<code>micro-task queue</code>。<strong>任务队列(task queue)</strong> == <code>macro-task queue</code> != <code>micro-task queue</code>。</li><li>一个任务(task)可以放入<code>macro-task queue</code>也可以放入<code>micro-task queue</code>中。</li></ul></li><li><p>执行原理：</p><div class="note info">事件循环的顺序，决定了JavaScript代码的执行顺序。它<strong>从script(整体代码)开始第一次循环</strong>。在<strong>执行完主线程上的所有任务时</strong>，会<strong>先去查看<code>micro-task</code>队列</strong>中有没有任务，如果有，则依次执行<code>micro-task</code>队列中的所有任务，<strong>之后才去查看<code>macro-task</code>队列</strong>。<strong>每次拿到<code>macro-task</code>队列上的任务并执行之后，都会去检查<code>micro-task</code>队列</strong>，以此循环。</div></li><li><p>可以看到，除了script整体代码，<strong><code>micro-task</code>的任务优先级高于<code>macro-task</code>的任务优先级</strong>。</p></li><li>其中，<strong>script(整体代码)</strong>，可以理解为<strong>待执行的所有代码</strong>。</li><li><p>以一个例子来说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(1); // macro-task</span><br><span class="line">&#125;,0);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    console.log(2); // macro-task</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve)&#123;</span><br><span class="line">    console.log(3); // script整体代码</span><br><span class="line">    resolve(); // script整体代码</span><br><span class="line">    console.log(4); // script整体代码</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    console.log(5); // micro-task</span><br><span class="line">&#125;);</span><br><span class="line">console.log(6);; // script整体代码</span><br><span class="line">process.nextTick(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(7); // micro-task</span><br><span class="line">&#125;);</span><br><span class="line">console.log(8); // script整体代码</span><br><span class="line"></span><br><span class="line">//输出结果是3 4 6 8 7 5 2 1</span><br></pre></td></tr></table></figure></li><li><p>第一步. script整体代码被执行，执行过程为：<br>① 创建setImmediate macro-task<br>② 创建setTimeout macro-task<br>③ 创建micro-task Promise.then 的回调，并执行script console.log(3); resolve(); console.log(4); 此时输出3和4，虽然resolve调用了，执行了但是整体代码还没执行完，无法进入Promise.then 流程。<br>④ console.log(6)输出6<br>⑤ process.nextTick 创建micro-task<br>⑥ console.log(8) 输出8</p></li><li>第一个过程过后，已经输出了3 4 6 8。</li><li>第二步. 由于其他<code>micro-task</code>的优先级高于<code>macro-task</code>。此时<code>micro-task</code>中有两个任务按照优先级：<strong>process.nextTick 高于 Promise</strong>。所以先输出7，再输出5。</li><li>第三步，<code>micro-task</code>任务列表已经执行完毕，接下来执行<code>macro-task</code>。由于<strong>setTimeout的优先级高于setIImmediate</strong>，所以先输出2，再输出1。</li><li>整个过程描述起来像是同步操作，实际上是<strong>基于Event Loop的事件循环</strong>。</li><li><p>再看一个例子，并详细解释它的执行流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">'script1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">&#125;, 300);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'script2'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">    Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'promise3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">// script1</span><br><span class="line">// script2</span><br><span class="line">// promise1</span><br><span class="line">// promise2</span><br><span class="line">// setTimeout2</span><br><span class="line">// promise3</span><br><span class="line">// setTimeout1</span><br></pre></td></tr></table></figure></li><li><p>结果如代码中注释所示。具体执行步骤如下：<br>① 代码从上到下执行，先打印出<code>script1</code>。<br>② 执行到第一个<code>setTimeout</code>时，发现300ms后把函数添加到<code>macro-task</code>队列中。<br>③ 执行<code>Promise</code>时，依次把输出<code>promise1</code>和<code>promise2</code>的任务添加到<code>micro-task</code>队列。<br>④ 打印<code>script2</code>。<br>⑤ 执行第二个<code>setTimeout</code>时因为设置的是0ms，所以立即（其实<strong>浏览器有最少4ms的限制</strong>）添加到<code>macro-task</code>队列中。<br>⑥ 主线程执行完毕则检查<code>micro-task</code>队列并执行，输出<code>promise1</code>和<code>promise2</code>。<br>⑦ 然后检查<code>macro-task</code>队列，输出<code>setTimeout2</code>，并把输出<code>promise3</code>的任务添加到<code>micro-task</code>队列。<br>⑧ 再次检查<code>micro-task</code>队列并执行，输出<code>promise3</code>。<br>⑨ 最后检查<code>macro-task</code>队列，输出<code>setTimeout1</code>，因为它是300ms后添加到<code>macro-task</code>队列，所以后输出。</p></li></ul><h5 id="setImmediate-和-setTimeout-的优先级"><a href="#setImmediate-和-setTimeout-的优先级" class="headerlink" title="setImmediate 和 setTimeout 的优先级"></a>setImmediate 和 setTimeout 的优先级</h5><ul><li><p>看下面这个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'1'</span>); </span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'2'</span>); </span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'3'</span>);</span><br><span class="line"></span><br><span class="line">//输出结果是3 2 1</span><br></pre></td></tr></table></figure></li><li><p>现在<strong>HTML5规定setTimeout的最小间隔时间是4ms</strong>，也就是说<strong>0实际上也会被默认设置为最小值4ms</strong>。</p></li><li>上面说到<strong>setTimeout的优先级比setImmediate的高</strong>，其实这种说法是<strong>有条件的</strong>。</li><li><p>再看下面这个例子，为<strong>setTimeout</strong>增加了一个延迟20ms的时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'1'</span>); </span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'2'</span>); </span><br><span class="line">&#125;, 20);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'3'</span>);</span><br><span class="line"></span><br><span class="line">//输出结果是3 2 1</span><br></pre></td></tr></table></figure></li><li><p><strong>setTimeout</strong>延迟20ms再执行，而<strong>setImmediate</strong>是立即执行，竟然2比1还先输出？？</p></li><li><p>试试打印出这个程序的执行时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var t1 = new Date();</span><br><span class="line">setImmediate(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'1'</span>); </span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'2'</span>); </span><br><span class="line">&#125;,20);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'3'</span>);</span><br><span class="line">var t2 = new Date();</span><br><span class="line">console.log(<span class="string">'time: '</span> + (t2 - t1));</span><br><span class="line">//输出</span><br><span class="line">3 </span><br><span class="line">time: 23 </span><br><span class="line">2 </span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p>程序执行用了23ms, 也就是说，<strong>在script(整体代码)执行完之前</strong>，<strong>setTimeout已经过时了</strong>，所以当进入<code>macro-task</code>的时候<strong>setTimeout</strong>依然优先于<strong>setImmediate</strong>执行。</p></li><li><p>如果再把延迟调大一点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var t1 = new Date();</span><br><span class="line">setImmediate(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'1'</span>); </span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'2'</span>); </span><br><span class="line">&#125;,30);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'3'</span>);</span><br><span class="line">var t2 = new Date();</span><br><span class="line">console.log(<span class="string">'time: '</span> + (t2 - t1));</span><br><span class="line">//输出</span><br><span class="line">3 </span><br><span class="line">time: 23 </span><br><span class="line">1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li><p>结果可以看到，<strong>setImmediate</strong>早于<strong>setTimeout</strong>执行了，因为进入<code>macro-task</code>循环的时候，<strong>setTimeout</strong>的定时器还没到。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JavaScript是&lt;strong&gt;单线程语言&lt;/strong&gt;，也就是说&lt;strong&gt;一次就只能做一件事情&lt;/strong&gt;。如果有&lt;strong&gt;多个任务&lt;/strong&gt;，则&lt;strong&gt;需要进行排队&lt;/strong&gt;，因此有了&lt;strong&gt;同步任务&lt;/strong&gt;和&lt;strong&gt;异步任务&lt;/strong&gt;之分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步任务&lt;/strong&gt;：在&lt;strong&gt;主线程上&lt;/strong&gt;排队执行的任务，前一个任务执行完毕，才能执行后一个任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步任务&lt;/strong&gt;：不进入主线程、而&lt;strong&gt;进入“任务队列”（task queue）&lt;/strong&gt;的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只要主线程空了，就会去读取“任务队列”&lt;/strong&gt;，这就是&lt;strong&gt;JavaScript的运行机制&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="同步" scheme="https://chongtianhong.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="异步" scheme="https://chongtianhong.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="事件循环" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSS控制超出一行内容显示省略号</title>
    <link href="https://chongtianhong.github.io/2018/05/04/textOverflow/"/>
    <id>https://chongtianhong.github.io/2018/05/04/textOverflow/</id>
    <published>2018-05-04T09:34:33.000Z</published>
    <updated>2018-08-13T15:23:16.639Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在前端开发过程中，经常会遇到<strong>文字超过一行内容</strong>的情况，要求<strong>隐藏超出部分</strong>并且<strong>以省略号显示</strong>。<a id="more"></a><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4></li><li><p>使用以下CSS代码即可解决这个需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">white-space: nowrap; /*规定段落中的文本不进行换行*/</span><br><span class="line">overflow: hidden; /*内容会被修剪，并且其余内容是不可见的。*/</span><br><span class="line">text-overflow: ellipsis; /*显示省略号来代表被修剪的文本*/</span><br></pre></td></tr></table></figure></li><li><p>接下来具体来看这三个CSS属性的用法。</p></li></ul><h5 id="white-space属性"><a href="#white-space属性" class="headerlink" title="white-space属性"></a>white-space属性</h5><h6 id="定义和用法："><a href="#定义和用法：" class="headerlink" title="定义和用法："></a>定义和用法：</h6><ul><li>white-space属性设置如何处理元素内的空白。</li></ul><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">normal</td><td style="text-align:center">默认值。空白被浏览器忽略</td></tr><tr><td style="text-align:center">pre</td><td style="text-align:center">空白会被浏览器保留。其行为方式类似于HTML中的pre标签</td></tr><tr><td style="text-align:center">nowrap</td><td style="text-align:center">文本不会换行，在同一行上继续，直到遇到br标签为止</td></tr><tr><td style="text-align:center">pre-wrap</td><td style="text-align:center">保留空白符序列，但是正常地进行换行</td></tr><tr><td style="text-align:center">pre-line</td><td style="text-align:center">合并空白符序列，但是保留换行符</td></tr><tr><td style="text-align:center">inherit</td><td style="text-align:center">规定应该从父元素继承white-space属性的值</td></tr></tbody></table><h6 id="浏览器支持："><a href="#浏览器支持：" class="headerlink" title="浏览器支持："></a>浏览器支持：</h6><ul><li>所有浏览器<strong>都支持</strong>white-space属性。</li><li><strong>注释</strong>：任何版本的Internet Explorer（包括IE8）都不支持属性值“inherit”。</li></ul><h5 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h5><h6 id="定义和用法：-1"><a href="#定义和用法：-1" class="headerlink" title="定义和用法："></a>定义和用法：</h6><ul><li>overflow属性规定<strong>当内容溢出元素框时</strong>发生的事情。</li></ul><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">visible</td><td style="text-align:center">默认值。内容不会被修剪，会呈现在元素框之外</td></tr><tr><td style="text-align:center">hidden</td><td style="text-align:center">内容会被修剪，并且超出内容是不可见的</td></tr><tr><td style="text-align:center">scroll</td><td style="text-align:center">内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容</td></tr><tr><td style="text-align:center">auto</td><td style="text-align:center">如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容</td></tr><tr><td style="text-align:center">inherit</td><td style="text-align:center">规定应该从父元素继承overflow属性的值</td></tr></tbody></table><h5 id="text-overflow属性"><a href="#text-overflow属性" class="headerlink" title="text-overflow属性"></a>text-overflow属性</h5><h6 id="定义和用法：-2"><a href="#定义和用法：-2" class="headerlink" title="定义和用法："></a>定义和用法：</h6><ul><li>text-overflow 属性规定<strong>当文本溢出包含元素时</strong>发生的事情。</li></ul><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">clip</td><td style="text-align:center">修剪文本</td></tr><tr><td style="text-align:center">ellipsis</td><td style="text-align:center">显示省略符号来代表被修剪的文本</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">使用给定字符串来代替被修剪文本</td></tr></tbody></table><h6 id="浏览器支持：-1"><a href="#浏览器支持：-1" class="headerlink" title="浏览器支持："></a>浏览器支持：</h6><ul><li>所有主流浏览器<strong>都支持</strong>text-overflow属性。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在前端开发过程中，经常会遇到&lt;strong&gt;文字超过一行内容&lt;/strong&gt;的情况，要求&lt;strong&gt;隐藏超出部分&lt;/strong&gt;并且&lt;strong&gt;以省略号显示&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>var与ES6中const、let声明的变量的区别</title>
    <link href="https://chongtianhong.github.io/2018/05/03/variableDelaration/"/>
    <id>https://chongtianhong.github.io/2018/05/03/variableDelaration/</id>
    <published>2018-05-03T08:05:37.000Z</published>
    <updated>2018-08-13T15:23:16.638Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在ES6之前，JavaScript是没有块级作用域的，如果在块内使用var声明一个变量，它在代码块外面仍旧是可见的。 </li><li>ES6规范给开发者带来了块级作用域，let和const添加了块级作用域。<a id="more"></a></li><li>let和const大大改进了ES5的变量机制，使得JS更严谨和规范：<ul><li>let和const<strong>约束了变量提升</strong>。</li><li>let和const有<strong>暂时性死区</strong>。</li><li>let和const<strong>禁止重复声明变量</strong>。</li><li>let和const<strong>不会成为全局对象的属性</strong>。</li></ul></li><li><strong>特别</strong>的是，<strong>const声明的变量不能重新赋值</strong>，也是由于这个规则，<strong>const变量声明时必须初始化</strong>，不能留到以后赋值。</li></ul><h4 id="let，var，const声明的变量的区别"><a href="#let，var，const声明的变量的区别" class="headerlink" title="let，var，const声明的变量的区别"></a>let，var，const声明的变量的区别</h4><h5 id="使用var声明的变量和不使用var声明的变量的区别。"><a href="#使用var声明的变量和不使用var声明的变量的区别。" class="headerlink" title="使用var声明的变量和不使用var声明的变量的区别。"></a>使用var声明的变量和不使用var声明的变量的区别。</h5><ul><li>使用var声明的变量声明前调用，那么该变量的值为undefined；不使用var声明的变量声明前调用直接报错Uncaught ReferenceError：xxx is not difined；</li><li>使用var声明的变量不可delete，不使用var声明则可以delete掉释放空间。（实则浏览器的垃圾回收机制也会清理掉用var声明但是不再使用的的变量，比如某个仅执行一次的函数中被调用的某个var 声明的变量）</li><li>在使用’use strict’的模式之下，不使用var 声明变量的语法是不被允许的，报错：Uncaugth SyntaxError;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);   //undefined，这里还涉及变量提升的概念</span><br><span class="line">console.log(b);   //报错 Uncaught ReferenceError: b is not defined</span><br><span class="line">var a = 1;</span><br><span class="line">b = 2;</span><br><span class="line">console.log(a);   //1</span><br><span class="line">console.log(b);   //2</span><br><span class="line">delete a;</span><br><span class="line">delete b;</span><br><span class="line">console.log(a);   //1</span><br><span class="line">console.log(b);   //报错 Uncaught ReferenceError: b is not defined,可见b在声明前使用和声明后delete再使用是一样的结果</span><br></pre></td></tr></table></figure></li></ul><h5 id="let"><a href="#let" class="headerlink" title="let"></a>let</h5><blockquote>不存在变量提升</blockquote><ul><li>由于<strong>let</strong>也<strong>不会变量提升</strong>，let声明的变量在声明前使用也会报错，这个与const一致；因此，<strong>变量需要先声明然后再使用</strong>，否则报错：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// var 的情况</span><br><span class="line">console.log(foo);  // undefined</span><br><span class="line">var foo = 2;</span><br><span class="line"></span><br><span class="line">// <span class="built_in">let</span>的情况；</span><br><span class="line">console.log(bar);  // 报错</span><br><span class="line"><span class="built_in">let</span> bar = 2;</span><br></pre></td></tr></table></figure></li></ul><blockquote>块级作用域</blockquote><ul><li><p>let声明了一个<strong>块级作用域</strong>的变量，在一个块的“}”结束的时候，该变量消失。也就是说，<strong>let声明的变量只在它所在的代码块有效</strong>。例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(x,y)&#123;</span><br><span class="line">    var b = x;</span><br><span class="line">    <span class="built_in">let</span> c = y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        var b = 5;</span><br><span class="line">        <span class="built_in">let</span> c = 6;</span><br><span class="line">        console.log(b);  //5</span><br><span class="line">        console.log(c);  //6，这里的<span class="built_in">let</span> c在下一行的<span class="string">"&#125;"</span>之后消失</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(b);  //5</span><br><span class="line">    console.log(c);  //3 ，这里仍然是第三行的<span class="built_in">let</span> c；</span><br><span class="line">&#125;(2,3));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> n = 5;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">let</span> n = 10;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(n); // 5</span><br><span class="line">&#125; </span><br><span class="line">f1()</span><br><span class="line">// 上面的代码有2个代码块，都声明了变量n，运行后输出5，说明了外层代码块不受内层代码块的影响</span><br><span class="line">// 如果使用了变量var，那么输出的就是10</span><br></pre></td></tr></table></figure></li><li><p>let是一个比较保守的变量，因此，let声明的变量适合用于循环体中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var array1 = []，array2 = [];</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; 10; i++)&#123; </span><br><span class="line">    array1[i] = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> j = 0; j &lt; 10; j++)&#123;  </span><br><span class="line">    array2[j] = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(j);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">array1[6]();  //10</span><br><span class="line">array2[6]();  //6</span><br></pre></td></tr></table></figure></li><li><p>代码分析：</p><ul><li>这里变量为<code>i</code>的for循环中，<code>i</code>是一个全局变量，在全局范围内都有效，所以<strong>每一次循环，新的i值都会覆盖旧值</strong>，导致最后输出的是最后一轮i的值，即<code>i</code>的最终结果为10，故而每次调用<code>array1[i]</code>，实际上都是<code>console.log(10)</code>;</li><li>而let作为<strong>仅在其代码块有效的变量</strong>，当前的<code>j</code>仅在本轮的循环中有效，就是说每一次循环，<code>j</code>其实都是一个新产生的变量。所以<strong>let变量适合用于循环体中</strong>。</li></ul></li></ul><blockquote>暂时性死区</blockquote><ul><li><p><strong>块级作用域内存在let命令，它所声明的变量就绑定在这个区域，不再受外部影响</strong>，如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 1;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    tmp = 2;   //ReferenceError</span><br><span class="line">    <span class="built_in">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个例子中<code>tmp=2</code>的赋值会报错，因为在<strong>if块中的let对tmp变量进行了声明</strong>，导致该tmp绑定了这个作用域，而<strong>let不会像var那样“变量提升”</strong>，所以<strong>未声明赋值会报错</strong>。</p></li><li>ES6中明确规定：<strong>如果区块中存在let和const命令</strong>，则<strong>这个区块对这些命令声明的变量</strong>从一开始就<strong>形成了封闭作用域</strong>，只要<strong>在声明之前做任何使用，都会报错</strong>。这在语法上称为<strong>“暂时性死区”（temporal dead zone ，简称TDZ）</strong>。</li></ul><blockquote>不允许重复声明</blockquote><ul><li><p>let 不允许在相同作用域内，重复声明同一个变量。如下代码会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> a1 = 10;</span><br><span class="line">  <span class="built_in">let</span> a1 = 1;</span><br><span class="line">  console.log(a1);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure></li><li><p>也不能在函数内部重新声明参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func1(arg) &#123;</span><br><span class="line">  <span class="built_in">let</span> arg; // 报错</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> func2(arg) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">let</span> arg; // 不报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li><strong>var声明的变量为全局变量</strong>，而<strong>let，const声明的变量不为全局变量，使用window访问不到</strong>，如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">console.log(window.a); //1</span><br><span class="line"><span class="built_in">let</span> b = 2;</span><br><span class="line">console.log(window.b) //undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><blockquote>声明一个只读的常量</blockquote><ul><li>const 声明一个<strong>只读</strong>的常量，<strong>一旦声明，常量的值就不允许改变</strong>，否则就会报错：<code>Uncaught TypeError: Assignment to constant variable</code>。</li><li><p><strong>const定义的变量</strong>不可以修改，而且<strong>必须初始化</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const b = 2;// 正确</span><br><span class="line">// const b;// 错误，必须初始化 </span><br><span class="line"></span><br><span class="line">const a = 1; </span><br><span class="line">a = 2; </span><br><span class="line">console.log(a);  //报错</span><br></pre></td></tr></table></figure></li><li><p>对于<strong>复合类型的变量</strong>，比如<strong>数组</strong>，<strong>存储的是一个地址，不可改变的是这个地址</strong>，即<strong>不能把一个地址指向另一个地址</strong>，但是<strong>对象本身是可变的</strong>，比如<strong>可以给它添加新的属性</strong>。看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line">foo.prop = 123;</span><br><span class="line">console.log(foo.prop);  //123</span><br><span class="line">foo.prop = 456;</span><br><span class="line">console.log(foo.prop);  //456</span><br><span class="line">const foo = &#123;&#125;;   //Identifier <span class="string">'foo'</span> has already been declared</span><br></pre></td></tr></table></figure></li><li><p>这里const定义一个foo之后，对其添加了属性prop，随后又对该属性进行了修改，<strong>没有报错</strong>是因为<strong>常量foo本身存储的是一个地址</strong>，<strong>该地址指向一个对象</strong>，<strong>不可变的是foo这个地址</strong>，即不能把foo指向另一个地址，但<strong>对象本身是可变的</strong>，所以依然可以为foo添加新属性，改变新属性值，而最后一行中尝试改变foo的地址，就会报错。</p></li><li><p>如果要<strong>彻底将对象冻结（不可修改其属性）</strong>，应该使用<code>Object.freeze(obj)</code>方法。同理，数组也是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const group = [];</span><br><span class="line">group.push(<span class="string">'Bob'</span>);</span><br><span class="line">console.log(group[0]); //Bob</span><br><span class="line">group = [<span class="string">"Tom"</span>];//Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></li><li><p>另外，由于<strong>const不会变量提升</strong>，所以<strong>在声明前使用也会报错</strong>：<code>Uncaught ReferenceError: a is not defined</code>。</p></li></ul><blockquote>块级作用域</blockquote><ul><li>const的作用域与let命令相同；只在声明所在的块级作用域内有效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    const aa = 1;</span><br><span class="line">&#125; </span><br><span class="line">console.log(aa);  // 报错</span><br></pre></td></tr></table></figure></li></ul><blockquote>不允许重复声明</blockquote><ul><li>和let一样，const不允许在相同作用域内，重复声明同一个变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">let</span> age = 25;</span><br><span class="line">// 以下两行都会报错</span><br><span class="line">const message = <span class="string">"Goodbye!"</span>;</span><br><span class="line">const age = 30;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在ES6之前，JavaScript是没有块级作用域的，如果在块内使用var声明一个变量，它在代码块外面仍旧是可见的。 &lt;/li&gt;
&lt;li&gt;ES6规范给开发者带来了块级作用域，let和const添加了块级作用域。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>使用JS准确获取URL网址中参数的几种方法</title>
    <link href="https://chongtianhong.github.io/2018/05/02/getParamsFromURL/"/>
    <id>https://chongtianhong.github.io/2018/05/02/getParamsFromURL/</id>
    <published>2018-05-01T16:11:36.000Z</published>
    <updated>2018-08-13T15:23:17.333Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在WEB开发中，时常会用到JavaScript来获取当前页面的url网址信息，这篇文章主要介绍了JS准确获取当前页面url网址信息的多种方法，包括正则法、split拆分法等。<a id="more"></a></li></ul><h4 id="获取整个URL字符串"><a href="#获取整个URL字符串" class="headerlink" title="获取整个URL字符串"></a>获取整个URL字符串</h4><ul><li>要想获取URL中的参数，首先我们就要<strong>获取到整个URL字符串</strong>。我们使用下面这个URL为例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xbhong.top/2018/05/01/vueSet/?token=hello<span class="comment">#more</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><ul><li>获取(或设置) URL 的协议部分：<code>window.location.protocol</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window.location.protocol设置或获取 URL 的协议部分</span><br><span class="line">var <span class="built_in">test</span> = window.location.protocol;</span><br><span class="line">alert(<span class="built_in">test</span>);</span><br><span class="line">// 返回弹出：http</span><br></pre></td></tr></table></figure></li></ul><h5 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h5><ul><li>获取(或设置) URL 的主机部分：<code>window.location.host</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window.location.host设置或获取 URL 的主机部分</span><br><span class="line">var <span class="built_in">test</span> = window.location.host;</span><br><span class="line">alert(<span class="built_in">test</span>);</span><br><span class="line">// 返回弹出：www.xbhong.top</span><br></pre></td></tr></table></figure></li></ul><h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><ul><li>获取(或设置)  URL 关联的端口号：<code>window.location.port</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window.location.port设置或获取与 URL 关联的端口号码</span><br><span class="line">var <span class="built_in">test</span> = window.location.port;</span><br><span class="line">alert(<span class="built_in">test</span>);</span><br><span class="line">// 返回弹出：空字符(如果采用默认的80端口(即使添加了:80)，那么返回值并不是默认的80而是空字符)</span><br></pre></td></tr></table></figure></li></ul><h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><ul><li>获取(或设置)  URL 的路径部分也就是文件地址：<code>window.location.pathname</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window.location.pathname设置或获取 URL 的路径部分（就是文件地址）</span><br><span class="line">var <span class="built_in">test</span> = window.location.pathname;</span><br><span class="line">alert(<span class="built_in">test</span>);</span><br><span class="line">// 返回弹出：/2018/05/01/vueSet/</span><br></pre></td></tr></table></figure></li></ul><h5 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h5><ul><li>获取(或设置) URL属性中跟在问号后面的部分：<code>window.location.search</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window.location.search设置或获取 href 属性中跟在问号后面的部分</span><br><span class="line">var <span class="built_in">test</span> = window.location.search;</span><br><span class="line">alert(<span class="built_in">test</span>);</span><br><span class="line">// 返回弹出：?token=hello</span><br></pre></td></tr></table></figure></li></ul><h5 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h5><ul><li>获取(或设置)  URL属性中在井号“#”后面的分段：<code>window.location.hash</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window.location.hash设置或获取 href 属性中在井号“<span class="comment">#”后面的分段</span></span><br><span class="line">var <span class="built_in">test</span> = window.location.hash;</span><br><span class="line">alert(<span class="built_in">test</span>);</span><br><span class="line">// 返回弹出：<span class="comment">#more</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="整个URL"><a href="#整个URL" class="headerlink" title="整个URL"></a>整个URL</h5><ul><li>获取(或设置) 整个 URL字符串：<code>window.location.href</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// window.location.href设置或获取整个 URL字符串</span><br><span class="line">var <span class="built_in">test</span> = window.location.href;</span><br><span class="line">alert(<span class="built_in">test</span>);</span><br><span class="line">// 返回弹出：http://xbhong.top/2018/05/01/vueSet/?token=hello<span class="comment">#more</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="获取URL中的参数值"><a href="#获取URL中的参数值" class="headerlink" title="获取URL中的参数值"></a>获取URL中的参数值</h4><ul><li>获取了URL字符串之后就是获取URL字符串中的参数数据信息。下面是几种获取参数的方法：</li></ul><h5 id="正则法"><a href="#正则法" class="headerlink" title="正则法"></a>正则法</h5><ul><li>同正则表达式对比获取参数值：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getQueryString(name)&#123;</span><br><span class="line">    var reg = new RegExp(<span class="string">"(^|&amp;)"</span>+ name +<span class="string">"=([^&amp;]*)(&amp;|$)"</span>, i);</span><br><span class="line">    var r = window.location.search.substr(1).match(reg);</span><br><span class="line">    <span class="keyword">if</span> (r!=null)&#123;</span><br><span class="line">        <span class="built_in">return</span> unescape(r[2]); // unescape() 函数可对通过 escape() 编码的字符串进行解码。</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 这样调用：</span><br><span class="line">alert(GetQueryString(<span class="string">"参数名1"</span>));</span><br><span class="line">alert(GetQueryString(<span class="string">"参数名2"</span>));</span><br><span class="line">alert(GetQueryString(<span class="string">"参数名3"</span>));</span><br></pre></td></tr></table></figure></li></ul><h5 id="split拆分法"><a href="#split拆分法" class="headerlink" title="split拆分法"></a>split拆分法</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">GetRequest</span></span>() &#123;</span><br><span class="line">    var url = location.search; //获取url中<span class="string">"?"</span>符后的字串</span><br><span class="line">    var theRequest = new Object();</span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">"?"</span>) != -1) &#123;</span><br><span class="line">        var str = url.substr(1);</span><br><span class="line">        strs = str.split(<span class="string">"&amp;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (var i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            theRequest[strs[i].split(<span class="string">"="</span>)[0]] = unescape(strs[i].split(<span class="string">"="</span>)[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> theRequest;</span><br><span class="line">&#125;</span><br><span class="line">var Request = new Object();</span><br><span class="line">Request = GetRequest();</span><br><span class="line">// var id=Request[<span class="string">"id"</span>]; </span><br><span class="line">// var 参数1,参数2,参数3,参数N;</span><br><span class="line">// 参数1 = Request[<span class="string">'参数1'</span>];</span><br><span class="line">// 参数2 = Request[<span class="string">'参数2'</span>];</span><br><span class="line">// 参数3 = Request[<span class="string">'参数3'</span>];</span><br><span class="line">// 参数N = Request[<span class="string">'参数N'</span>];</span><br></pre></td></tr></table></figure><h5 id="单个参数的获取方法"><a href="#单个参数的获取方法" class="headerlink" title="单个参数的获取方法"></a>单个参数的获取方法</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">GetRequest</span></span>() &#123;</span><br><span class="line">    var url = location.search; //获取url中<span class="string">"?"</span>符后的字串</span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">"?"</span>) != -1) &#123;  //判断是否有参数</span><br><span class="line">        var str = url.substr(1); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串</span><br><span class="line">        strs = str.split(<span class="string">"="</span>);  //用等号进行分隔 （因为知道只有一个参数 所以直接用等号进分隔 如果有多个参数 要用&amp;号分隔 再用等号进行分隔）</span><br><span class="line">        alert(strs[1]);     //直接弹出第一个参数 （如果有多个参数 还要进行循环的）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在WEB开发中，时常会用到JavaScript来获取当前页面的url网址信息，这篇文章主要介绍了JS准确获取当前页面url网址信息的多种方法，包括正则法、split拆分法等。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0 $set()的正确使用方式</title>
    <link href="https://chongtianhong.github.io/2018/05/01/vueSet/"/>
    <id>https://chongtianhong.github.io/2018/05/01/vueSet/</id>
    <published>2018-05-01T15:07:06.000Z</published>
    <updated>2018-08-13T15:23:17.713Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在Vue开发中，当生成Vue实例后，再次给数据赋值时，有时候并不会自动更新到视图上去。</li><li>Vue文档中写明：如果<strong>在实例创建之后添加新的属性到实例上</strong>，它<strong>不会触发视图更新</strong>。<a id="more"></a></li><li><p>如下代码，给 student对象新增 age 属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        student: &#123;</span><br><span class="line">            name: <span class="string">''</span>,</span><br><span class="line">            sex: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>直接</strong>给student<strong>赋值操作</strong>，虽然<strong>可以新增属性</strong>，但是<strong>不会触发视图更新</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span></span> () &#123;</span><br><span class="line">    this.student.age = 24;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>原因</strong>：受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。</p></li><li><p>只有当<strong>实例被创建时</strong>，<strong>data中存在的属性才是响应式的</strong>。也就是说如果你添加一个新的属性，比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.b = <span class="string">'hi'</span></span><br></pre></td></tr></table></figure></li><li><p>那么对 b 的改动将不会触发任何视图的更新。</p></li><li><p>要处理这种情况，我们可以<strong>使用<code>$set()</code>方法</strong>，既可以新增属性，又可以触发视图更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 语法：this.<span class="variable">$set</span>(this.data,<span class="string">"key"</span>,value)</span><br><span class="line"><span class="function"><span class="title">mounted</span></span> () &#123;</span><br><span class="line">    this.<span class="variable">$set</span>(this.student,<span class="string">"age"</span>, 24);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果我们知道我们会在晚些时候需要一个属性，但是一开始它为空或不存在，那么我们仅需要设置一些初始值。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        newTodoText: <span class="string">''</span>,</span><br><span class="line">        visitCount: 0,</span><br><span class="line">        hideCompletedTodos: <span class="literal">false</span>,</span><br><span class="line">        todos: [],</span><br><span class="line">        error: null</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在Vue开发中，当生成Vue实例后，再次给数据赋值时，有时候并不会自动更新到视图上去。&lt;/li&gt;
&lt;li&gt;Vue文档中写明：如果&lt;strong&gt;在实例创建之后添加新的属性到实例上&lt;/strong&gt;，它&lt;strong&gt;不会触发视图更新&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Vue.js" scheme="https://chongtianhong.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>页面的重绘与回流及优化</title>
    <link href="https://chongtianhong.github.io/2018/04/30/reflowAndRepaint/"/>
    <id>https://chongtianhong.github.io/2018/04/30/reflowAndRepaint/</id>
    <published>2018-04-30T14:24:28.000Z</published>
    <updated>2018-08-13T15:23:17.646Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在理解页面的重绘与回流（重排）之前，首先要清楚页面呈现的具体过程。<a id="more"></a></li></ul><h4 id="页面呈现的具体过程"><a href="#页面呈现的具体过程" class="headerlink" title="页面呈现的具体过程"></a>页面呈现的具体过程</h4><blockquote>Step1</blockquote><ul><li>浏览器把获取到的<strong>HTML代码解析成1个DOM树</strong>，HTML中的每个tag都是DOM树中的1个节点，<strong>根节点</strong>就是我们常用的<strong>document对象</strong>。</li><li>DOM树里包含了<strong>所有HTML标签</strong>，包括<strong>使用了<code>display:none</code>隐藏的元素</strong>，还有<strong>用JS动态添加的元素</strong>等。</li></ul><blockquote>Step2</blockquote><ul><li>浏览器把<strong>所有样式（用户定义的CSS和用户代理）解析成样式结构体（CSSOM树）</strong>，在解析的过程中会<strong>去掉浏览器不能识别的样式</strong>，比如IE会去掉-moz开头的样式，而FF会去掉_开头的样式。</li></ul><blockquote>Step3</blockquote><ul><li><strong>DOM树</strong>和<strong>样式结构体（CSSOM树）</strong>组合后构建<strong>render tree</strong>。</li><li>render tree类似于DOM tree，但区别很大。<ul><li><strong>render tree能识别样式</strong>，render tree中每个NODE都有自己的style，而且 <strong>render tree不包含隐藏的节点</strong> (比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。</li></ul></li><li><strong>注意</strong>：<strong>visibility:hidden隐藏的元素还是会包含到 render tree中</strong>的，因为<strong>visibility:hidden 会影响布局(layout)，会占有空间</strong>。</li><li>根据CSS2的标准，<strong>render tree中的每个节点都称为Box (Box dimensions)</strong>，理解页面元素为一个具有填充、边距、边框和位置的盒子。</li></ul><blockquote>Step4</blockquote><ul><li>一旦render tree构建完毕后，<strong>浏览器</strong>就可以<strong>根据render tree来绘制页面</strong>了。如下图：<br><img src="/images/pageShow.jpg" width="600" alt="页面呈现的具体过程" style="border:none"></li></ul><h4 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h4><h5 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h5><ul><li><strong>回流(reflow)</strong>指的是当<strong>render tree中的一部分(或全部)</strong>因为<strong>元素的规模尺寸，布局，隐藏等改变</strong>而<strong>需要重新构建</strong>，即渲染树需要重新计算。</li><li>也就是说，回流是指<strong>DOM的变化影响到了元素的几何属性（宽和高）</strong>，浏览器会<strong>重新计算元素的几何属性</strong>，会<strong>使渲染树中受到影响的部分失效</strong>，浏览器会<strong>验证DOM树上的所有其他节点的visibility属性</strong>，因此，<strong>回流是低效的</strong>。</li><li><strong>每个页面至少需要一次回流</strong>，就是在<strong>页面第一次加载</strong>的时候。</li><li>在回流的时候，<strong>浏览器</strong>会使渲染树中受到影响的部分失效，并<strong>重新构造这部分渲染树</strong>，<strong>完成回流后</strong>，浏览器会<strong>重新绘制受影响的部分到屏幕中</strong>，该过程称为<strong>重绘</strong>。</li></ul><blockquote>回流的产生</blockquote><ul><li>当<strong>页面布局</strong>和<strong>几何属性改变</strong>时就会<strong>产生回流</strong>。下述情况会发生浏览器回流：<ul><li><strong>DOM树的结构变化</strong>：例如<strong>节点的增减、移动</strong>等。浏览器引擎布局的过程，类似于树的前序遍历，是一个从上到下从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。所以，<strong>如果在body最前面插入一个元素，会导致整个文档的重新渲染</strong>，而<strong>在其后插入一个元素，则不会影响到前面的元素</strong>。</li><li><strong>元素尺寸改变</strong>（边距、填充、边框、宽度和高度）：当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重新构建渲染树中失效的节点。</li><li><strong>获取某些属性</strong>：当获取一些属性时，浏览器为取得正确的值也会触发重排。这些属性包括：<code>offsetTop</code>、<code>offsetLeft</code>、 <code>offsetWidth</code>、<code>offsetHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code>、<code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code>、<code>getComputedStyle() (currentStyle in IE)</code>。所以，<strong>在多次使用这些值时应进行缓存</strong>。</li><li><strong>内容改变</strong>，比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；</li><li>页面渲染初始化；</li><li><strong>浏览器窗口尺寸改变</strong>，如resize事件发生时。</li></ul></li></ul><h5 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h5><ul><li>重绘指的是当render tree中的一些<strong>元素</strong>需要<strong>更新属性</strong>，而这些属性只是<strong>影响元素的外观，风格</strong>，而<strong>不会影响布局</strong>的，比如background-color，visibility，outline等。</li><li>重绘不会带来重新布局，并<strong>不一定伴随回流（重排）</strong>。</li></ul><h5 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h5><ul><li>回流必将引起重绘，而重绘不一定会引起回流。</li><li><p>如果<strong>回流</strong>的频率很高，CPU使用率会大大增加。一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，<strong>性能代价是高昂的</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style; </span><br><span class="line"></span><br><span class="line">s.padding = <span class="string">"2px"</span>; // 回流+重绘</span><br><span class="line"></span><br><span class="line">s.border = <span class="string">"1px solid red"</span>; // 再一次 回流+重绘</span><br><span class="line"></span><br><span class="line">s.color = <span class="string">"blue"</span>; // 再一次重绘</span><br><span class="line"></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span>; // 再一次 重绘</span><br><span class="line"></span><br><span class="line">s.fontSize = <span class="string">"14px"</span>; // 再一次 回流+重绘</span><br><span class="line"></span><br><span class="line">// 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(<span class="string">'abc!'</span>));</span><br><span class="line"></span><br><span class="line">///可以看到每次DOM元素的样式操作都会引发重绘，如果涉及布局还会引发回流。</span><br></pre></td></tr></table></figure></li><li><p><strong>display: none</strong>指的是元素完全不陈列出来，不占据空间，涉及到了DOM结构的改变，因此产生回流和重绘。</p></li><li><strong>visibility：hidden指</strong>的是元素不可见但存在，保留空间，不影响DOM结构的变化，因此只产生重绘。</li></ul><h4 id="减少回流、重绘的方法"><a href="#减少回流、重绘的方法" class="headerlink" title="减少回流、重绘的方法"></a>减少回流、重绘的方法</h4><ul><li><strong>减少回流、重绘</strong>其实就是需要<strong>减少对render tree的操作</strong>（合并多次对DOM和样式的修改），并<strong>减少对一些style信息的请求</strong>，尽量<strong>利用好浏览器的优化策略</strong>。接下来介绍解决方法。</li><li><p>尽量不用内联样式style属性，操作元素样式的时候用添加去掉class类的方式，实现合并多次改变样式属性的操作:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 不好的写法</span><br><span class="line">var left = 1;</span><br><span class="line">var top = 1;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top = top + <span class="string">"px"</span>;</span><br><span class="line">// 比较好的写法</span><br><span class="line">el.className += <span class="string">" className1"</span>;</span><br></pre></td></tr></table></figure></li><li><p>让要操作的元素进行“离线处理”，处理完后一起更新：<br>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//不好的写法（模式中所说的反模式）</span><br><span class="line">var p, t;</span><br><span class="line">p = document.creatElement(<span class="string">'p'</span>);</span><br><span class="line">t = document.creatTextNode(<span class="string">'fist paragraph'</span>);</span><br><span class="line">p.appendChild(t);</span><br><span class="line">document.body.appendChild(p);  //将引起一次回流</span><br><span class="line"></span><br><span class="line">p = document.creatElement(<span class="string">'p'</span>);</span><br><span class="line">t = document.creatTextNode(<span class="string">'second paragraph'</span>);</span><br><span class="line">p.appendChild(t);</span><br><span class="line">document.body.appendChild(p);  //将再引起一次回流</span><br><span class="line"></span><br><span class="line">//好的写法</span><br><span class="line">var p, t, frag;</span><br><span class="line">frag = document.creatDocumentFragment();</span><br><span class="line">p = document.creatElement(<span class="string">'p'</span>);</span><br><span class="line">t = document.creatTextNode(<span class="string">'fist paragraph'</span>);</span><br><span class="line">p.appendChild(t);</span><br><span class="line">farg.appendChild(p);</span><br><span class="line"></span><br><span class="line">p = document.creatElement(<span class="string">'p'</span>);</span><br><span class="line">t = document.creatTextNode(<span class="string">'second paragraph'</span>);</span><br><span class="line">p.appendChild(t);</span><br><span class="line">farg.appendChild(p);</span><br><span class="line"></span><br><span class="line">document.body.appendChild(frag);    //相比前面的方法，这里仅仅引起一次回流，倘若页面里有很多这样的操作，利用文档随便将会提升很多</span><br></pre></td></tr></table></figure><p>b) 使用display:none技术，只引发两次回流和重绘; (只是减少重绘和回流的次数，display：none 是会引起重绘并回流，相对来说，visibility: hidden只会引起重绘)<br>c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//建立克隆镜像</span><br><span class="line">var oldNode = document.getElementById(<span class="string">'target'</span>),</span><br><span class="line">      <span class="built_in">clone</span> = oldNode.cloneNode(<span class="literal">true</span>);   //深复制</span><br><span class="line"></span><br><span class="line">//   处理克隆对象的操作....</span><br><span class="line"></span><br><span class="line">//完成后</span><br><span class="line">oldNode.parentNode.replaceChild(<span class="built_in">clone</span>, oldNode);</span><br></pre></td></tr></table></figure></li><li><p><strong>给元素加动画的时</strong>候，可以<strong>把该元素的定位设置成absolute或者fixed（动画元素脱离文档流）</strong>，这样不会影响其他元素，<strong>减少回流的Render Tree的规模</strong>。</p></li><li>在<strong>需要经常获取那些引起浏览器重排的属性值</strong>时，要<strong>缓存到变量</strong>。</li></ul><h4 id="减少回流的方法"><a href="#减少回流的方法" class="headerlink" title="减少回流的方法"></a>减少回流的方法</h4><h5 id="CSS中避免回流"><a href="#CSS中避免回流" class="headerlink" title="CSS中避免回流"></a>CSS中避免回流</h5><ul><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>动画效果应用到position属性为absolute或fixed的元素上。</li><li>牺牲平滑度换取速度。</li><li>避免使用table布局。</li><li>避免使用CSS的JavaScript表达式。</li></ul><h5 id="JS操作避免回流"><a href="#JS操作避免回流" class="headerlink" title="JS操作避免回流"></a>JS操作避免回流</h5><ul><li>避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免循环操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document。</li><li>可以在一个display:none的元素上进行操作，最终把它显示出来。因为display:none上的DOM操作不会引发回流和重绘。</li><li>避免循环读取offsetLeft等属性，在循环之前把它们存起来。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在理解页面的重绘与回流（重排）之前，首先要清楚页面呈现的具体过程。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="浏览器" scheme="https://chongtianhong.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="重绘" scheme="https://chongtianhong.github.io/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="回流" scheme="https://chongtianhong.github.io/tags/%E5%9B%9E%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>block，inline和inline-block的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/28/block/"/>
    <id>https://chongtianhong.github.io/2018/04/28/block/</id>
    <published>2018-04-28T14:25:07.000Z</published>
    <updated>2018-08-13T15:23:17.780Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>display 属性规定元素应该生成的框的类型，这个属性用于定义建立布局时元素生成的显示框类型。</li><li>设置了<code>display：block</code>的元素将显示为<strong>块级元素</strong>，此元素前后会<strong>带有换行符</strong>。</li><li>设置了<code>display：inline</code>的元素会被显示为<strong>内联元素</strong>，元素前后<strong>没有换行符</strong>。<a id="more"></a></li><li>设置了<code>display：inline-block</code>的元素会显示为<strong>行内块元素</strong>（CSS2.1 新增的值），意思就是说，让这个元素<strong>显示在同一行不换行</strong>，但是又<strong>可以控制高度和宽度</strong>，这相当于内联元素的增强。</li><li><strong>注意</strong>：IE6 不支持inline-block。</li></ul><h4 id="内联元素和块级元素的定义"><a href="#内联元素和块级元素的定义" class="headerlink" title="内联元素和块级元素的定义"></a>内联元素和块级元素的定义</h4><ul><li>内联元素（行内元素）是<strong>不可以控制宽和高</strong>、<strong>竖直margin等盒模型属性</strong>；并且<strong>在同一行显示，不换行</strong>，比如<code>span</code>, <code>a</code>, <code>strong</code>, <code>em</code>, <code>label</code>, <code>input</code>, <code>select</code>, <code>textarea</code>, <code>img</code>, <code>br</code>等元素。</li><li>块级元素时<strong>可以控制宽和高、margin等盒模型属性</strong>，并且<strong>会换行</strong>，比如<code>div</code>、<code>p</code>、<code>ul</code>、<code>li</code>、<code>p</code>和所有的<code>h</code>类标签。</li></ul><h4 id="内联元素和块级元素的区别"><a href="#内联元素和块级元素的区别" class="headerlink" title="内联元素和块级元素的区别"></a>内联元素和块级元素的区别</h4><h5 id="起新行"><a href="#起新行" class="headerlink" title="起新行"></a>起新行</h5><ul><li><strong>块级(block)元素会独占一行</strong>，多个block元素会各自新起一行。<strong>默认情况下，block元素宽度自动填满其父元素宽度</strong>。</li><li><strong>内联(inline)元素不会独占一行</strong>，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其<strong>宽度随元素的内容而变化</strong>。</li></ul><h5 id="设置宽高"><a href="#设置宽高" class="headerlink" title="设置宽高"></a>设置宽高</h5><ul><li><strong>块级(block)元素</strong>可以设置width，height属性。块级元素即使设置了宽度，仍然独占一行。</li><li><strong>内联(inline)元素</strong>设置width，height无效。</li></ul><h5 id="内外边距"><a href="#内外边距" class="headerlink" title="内外边距"></a>内外边距</h5><ul><li><strong>块级(block)元素</strong>可以设置margin和padding属性。</li><li><strong>内联(inline)元素</strong>的margin和padding属性，水平方向的padding-left，padding-right，margin-left，margin-right都<strong>会产生边距效果</strong>，但<strong>竖直方向</strong>的 margin/padding-top/bottom<strong>不会产生边距效果</strong>。</li></ul><h5 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h5><ul><li><strong>块级(block)元素</strong>可以包含<strong>内联(inline)元素</strong>和<strong>块级(block)元素</strong>，而<strong>内联(inline)元素</strong>只能包含<strong>内联(inline)元素</strong>。</li></ul><blockquote>display: inline-block</blockquote><ul><li><strong>行内块级(inline-block)元素</strong>将对象呈现为inline对象，但是对象的内容作为block对象呈现，之后的内联对象会被排列到一行内。比如我们可以给一个link(a元素)inline-block的属性, 使其<strong>既有块级(block)元素的高宽特性又有内联(inline)元素的同行特性</strong>。</li><li><strong>注意</strong>：IE6 不支持inline-block。在实际运用过程中，要注意浏览器的兼容问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;display 属性规定元素应该生成的框的类型，这个属性用于定义建立布局时元素生成的显示框类型。&lt;/li&gt;
&lt;li&gt;设置了&lt;code&gt;display：block&lt;/code&gt;的元素将显示为&lt;strong&gt;块级元素&lt;/strong&gt;，此元素前后会&lt;strong&gt;带有换行符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;设置了&lt;code&gt;display：inline&lt;/code&gt;的元素会被显示为&lt;strong&gt;内联元素&lt;/strong&gt;，元素前后&lt;strong&gt;没有换行符&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>generator函数返回的遍历器对象中的next方法</title>
    <link href="https://chongtianhong.github.io/2018/04/27/nextOfGenerator/"/>
    <id>https://chongtianhong.github.io/2018/04/27/nextOfGenerator/</id>
    <published>2018-04-27T14:01:36.000Z</published>
    <updated>2018-08-13T15:23:17.578Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong><code>yield</code>表达式本身没有返回值</strong>，或者说<strong>总是返回<code>undefined</code></strong>。</li><li><strong><code>next()</code>方法可以带一个参数</strong>，该参数就会被当作<strong>上一个<code>yield</code>表达式的返回值</strong>。<a id="more"></a></li><li><p>先看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span>(var i = 0; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">        var reset = yield i;</span><br><span class="line">        <span class="keyword">if</span>(reset) &#123; </span><br><span class="line">            i = -1; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var g = f();</span><br><span class="line">g.next() // &#123; value: 0, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next() // &#123; value: 1, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">g.next(<span class="literal">true</span>) // &#123; value: 0, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码先定义了一个<strong>可以无限运行的Generator函数<code>f</code></strong>，如果<code>next()</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next()</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p></li><li>注：<strong>每次调用遍历器对象的next方法</strong>，就会<strong>返回一个有着value和done两个属性的对象</strong>。其中，<strong>value属性表示当前的内部状态的值</strong>，是<strong>本次<code>yield</code>表达式</strong>后面的值。</li><li>这个功能有很重要的语法意义。<strong>Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的</strong>。通过<code>next()</code>方法的参数，就有办法在 Generator函数开始运行之后，继续向函数体内部注入值。也就是说，<strong>可以在Generator函数运行的不同阶段，从外部向内部注入不同的值</strong>，从而<strong>调整函数行为</strong>。</li><li><p>再看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* foo(x) &#123;</span><br><span class="line">    var y = 2 * (yield (x + 1));</span><br><span class="line">    var z = yield (y / 3);</span><br><span class="line">    <span class="built_in">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line">var a = foo(5);</span><br><span class="line">a.next() // Object&#123;value:6, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next() // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">a.next() // Object&#123;value:NaN, <span class="keyword">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">var b = foo(5);</span><br><span class="line">b.next() // &#123; value:6, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(12) // &#123; value:8, <span class="keyword">done</span>:<span class="literal">false</span> &#125;</span><br><span class="line">b.next(13) // &#123; value:42, <span class="keyword">done</span>:<span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，第二次运行<code>next()</code>方法的时候不带参数，导致 y 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>next()</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p></li><li>如果向<code>next()</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的<code>next()</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next()</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next()</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</li><li>注意：由于<strong>next()方法的参数表示上一个yield表达式的返回值</strong>，所以<strong>在第一次使用next()方法时，传递参数是无效的</strong>。</li><li>V8 引擎直接忽略第一次使用next()方法时的参数，<strong>只有从第二次使用next()方法开始，参数才是有效的</strong>。从语义上讲，第一个next()方法用来启动遍历器对象，所以不用带有参数。</li><li><p>再看一个通过<code>next()</code>方法的参数，向<strong>Generator函数</strong>内部输入值的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">dataConsumer</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'Started'</span>);</span><br><span class="line">    console.log(`1. <span class="variable">$&#123;yield&#125;</span>`);</span><br><span class="line">    console.log(`2. <span class="variable">$&#123;yield&#125;</span>`);</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next();</span><br><span class="line">// Started</span><br><span class="line">// &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">genObj.next(<span class="string">'a'</span>)</span><br><span class="line">// 1. a</span><br><span class="line">// &#123;value: undefined, <span class="keyword">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">genObj.next(<span class="string">'b'</span>)</span><br><span class="line">// 2. b</span><br><span class="line">// &#123;value: <span class="string">"result"</span>, <span class="keyword">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码是一个很直观的例子，每次通过<code>next()</code>方法向<strong>Generator函数</strong>输入值，然后打印出来。</p></li><li><p>如果想要第一次调用<code>next()</code>方法时，就能够输入值，可以<strong><strong>在Generator函数外面再包一层</strong></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> wrapper(generatorFunction) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (...args) &#123;</span><br><span class="line">        <span class="built_in">let</span> generatorObject = generatorFunction(...args);</span><br><span class="line">        generatorObject.next();</span><br><span class="line">        <span class="built_in">return</span> generatorObject;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const wrapped = wrapper(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    console.log(`First input: <span class="variable">$&#123;yield&#125;</span>`);</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'DONE'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">wrapped().next(<span class="string">'hello!'</span>)</span><br><span class="line">// First input: hello!</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，Generator函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next()</code>方法就输入参数的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;表达式本身没有返回值&lt;/strong&gt;，或者说&lt;strong&gt;总是返回&lt;code&gt;undefined&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;next()&lt;/code&gt;方法可以带一个参数&lt;/strong&gt;，该参数就会被当作&lt;strong&gt;上一个&lt;code&gt;yield&lt;/code&gt;表达式的返回值&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="异步编程" scheme="https://chongtianhong.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>yield 表达式</title>
    <link href="https://chongtianhong.github.io/2018/04/26/yield/"/>
    <id>https://chongtianhong.github.io/2018/04/26/yield/</id>
    <published>2018-04-26T13:04:08.000Z</published>
    <updated>2018-08-13T15:23:17.779Z</updated>
    
    <content type="html"><![CDATA[<ul><li>由于<strong>执行Generator函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态</strong>，所以其实提供了一种可以<strong>暂停执行</strong>的函数。</li><li><strong><code>yield</code>表达式</strong>就是<strong>暂停标志</strong>。<a id="more"></a></li><li>遍历器对象的<code>next</code>方法的运行逻辑如下:<br>1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。<br>2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。<br>3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。<br>4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</li><li>需要注意的是，<strong><code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行</strong>，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</li><li><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别：<ul><li>相似之处：都能返回紧跟在语句后面的那个表达式的值。</li><li>区别：①每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<strong><code>return</code>语句不具备位置记忆的功能</strong>。②一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。</li></ul></li><li>正常函数只能返回一个值，因为只能执行一次<code>return</code>；<strong>Generator函数</strong>可以返回一系列的值，因为可以有任意多个<code>yield</code>。</li><li><p><strong>Generator函数</strong>可以<strong>不用<code>yield</code>表达式</strong>，这时就变成了一个单纯的<strong>暂缓执行函数</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">f</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'执行了！'</span>)</span><br><span class="line">&#125;</span><br><span class="line">var generator = f();</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    generator.next()</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，<strong>函数f是一个 Generator 函数</strong>，就变成<strong>只有调用next方法时，函数f才会执行</strong>。</p></li><li><strong>注意</strong>：<code>yield</code>表达式<strong>只能用在Generator函数里面</strong>，用在其他地方都会报错。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;由于&lt;strong&gt;执行Generator函数返回的遍历器对象，只有调用&lt;code&gt;next&lt;/code&gt;方法才会遍历下一个内部状态&lt;/strong&gt;，所以其实提供了一种可以&lt;strong&gt;暂停执行&lt;/strong&gt;的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;表达式&lt;/strong&gt;就是&lt;strong&gt;暂停标志&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="异步编程" scheme="https://chongtianhong.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Generator 函数的语法</title>
    <link href="https://chongtianhong.github.io/2018/04/25/generator/"/>
    <id>https://chongtianhong.github.io/2018/04/25/generator/</id>
    <published>2018-04-25T11:17:06.000Z</published>
    <updated>2018-08-13T15:23:17.333Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>Generator函数</strong>是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。</li><li><strong>Generator函数</strong>有多种理解角度。可以从<strong>语法</strong>和<strong>形式</strong>上进行理解。<a id="more"></a></li></ul><blockquote>从语法上进行理解</blockquote><ul><li>语法上，<strong>Generator函数是一个状态机，封装了多个内部状态</strong>。</li><li><strong>执行Generator函数</strong>会<strong>返回一个遍历器对象</strong>，也就是说，<strong>Generator 函数</strong>除了是状态机，还是一个遍历器对象生成函数。<strong>返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态</strong>。</li></ul><blockquote>从形式上进行理解</blockquote><ul><li>形式上，<strong>Generator函数</strong>是一个普通函数，但是有两个特征<ul><li><code>function</code>关键字与函数名之间有一个星号(*)；</li><li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态。</li></ul></li><li><p>例如，下面代码定义了一个<strong>Generator函数</strong><code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="function"><span class="title">helloWorldGenerator</span></span>() &#123;</span><br><span class="line">    yield <span class="string">'hello'</span>;</span><br><span class="line">    yield <span class="string">'world'</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure></li><li><p>然后，<strong>Generator函数</strong>的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。</p></li><li><p><strong>不同</strong>的是，<strong>调用Generator函数后，该函数并不执行</strong>，<strong>返回的</strong>也不是函数运行结果，而<strong>是一个指向内部状态的指针对象</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hw.next()  // &#123; value: <span class="string">'hello'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">hw.next()  // &#123; value: <span class="string">'world'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">hw.next()  // &#123; value: <span class="string">'ending'</span>, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">hw.next()  // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>下一步，必须<strong>调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态</strong>。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或return语句）为止。</p></li><li>换言之，<strong>Generator函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行</strong>。</li></ul><blockquote>判断是否为generator</blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isGen(fn) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'function'</span> === typeof fn &amp;&amp; fn.constructor.name === <span class="string">'GeneratorFunction'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote>总结</blockquote><ul><li><strong>调用Generator函数，返回一个遍历器对象</strong>，代表<strong>Generator函数</strong>的<strong>内部指针</strong>。以后，<strong>每次调用遍历器对象的next方法</strong>，就会<strong>返回一个有着value和done两个属性的对象</strong>。<ul><li>value属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；</li><li><code>done</code>属性是一个<strong>布尔值</strong>，表示<strong>是否遍历结束</strong>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Generator函数&lt;/strong&gt;是 ES6 提供的一种&lt;strong&gt;异步编程解决方案&lt;/strong&gt;，语法行为与传统函数完全不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generator函数&lt;/strong&gt;有多种理解角度。可以从&lt;strong&gt;语法&lt;/strong&gt;和&lt;strong&gt;形式&lt;/strong&gt;上进行理解。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="异步编程" scheme="https://chongtianhong.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入理解JS闭包</title>
    <link href="https://chongtianhong.github.io/2018/04/24/closure/"/>
    <id>https://chongtianhong.github.io/2018/04/24/closure/</id>
    <published>2018-04-24T11:14:57.000Z</published>
    <updated>2018-08-13T15:23:16.908Z</updated>
    
    <content type="html"><![CDATA[<ul><li>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。<a id="more"></a></li></ul><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><ul><li>要理解闭包，首先必须理解Javascript特殊的<strong>变量作用域</strong>。</li><li>变量的作用域无非就是两种：<strong>全局变量</strong>和<strong>局部变量</strong>。</li><li><p>Javascript语言的特殊之处，就在于<strong>函数内部可以直接读取全局变量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var n = 999;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(); // 999</span><br></pre></td></tr></table></figure></li><li><p>另一方面，在<strong>函数外部无法读取函数内的局部变量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">    var n = 999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(n); // Uncaught ReferenceError: n is not defined</span><br></pre></td></tr></table></figure></li><li><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用<code>var</code>命令。如果不用的话，实际上相当于声明了一个全局变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">    n = 999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">alert(n); // 999</span><br></pre></td></tr></table></figure></li></ul><h4 id="如何从函数外部读取局部变量？"><a href="#如何从函数外部读取局部变量？" class="headerlink" title="如何从函数外部读取局部变量？"></a>如何从函数外部读取局部变量？</h4><ul><li><p>出于种种原因，我们有时候<strong>需要得到函数内的局部变量</strong>。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是<strong>在函数的内部，再定义一个函数</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">    n = 999;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">        alert(n); // 999</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的<strong>“链式作用域（chain scope）”</strong>结构，子对象会一级一级地向上寻找所有父对象的变量。所以，<strong>父对象的所有变量，对子对象都是可见的，反之则不成立</strong>。</p></li><li>因为f2可以读取f1中的局部变量，所以只要把f2作为返回值，就可以在f1外部读取它的内部变量了：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">    n = 999;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line">var result = f1();</span><br><span class="line"></span><br><span class="line">result(); // 999</span><br></pre></td></tr></table></figure></li></ul><h4 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h4><ul><li>上面代码中的提到的f2函数，就是闭包。</li><li>使用闭包的原因：<strong>局部变量无法共享和长久的保存</strong>，而<strong>全局变量可能造成变量污染</strong>，所以我们希望有一种机制<strong>既可以长久的保存变量又不会造成全局污染</strong>。</li><li><strong>有权访问另一个函数作用域内变量的函数</strong>都是闭包。</li><li>由于在Javascript语言中，<strong>只有函数内部的子函数才能读取局部变量</strong>，因此可以把闭包简单理解成“<strong>定义在一个函数内部的函数</strong>”。</li><li>利用闭包可以<strong>突破作用链域</strong>，将函数内部的<strong>变量</strong>和<strong>方法</strong>传递到外部。所以，在本质上，<strong>闭包</strong>就是将<strong>函数内部</strong>和<strong>函数外部</strong>连接起来的一座<strong>桥梁</strong>。</li></ul><h4 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h4><ul><li>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的<strong>可以读取函数内部的变量</strong>；另一个就是<strong>让这些变量的值始终保持在内存中</strong>，这些变量不会被垃圾回收机制回收。</li><li><p>如下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>()&#123;</span><br><span class="line">    var n = 999;</span><br><span class="line">    nAdd = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        n += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">f2</span></span>()&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = f1();</span><br><span class="line">result(); // 999</span><br><span class="line">nAdd();</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure></li><li><p>在这段代码中，<strong>result实际上就是闭包f2函数</strong>。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，<strong>函数f1中的局部变量n一直保存在内存中</strong>，并没有在f1调用后被自动清除。</p></li><li>原因：<strong>f1是f2的父函数</strong>，而<strong>f2被赋给了一个全局变量</strong>，这导致<strong>f2始终在内存中</strong>，而<strong>f2的存在依赖于f1</strong>，因此<strong>f1也始终在内存中</strong>，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</li><li>这段代码中另一个值得注意的地方，就是<code>nAdd=function(){n+=1}</code>这一部分的代码，首先在<strong>nAdd前面没有使用var关键字</strong>，因此，<strong>nAdd是一个全局变量</strong>，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以<strong>nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作</strong>。</li><li>再看一个例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段一</span><br><span class="line">var name = <span class="string">"The Window"</span>;   </span><br><span class="line">var object = &#123;   </span><br><span class="line">    name : <span class="string">"My Object"</span>,   </span><br><span class="line">    getNameFunc : <span class="function"><span class="title">function</span></span>()&#123;   </span><br><span class="line">        <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;   </span><br><span class="line">            <span class="built_in">return</span> this.name;   </span><br><span class="line">        &#125;;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;   </span><br><span class="line">alert(object.getNameFunc()());  //The Window</span><br><span class="line"></span><br><span class="line">// 代码片段二</span><br><span class="line">var name = <span class="string">"The Window"</span>;</span><br><span class="line">var object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); //My Object</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h4><ul><li>由于<strong>闭包会使得函数中的变量都被保存在内存中</strong>，<strong>内存消耗很大</strong>，所以<strong>不能滥用闭包</strong>，否则会造成网页的性能问题，在IE中可能导致<strong>内存泄露</strong>。<strong>解决方法</strong>：在<strong>退出函数之前，将不使用的局部变量全部删除</strong>。</li><li><strong>闭包会在父函数外部，改变父函数内部变量的值</strong>。所以，如果我们把<strong>父函数</strong>当作<strong>对象（object）</strong>使用，把<strong>闭包</strong>当作它的<strong>公用方法（Public Method）</strong>，把<strong>内部变量</strong>当作它的<strong>私有属性（private value）</strong>，这时一定要小心，<strong>不要随便改变父函数内部变量的值</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="闭包" scheme="https://chongtianhong.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
</feed>
