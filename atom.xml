<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-09-02T10:20:11.124Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式括号的作用</title>
    <link href="https://chongtianhong.github.io/2018/05/31/regExp2/"/>
    <id>https://chongtianhong.github.io/2018/05/31/regExp2/</id>
    <published>2018-05-31T07:32:32.000Z</published>
    <updated>2018-09-02T10:20:11.124Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>不管哪门语言中都有括号。<strong>正则表达式</strong>也是一门语言，而括号的存在使这门语言更为强大。</li><li>对<strong>括号的使用</strong>是否得心应手，是衡量对正则的掌握水平的一个侧面标准。<a id="more"></a></li><li><strong>正则表达式中的括号</strong>提供了<strong>分组</strong>，便于我们引用它。</li><li>引用某个分组，会有两种情形：在<strong>JavaScript里引用（使用相应API）</strong>，在<strong>正则表达式里引用</strong>。</li></ul><h4 id="分组和分支结构"><a href="#分组和分支结构" class="headerlink" title="分组和分支结构"></a>分组和分支结构</h4><ul><li>这二者是括号最直接的作用，也是最原始的功能。</li></ul><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><ul><li>我们知道<code>/a+/</code>匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用<code>/(ab)+/</code>。其中<strong>括号是提供分组功能</strong>，使量词<code>“+”</code>作用于<code>“ab”</code>这个整体，测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(ab)+/g;</span><br><span class="line">var string = <span class="string">"ababa abbb ababab"</span>;</span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"abab"</span>, <span class="string">"ab"</span>, <span class="string">"ababab"</span>]</span><br></pre></td></tr></table></figure></li></ul><h5 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h5><ul><li><p>在<strong>多选分支结构</strong><code>(p1|p2)</code>中，此处括号的作用也是不言而喻的，提供了<strong>子表达式的所有可能</strong>。比如，要匹配如下的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I love JavaScript</span><br><span class="line"></span><br><span class="line">I love Regular Expression</span><br></pre></td></tr></table></figure></li><li><p>可以使用正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^I love (JavaScript|Regular Expression)$/;</span><br><span class="line">var string1 = <span class="string">"I love JavaScript"</span>;</span><br><span class="line">var string2 = <span class="string">"I love Regular Expression"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">string1.match(regex) // [<span class="string">"I love JavaScript"</span>, <span class="string">"JavaScript"</span>, index: 0, input: <span class="string">"I love JavaScript"</span>]</span><br><span class="line">string2.match(regex) // [<span class="string">"I love Regular Expression"</span>, <span class="string">"Regular Expression"</span>, index: 0, input: <span class="string">"I love Regular Expression"</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果去掉正则中的括号，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^I love JavaScript|Regular Expression$/;</span><br><span class="line">var string1 = <span class="string">"I love JavaScript"</span>;</span><br><span class="line">var string2 = <span class="string">"I love Regular Expression"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">string1.match(regex) // [<span class="string">"I love JavaScript"</span>, index: 0, input: <span class="string">"I love JavaScript"</span>]</span><br><span class="line">string2.match(regex) // [<span class="string">"Regular Expression"</span>, index: 7, input: <span class="string">"I love Regular Expression"</span>]</span><br></pre></td></tr></table></figure></li><li><p>可以看到，匹配字符串是<code>“I love JavaScript”</code>和<code>“Regular Expression”</code>，当然这不是我们想要的。</p></li></ul><h4 id="引用分组"><a href="#引用分组" class="headerlink" title="引用分组"></a>引用分组</h4><ul><li>这是括号一个<strong>重要的作用</strong>，有了它，我们就可以进行<strong>数据提取</strong>，以及更强大的<strong>替换操作</strong>。而要使用它带来的好处，必须配合使用实现环境的API。</li><li><p>以日期为例。假设格式是<code>yyyy-mm-dd</code>的，我们可以先写一个简单的正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/;</span><br></pre></td></tr></table></figure></li><li><p>然后再修改成括号版的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br></pre></td></tr></table></figure></li><li><p>使用括号版的正则，能方便地实现<strong>数据的提取和替换</strong>功能。</p></li></ul><h5 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h5><ul><li><p>比如提取出年、月、日，可以这么做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">console.log( string.match(regex) ); </span><br><span class="line">// =&gt; [<span class="string">"2017-06-12"</span>, <span class="string">"2017"</span>, <span class="string">"06"</span>, <span class="string">"12"</span>, index: 0, input: <span class="string">"2017-06-12"</span>]</span><br></pre></td></tr></table></figure></li><li><p>match返回的一个数组，第一个元素是<strong>整体匹配结果</strong>，然后是<strong>各个分组（括号里）匹配的内容</strong>，然后是<strong>匹配下标(index)</strong>，最后是<strong>输入的文本(input)</strong>。</p></li><li><strong>注意</strong>：如果正则是否有修饰符<code>g</code>，match返回的数组格式是不一样的。</li><li><p>另外也可以使用正则对象的exec方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">console.log( regex.exec(string) ); </span><br><span class="line">// =&gt; [<span class="string">"2017-06-12"</span>, <span class="string">"2017"</span>, <span class="string">"06"</span>, <span class="string">"12"</span>, index: 0, input: <span class="string">"2017-06-12"</span>]</span><br></pre></td></tr></table></figure></li><li><p>同时，也可以使用构造函数的全局属性<code>$1</code>至<code>$9</code>来获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line"></span><br><span class="line">regex.test(string); // 正则操作即可，例如</span><br><span class="line">// regex.exec(string);</span><br><span class="line">// string.match(regex);</span><br><span class="line"></span><br><span class="line">console.log(RegExp.<span class="variable">$1</span>); // <span class="string">"2017"</span></span><br><span class="line">console.log(RegExp.<span class="variable">$2</span>); // <span class="string">"06"</span></span><br><span class="line">console.log(RegExp.<span class="variable">$3</span>); // <span class="string">"12"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul><li><p>比如，想把<code>yyyy-mm-dd</code>格式，替换成<code>mm/dd/yyyy</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="string">"<span class="variable">$2</span>/<span class="variable">$3</span>/<span class="variable">$1</span>"</span>);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li><li><p>其中replace中的<strong>第二个参数</strong>里用<code>$1</code>、<code>$2</code>、<code>$3</code>指代相应的分组。等价于如下的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> RegExp.<span class="variable">$2</span> + <span class="string">"/"</span> + RegExp.<span class="variable">$3</span> + <span class="string">"/"</span> + RegExp.<span class="variable">$1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li><li><p>也等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="keyword">function</span>(match, year, month, day) &#123;</span><br><span class="line"><span class="built_in">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><ul><li>除了使用<strong>相应API</strong>来引用分组，也可以在<strong>正则本身里引用分组</strong>。但<strong>只能引用之前出现的分组</strong>，即<strong>反向引用</strong>。</li><li><p>还是以日期为例。比如要写一个正则支持匹配如下三种格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-06-12</span><br><span class="line"></span><br><span class="line">2016/06/12</span><br><span class="line"></span><br><span class="line">2016.06.12</span><br></pre></td></tr></table></figure></li><li><p>最先可能想到的正则是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/;</span><br><span class="line">var string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line">var string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line">var string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string4) ); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>其中/和.需要转义。虽然匹配了要求的情况，但也匹配<code>“2016-06/12”</code>这样的数据。</p></li><li><p>如果<strong>要求分割符前后一致</strong>则需要<strong>使用反向引用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br><span class="line">var string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line">var string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line">var string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string4) ); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>注意正则表达式里面的<code>\1</code>，表示的引用之前的那个分组<code>(-|\/|.)</code>。不管它匹配到什么（比如<code>-</code>），<code>\1</code>都<strong>匹配</strong>那个<strong>同样的具体某个字符</strong>。</p></li><li>知道了<code>\1</code>的含义后，那么<code>\2</code>和<code>\3</code>的概念也就理解了，即分别指代<strong>第二个</strong>和<strong>第三个分组</strong>。</li></ul><h5 id="括号嵌套怎么办？"><a href="#括号嵌套怎么办？" class="headerlink" title="括号嵌套怎么办？"></a>括号嵌套怎么办？</h5><ul><li>以<strong>左括号（开括号）</strong>为准。比如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</span><br><span class="line">var string = <span class="string">"1231231233"</span>;</span><br><span class="line">console.log( regex.test(string) ); // <span class="literal">true</span></span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"1231231233"</span>, <span class="string">"123"</span>, <span class="string">"1"</span>, <span class="string">"23"</span>, <span class="string">"3"</span>, index: 0, input: <span class="string">"1231231233"</span>]</span><br><span class="line">console.log( RegExp.<span class="variable">$1</span> ); // 123</span><br><span class="line">console.log( RegExp.<span class="variable">$2</span> ); // 1</span><br><span class="line">console.log( RegExp.<span class="variable">$3</span> ); // 23</span><br><span class="line">console.log( RegExp.<span class="variable">$4</span> ); // 3</span><br></pre></td></tr></table></figure></li></ul><h5 id="10表示什么？"><a href="#10表示什么？" class="headerlink" title="\10表示什么？"></a>\10表示什么？</h5><ul><li>有可能会产生这样的疑问，即<code>\10</code>是表示第10个分组，还是<code>\1</code>和<code>0</code>呢？答案是<strong>前者</strong>，虽然一个正则里出现\10比较罕见。测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(<span class="comment">#) \10+/;</span></span><br><span class="line">var string = <span class="string">"123456789# ######"</span></span><br><span class="line">console.log( regex.test(string) ); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="引用不存在的分组会怎样？"><a href="#引用不存在的分组会怎样？" class="headerlink" title="引用不存在的分组会怎样？"></a>引用不存在的分组会怎样？</h5><ul><li>因为<strong>反向引用</strong>是<strong>引用前面的分组</strong>，但我们在正则里<strong>引用了不存在的分组时</strong>，此时正则<strong>不会报错</strong>，只是<strong>匹配反向引用的字符本身</strong>。例如<code>\2</code>，就匹配<code>“\2”</code>。注意<code>“\2”</code>表示<strong>对2进行了转义</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\1\2\3\4\5\6\7\8\9/;</span><br><span class="line">console.log( regex.test(<span class="string">"\1\2\3\4\5\6\7\8\9"</span>) ); </span><br><span class="line">console.log( <span class="string">"\1\2\3\4\5\6\7\8\9"</span>.split(<span class="string">""</span>) ); //  [<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"8"</span>, <span class="string">"9"</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h4><ul><li>之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是<strong>捕获型分组</strong>。</li><li><p>如果<strong>只想要括号最原始的功能</strong>，但<strong>不会引用它</strong>，即，既不在API里引用，也不在正则里反向引用。此时可以<strong>使用非捕获分组<code>(?:p)</code></strong>，例如本文第一个例子可以修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(?:ab)+/g;</span><br><span class="line">var string = <span class="string">"ababa abbb ababab"</span>;</span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"abab"</span>, <span class="string">"ab"</span>, <span class="string">"ababab"</span>]</span><br></pre></td></tr></table></figure></li><li><p>这样使用括号匹配到的数据，将不能在API里或正则里反向引用。</p></li></ul><h4 id="相关案例"><a href="#相关案例" class="headerlink" title="相关案例"></a>相关案例</h4><h5 id="字符串trim方法模拟"><a href="#字符串trim方法模拟" class="headerlink" title="字符串trim方法模拟"></a>字符串trim方法模拟</h5><ul><li><code>trim</code>方法是<strong>去掉字符串的开头和结尾的空白符</strong>。有两种思路去做。</li><li><p><strong>第一种</strong>，匹配到开头和结尾的空白符，然后替换成空字符。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trim(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/^\s+|\s+$/g, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(<span class="string">"  foobar   "</span>) ); // <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>第二种</strong>，匹配整个字符串，然后<strong>用引用来提取出相应的数据</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trim(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/^\s*(.*?)\s*$/g, <span class="string">"<span class="variable">$1</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(<span class="string">"  foobar   "</span>) ); // <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></li><li><p>这里使用了惰性匹配<code><em>?</em></code>，不然也会<em>*匹配最后一个空格之前的所有空格</em>。</p></li><li>第一种方法效率高。</li></ul><h5 id="将每个单词的首字母转换为大写"><a href="#将每个单词的首字母转换为大写" class="headerlink" title="将每个单词的首字母转换为大写"></a>将每个单词的首字母转换为大写</h5><ul><li>思路是<strong>找到每个单词的首字母</strong>，当然这里<strong>不使用非捕获匹配也是可以的</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> titleize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.toLowerCase().replace(/(?:^|\s)\w/g, <span class="keyword">function</span>(c) &#123;</span><br><span class="line"><span class="built_in">return</span> c.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( titleize(<span class="string">'my name is epeli'</span>) ); // <span class="string">"My Name Is Epeli"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="驼峰化"><a href="#驼峰化" class="headerlink" title="驼峰化"></a>驼峰化</h5><ul><li><p>比如对<code>‘-moz-transform’</code>进行驼峰化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> camelize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/[-_\s]+(.)?/g, <span class="keyword">function</span>(match, firstLetter) &#123;</span><br><span class="line"><span class="built_in">return</span> firstLetter ? firstLetter.toUpperCase() : <span class="string">''</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( camelize(<span class="string">'-moz-transform'</span>) ); // MozTransform</span><br></pre></td></tr></table></figure></li><li><p>其中<strong>分组<code>(.)</code>表示首字母</strong>，单词的界定，<strong>前面的字符</strong>可以是多个连字符、下划线以及空白符（中括号规定）。正则后面的<code>?</code>的目的，是为了应对str尾部的字符可能不是单词字符，比如str是<code>‘-moz-transform ‘</code>。</p></li></ul><h5 id="中划线化"><a href="#中划线化" class="headerlink" title="中划线化"></a>中划线化</h5><ul><li>驼峰化的逆过程，比如对<code>‘MozTransform’</code>进行中划线化：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dasherize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/([A-Z])/g, <span class="string">'-$1'</span>).replace(/[-_\s]+/g, <span class="string">'-'</span>).toLowerCase();</span><br><span class="line">    // 前一个replace结果：-Moz-Transform</span><br><span class="line">    // 后一个replace结果：-Moz-Transform</span><br><span class="line">    // 最后使用toLowerCase：-moz-transform</span><br><span class="line">&#125;</span><br><span class="line">console.log( dasherize(<span class="string">'MozTransform'</span>) ); // -moz-transform</span><br></pre></td></tr></table></figure></li></ul><h5 id="匹配成对标签"><a href="#匹配成对标签" class="headerlink" title="匹配成对标签"></a>匹配成对标签</h5><ul><li><p>要求匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;regular expression&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;laoyao <span class="built_in">bye</span> <span class="built_in">bye</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>不匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;wrong!&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>匹配一个开标签，可以使用正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;[^&gt;]+&gt;</span><br></pre></td></tr></table></figure></li><li><p>匹配一个闭标签，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;\/[^&gt;]+&gt;</span><br></pre></td></tr></table></figure></li><li><p>但是要求<strong>匹配成对标签</strong>，那就需要<strong>使用反向引用</strong>，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</span><br><span class="line">var string1 = <span class="string">"&lt;title&gt;regular expression&lt;/title&gt;"</span>;</span><br><span class="line">var string2 = <span class="string">"&lt;p&gt;laoyao bye bye&lt;/p&gt;"</span>;</span><br><span class="line">var string3 = <span class="string">"&lt;title&gt;wrong!&lt;/p&gt;"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>其中开标签增加括号版，使用括号的目的是为了后面<strong>使用反向引用</strong>，而提供分组。闭标签使用了反向引用。</p></li><li>另外，<code>[\d\D]</code>的意思是，这个字符是数字或者不是数字，因此，也就是<strong>匹配任意字符</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不管哪门语言中都有括号。&lt;strong&gt;正则表达式&lt;/strong&gt;也是一门语言，而括号的存在使这门语言更为强大。&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;括号的使用&lt;/strong&gt;是否得心应手，是衡量对正则的掌握水平的一个侧面标准。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="正则表达式" scheme="https://chongtianhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Express使用进阶：cookie-parser中间件实现深入剖析</title>
    <link href="https://chongtianhong.github.io/2018/05/30/cookieParse/"/>
    <id>https://chongtianhong.github.io/2018/05/30/cookieParse/</id>
    <published>2018-05-30T08:12:21.000Z</published>
    <updated>2018-09-01T11:56:04.082Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><code>cookie-parser</code>是Express的中间件，用来<strong>实现cookie的解析</strong>，是官方脚手架内置的中间件之一。</li><li>它的使用非常简单，但在使用过程中偶尔也会遇到问题。一般都是因为对<code>Express + cookie-parser</code>的<strong>签名、验证机制</strong>不了解导致的。</li><li>本文深入讲解<code>Express + cookie-parser</code>的<strong>签名和验证</strong>的实现机制，以及cookie签名是如何<strong>增强网站的安全性</strong>的。<a id="more"></a></li></ul><h4 id="cookie特点"><a href="#cookie特点" class="headerlink" title="cookie特点"></a>cookie特点</h4><ul><li>cookie 保存在<strong>浏览器</strong>本地；</li><li>正常设置的 cookie 是不加密的，用户可以自由看到；</li><li>用户可以删除 cookie，或者禁用它；</li><li>cookie 可以<strong>被篡改</strong>；</li><li>cookie 可以用于XSS攻击；</li><li>cookie <strong>存储量很小</strong>。</li></ul><h4 id="cookie的创建"><a href="#cookie的创建" class="headerlink" title="cookie的创建"></a>cookie的创建</h4><ul><li><p>Express直接提供了api，只需要在需要使用的地方调用如下api即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(name, value [, options]);</span><br><span class="line"></span><br><span class="line">// name: 类型为String</span><br><span class="line">// value: 类型为String和Object，如果是Object会在cookie.serialize()之前自动调用JSON.stringify对其进行处理</span><br><span class="line">// Option: 类型为对象，可使用的属性如下:</span><br><span class="line">domain：cookie在什么域名下有效，类型为String,。默认为网站域名</span><br><span class="line">expires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。</span><br><span class="line">httpOnly: 只能被web server访问，类型Boolean，默认<span class="literal">false</span>，设置为<span class="literal">true</span>时不允许客户端脚本访问，能有效的防止XSS攻击。</span><br><span class="line">maxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。</span><br><span class="line">path: cookie在什么路径下有效，默认为<span class="string">'/'</span>，类型为String</span><br><span class="line">secure：只能被HTTPS使用，类型Boolean，默认为<span class="literal">false</span></span><br><span class="line">signed：使用签名，类型Boolean，默认为<span class="literal">false</span>。`express会使用req.secret来完成签名，需要cookie-parser配合使用`</span><br></pre></td></tr></table></figure></li><li><p>Express就会将其填入<code>Response Header</code>中的<code>Set-Cookie</code>，达到<strong>在浏览器中设置cookie</strong>的作用。</p></li><li>用例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(<span class="string">'name'</span>, <span class="string">'koby'</span>, &#123; domain: <span class="string">'.example.com'</span>, path: <span class="string">'/admin'</span>, secure: <span class="literal">true</span> &#125;);</span><br><span class="line">//cookie的有效期为900000ms</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>, <span class="string">'1'</span>, &#123; expires: new Date(Date.now() + 900000), httpOnly: <span class="literal">true</span> &#125;);</span><br><span class="line">//cookie的有效期为900000ms</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>, <span class="string">'1'</span>, &#123; maxAge: 900000, httpOnly: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">//cookie的value为对象</span><br><span class="line">res.cookie(<span class="string">'cart'</span>, &#123; items: [1,2,3] &#125;);</span><br><span class="line">res.cookie(<span class="string">'cart'</span>, &#123; items: [1,2,3] &#125;, &#123; maxAge: 900000 &#125;);</span><br><span class="line"></span><br><span class="line">res.cookie(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; signed: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="cookie的删除"><a href="#cookie的删除" class="headerlink" title="cookie的删除"></a>cookie的删除</h4><ul><li>Express直接提供了api，只需要在需要使用的地方调用如下api即可：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.clearCookie(name [, options]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="入门例子：cookie设置与解析"><a href="#入门例子：cookie设置与解析" class="headerlink" title="入门例子：cookie设置与解析"></a>入门例子：cookie设置与解析</h4><ul><li>先从最简单的例子来看下<code>cookie-parser</code>的使用，这里采用默认配置：<br>1、<strong>cookie设置</strong>：使用Express的内置方法<code>res.cookie()</code>。<br>2、<strong>cookie解析</strong>：使用<code>cookie-parser</code>中间件。</li><li><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var cookieParser = require(<span class="string">'cookie-parser'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">    console.log(req.cookies.nick); // 第二次访问，输出hongxb</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;  </span><br><span class="line">    res.cookie(<span class="string">'nick'</span>, <span class="string">'hongxb'</span>);</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li><li><p>在当前场景下，<code>cookie-parser</code>中间件大致实现如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">  req.cookies = cookie.parse(req.headers.cookie);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="进阶例子：cookie签名与解析"><a href="#进阶例子：cookie签名与解析" class="headerlink" title="进阶例子：cookie签名与解析"></a>进阶例子：cookie签名与解析</h4><ul><li>出于安全的考虑，我们通常需要<strong>对cookie进行签名</strong>。</li><li>改写例子有几个注意点：<br>1、<code>cookieParser</code>初始化时，传入<code>secret</code>作为签名的<strong>密钥</strong>。<br>2、设置cookie时，将<code>signed</code>设置为<code>true</code>，表示<strong>对即将设置的cookie进行签名</strong>。<br>3、获取cookie时，可以通过<code>req.cookies</code>获取<strong>未签名的cookie</strong>，也可以通过<code>req.signedCookies</code>获取<strong>使用签名的cookie</strong>。<br>4、当然如果想拿到<strong>浏览器传过来的cookie原始数据</strong>，总是可以通过express中的<code>req.headers.cookie</code>获得：</li><li><p>例子改写如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var cookieParser = require(<span class="string">'cookie-parser'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// 初始化中间件，传入的第一个参数为singed secret</span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">    console.log(req.cookies.nick); // undefined</span><br><span class="line">    console.log(req.signedCookies.nick); // hongxb</span><br><span class="line">    console.log(req.headers.cookie); // nick=s%3Ahongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;  </span><br><span class="line">    // 传入第三个参数 &#123;signed: <span class="literal">true</span>&#125;，表示要对cookie进行摘要计算</span><br><span class="line">    res.cookie(<span class="string">'nick'</span>, <span class="string">'hongxb'</span>, &#123;signed: <span class="literal">true</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li><li><p>可以看到，签名前的cookie值为<code>chyingp</code>，签名后的cookie值为<code>s%3Ahongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</code>，decode后为<code>s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</code>。</p></li><li>下面就来分析下，cookie的签名、解析是如何实现的。</li></ul><h4 id="cookie签名、验证实现剖析"><a href="#cookie签名、验证实现剖析" class="headerlink" title="cookie签名、验证实现剖析"></a>cookie签名、验证实现剖析</h4><ul><li>Express的内置方法<code>res.cookie()</code>完成cookie值的签名，中间件<code>cookie-parser</code>（<code>req.signedCookies</code>）实现签名cookie的解析。两者<strong>共用同一个密钥</strong>。</li></ul><h5 id="cookie签名"><a href="#cookie签名" class="headerlink" title="cookie签名"></a>cookie签名</h5><ul><li>Express对<strong>cookie的设置（包括签名）</strong>，都是通过<code>res.cookie()</code>这个方法实现的。</li><li><p>精简后的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res.cookie = <span class="keyword">function</span> (name, value, options) &#123;  </span><br><span class="line">    var secret = this.req.secret; // cookie-parser初始化的时候传入的</span><br><span class="line">    var signed = opts.signed;</span><br><span class="line"></span><br><span class="line">    // 如果 options.signed 为<span class="literal">true</span>，则对cookie进行签名</span><br><span class="line">    <span class="keyword">if</span> (signed) &#123;</span><br><span class="line">        val = <span class="string">'s:'</span> + sign(val, secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.append(<span class="string">'Set-Cookie'</span>, cookie.serialize(name, String(val), opts));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sign</code>为<strong>签名函数</strong>。伪代码如下，其实就是<strong>把cookie的原始值，跟hmac后的值拼接起来</strong>。</p></li><li><p><strong>注意</strong>：签名后的cookie值，包含了原始值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sign (val, secret) &#123;</span><br><span class="line">    <span class="built_in">return</span> val + <span class="string">'.'</span> + hmac(val, secret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码中的<code>req.secret</code>是<code>cookie-parser</code>初始化的时候传入的。如下伪代码所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var cookieParser = <span class="keyword">function</span> (secret) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">        req.secret = secret;</span><br><span class="line">        // ...</span><br><span class="line">        next();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>));</span><br></pre></td></tr></table></figure></li></ul><h5 id="签名cookie解析"><a href="#签名cookie解析" class="headerlink" title="签名cookie解析"></a>签名cookie解析</h5><ul><li>“解析”签名cookie这个阶段，中间件主要做了两件事：<br>1、将签名cookie对应的<strong>原始值提取</strong>出来；<br>2、<strong>验证签名cookie是否合法</strong>。</li><li><p>实现代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// str：签名后的cookie，比如 <span class="string">"s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA"</span></span><br><span class="line">// secret：密钥，比如 <span class="string">"secret"</span></span><br><span class="line"><span class="keyword">function</span> signedCookie(str, secret) &#123;</span><br><span class="line"></span><br><span class="line">    // 检查是否 s: 开头，确保只对签过名的cookie进行解析</span><br><span class="line">    <span class="keyword">if</span> (str.substr(0, 2) !== <span class="string">'s:'</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 校验签名的值是否合法，如合法，返回<span class="literal">true</span>，否则，返回<span class="literal">false</span></span><br><span class="line">    var isValid = unsign(str.slice(2), secret);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断、提取cookie原始值比较简单。只是<code>unsign</code>方法名比较有迷惑性，该方法用于<strong>对签名进行合法校验</strong>。</p></li><li><code>unsign</code>方法主要做了以下三件事：<br>1、从传入的cookie值中，分别提取出原始值A1、签名值B1。<br>2、用同样的密钥对A1进行签名，得到A2。<br>3、根据A2、B1是否相等，判断签名是否合法。</li><li>大致代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> unsign(val, secret)&#123;</span><br><span class="line">    var A1 = val.slice(0, val.lastIndexOf(<span class="string">'.'</span>)),  // hongxb</span><br><span class="line">        B1 = val, // hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br><span class="line">        A2 = sign(A1, secret); // hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> B1 == A2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="cookie签名的作用"><a href="#cookie签名的作用" class="headerlink" title="cookie签名的作用"></a>cookie签名的作用</h4><ul><li>主要是出于安全考虑，<strong>防止cookie被篡改</strong>，增强安全性。</li><li>举个小例子来看下cookie签名是如何实现防篡改的。</li><li><p>基于前面的例子展开。假设网站通过<code>nick</code>这个cookie来<strong>区分当前登录的用户</strong>。在前面例子中，登录用户的cookie中，<code>nick</code>对应的值如下：(decode后的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br></pre></td></tr></table></figure></li><li><p>此时，有人试图修改这个cookie值，来达到伪造身份的目的。比如修改成<code>xiaoming</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:xiaoming.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br></pre></td></tr></table></figure></li><li><p>当网站收到请求，对签名cookie进行解析，发现签名验证不通过。由此可判断，cookie是伪造的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmac(<span class="string">"xiaoming"</span>, <span class="string">"secret"</span>) !== <span class="string">"2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA"</span></span><br></pre></td></tr></table></figure></li><li><p>cookie签名缺点：<br>1、cookie值依然能被看到。<br>2、读取签名过的cookie必须进行解签。<br>3、增加cookie大小，浪费空间。</p></li></ul><h4 id="签名就一定能够确保安全吗"><a href="#签名就一定能够确保安全吗" class="headerlink" title="签名就一定能够确保安全吗"></a>签名就一定能够确保安全吗</h4><ul><li>上个小节的例子，仅通过<code>nick</code>这个cookie的值来判断登录的是哪个用户，这是一个非常糟糕的设计。虽然<strong>在密钥未知的情况下，很难伪造签名cookie</strong>。但<strong>用户名相同的情况下，签名也是相同的</strong>。这种情况下，其实是很容易伪造的。</li><li>另外，开源组件的算法是公开的，因此密钥的安全性就成了关键，要<strong>确保密钥不泄露</strong>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>发送cookie：使用res.cookie直接设置cookie。</li><li>获取cookie时，可以通过<code>req.cookies</code>获取<strong>未签名的cookie</strong>，也可以通过<code>req.signedCookies</code>获取<strong>使用签名的cookie</strong>。</li><li>使用签名cookie可防止cookie被修改，通过在<strong>设置cookie的时候</strong>配置<code>signed</code>属性值为<code>true</code>。</li><li>配置<code>cookie-parser</code>中间件的时候需要传参，作为签名的密钥。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cookie-parser&lt;/code&gt;是Express的中间件，用来&lt;strong&gt;实现cookie的解析&lt;/strong&gt;，是官方脚手架内置的中间件之一。&lt;/li&gt;
&lt;li&gt;它的使用非常简单，但在使用过程中偶尔也会遇到问题。一般都是因为对&lt;code&gt;Express + cookie-parser&lt;/code&gt;的&lt;strong&gt;签名、验证机制&lt;/strong&gt;不了解导致的。&lt;/li&gt;
&lt;li&gt;本文深入讲解&lt;code&gt;Express + cookie-parser&lt;/code&gt;的&lt;strong&gt;签名和验证&lt;/strong&gt;的实现机制，以及cookie签名是如何&lt;strong&gt;增强网站的安全性&lt;/strong&gt;的。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://chongtianhong.github.io/tags/Express/"/>
    
      <category term="cookie-parser" scheme="https://chongtianhong.github.io/tags/cookie-parser/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化（CommonJs、AMD和CMD）</title>
    <link href="https://chongtianhong.github.io/2018/05/29/frontEndModule/"/>
    <id>https://chongtianhong.github.io/2018/05/29/frontEndModule/</id>
    <published>2018-05-29T12:27:50.000Z</published>
    <updated>2018-08-31T15:34:37.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>前端模块规范有三种，分别是<code>CommonJs</code>、<code>AMD</code>和<code>CMD</code>。</li><li><code>CommonJs</code>用在服务器端，<code>AMD</code>和<code>CMD</code>用在浏览器环境。</li><li><code>AMD</code>是<strong>RequireJS</strong>在推广过程中对模块定义的规范化产出。</li><li><code>CMD</code>是<strong>SeaJS</strong>在推广过程中对模块定义的规范化产出。<a id="more"></a></li><li><code>AMD</code>：提前执行（异步加载：依赖先执行）/ 延迟执行（RequireJS 从 2.0 开始，也改成可以延迟执行）。</li><li><code>CMD</code>：延迟执行（运行到需加载，根据顺序执行）。</li></ul><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h5 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h5><ul><li>模块就是实现特定功能的一组方法。</li><li><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m1</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m2</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，组成一个模块。使用的时候，直接调用就行了。</p></li><li>这种做法的<strong>缺点</strong>很明显：<strong>“污染”了全局变量</strong>，<strong>无法保证不与其他模块发生变量名冲突</strong>，而且<strong>模块成员之间看不出直接关系</strong>。</li></ul><h5 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h5><ul><li><p>为了解决上面的缺点，可以<strong>把模块写成一个对象</strong>，所有的<strong>模块成员都放到</strong>这个<strong>对象里面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var module1 = new Object(&#123;</span><br><span class="line"></span><br><span class="line">　　_count : 0,</span><br><span class="line"></span><br><span class="line">　　m1 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;,</span><br><span class="line"></span><br><span class="line">　　m2 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，都封装在module1对象里。使用的时候，就是<strong>调用这个对象的属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure></li><li><p>但是，这样的写法会<strong>暴露所有模块成员</strong>，<strong>内部状态可以被外部改写</strong>。比如，外部代码可以直接改变内部计数器的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1._count = 5;</span><br></pre></td></tr></table></figure></li></ul><h5 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h5><ul><li><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到<strong>不暴露私有成员</strong>的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    var _count = 0;</span><br><span class="line"></span><br><span class="line">    var m1 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var m2 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">    　　m1 : m1,</span><br><span class="line">    　　m2 : m2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>使用上面的写法，<strong>外部代码无法读取内部的</strong><code>_count</code><strong>变量</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.info(module1._count); //undefined</span><br></pre></td></tr></table></figure></li><li><p><code>module1</code>就是Javascript模块的基本写法。</p></li></ul><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ul><li><p><code>CommonJs</code>是<strong>服务器端模块</strong>的规范，由Node推广使用。由于服务端编程的复杂性，如果没有模块很难与操作系统及其他应用程序互动。使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">    <span class="built_in">return</span> add(val, 1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">var increment = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">var a = increment(1); //2</span><br></pre></td></tr></table></figure></li><li><p>根据CommonJS规范：</p><ul><li>一个单独的文件就是一个模块。<strong>每一个模块都是一个单独的作用域</strong>，也就是说，在该<strong>模块内部定义的变量，无法被其他模块读取</strong>，除非定义为<code>global</code>对象的属性。<br>-<strong> 输出模块变量</strong>的最好方法是<strong>使用<code>module.exports</code>对象</strong>。</li><li><strong>加载模块</strong>使用<code>require</code>方法，该方法读取一个文件并执行，返回文件内部的<code>module.exports</code>对象。</li></ul></li><li>仔细看上面的代码，可以发现<strong><code>require</code>是同步的</strong>。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。</li><li>然而，这在浏览器端就会有很大问题。因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，<strong>浏览器处于”假死”状态</strong>。因此，<strong>浏览器端的模块，不能采用”同步加载”（synchronous）</strong>，只能采用”异步加载”（asynchronous）。</li><li><strong>浏览器端</strong>，加载 JavaScript 最佳、最容易的方式是在 document 中插入<code>&lt;script&gt;</code>标签。但<strong>脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载</strong>。</li><li><strong>解决思路之一</strong>是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</li><li><p><strong>另一种解决思路</strong>是，用一套标准模板来封装模块定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  // The module code goes here</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这套模板代码为模块加载器提供了机会，使其能在<strong>模块代码执行之前</strong>，对模块代码进行<strong>静态分析</strong>，并<strong>动态生成依赖列表</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">            sum += args[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">    exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">        <span class="built_in">return</span> add(val, 1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var inc = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">    inc(1); // 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ul><li>AMD是<code>“Asynchronous Module Definition”</code>的缩写，意思就是”异步模块定义”。由于不是JavaScript原生支持，<strong>使用AMD规范进行页面开发需要用到对应的库函数</strong>，也就是<code>RequireJS</code>，实际上AMD 是<code>RequireJS</code>在推广过程中对模块定义的规范化的产出。</li><li>AMD采用<strong>异步方式</strong>加载模块，模块的加载不影响它后面语句的运行。所有<strong>依赖这个模块的语句，都定义在一个回调函数中</strong>，等到加载完成之后，这个回调函数才会运行。</li><li><code>RequireJS</code>主要解决两个问题：<ul><li><strong>多个JS文件可能有依赖关系</strong>，被依赖的文件需要早于依赖它的文件加载到浏览器；</li><li><strong>JS加载的时候浏览器会停止页面渲染</strong>，加载文件越多，页面失去响应时间越长。</li></ul></li><li><code>RequireJS</code>也采用<code>require()</code>语句加载模块，但是<strong>不同于CommonJS，它要求两个参数</strong>，语法：<code>require([module], callback)</code>:<ul><li>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；</li><li>第二个参数callback，则是加载成功之后的回调函数。</li></ul></li><li><p>将使用<strong>不适用于浏览器环境的CommonJS规范</strong>的代码改成<strong>符合AMD规范</strong>的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* CommonJS */</span><br><span class="line">var math = require(<span class="string">'math'</span>);</span><br><span class="line">math.add(2, 3);</span><br><span class="line"></span><br><span class="line">/* AMD */</span><br><span class="line">require([<span class="string">'math'</span>], <span class="keyword">function</span> (math) &#123;</span><br><span class="line">    math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>math.add()</code>与<code>math</code>模块加载不是同步的，浏览器不会发生假死。所以很显然，<strong>AMD比较适合浏览器环境</strong>。</p></li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><ul><li>CMD(Common Module Definition)即<strong>通用模块定义</strong>，CMD规范是国内发展出来的，就像AMD有个<code>RequireJS</code>，CMD有个浏览器的实现<code>SeaJS</code>，<code>SeaJS</code>要解决的问题和<code>RequireJS</code>一样，只不过在<strong>模块定义方式</strong>和<strong>模块加载（可以说运行、解析）时机</strong>上有所不同。</li><li><p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    // require是可以把其他模块导入进来的一个参数;</span><br><span class="line">    // exports是可以把模块内的一些属性和方法导出的;</span><br><span class="line">    // module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</span><br><span class="line"></span><br><span class="line">    // 模块代码</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>AMD是<strong>依赖关系前置</strong>，在定义模块的时候就要声明其依赖的模块；</p></li><li><p>CMD是<strong>按需加载依赖就近</strong>，只有在用到某个模块的时候再去require：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    var b = require(<span class="string">'./b'</span>) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">    // ... </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD 默认推荐的是</span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    b.doSomething()</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>seajs使用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义模块  myModule.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var $ = require(<span class="string">'jquery.js'</span>)</span><br><span class="line">    $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">    exports.data = 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="keyword">function</span>(my)&#123;</span><br><span class="line">    var star = my.data;</span><br><span class="line">    console.log(star);  // 1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/frontEndModule.png" alt="模块方案" style="border:none" width="300"></p><ul><li>AMD和CMD的区别：<ul><li>CMD 推崇<strong>依赖就近</strong>；AMD 推崇<strong>依赖前置</strong>；</li><li>CMD 是<strong>延迟执行</strong>；AMD 是<strong>提前执行</strong>；</li><li>CMD <strong>性能好</strong>，因为只有用户需要的时候才执行；AMD<strong>用户体验好</strong>，因为没有延迟，依赖模块提前执行了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前端模块规范有三种，分别是&lt;code&gt;CommonJs&lt;/code&gt;、&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CommonJs&lt;/code&gt;用在服务器端，&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;用在浏览器环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AMD&lt;/code&gt;是&lt;strong&gt;RequireJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMD&lt;/code&gt;是&lt;strong&gt;SeaJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="CommonJs" scheme="https://chongtianhong.github.io/tags/CommonJs/"/>
    
      <category term="AMD规范" scheme="https://chongtianhong.github.io/tags/AMD%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>SeaJS中use函数用法实例分析</title>
    <link href="https://chongtianhong.github.io/2018/05/28/SeaJS/"/>
    <id>https://chongtianhong.github.io/2018/05/28/SeaJS/</id>
    <published>2018-05-28T09:34:57.000Z</published>
    <updated>2018-08-30T13:31:19.807Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这篇文章主要介绍了<strong>SeaJS</strong>中<strong>use函数</strong>的用法，结合实例形式分析了<strong>use函数</strong>加载模块的使用方法与相关操作技巧。<a id="more"></a></li><li><p>有了<code>define</code>等<strong>模块定义规范</strong>的实现，我们可以开发出很多模块。但光有一堆模块不管用，我们还得让它们能跑起来。在 SeaJS 里，要<strong>启动模块系统</strong>很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>seajs.use</code>用来<strong>在页面中加载模块</strong>。通过<code>use</code>方法，可以在页面中加载任意模块。</p></li><li><p>语法：<code>seajs.use seajs.use(id, callback?)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 加载模块 main，并在加载完成时，执行指定回调</span><br><span class="line">seajs.use(<span class="string">'./main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>use</code>方法还可以<strong>一次加载多个模块</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 并发加载模块 a 和模块 b，并在都加载完成时，执行指定回调</span><br><span class="line">seajs.use([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123;</span><br><span class="line">    a.init();</span><br><span class="line">    b.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>callback</code>参数可选</strong>。当<strong>只加载一个模块，且不需要<code>callback</code>时</strong>，可以用<code>data-main</code>属性来简化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-main=<span class="string">"./main"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>上面的代码等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>SeaJS</strong>还提供<code>data-config</code>来<strong>加载配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-config=<span class="string">"path/to/config"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>data-config</code>等价：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">    preload: [<span class="string">'path/to/config'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>路径解析规则</strong>与<code>seajs.use</code>一致。</p></li><li><p>再看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/js/lib/sea.js"</span> data-config=<span class="string">"/js/config.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">seajs.use(<span class="string">'/js/main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.banner_focus(<span class="string">'#focus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>main</code>为<strong>模块名</strong>，<code>main.method</code>为<strong>模块定义的函数</strong>，<strong>可以传递参数</strong>过去。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;这篇文章主要介绍了&lt;strong&gt;SeaJS&lt;/strong&gt;中&lt;strong&gt;use函数&lt;/strong&gt;的用法，结合实例形式分析了&lt;strong&gt;use函数&lt;/strong&gt;加载模块的使用方法与相关操作技巧。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="SeaJS" scheme="https://chongtianhong.github.io/tags/SeaJS/"/>
    
  </entry>
  
  <entry>
    <title>Node.js使用MySQL数据库时对RowDataPacket对象的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/27/RowDataPacket/"/>
    <id>https://chongtianhong.github.io/2018/05/27/RowDataPacket/</id>
    <published>2018-05-27T03:30:12.000Z</published>
    <updated>2018-08-29T13:57:00.970Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>使用Node.js连接数据库查询表后</strong>，拿到的<strong>数据是一个数组</strong>，数组里面是<strong>JSON格式的数据</strong>，但是每个JSON前面都有一个<strong>RowDataPacket</strong>，这就导致<strong>前端获取到这些数据</strong>后不得不<strong>进行一些格式处理</strong>。<a id="more"></a></li><li><p>未处理前是这个样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">  RowDataPacket &#123;</span><br><span class="line">    contractname: <span class="string">'datatime'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdfsd'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: null,</span><br><span class="line">    uploaddate: <span class="string">'2018-07-16 16:36:08'</span>,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  RowDataPacket &#123;</span><br><span class="line">    contractname: <span class="string">'sd'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdf'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: <span class="string">''</span>,</span><br><span class="line">    uploaddate: null,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>我们可以在拿到数据后，进行一个<strong>JSON的格式化处理</strong>，即利用<code>JSON.stringify()</code>把对象转为对象字符串，可<strong>去掉RowDataPacket</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataString = JSON.stringify(results);</span><br><span class="line">var data = JSON.parse(dataString);</span><br></pre></td></tr></table></figure></li><li><p>其中<code>results</code>就是<strong>从数据库拿到的数据</strong>，通过这样的格式化后，我们得到最终的数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">  &#123; </span><br><span class="line">    contractname: <span class="string">'datatime'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdfsd'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: null,</span><br><span class="line">    uploaddate: <span class="string">'2018-07-16 16:36:08'</span>,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; </span><br><span class="line">    contractname: <span class="string">'sd'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdf'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: <span class="string">''</span>,</span><br><span class="line">    uploaddate: null,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用Node.js连接数据库查询表后&lt;/strong&gt;，拿到的&lt;strong&gt;数据是一个数组&lt;/strong&gt;，数组里面是&lt;strong&gt;JSON格式的数据&lt;/strong&gt;，但是每个JSON前面都有一个&lt;strong&gt;RowDataPacket&lt;/strong&gt;，这就导致&lt;strong&gt;前端获取到这些数据&lt;/strong&gt;后不得不&lt;strong&gt;进行一些格式处理&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="MySQL" scheme="https://chongtianhong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题整理二（JS部分）</title>
    <link href="https://chongtianhong.github.io/2018/05/26/interviewMap2/"/>
    <id>https://chongtianhong.github.io/2018/05/26/interviewMap2/</id>
    <published>2018-05-26T11:35:34.000Z</published>
    <updated>2018-09-03T08:48:19.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS-Part"><a href="#JS-Part" class="headerlink" title="JS Part"></a>JS Part</h4><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><ul><li>每个对象都有<code>__proto__</code>属性，指向了<strong>创建该对象的构造函数的原型</strong>。其实这个属性指向了<code>[[prototype]]</code>，但是<strong><code>[[prototype]]</code>是内部属性</strong>，我们并<strong>不能访问到</strong>，所以使用<code>__proto__</code>来访问。<a id="more"></a></li><li><strong>对象</strong>可以<strong>通过<code>__proto__</code>来寻找不属于该对象的属性</strong>，<code>__proto__</code><strong>将对象连接起来</strong>组成了<strong>原型链</strong>。</li></ul><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><ul><li><strong>new操作符创建对象</strong>可以分为四个步骤：<br>1、创建一个空对象，这个对象的类型是<code>object</code>；<br>2、将<strong>所创建的实例对象</strong>的<code>__proto__</code>属性值设成<strong>构造函数</strong>的<code>prototype</code>属性值（关系：<code>instance.constructor.prototype = instance.__proto__</code>）；<br>3、执行<strong>构造函数</strong>中的代码，构造函数中的this指向新创建的对象；<br>4、返回该对象（如果构造器函数有返回值，则以该对象作为返回值。若没有return或return了基本类型，则将上述的新对象作为返回值）。</li><li>对于实例对象来说，都是通过<code>new</code>产生的，无论是<strong>使用构造函数创建对象</strong><code>function Foo()</code>还是<strong>使用字面量的方式创建对象</strong><code>let a = { b : 1 }</code>。</li><li><p>对于<strong>创建一个对象</strong>来说，<strong>更推荐使用字面量的方式创建对象</strong>（无论性能上还是可读性）。因为<strong>使用<code>new Object()</code>的方式创建对象</strong>需要<strong>通过作用域链一层层找到 Object</strong>，但是如果使用字面量的方式就没这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;&#125;</span><br><span class="line">// <span class="keyword">function</span> 就是个语法糖</span><br><span class="line">// 内部等同于 new Function()</span><br><span class="line"><span class="built_in">let</span> a = &#123; b: 1 &#125;</span><br><span class="line">// 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure></li><li><p>对于<code>new</code>来说，还需要<strong>注意运算符优先级</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Foo.getName();   // -&gt; 1</span><br><span class="line">new Foo().getName(); // -&gt; 2</span><br></pre></td></tr></table></figure></li><li><p><code>new Func()</code>的优先级大于<code>new Func</code>，所以对于上述代码来说可以这样划分执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new (Foo.getName());   </span><br><span class="line">(new Foo()).getName();</span><br></pre></td></tr></table></figure></li><li><p>对于第一个函数来说，先执行了<code>Foo.getName()</code>，所以结果为<code>1</code>；</p></li><li>对于第二个函数来说，先执行<code>new Foo()</code>产生了一个实例，然后通过原型链找到了<code>Foo</code>上的<code>getName</code>函数，所以结果为<code>2</code>。</li></ul><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><ul><li><code>instanceof</code>可以正确的判断对象的类型，因为内部机制是通过<strong>判断对象的原型链中是否能找到构造函数的<code>prototype</code></strong>。</li><li>试着实现一下<code>instanceof</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> instanceOf(left, right) &#123;</span><br><span class="line">    // 获得构造函数的原型</span><br><span class="line">    <span class="built_in">let</span> prototype = right.prototype</span><br><span class="line">    // 判断对象的类型是否等于构造函数的原型</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === null)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        // 获得实例对象的原型</span><br><span class="line">        left = left.__proto__</span><br><span class="line">    <span class="keyword">if</span> (prototype === left)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h5><ul><li>当执行 JS 代码时，会产生三种执行上下文：<ul><li>全局执行上下文；</li><li>函数执行上下文；</li><li>eval执行上下文。</li></ul></li><li>每个执行上下文中都有三个重要的属性：<ul><li><strong>变量对象（VO）</strong>，包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问；</li><li><strong>作用域链</strong>，JS 采用词法作用域，也就是说<strong>变量的作用域是在定义时就决定了</strong>；</li><li><strong>this</strong>。</li></ul></li><li><p>接下来看一个老生常谈的例子，<code>var</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() // call b</span><br><span class="line">console.log(a) // undefined</span><br><span class="line"></span><br><span class="line">var a = <span class="string">'Hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'call b'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这是因为函数和变量提升的原因。在生成执行上下文时，会有两个阶段。</p><ul><li>第一个阶段是创建<strong>变量对象（VO）</strong>的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，<strong>函数</strong>的话会<strong>将整个函数存入内存中</strong>，<strong>变量只声明并且赋值为 undefined</strong>；</li><li>所以在第二个阶段，也就是<strong>代码执行阶段</strong>，我们可以<strong>直接提前使用函数和变量</strong>。</li></ul></li><li>在提升的过程中，相同的函数会覆盖上一个函数，并且<strong>函数优先于变量提升</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() // call b second</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'call b fist'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'call b second'</span>)</span><br><span class="line">&#125;</span><br><span class="line">var b = <span class="string">'Hello world'</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JS-Part&quot;&gt;&lt;a href=&quot;#JS-Part&quot; class=&quot;headerlink&quot; title=&quot;JS Part&quot;&gt;&lt;/a&gt;JS Part&lt;/h4&gt;&lt;h5 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;每个对象都有&lt;code&gt;__proto__&lt;/code&gt;属性，指向了&lt;strong&gt;创建该对象的构造函数的原型&lt;/strong&gt;。其实这个属性指向了&lt;code&gt;[[prototype]]&lt;/code&gt;，但是&lt;strong&gt;&lt;code&gt;[[prototype]]&lt;/code&gt;是内部属性&lt;/strong&gt;，我们并&lt;strong&gt;不能访问到&lt;/strong&gt;，所以使用&lt;code&gt;__proto__&lt;/code&gt;来访问。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题整理一（JS部分）</title>
    <link href="https://chongtianhong.github.io/2018/05/25/interviewMap1/"/>
    <id>https://chongtianhong.github.io/2018/05/25/interviewMap1/</id>
    <published>2018-05-25T05:42:04.000Z</published>
    <updated>2018-08-30T13:31:02.087Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS-Part"><a href="#JS-Part" class="headerlink" title="JS Part"></a>JS Part</h4><h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><ul><li>JS 中分为<strong>七种内置类型</strong>，七种内置类型<strong>又分为两大类型</strong>：<strong>基本类型</strong>和<strong>对象（Object）</strong>。</li><li>基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</li><li>其中 <strong>JS 的数字类型是浮点类型的，没有整型</strong>。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。</li><li><code>NaN</code> 也属于 number 类型，并且<strong><code>NaN</code> 不等于自身</strong>。</li><li><p>对于<strong>基本类型</strong>来说，如果<strong>使用字面量的方式</strong>，那么<strong>这个变量只是个字面量</strong>，只有<strong>在必要的时候才会转换为对应的类型</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 111 // 这只是字面量，不是 number 类型</span><br><span class="line">a.toString() // 使用时候才会转换为对象类型</span><br></pre></td></tr></table></figure></li><li><p>对<strong>象（Object）</strong>是<strong>引用类型</strong>，在使用过程中会遇到<strong>浅拷贝</strong>和<strong>深拷贝</strong>的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123; name: <span class="string">'FE'</span> &#125;</span><br><span class="line"><span class="built_in">let</span> b = a</span><br><span class="line">b.name = <span class="string">'EF'</span></span><br><span class="line">console.log(a.name) // EF</span><br></pre></td></tr></table></figure></li></ul><h5 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h5><ul><li><p><code>typeof</code>对于<strong>基本类型</strong>，<strong>除了<code>null</code></strong>都可以显示正确的类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // <span class="string">'number'</span></span><br><span class="line">typeof <span class="string">'1'</span> // <span class="string">'string'</span></span><br><span class="line">typeof undefined // <span class="string">'undefined'</span></span><br><span class="line">typeof <span class="literal">true</span> // <span class="string">'boolean'</span></span><br><span class="line">typeof Symbol() // <span class="string">'symbol'</span></span><br><span class="line">typeof b // b 没有声明，但是还会显示 undefined</span><br></pre></td></tr></table></figure></li><li><p><code>typeof</code>对于<strong>对象</strong>，<strong>除了函数</strong>都会显示<code>object</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] // <span class="string">'object'</span></span><br><span class="line">typeof &#123;&#125; // <span class="string">'object'</span></span><br><span class="line">typeof console.log // <span class="string">'function'</span></span><br></pre></td></tr></table></figure></li><li><p>对于<code>null</code>来说，虽然它是<strong>基本类型</strong>，但是会<strong>显示 <code>object</code></strong>，这是一个存在很久了的 Bug：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof null // <span class="string">'object'</span></span><br><span class="line">/* 原因：</span><br><span class="line">因为在 JS 的最初版本中，使用的是 32 位系统，</span><br><span class="line">为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，</span><br><span class="line">然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class="line">虽然现在的内部类型判断代码已经改变了，</span><br><span class="line">但是对于这个 Bug 却是一直流传下来。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>如果我们想获得一个变量的正确类型，可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似<code>[object Type]</code>的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">type</span> = Object.prototype.toString;</span><br><span class="line">console.log(type.call(<span class="string">''</span>));//object String</span><br><span class="line">console.log(type.call([]));//object Array</span><br><span class="line">console.log(type.call(&#123;&#125;));//object Object</span><br><span class="line">console.log(type.call(<span class="literal">false</span>));//object Boolean</span><br><span class="line">console.log(type.call(null));//object Null</span><br><span class="line">console.log(type.call(undefined));//object Undefined</span><br><span class="line">console.log(type.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;));//object Function</span><br></pre></td></tr></table></figure></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><h5 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h5><ul><li>在条件判断时，除了<code>undefined</code>，<code>null</code>，<code>false</code>，<code>NaN</code>，<code>‘’</code>，<code>0</code>，<code>-0</code>，<strong>其他所有值都转为<code>true</code>，包括所有对象</strong>。</li></ul><h5 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h5><ul><li><p><strong>对象在转换基本类型</strong>时，首先会<strong>调用<code>valueOf</code></strong>，然后<strong>调用<code>toString</code></strong>。并且这两个方法是<strong>可以重写</strong>的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">    <span class="function"><span class="title">valueOf</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当然也<strong>可以重写<code>Symbol.toPrimitive</code></strong>，该方法<strong>在转基本类型时调用优先级最高</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'1'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    <span class="built_in">return</span> 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 + a // =&gt; 3</span><br><span class="line"><span class="string">'1'</span> + a // =&gt; <span class="string">'12'</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h5><ul><li>只有当<strong>加法运算</strong>时，其中<strong>一方是字符串类型</strong>，就会<strong>把另一个也转为字符串类型</strong>。</li><li>并且<strong>加法运算会触发三种类型转换</strong>：将值转换为原始值，转换为数字，转换为字符串。</li><li><p><strong>其他运算</strong>只要其中一方是数字，那么另一方就转为数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 + <span class="string">'1'</span> // <span class="string">'11'</span></span><br><span class="line">2 * <span class="string">'2'</span> // 4</span><br><span class="line">[1, 2] + [2, 1] // <span class="string">'1,22,1'</span></span><br><span class="line">// [1, 2].toString() -&gt; <span class="string">'1,2'</span></span><br><span class="line">// [2, 1].toString() -&gt; <span class="string">'2,1'</span></span><br><span class="line">// <span class="string">'1,2'</span> + <span class="string">'2,1'</span> = <span class="string">'1,22,1'</span></span><br></pre></td></tr></table></figure></li><li><p>对于加号需要注意这个表达式 ‘a’ + + ‘b’，<strong>一元加操作符</strong>可以<strong>实现与<code>Number</code>相同的作用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> // -&gt; <span class="string">"aNaN"</span></span><br><span class="line">// 因为 + <span class="string">'b'</span> -&gt; NaN</span><br></pre></td></tr></table></figure></li></ul><h5 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a>== 操作符</h5><ul><li><p>比较运算<code>x==y</code>，其中<code>x</code>和<code>y</code>是值，比较运算产生<code>true</code>或<code>false</code>。这样的比较按如下方式进行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 若Type(x)与Type(y)相同，则</span><br><span class="line">    a. 若Type(x)为Undefined，返回<span class="literal">true</span>。</span><br><span class="line">    b. 若Type(x)为Null，返回<span class="literal">true</span>。</span><br><span class="line">    c. 若Type(x)为Number，则</span><br><span class="line">        i. 若x为NaN，返回<span class="literal">false</span>。</span><br><span class="line">       ii. 若y为NaN，返回<span class="literal">false</span>。</span><br><span class="line">      iii. 若x与为为相同数值，返回<span class="literal">true</span>。</span><br><span class="line">       iv. 若x为+0且y为-0，返回<span class="literal">true</span>。</span><br><span class="line">        v. 若x为-0且y为+0，返回<span class="literal">true</span>。</span><br><span class="line">       vi. 返回<span class="literal">false</span>。</span><br><span class="line">    d. 若Type(x)为String，则当x和y为完全相同的字符串序列（长度相等且相同字符在相同位置）时返回ture，否则返回<span class="literal">false</span>。</span><br><span class="line">    e. 若Type(x)为Boolean，当x和y同为<span class="literal">true</span>或者同为<span class="literal">false</span>时返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">    f. 当x和y引用同一对象时返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">2. 若x为null且y为undefined，返回<span class="literal">true</span>。</span><br><span class="line">3. 若x为undefined且y为null，返回ture。</span><br><span class="line">4. 若Type(x)为Number且Type(y)为String，返回x==Number(y)的结果。</span><br><span class="line">5. 若Type(x)为String且Type(y)为Number，返回Number(x)==y的结果。</span><br><span class="line">6. 若Type(x)为Boolean，返回比较Number(x)==y的结果。</span><br><span class="line">7. 若Type(y)为Boolean，返回比较X==Number(y)的结果。</span><br><span class="line">8. 若Type(x)为String或Number，且Type(y)为Object，返回比较x==ToPrimitive(y)的结果。</span><br><span class="line">9. 若Type(x)为Object，且Type(y)为String或Number，返回比较ToPrimitive(x)==y的结果。</span><br><span class="line">10.其余情况返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure></li><li><p>上面提到的<code>toPrimitive</code>就是<strong>对象转基本类型</strong>。</p></li><li>解析一道题目<code>[] == ![] // -&gt; true</code>，下面是这个表达式为何为 true 的步骤：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// [] 转成 <span class="literal">true</span>，然后取反变成 <span class="literal">false</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line">// 根据第 8 条得出</span><br><span class="line">[] == ToNumber(<span class="literal">false</span>)</span><br><span class="line">[] == 0</span><br><span class="line">// 根据第 10 条得出</span><br><span class="line">ToPrimitive([]) == 0</span><br><span class="line">// [].toString() -&gt; <span class="string">''</span></span><br><span class="line"><span class="string">''</span> == 0</span><br><span class="line">// 根据第 6 条得出</span><br><span class="line">0 == 0 // -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><ul><li>如果是<strong>对象</strong>，就<strong>通过<code>toPrimitive<code>将对象转换为基本类型</code></code></strong>。</li><li>如果是<strong>字符串</strong>，就<strong>通过<code>unicode<code>字符索引</code></code></strong>来比较。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JS-Part&quot;&gt;&lt;a href=&quot;#JS-Part&quot; class=&quot;headerlink&quot; title=&quot;JS Part&quot;&gt;&lt;/a&gt;JS Part&lt;/h4&gt;&lt;h5 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的 NaN 与 isNaN</title>
    <link href="https://chongtianhong.github.io/2018/05/24/NaN/"/>
    <id>https://chongtianhong.github.io/2018/05/24/NaN/</id>
    <published>2018-05-24T05:53:29.000Z</published>
    <updated>2018-08-27T06:22:30.911Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><ul><li><code>NaN</code> 即 <strong>Not a Number</strong>，不是一个数字。 在 JavaScript 中，<strong>整数和浮点数都统称为 <code>Number</code> 类型</strong>。</li><li><p>除此之外，<code>Number</code> 类型类型还有一个很特殊的值，即 <strong><code>NaN</code></strong> 。它<strong>是 <code>Number</code> 对象上的一个静态属性，可以通过 Number.NaN 来访问</strong>：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在 ECMAScript v1 和其后的版本中，还可以用<strong>预定义的全局属性 <code>NaN</code> 代替 <code>Number.NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在以下两种场景中，可能会产生 NaN 值：</p></li></ul><blockquote>表达式计算</blockquote><ul><li><p>一个表达式中如果有<strong>减号 (-)</strong>、<strong>乘号 (*)</strong>或 <strong>除号 (/) </strong>等运算符时，JS 引擎在计算之前，会试图<strong>将表达式的每个分项转化为 <code>Number</code> 类型（使用 <code>Number(x)</code> 做转换）</strong>。如果<strong>转换失败，表达式将返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100 - <span class="string">'2a'</span> ;    // NaN</span><br><span class="line"><span class="string">'100'</span> / <span class="string">'20a'</span>;  // NaN</span><br><span class="line"><span class="string">'20a'</span> * 5 ;     // NaN</span><br><span class="line">undefined - 1;  // NaN, Number(undefined) == NaN</span><br><span class="line">[] * 20 ;       // 0, Number([]) == 0</span><br><span class="line">null - 5;       // -5, Number(null) == 0</span><br></pre></td></tr></table></figure></li><li><p>而<strong>加号 (+)</strong>不会将其两边的变量转化为 Number 类型，这是因为JS表达式的执行顺序是按照运算符的优先级从左到右依次进行的：</p><ul><li><strong>如果加号 (+) 两边的变量都是 Number 类型时，才会做数字相加运算</strong>;</li><li>如果<strong>其中有一个变量是字符串</strong>，则会<strong>将两边都作为字符串相加</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 + 4 + <span class="string">'6'</span> = <span class="string">'96'</span>;</span><br><span class="line">1 + <span class="string">'2'</span> + 3 =  <span class="string">'123'</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>类型转换</blockquote><ul><li><p>直接使用<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code><strong>将一个非数字的值转化为数字</strong>时，<strong>表达式返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span> - 3   // NaN</span><br><span class="line">parseInt(<span class="string">'abc'</span>)  // NaN</span><br><span class="line">parseFloat(<span class="string">'abc'</span>) // NaN</span><br><span class="line">Number(<span class="string">'abc'</span>)    // NaN</span><br></pre></td></tr></table></figure></li><li><p>对于<strong>数字+字符</strong>的值，其转化结果会有所不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">'123abc'</span>); // NaN</span><br><span class="line">parseInt(<span class="string">'123abc'</span>); // 123</span><br><span class="line">parseInt(<span class="string">'123abc45'</span>); // 123</span><br><span class="line">parseFloat(<span class="string">'123.45abc'</span>);// 123.45</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Number</code>转换的是整个值</strong>，而不是部分值；<strong><code>parseInt</code>和 <code>parseFloat</code>只转化第一个无效字符之前的字符串</strong>。</p></li><li><p>另外，<strong>一元加操作符</strong>也可以<strong>实现与<code>Number</code>相同的作用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">'12abc'</span>; // NaN</span><br><span class="line">+ <span class="string">'123'</span>; // 123</span><br><span class="line">+ <span class="string">'123.78'</span>; // 123.78</span><br><span class="line">+ <span class="string">'abc'</span>; // NaN</span><br></pre></td></tr></table></figure></li><li><p>因此，<strong>当一个字符串不能被<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code>成功转换时</strong>，就<strong>返回 <code>NaN</code></strong>，表示<strong>该字符串无法被识别为数字类型</strong>，这是一个<strong>异常状态</strong>，并<strong>不是一个确切的值</strong>。</p></li></ul><h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h4><ul><li><code>isNaN()</code>是一个全局方法，它的作用是<strong>检查一个值是否能被<code>Number()</code>成功转换</strong>。</li><li><p>如果<strong>能转换成功</strong>，就<strong>返回<code>false</code></strong>，否则返回<code>true</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)          // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123'</span>)        // <span class="literal">false</span> 能转换</span><br><span class="line">isNaN(<span class="string">'abc'</span>)        // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123ab'</span>)      // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123.45abc'</span>)  // <span class="literal">true</span> 不能转换</span><br></pre></td></tr></table></figure></li><li><p>可以看出，<strong><code>isNaN()</code>没有办法判断某个值本身是否为<code>NaN</code></strong>。</p></li><li><p>如果<strong>想要知道某个值本身是否为<code>NaN</code></strong>，可以利用<strong>NaN 不等于自身</strong>这一特性来判断：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selfIsNaN(value)&#123;</span><br><span class="line">    <span class="built_in">return</span> value !== value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另外，ES6 在<strong><code>Number</code>对象上</strong>也<strong>提供了<code>isNaN()</code>方法</strong>，和全局方法<code>isNaN()</code><strong>不同的是</strong>，它<strong>用于判断某个值本身是否为<code>NaN</code></strong>，而<strong>不需要进行类型转换</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(<span class="string">'123'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(<span class="string">'abc'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(NaN);      // <span class="literal">true</span>　本身是NaN</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NaN&quot;&gt;&lt;a href=&quot;#NaN&quot; class=&quot;headerlink&quot; title=&quot;NaN&quot;&gt;&lt;/a&gt;NaN&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NaN&lt;/code&gt; 即 &lt;strong&gt;Not a Number&lt;/strong&gt;，不是一个数字。 在 JavaScript 中，&lt;strong&gt;整数和浮点数都统称为 &lt;code&gt;Number&lt;/code&gt; 类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除此之外，&lt;code&gt;Number&lt;/code&gt; 类型类型还有一个很特殊的值，即 &lt;strong&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/strong&gt; 。它&lt;strong&gt;是 &lt;code&gt;Number&lt;/code&gt; 对象上的一个静态属性，可以通过 Number.NaN 来访问&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动的四种方式及其原理理解</title>
    <link href="https://chongtianhong.github.io/2018/05/23/clearFloat/"/>
    <id>https://chongtianhong.github.io/2018/05/23/clearFloat/</id>
    <published>2018-05-23T06:25:03.000Z</published>
    <updated>2018-09-01T12:18:09.371Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文介绍了四种清除浮动的方法，并尝试解释其原理。</li><li>在理解了各种清除浮动的原理之后，我们会发现，很多<strong>清除浮动的方法本质上其实是一样的</strong>。<a id="more"></a></li></ul><h4 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h4><ul><li><p>在讲清除浮动的方法之前，我们先来了解一下<strong>为什么要清除浮动</strong>，清除浮动的目的是什么，即，要解决什么样的问题。来看一个浮动的例子(略去了文字内容)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>其样式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在chrome中渲染的效果如下图所示：<br><img src="images/clearFloat1.png" stype="border:none" alt="浮动效果"></p></li><li>这肯定不是我们想要的渲染效果，它可能存在如下问题：<br>① <strong>文字围绕浮动元素排版</strong>，但我们可能希望文字（<code>.textDiv</code>）排列在浮动元素下方，或者，我们并不希望<code>.textDiv</code>两边有浮动元素存在。<br>② 浮动元素排版超出了其父级元素（<code>.topDiv</code>），<strong>父元素的高度出现了塌缩</strong>，若没有文字高度的支撑，不考虑边框，父级元素高度会塌缩成零。<br>③ <strong>浮动元素甚至影响到了其父元素的兄弟元素（<code>.bottomDiv</code>）排版</strong>。因为浮动元素脱离了文档流，<code>.bottomDiv</code>在计算元素位置的时候会忽略其影响，紧接着上一个元素的位置继续排列。</li><li>解决第一个问题，需要<strong>清除<code>.textDiv</code>周围的浮动</strong>。</li><li>解决第二、第三个问题，因为父元素的兄弟元素位置只受父元素位置的影响，就<strong>需要一种方法将父级元素的高度撑起来，将浮动元素包裹在其中</strong>，避免浮动元素影响父元素外部的元素排列。</li><li>接下来就开始介绍清除浮动的方法。</li></ul><h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><h5 id="利用clear样式"><a href="#利用clear样式" class="headerlink" title="利用clear样式"></a>利用clear样式</h5><ul><li><p>还是开篇的例子，我们给<strong>需要清除浮动的元素</strong>添加如下样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">    clear: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清除浮动后的渲染效果如下：<br><img src="images/clearFloat2.png" stype="border:none" alt="清除浮动后的渲染效果"></p></li><li>解析：<ul><li>通过上面的样式，<code>.textDiv</code>告诉浏览器，我的<strong>左边不允许有浮动的元素存在</strong>，请清除掉我左边的浮动元素。</li><li>然而，因为<strong>浮动元素（.floatDiv）位置已经确定</strong>，浏览器在计算<code>.textDiv</code>的位置时，<strong>为满足其需求，将<code>.textDiv</code>渲染在浮动元素下方</strong>，保证了<code>.textDiv</code>左边没有浮动元素。</li><li>同时可以看出，<strong>父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响</strong>，这是因为<strong><code>.textDiv</code>仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的</strong>。</li><li>设置样式为<code>clear: both</code>也有相同的效果，即<strong>两边都不允许有浮动元素</strong>，clear就是对应方向的值，两边都不允许就是both。</li></ul></li><li><strong>注意</strong>：这个规则<strong>只能影响使用清除的元素本身，不能影响其他元素</strong>。</li><li><p>但是，如果我们把HTML中的<code>.floatDiv</code>和<code>.textDiv</code>55：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>无论<code>.textDiv</code>是否应用清除浮动，情况都是下面的样子：<br><img src="images/clearFloat3.png" stype="border:none" alt="交换位置后的结果"></p></li><li><strong><code>.textDiv</code>的位置先确定了</strong>，于是<strong>浮动元素就紧接着<code>.textDiv</code>下方渲染在父元素的左侧</strong>。然而，父元素的高度并没有被撑起来，没有将浮动影响“内化”，导致浮动影响到了接下来的元素排版。</li><li>看来，为达到撑起父元素高度的目的，<strong>使用clear清除浮动的方法</strong>还是<strong>有适用范围</strong>的。我们需要更加通用和可靠的方法。</li></ul><h5 id="父元素结束标签之前插入清除浮动的块级元素"><a href="#父元素结束标签之前插入清除浮动的块级元素" class="headerlink" title="父元素结束标签之前插入清除浮动的块级元素"></a>父元素结束标签之前插入清除浮动的块级元素</h5><ul><li><p>HTML结构如下，在<strong>有浮动的父级元素的末尾</strong>插入了一个<strong>没有内容的块级元素div</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"blankDiv"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>应用样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">// 区别在这里</span><br><span class="line">.blankDiv &#123;</span><br><span class="line">    clear: both; // or left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>渲染效果如下：<br><img src="images/clearFloat4.png" stype="border:none" alt="父元素结束标签之前插入清除浮动的块级元素渲染效果"></p></li><li>和第一个例子里<code>.textDiv</code>应用clear清除浮动，撑起父级元素高度的原理完全一样。这里强调一点，即，<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</li></ul><h5 id="利用伪元素（clearfix）"><a href="#利用伪元素（clearfix）" class="headerlink" title="利用伪元素（clearfix）"></a>利用伪元素（clearfix）</h5><ul><li><p>HTML结构如下，在<code>.topDiv</code>的div上再添加一个<code>clearfix</code>类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv clearfix"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 省略基本的样式</span><br><span class="line">// 区别在这里</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: <span class="string">'.'</span>;       /*生成内容作为最后一个元素，至于content里面是点还是其他都是可以的*/</span><br><span class="line">    height: 0;          /*避免生成内容破坏原有布局的高度*/</span><br><span class="line">    visibility:hidden;  /*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互*/</span><br><span class="line">    display: block;     /*使生成的元素以块级元素显示,占满剩余空间*/</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该样式在<code>.clearfix</code>，即父级元素的最后，添加了一个:after伪元素，<strong>通过清除伪元素的浮动，达到撑起父元素高度的目的</strong>。</p></li><li>注意到该伪元素的<code>display</code>值为<code>block</code>，即，它是一个<strong>不可见的块级元素</strong>。你可能已经意识到，这也只不过是前一种清除浮动方法（添加空白div）的另一种变形，其底层逻辑也是完全一样的。这三种方法，其本质上是一样的。</li></ul><h5 id="利用overflow清除浮动"><a href="#利用overflow清除浮动" class="headerlink" title="利用overflow清除浮动"></a>利用overflow清除浮动</h5><ul><li>首先直观地看看，<code>overflow</code>是如何清除浮动的。</li><li><p>HTML结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用CSS后的渲染效果如下：<br>&lt;img src=”images/clearFloat5.png” stype=”border:none” alt=”利用overflow清除浮动后的渲染效果&gt;</p></li><li>仅仅只<strong>在父级元素上添加了一个值为<code>auto</code>的<code>overflow</code>属性，父元素的高度立即被撑起</strong>，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染。</li><li>其实，<strong>这里的<code>overflow</code>值</strong>，还可以是<strong>除了”visible”之外的任何有效值，它们都能达到撑起父元素高度，清除浮动的目的</strong>。</li><li>不过，<strong>有的值可能会带来副作用</strong>，比如，scroll值会导致滚动条始终可见，hidden会使得超出边框部分不可见等。</li><li><strong>原理</strong>：当<strong>元素设置了<code>overflow</code>样式，且值不为<code>visible</code>时</strong>，该<strong>元素就建构了一个BFC</strong>。</li><li>在上面的例子中，<code>.topDiv</code>因设置了值为<code>auto</code>的<code>overflow</code>样式，所以<strong>该元素建构出一个BFC</strong>，按照第三个特点，<strong>BFC的高度是要包括浮动元素的</strong>，所以<code>.topDiv</code>的高度被撑起来，<strong>达到了清除浮动影响的目的</strong>。</li><li><strong>注意</strong>：这里<strong><code>overflow</code>的作用就是为了构建一个BFC区域，让内部浮动的影响都得以“内化”</strong>。而<strong>构建一个BFC区域的方法有很多种，<code>overflow</code>只是其中的一种</strong>，因此，我们也<strong>可以利用其它的方式构建BFC，且同样能达到清除浮动的目的</strong>。</li><li><p>BFC定义中说，<code>inline-block</code>同样也能构建BFC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">// 其他样式相同，省略</span><br></pre></td></tr></table></figure></li><li><p>渲染效果和使用<code>overflow</code>的效果完全一样。</p></li></ul><h5 id="另外一些方法"><a href="#另外一些方法" class="headerlink" title="另外一些方法"></a>另外一些方法</h5><blockquote>给浮动元素父级设置高度</blockquote><ul><li>使用浮动后，<strong>父元素高度塌陷</strong>是因为<strong>给浮动元素的父级高度是自适应导致的</strong>，因此，可以<strong>给它设置适当的高度</strong>来解决这一问题，然而，缺点是<strong>在浮动元素高度不确定的时候不适用</strong>。</li></ul><blockquote>父级也设置浮动</blockquote><ul><li>缺点：需要给每个浮动元素父级添加浮动，浮动多了容易出现问题。</li></ul><blockquote>使用br清浮动</blockquote><ul><li><p><strong>br标签自带clear属性</strong>，将它的<strong>clear属性设置成both</strong>其实和<strong>添加空div</strong>原理是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"top"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;br clear=<span class="string">"both"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>缺点：<strong>不符合工作中结构、样式、行为，三者分离的要求</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文介绍了四种清除浮动的方法，并尝试解释其原理。&lt;/li&gt;
&lt;li&gt;在理解了各种清除浮动的原理之后，我们会发现，很多&lt;strong&gt;清除浮动的方法本质上其实是一样的&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="浮动" scheme="https://chongtianhong.github.io/tags/%E6%B5%AE%E5%8A%A8/"/>
    
      <category term="清除浮动" scheme="https://chongtianhong.github.io/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6 类(Class)基本用法与静态属性 + 静态方法</title>
    <link href="https://chongtianhong.github.io/2018/05/22/ES6Class/"/>
    <id>https://chongtianhong.github.io/2018/05/22/ES6Class/</id>
    <published>2018-05-22T06:33:15.000Z</published>
    <updated>2018-08-24T14:41:56.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类-Class-的基本用法"><a href="#类-Class-的基本用法" class="headerlink" title="类(Class)的基本用法"></a>类(Class)的基本用法</h4><ul><li>在 ES6 规范中，引入了<code>Class</code>的概念。使得 JS 开发者终于告别了<strong>直接使用原型对象模仿面向对象中的类</strong>和<strong>类继承</strong>时代。</li><li>但是JS 中并没有一个真正的<code>Class</code>原始类型，<strong><code>Class</code></strong>仅仅只是对原型对象运用语法糖，<strong>作为对象的模板</strong>。所以，只有理解如何<strong>使用原型对象实现类和类继承</strong>，才能真正地用好<code>Class</code>。<a id="more"></a></li><li><p>下面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是<strong>构造方法</strong>，而<code>this</code>关键字则代表实例对象。也就是说，<strong>ES5的构造函数</strong><code>Point</code>，<strong>对应ES6的<code>Point</code>类的构造方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ES6定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    // prototype属性</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">// ES5的构造函数</span><br><span class="line"><span class="keyword">function</span> Point(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype = <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义“类”的方法</strong>的时候，<strong>前面不需要加上<code>function</code>这个关键字</strong>，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔</strong>，加了会报错。</p></li><li><p><strong>构造函数的prototype属性</strong>，在ES6的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的prototype属性上面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>方法可以很方便地<strong>一次向类添加多个方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Point.prototype, &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>类的内部所有定义的方法</strong>，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与ES5的行为不一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES5可枚举，ES6不可枚举</span><br><span class="line">Object.keys(Point.prototype)</span><br></pre></td></tr></table></figure></li><li><p>constructor方法是类的默认方法，<strong>通过new命令生成对象实例时，自动调用该方法</strong>。一个类必须有constructor方法，如果<strong>没有显式定义，一个空的constructor方法会被默认添加</strong>。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p></li><li><strong>类的构造函数，不使用new是没法调用的</strong>，会报错。</li><li><p>可以<strong>通过实例的<code>__proto__</code>属性</strong>为Class添加方法，<strong>可被所有的实例所共享</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3);</span><br><span class="line">var p2 = new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // <span class="string">"Oops"</span></span><br><span class="line">p2.printName() // <span class="string">"Oops"</span></span><br><span class="line"></span><br><span class="line">var p3 = new Point(4,2);</span><br><span class="line">p3.printName() // <span class="string">"Oops"</span></span><br></pre></td></tr></table></figure></li><li><p>可见，<strong>使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎</strong>，不推荐使用，因为这<strong>会改变Class的原始定义，影响到所有实例</strong>。</p></li><li><code>Class</code><strong>不存在变量提升（hoist）</strong>。</li></ul><h4 id="typeof-class-“function”"><a href="#typeof-class-“function”" class="headerlink" title="typeof class == “function”"></a>typeof class == “function”</h4><ul><li>使用<code>Class</code>的语法，让开发者告别了使用 prototype 模仿面向对象的时代。但是，<strong><code>Class</code></strong>并不是 ES6 引入的全新概念，它的<strong>原理依旧是原型继承</strong>。</li><li>通过类型判断，我们可以得知，<strong><code>Class</code></strong>的并不是什么全新的数据类型，它<strong>实际只是 function (或者说 object)</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeof Person // <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><ul><li>在传统面向对象中，<strong>类</strong>是<strong>可以继承类</strong>的。这样子<strong>类</strong>就<strong>可以复制父类的方法，达到代码复用的目的</strong>。</li><li><p>ES6 也提供了类继承的语法<code>extends</code>，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        this.me = who;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">identify</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"I am "</span> + this.me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        // super() 指的是调用父类</span><br><span class="line">        // 调用的同时，会绑定 this 。</span><br><span class="line">        // 如：Foo.call(this, who)</span><br><span class="line">        super(who);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">speak</span></span>()&#123;</span><br><span class="line">        alert( <span class="string">"Hello, "</span> + this.identify() + <span class="string">"."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b1 = new Bar( <span class="string">"b1"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br></pre></td></tr></table></figure></li><li><p>当实例<code>b1</code>调用<code>speak</code>方法时，<code>b1</code>本身没有 <code>speak</code>，所以会到<code>Bar.prototype</code>原型对象上查找，并且调用原型对象上的<code>speak</code>方法。调用<code>identify</code>方式时，由于<code>this</code>指向的是<code>b1</code>对象。所以也会先在<code>b1</code>本身查找，然后沿着原型链，查找<code>Bar.prototype</code>，最后在<code>Foo.prototype</code>原型对象上找到<code>identify</code>方法，然后调用。</p></li><li>实际上，在 JavaScript 中，<strong>类继承的本质依旧是原型对象</strong>。</li></ul><h4 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h4><ul><li><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果<strong>在一个方法前，加上static关键字，就表示该方法不会被实例继承</strong>，而是<strong>直接通过类来调用</strong>，这就称为<strong>“静态方法”</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line">// 定义静态方法</span><br><span class="line">static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 通过类名直接调用</span><br><span class="line">console.log(StaticMethod.getAge());</span><br></pre></td></tr></table></figure></li><li><p><strong>静态方法只能在静态方法中调用，不能在实例方法中调用</strong>。</p></li></ul><h4 id="Class的静态属性和实例属性"><a href="#Class的静态属性和实例属性" class="headerlink" title="Class的静态属性和实例属性"></a>Class的静态属性和实例属性</h4><ul><li><p><strong>静态属性</strong>指的是<strong>Class本身的属性</strong>，即<code>Class.propname</code>，而不是定义在实例对象（this）上的属性。ES6使用静态属性和实例属性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line"></span><br><span class="line">// 定义实例属性</span><br><span class="line">// ES6实例属性只能在constructor构造函数中定义</span><br><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.width = <span class="string">'40cm'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">&#125;</span><br><span class="line">// 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">width;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：目前ES6，只有这种写法可行，<strong>因为ES6明确规定，Class内部只有静态方法，没有静态属性</strong>。</p></li><li><p><strong>ES7</strong>有一个<strong>静态属性的提案</strong>，目前Babel转码器支持。安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，不同的stage封装了不同的插件，官方推荐是使用stage-1安装命令(根据自己的需求调整):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-preset-stage-0</span><br></pre></td></tr></table></figure></li><li><p>ES7使用<strong>静态属性</strong>和<strong>实例属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// ES7提案 定义静态属性</span><br><span class="line">static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"></span><br><span class="line">// ES7定义实例属性</span><br><span class="line">height = <span class="string">'150cm'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：<strong>ES7和ES6的静态属性和实例属性</strong>只是<strong>定义不一样</strong>，<strong>调用的方式是一样的</strong>。</p></li><li>Class的<strong>静态方法/Class静态属性</strong>和<strong>实例属性</strong>的整个案例:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethodParent.js</span><br><span class="line"><span class="built_in">export</span> default class StaticMethodParent&#123;</span><br><span class="line">    static <span class="function"><span class="title">getCommon</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'父类的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// StaticMethod.js</span><br><span class="line">import StaticMethodParent from <span class="string">'./StaticMethodParent'</span></span><br><span class="line"> </span><br><span class="line">// 定义静态属性和静态方法</span><br><span class="line">class StaticMethod extends StaticMethodParent&#123;</span><br><span class="line">    // 因为ES6明确规定，Class内部只有静态方法，没有静态属性,所以ES6在类中定义静态属性都是错误的。</span><br><span class="line">    // static lastName = <span class="string">'pcaca'</span>;ES6错误</span><br><span class="line"> </span><br><span class="line">    // ES7提案 定义静态属性</span><br><span class="line">    // 安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，</span><br><span class="line">    // 不同的stage封装了不同的插件，官方推荐是使用stage-1</span><br><span class="line">    static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"> </span><br><span class="line">    // ES7定义实例属性</span><br><span class="line">    height = <span class="string">'150cm'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getHeight</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.height;//ES7的使用也要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // ES6实例属性只能在constructor构造函数中定义</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.width = <span class="string">'40cm'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">    width;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 定义静态方法</span><br><span class="line">    static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">        // 子类可以调用父类的静态方法</span><br><span class="line">        console.log(super.getCommon());</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">export</span> &#123;StaticMethod&#125;;</span><br><span class="line"> </span><br><span class="line">// index.js</span><br><span class="line">import &#123;StaticMethod&#125; from <span class="string">'./StaticMethod'</span>;</span><br><span class="line">console.log(StaticMethod.getAge());</span><br><span class="line">console.log(StaticMethod.getCommon());</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line">console.log(StaticMethod.lastName);</span><br><span class="line"><span class="built_in">let</span> staticMethod = new StaticMethod();</span><br><span class="line">console.log(staticMethod.height);</span><br><span class="line">console.log(staticMethod.getHeight());</span><br><span class="line">console.log(staticMethod.width);</span><br><span class="line">console.log(staticMethod.getWidth());</span><br><span class="line">//staticMethod.getAge();//bundle.js:7906 Uncaught TypeError: staticMethod.getAge is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类-Class-的基本用法&quot;&gt;&lt;a href=&quot;#类-Class-的基本用法&quot; class=&quot;headerlink&quot; title=&quot;类(Class)的基本用法&quot;&gt;&lt;/a&gt;类(Class)的基本用法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在 ES6 规范中，引入了&lt;code&gt;Class&lt;/code&gt;的概念。使得 JS 开发者终于告别了&lt;strong&gt;直接使用原型对象模仿面向对象中的类&lt;/strong&gt;和&lt;strong&gt;类继承&lt;/strong&gt;时代。&lt;/li&gt;
&lt;li&gt;但是JS 中并没有一个真正的&lt;code&gt;Class&lt;/code&gt;原始类型，&lt;strong&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/strong&gt;仅仅只是对原型对象运用语法糖，&lt;strong&gt;作为对象的模板&lt;/strong&gt;。所以，只有理解如何&lt;strong&gt;使用原型对象实现类和类继承&lt;/strong&gt;，才能真正地用好&lt;code&gt;Class&lt;/code&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Class" scheme="https://chongtianhong.github.io/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>使用Javascript监控前端相关数据</title>
    <link href="https://chongtianhong.github.io/2018/05/21/frontEndMonitor/"/>
    <id>https://chongtianhong.github.io/2018/05/21/frontEndMonitor/</id>
    <published>2018-05-21T12:40:59.000Z</published>
    <updated>2018-08-23T15:06:44.798Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。<strong>项目上线前期的粒度较大的错误</strong>我们都会<strong>在自测和QA测试中发现</strong>，然而<strong>上线之后的错误不是那么好发现</strong>。同时<strong>移动端的开发</strong>也面临着一个问题就是<strong>不好调试</strong>，所以<strong>web开发的错误监控</strong>是一个非常有用的措施。<a id="more"></a></li></ul><h4 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h4><ul><li>常见的web错误主要分为两类：<br>① <strong>运行时错误</strong>：这个错误往往是我们在代码书写时造成的，比如语法错误、逻辑错误，这样的错误通常在测试阶段就会被发现，但是也可能存在“漏网之鱼”。<br>② <strong>资源加载错误</strong>：这个错误通常是找不到文件或者是文件加载超时造成的。</li></ul><h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><ul><li>基于上面两种的错误类型，也有不同的错误捕获方式：</li></ul><blockquote>代码错误捕获：</blockquote><ul><li><p>使用<code>try…catch…</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">    // 运行可能出错的代码</span><br><span class="line"></span><br><span class="line">&#125;catch&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>windown.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>资源加载错误：</blockquote><ul><li><p><code>bject.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var img =document.getElementById(<span class="string">'#img'</span>);</span><br><span class="line"></span><br><span class="line">img.onerror = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用window的Error事件代理，但是需要注意的是<strong>Error事件是不冒泡的</strong>，我们可以<strong>使用事件捕获进行代理</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">"error"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h4><ul><li>常见错误上报有两种： <strong>ajax</strong>、<strong>image对象</strong>推荐）。</li><li><strong>ajax上报</strong>就是在上文注释错误捕获的地方发起ajax请求，来向服务器发送错误信息。</li><li>利用<strong>image对象</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src =<span class="string">"http://post.error.com?"</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="跨域js文件错误获取"><a href="#跨域js文件错误获取" class="headerlink" title="跨域js文件错误获取"></a>跨域js文件错误获取</h4><ul><li><strong>跨域js文件获取是有限制的</strong>，如果想<strong>获取其他域下的js错误</strong>需要<strong>在script标签里添加crossorigin属性</strong>，然后<strong>服务器端要设置</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">'Access-Control-Allow-Origin: *'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="前端监控系统模块实现"><a href="#前端监控系统模块实现" class="headerlink" title="前端监控系统模块实现"></a>前端监控系统模块实现</h4><ul><li>项目开发完成外发后，没有一个监控系统，我们很难了解到发布出去的代码在用户机器上执行是否正确，所以需要建立<strong>前端代码性能相关的监控系统</strong>。</li><li>所以我们需要做以下的一些模块：</li></ul><h5 id="收集脚本执行错误"><a href="#收集脚本执行错误" class="headerlink" title="收集脚本执行错误"></a>收集脚本执行错误</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> error(msg, url, line)&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi"</span>; // 收集上报数据的信息</span><br><span class="line">    var m =[msg, url, line, navigator.userAgent, +new Date];// 收集错误信息，发生错误的脚本文件网络地址，用户代理信息，时间</span><br><span class="line">    var url = REPORT_URL + m.join(<span class="string">'||'</span>);// 组装错误上报信息内容URL</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = url;// 发送数据到后台cgi</span><br><span class="line">&#125;</span><br><span class="line">// 监听错误上报</span><br><span class="line">window.onerror = <span class="keyword">function</span>(msg,url,line)&#123;</span><br><span class="line">    error(msg,url,line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<strong>管理后台系统</strong>，我们可以看到页面上每次错误的信息，通过这些信息我们可以很快定位并且解决问题。</li></ul><h5 id="收集页面执行性能信息"><a href="#收集页面执行性能信息" class="headerlink" title="收集页面执行性能信息"></a>收集页面执行性能信息</h5><ul><li>performance包含<strong>页面加载到执行完成</strong>的整个生命周期中<strong>不同执行步骤的执行时间</strong>。</li><li><p>计算不同步骤时间相对于navigationStart的时间差，可以通过相应后台CGI收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_performance</span></span>()&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi?perf="</span>;</span><br><span class="line">    var perf = (window.webkitPerformance ? window.webkitPerformance : window.msPerformance ),</span><br><span class="line">        points = [<span class="string">'navigationStart'</span>,<span class="string">'unloadEventStart'</span>,<span class="string">'unloadEventEnd'</span>,<span class="string">'redirectStart'</span>,<span class="string">'redirectEnd'</span>,<span class="string">'fetchStart'</span>,<span class="string">'domainLookupStart'</span>,<span class="string">'connectStart'</span>,<span class="string">'requestStart'</span>,<span class="string">'responseStart'</span>,<span class="string">'responseEnd'</span>,<span class="string">'domLoading'</span>,<span class="string">'domInteractive'</span>,<span class="string">'domContentLoadedEventEnd'</span>,<span class="string">'domComplete'</span>,<span class="string">'loadEventStart'</span>,<span class="string">'loadEventEnd'</span>];</span><br><span class="line">    var timing = pref.timing;</span><br><span class="line">    perf = perf  ? perf : window.performance;</span><br><span class="line">    <span class="keyword">if</span>( perf  &amp;&amp; timing ) &#123;</span><br><span class="line">        var arr = [];</span><br><span class="line">        var navigationStart = timing[points[0]];</span><br><span class="line">        <span class="keyword">for</span>(var i=0,l=points.length;i&lt;l;i++)&#123;</span><br><span class="line">            arr[i] = timing[points[i]] - navigationStart;</span><br><span class="line">        &#125;</span><br><span class="line">    var url = REPORT_URL + arr.join(<span class="string">"-"</span>);</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img=null;</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过后台接口收集和统计，我们可以对<strong>页面执行性能</strong>有很详细的了解。</p></li></ul><h5 id="统计每个页面的JS和CSS加载时间"><a href="#统计每个页面的JS和CSS加载时间" class="headerlink" title="统计每个页面的JS和CSS加载时间"></a>统计每个页面的JS和CSS加载时间</h5><ul><li>在<strong>JS或者CSS加载之前打上时间戳，加载之后打上时间戳</strong>，并且将数据（时间差）上报到后台。<strong>加载时间</strong>反映了<strong>页面白屏</strong>，<strong>可操作的等待时间</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;var cssLoadStart = +new Date&lt;/script&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx1.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx2.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;sript&gt;</span><br><span class="line">    var cssLoadTime = (+new Date) - cssLoadStart;</span><br><span class="line">    var jsLoadStart = +new Date;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx1.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx2.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx3.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var jsLoadTime = (+new Date) - jsLoadStart;</span><br><span class="line">    var REPORT_URL = <span class="string">'xxx/cgi?data='</span></span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = REPORT_URL + cssLoadTime + <span class="string">'-'</span> + jsLoadTime;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><h5 id="new-Date"><a href="#new-Date" class="headerlink" title="+new Date"></a>+new Date</h5><ul><li>JavaScript中可以在某个元素前使用 ‘+’ 号，这个操作是<strong>将该元素转换成Number类型</strong>，如果<strong>转换失败</strong>，那么<strong>将得到 NaN</strong>。</li><li>所以，<code>+new Date</code>将会调用<code>Date.prototype</code>上的 <code>valueOf</code>方法，而根据 MDN 文档，<code>Date.prototype.valueOf</code>方法等同于<code>Date.prototype.getTime()</code>，得到毫秒。</li><li>所以下列代码效果相同：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(+new Date);</span><br><span class="line"> </span><br><span class="line">console.log(new Date().getTime());</span><br><span class="line"> </span><br><span class="line">console.log(new Date().valueOf());</span><br><span class="line"> </span><br><span class="line">console.log(new Date() * 1);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。&lt;strong&gt;项目上线前期的粒度较大的错误&lt;/strong&gt;我们都会&lt;strong&gt;在自测和QA测试中发现&lt;/strong&gt;，然而&lt;strong&gt;上线之后的错误不是那么好发现&lt;/strong&gt;。同时&lt;strong&gt;移动端的开发&lt;/strong&gt;也面临着一个问题就是&lt;strong&gt;不好调试&lt;/strong&gt;，所以&lt;strong&gt;web开发的错误监控&lt;/strong&gt;是一个非常有用的措施。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端监控" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Javascript" scheme="https://chongtianhong.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript定义类（class）的三种方法</title>
    <link href="https://chongtianhong.github.io/2018/05/20/ClassDefinition/"/>
    <id>https://chongtianhong.github.io/2018/05/20/ClassDefinition/</id>
    <published>2018-05-20T03:13:53.000Z</published>
    <updated>2018-08-23T15:09:25.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在<strong>面向对象编程</strong>中，<strong>类（class）是对象（object）的模板</strong>，定义了<strong>同一组对象（又称”实例”）共有的属性和方法</strong>。</li><li>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。</li><li>本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。<a id="more"></a><h4 id="构造函数法"><a href="#构造函数法" class="headerlink" title="构造函数法"></a>构造函数法</h4></li><li>这是经典方法，也是教科书必教的方法。</li><li><p>它用<strong>构造函数模拟”类”</strong>，在其内部用<code>this</code>关键字指代实例对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Cat</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"大毛"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成实例的时候，使用<code>new</code>关键字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = new Cat();</span><br><span class="line">alert(cat1.name); // 大毛</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法，还可以<strong>定义在构造函数的prototype对象之上</strong>，<strong>实现不同实例属性和方法的共享</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.makeSound = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(<span class="string">"喵喵喵"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法的主要缺点是，比较复杂，用到了<code>this</code>和<code>prototype</code>，编写和阅读都很费力。</p></li></ul><h4 id="Object-create-法"><a href="#Object-create-法" class="headerlink" title="Object.create()法"></a>Object.create()法</h4><ul><li>为了解决”构造函数法”的缺点，<strong>更方便地生成对象</strong>，Javascript的国际标准ECMAScript第五版，提出了一个新的方法<code>Object.create()</code>。</li><li><p>用这个方法，<strong>“类”</strong>就<strong>是一个对象</strong>，不是函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    name: <span class="string">"大毛"</span>,</span><br><span class="line">    makeSound: <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">        alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，直接用<code>Object.create()</code>生成实例，不需要用到<code>new</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Object.create(Cat);</span><br><span class="line">alert(cat1.name); // 大毛</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Object.create) &#123;</span><br><span class="line">    Object.create = <span class="keyword">function</span> (o) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="built_in">return</span> new F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法<strong>比”构造函数法”简单</strong>，但是<strong>不能实现私有属性和私有方法</strong>，<strong>实例对象之间也不能共享数据</strong>，<strong>对”类”的模拟不够全面</strong>。</p></li></ul><h4 id="极简主义法（推荐）"><a href="#极简主义法（推荐）" class="headerlink" title="极简主义法（推荐）"></a>极简主义法（推荐）</h4><ul><li>荷兰程序员Gabor de Mooij提出了一种比<code>Object.create()</code>更好的新方法，他称这种方法为”极简主义法”（minimalist approach）。这也是<strong>本文推荐的方法</strong>。</li><li>接下来介绍该方法的特点。</li></ul><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul><li>这种方法<strong>不使用<code>this</code>和<code>prototype</code></strong>，<strong>代码部署起来非常简单</strong>，这大概也是它被叫做”极简主义法”的原因。</li><li><p>首先，它也是<strong>用一个对象模拟”类”</strong>。在这个类里面，定义一个构造函数（方法）<code>createNew()</code>，用来生成实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // some code here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，<strong>在<code>createNew()</code>里面，定义一个实例对象</strong>，把这个<strong>实例对象作为返回值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用的时候，<strong>调用<code>createNew()</code>方法，就可以得到实例对象</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这种方法的好处是，<strong>容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</strong>，因此可以方便地部署下面的特性。</p></li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li><strong>让一个类继承另一个类</strong>，实现起来很方便。只要<strong>在前者（继承者）的<code>createNew()</code>方法中，调用后者（被继承者）的<code>createNew()</code>方法</strong>即可。</li><li><p>先定义一个Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Animal = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var animal = &#123;&#125;;</span><br><span class="line">        animal.sleep = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"睡懒觉"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，在Cat的<code>createNew()</code>方法中，调用Animal的<code>createNew()</code>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var cat = Animal.createNew();</span><br><span class="line">    cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">    cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"喵喵喵"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>这样得到的Cat实例，就会同时继承Cat类和Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.sleep(); // 睡懒觉</span><br></pre></td></tr></table></figure></li></ul><h5 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h5><ul><li><p>在<code>createNew()</code>方法中，只要不是定义在cat对象上的方法和属性，都是私有的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        var sound = <span class="string">"喵喵喵"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上例的内部变量<code>sound</code>，外部无法读取，只有通过cat的公有方法<code>makeSound()</code>来读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">alert(cat1.sound); // undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h5><ul><li><p>有时候，我们<strong>需要所有实例对象，能够读写同一项内部数据</strong>。这个时候，只要<strong>把这个内部数据，封装在类对象的里面、createNew()方法的外面</strong>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    sound : <span class="string">"喵喵喵"</span>,</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(Cat.sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        cat.changeSound = <span class="keyword">function</span>(x)&#123; </span><br><span class="line">            Cat.sound = x; </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，生成两个实例对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">var cat2 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这时，如果有一个<strong>实例对象，修改了共享的数据，另一个实例对象也会受到影响</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat2.changeSound(<span class="string">"啦啦啦"</span>);</span><br><span class="line">cat1.makeSound(); // 啦啦啦</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;面向对象编程&lt;/strong&gt;中，&lt;strong&gt;类（class）是对象（object）的模板&lt;/strong&gt;，定义了&lt;strong&gt;同一组对象（又称”实例”）共有的属性和方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。&lt;/li&gt;
&lt;li&gt;本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>defer和async的区别</title>
    <link href="https://chongtianhong.github.io/2018/05/19/asyncAndDefer/"/>
    <id>https://chongtianhong.github.io/2018/05/19/asyncAndDefer/</id>
    <published>2018-05-19T10:35:46.000Z</published>
    <updated>2018-08-22T14:42:14.840Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>script</code>标签用于<strong>加载脚本与执行脚本</strong>，直接使用<code>script</code>标签（不加<code>defer</code>或<code>async</code>属性）的话，<strong>HTML会按照顺序来加载并执行脚本</strong>，在<strong>脚本加载&amp;执行的过程中</strong>，会<strong>阻塞后续的DOM渲染</strong>。<a id="more"></a></li><li><p>使用<code>async</code>属性，<strong>加载和渲染后续文档元素的过程</strong>将和 script.js 的<strong>加载与执行</strong>并行进行（异步）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=<span class="string">"script.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>defer</code>属性，<strong>加载后续文档元素的过程</strong>将和script.js的<strong>加载</strong>并行进行（异步），但是<strong>script.js的执行要在所有元素解析完成之后</strong>、<strong>DOMContentLoaded 事件触发之前</strong>完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"myscript.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>从实用角度来说，<strong>把所有脚本都丢到HTML文档最后、&lt;/body&gt;之前</strong>是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可<strong>保证非脚本的其他一切元素</strong>能够<strong>以最快的速度得到加载和解析</strong>。</p></li><li>下图中，蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。<br><img src="/images/asyncAndDefer1.png" alt="脚本加载和执行过程" width="600" style="border:none"></li><li>此图告诉我们以下几个要点：<br>1.<code>defer</code> 和 async 在<strong>网络读取（下载）时都是异步的</strong>（相较于 HTML 解析）。<br>2.它们差别在于脚本下载完之后何时执行，显然<strong><code>defer</code>是最接近我们对于应用脚本加载和执行的要求的</strong>。<br>3.关于<code>defer</code>，HTML5规范要求脚本执行应该按照脚本出现的先后顺序执行，但<strong>实际情况下，延迟脚本不一定按照先后顺序执行</strong>。<br>4.<strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>，与声明顺序无关。<br>5.<code>async</code>对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它<strong>对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适</strong>的，最典型的例子：谷歌/百度统计。</li></ul><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li>如果<code>script</code>标签设置了<code>defer</code>属性，则浏览器会<strong>异步的下载该文件</strong>并且<strong>不会影响到后续DOM的渲染</strong>；</li><li>如果有<strong>多个设置了<code>defer</code>的<code>script</code>标签</strong>存在，则会<strong>按照顺序执行所有的<code>script</code></strong>；</li><li><code>defer</code>脚本会<strong>在文档渲染完毕后，DOMContentLoaded事件调用前执行</strong>。</li></ul><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul><li><code>async</code>的设置，会使得<strong><code>script</code>脚本异步的加载</strong>并在允许的情况下执行。</li><li><strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>。</li><li><strong>DOMContentLoaded事件的触发并不受设置了<code>async</code>属性的脚本加载的影响</strong>，也就是说，<strong><code>async</code>属性脚本的加载不计入DOMContentLoaded事件统计</strong>。在脚本加载完之前，有可能已经触发了DOMContentLoaded。如果给设置了<code>async</code>属性的脚本一定的时间，是<strong>有可能在DOMContentLoaded事件之前就执行</strong>的。</li><li>设置了<code>async</code>属性的脚本的执行是<strong>加载完成就会去执行</strong>，而不像defer那样要等待所有的脚本加载完后按照顺序执行。</li></ul><h4 id="图例分析"><a href="#图例分析" class="headerlink" title="图例分析"></a>图例分析</h4><ul><li>拿四个不同的颜色来标明各自代表的含义，蓝色为文档解析，紫色为脚本渲染，黄色为脚本执行，绿色为DOMContentLoaded。</li></ul><h5 id="普通script"><a href="#普通script" class="headerlink" title="普通script"></a>普通script</h5><ul><li>文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载（但是Chrome会做一个优化，如果遇到script脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载script所对应的资源，这样能够节省一部分下载的时间）。</li><li><strong>资源的下载是在解析过程中进行</strong>的，虽说script1脚本会很快的加载完毕，但是如果它前边的script2并没有加载&amp;执行，所以它只能处于一个挂起的状态，等待script2执行完毕后再执行。</li><li>当这两个脚本都执行完毕后，才会继续解析页面。<br><img src="/images/asyncAndDefer2.png" alt="普通script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="defer-1"><a href="#defer-1" class="headerlink" title="defer"></a>defer</h5><ul><li>文档解析时，遇到设置了<code>defer</code>的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。</li><li>会<strong>等到所有的<code>defer</code>脚本加载完毕并按照顺序执行，执行完毕后</strong>会<strong>触发DOMContentLoaded事件</strong>。<br><img src="/images/asyncAndDefer3.png" alt="设置defer属性script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="async-1"><a href="#async-1" class="headerlink" title="async"></a>async</h5><ul><li><code>async</code>脚本会在<strong>加载完毕后立即执行</strong>。</li><li><code>async</code>脚本的加载<strong>不计入DOMContentLoaded事件统计</strong>，也就是说下图两种情况都是有可能发生的。</li><li>情况一：<br><img src="/images/asyncAndDefer4.png" alt="设置async属性script的加载和执行过程情况1" width="600" style="border:none"></li><li>情况二：<br><img src="/images/asyncAndDefer5.png" alt="设置async属性script的加载和执行过程情况2" width="600" style="border:none"></li></ul><h4 id="推荐的应用场景"><a href="#推荐的应用场景" class="headerlink" title="推荐的应用场景"></a>推荐的应用场景</h4><h5 id="defer-2"><a href="#defer-2" class="headerlink" title="defer"></a>defer</h5><ul><li>如果<strong>脚本代码依赖于页面中的DOM元素</strong>（文档是否解析完毕），或者<strong>被其他脚本文件依赖</strong>。例：<ul><li>评论框</li><li>代码语法高亮</li><li>polyfill.js</li></ul></li></ul><h5 id="async-2"><a href="#async-2" class="headerlink" title="async"></a>async</h5><ul><li>如果<strong>脚本并不关心页面中的DOM元素</strong>（文档是否解析完毕），并且<strong>也不会产生其他脚本需要的数据</strong>。例：<ul><li>谷歌/百度统计</li></ul></li><li>如果不太能确定的话，用defer总是会比async稳定（保证脚本执行顺序性、文档渲染完成后才执行）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;script&lt;/code&gt;标签用于&lt;strong&gt;加载脚本与执行脚本&lt;/strong&gt;，直接使用&lt;code&gt;script&lt;/code&gt;标签（不加&lt;code&gt;defer&lt;/code&gt;或&lt;code&gt;async&lt;/code&gt;属性）的话，&lt;strong&gt;HTML会按照顺序来加载并执行脚本&lt;/strong&gt;，在&lt;strong&gt;脚本加载&amp;amp;执行的过程中&lt;/strong&gt;，会&lt;strong&gt;阻塞后续的DOM渲染&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Object.getOwnPropertyNames的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/"/>
    <id>https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/</id>
    <published>2018-05-18T02:11:02.000Z</published>
    <updated>2018-08-22T14:30:04.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.getOwnPropertyNames()</code>方法返回一个由<strong>指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><code>Object.getOwnPropertyNames()</code>返回的数组中，<strong>枚举属性</strong>的顺序与通过<code>for…in</code>循环（或 Object.keys）迭代该对象属性时一致。数组中<strong>不可枚举属性的顺序未定义</strong>。</li><li><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">console.log(Object.getOwnPropertyNames(arr).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"length"</span>]</span><br><span class="line"></span><br><span class="line">// 类数组对象</span><br><span class="line">var obj = &#123; 0: <span class="string">"a"</span>, 1: <span class="string">"b"</span>, 2: <span class="string">"c"</span>&#125;;</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line"></span><br><span class="line">// 使用Array.forEach输出属性名和属性值</span><br><span class="line">Object.getOwnPropertyNames(obj).forEach(<span class="keyword">function</span>(val, idx, array) &#123;</span><br><span class="line">    console.log(val + <span class="string">" -&gt; "</span> + obj[val]);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出</span><br><span class="line">// 0 -&gt; a</span><br><span class="line">// 1 -&gt; b</span><br><span class="line">// 2 -&gt; c</span><br><span class="line"></span><br><span class="line">//不可枚举属性</span><br><span class="line">var my_obj = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    getFoo: &#123;</span><br><span class="line">        value: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.foo; &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">my_obj.foo = 1;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(my_obj).sort()); // [<span class="string">"foo"</span>, <span class="string">"getFoo"</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>只要获取到可枚举属性</strong>，可使用<code>Object.keys</code>或用<code>for…in</code>循环（<code>for…in</code>还会获取到原型链上的可枚举属性，不过<strong>可以使用<code>hasOwnProperty()</code>方法过滤掉</strong>）。</p></li><li>下面的例子演示了<code>Object.getOwnPropertyNames()</code>方法<strong>不会获取到原型链上的属性</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ParentClass</span></span>() &#123;&#125;</span><br><span class="line">ParentClass.prototype.inheritedMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ChildClass</span></span>() &#123;</span><br><span class="line">  this.prop = 5;</span><br><span class="line">  this.method = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildClass.prototype = new ParentClass;</span><br><span class="line">ChildClass.prototype.prototypeMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Object.getOwnPropertyNames(</span><br><span class="line">    new ChildClass()  // [<span class="string">"prop"</span>, <span class="string">"method"</span>]</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><blockquote>只获取不可枚举的属性</blockquote><ul><li><p>下面的例子使用了<code>Array.prototype.filter()</code>方法，从所有的属性名数组（使用<code>Object.getOwnPropertyNames()</code>方法获得）中去除可枚举的属性（使用<code>Object.keys()</code>方法获得），剩余的属性便是不可枚举的属性了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var target = myObject;</span><br><span class="line">var enum_and_nonenum = Object.getOwnPropertyNames(target);</span><br><span class="line">var enum_only = Object.keys(target);</span><br><span class="line">var nonenum_only = enum_and_nonenum.filter(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">    var indexInEnum = enum_only.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (indexInEnum == -1) &#123;</span><br><span class="line">        // 没有发现在enum_only键集中意味着这个键是不可枚举的,</span><br><span class="line">        // 因此返回<span class="literal">true</span> 以便让它保持在过滤结果中</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(nonenum_only);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>Array.filter(filt_func)</code>方法<strong>创建一个新数组</strong>, 其包含<strong>通过</strong>所提供函数实现的<strong>测试的所有元素</strong>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在 ES5 中，如果参数不是一个原始对象类型，将抛出一个 TypeError  异常。</li><li>在 ES2015 中，非对象参数被强制转换为对象 。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// [<span class="string">'length'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]  (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;方法返回一个由&lt;strong&gt;指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Object.keys的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/17/ObejectKeys/"/>
    <id>https://chongtianhong.github.io/2018/05/17/ObejectKeys/</id>
    <published>2018-05-17T01:44:26.000Z</published>
    <updated>2018-08-22T14:30:10.432Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.keys()</code>方法会返回一个由一个<strong>给定对象的自身可枚举属性（不包括可枚举属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><p>看下面的题目，输出对象中值大于2的key的数组，即期待输出的结果为：<code>[“c”,”d”]</code>请问xxx处填什么？：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> xxx ;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>正确答案：xxx处应该填入<code>data[x] &lt; 2</code>，即代码修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> data[x] &gt; 2;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>Object.keys()</code>是ES5中新增的方法，用来<strong>获取对象自身所有的可枚举的属性名</strong>，但<strong>不包括原型中的属性</strong>，然后返回一个<strong>由属性名组成的数组</strong>。</p></li><li>注意它同<code>for..in</code>一样<strong>不能保证属性按对象原来的顺序输出</strong>。数组中<strong>属性名的排列顺序和使用<code>for..in</code>循环遍历该对象时返回的顺序一致</strong>。</li><li><code>Array.filter(function)</code>对数组进行过滤返回符合条件的数组。</li><li><p>更多例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// simple array</span><br><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">console.log(Object.keys(arr)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object</span><br><span class="line">var obj = &#123; 0: <span class="string">'a'</span>, 1: <span class="string">'b'</span>, 2: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(obj)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object with random key ordering</span><br><span class="line">var anObj = &#123; 100: <span class="string">'a'</span>, 2: <span class="string">'b'</span>, 7: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(anObj)); // console: [<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'100'</span>]</span><br><span class="line"></span><br><span class="line">// getFoo is a property <span class="built_in">which</span> isn<span class="string">'t enumerable</span></span><br><span class="line"><span class="string">var myObj = Object.create(&#123;&#125;, &#123;</span></span><br><span class="line"><span class="string">    getFoo: &#123;</span></span><br><span class="line"><span class="string">        value: function () &#123; return this.foo; &#125;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">myObj.foo = 1;</span></span><br><span class="line"><span class="string">console.log(Object.keys(myObj)); // console: ['</span>foo<span class="string">']</span></span><br></pre></td></tr></table></figure></li><li><p>如果想获取一个对象的所有属性，甚至包括不可枚举的，应使用<code>Object.getOwnPropertyNames</code>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在ES5里，如果<strong>此方法的参数不是对象（而是一个原始值）</strong>，那么它<strong>会抛出 TypeError</strong>。</li><li>在ES2015中，非对象的参数将被强制转换为一个对象。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]                   (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.keys()&lt;/code&gt;方法会返回一个由一个&lt;strong&gt;给定对象的自身可枚举属性（不包括可枚举属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Object.create()的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/16/ObjectCreate/"/>
    <id>https://chongtianhong.github.io/2018/05/16/ObjectCreate/</id>
    <published>2018-05-16T02:49:41.000Z</published>
    <updated>2018-08-22T14:27:55.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>Object.create()</code>是Object的内置方法，可以创建一个新对象，<strong>使用现有的对象</strong>来<strong>提供新创建的对象的<code>__proto__</code></strong>。 <a id="more"></a></li><li>语法：<code>Object.create ( proto, [ propertiesObject ] ) </code></li><li>该方法有两个参数：<ul><li>第一个<strong>参数proto</strong>是一个对象，作为新建对象的原型对象；</li><li>第二个<strong>参数propertiesObject</strong>是可选的，如果<strong>没有则指定为 undefined</strong>。该<strong>参数对象</strong>是一组属性与值，该对象的<strong>属性名称</strong>将是<strong>新创建的对象的属性名称</strong>，<strong>值</strong>是<strong>属性描述符</strong>（这些属性描述符的结构与Object.defineProperties()的第三个参数一样）。如果<strong>propertiesObject参数不是 null 或一个对象，则抛出一个 TypeError 异常</strong>。</li></ul></li><li>使用该方法，创建对象会执行以下步骤：<br>①方法内部定义一个新的空对象obj<br>②将obj.__proto__的对象指向传入的参数proto<br>③返回一个新的对象</li><li><p>例子1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    isHuman: <span class="literal">false</span>,</span><br><span class="line">    printIntroduction: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(`My name is <span class="variable">$&#123;this.name&#125;</span>. Am I human? <span class="variable">$&#123;this.isHuman&#125;</span>`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me = Object.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">"Matthew"</span>; // <span class="string">"name"</span> is a property <span class="built_in">set</span> on <span class="string">"me"</span>, but not on <span class="string">"person"</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; // inherited properties can be overwritten</span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line">// expected output: <span class="string">"My name is Matthew. Am I human? true"</span></span><br></pre></td></tr></table></figure></li><li><p>例子2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var o;</span><br><span class="line"></span><br><span class="line">// 创建一个原型为null的空对象</span><br><span class="line">o = Object.create(null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line">// 以字面量方式创建的空对象就相当于:</span><br><span class="line">o = Object.create(Object.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = Object.create(Object.prototype, &#123;</span><br><span class="line">  // foo会成为所创建对象的数据属性</span><br><span class="line">    foo: &#123; </span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        value: <span class="string">"hello"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    // bar会成为所创建对象的访问器属性</span><br><span class="line">    bar: &#123;</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        get: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> 10 &#125;,</span><br><span class="line">        <span class="built_in">set</span>: <span class="keyword">function</span>(value) &#123;</span><br><span class="line">        console.log(<span class="string">"Setting `o.bar` to"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Constructor</span></span>()&#123;&#125;</span><br><span class="line">o = new Constructor();</span><br><span class="line">// 上面的一句就相当于:</span><br><span class="line">o = Object.create(Constructor.prototype);</span><br><span class="line">// 当然，如果在Constructor函数中有一些初始化代码，Object.create不能执行那些代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个以另一个空对象为原型，且拥有一个属性p的对象</span><br><span class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">// 省略了的属性特性默认为<span class="literal">false</span>，所以属性p是不可写，不可枚举，不可配置的:</span><br><span class="line">o.p = 24</span><br><span class="line">o.p</span><br><span class="line">//42</span><br><span class="line"></span><br><span class="line">o.q = 12</span><br><span class="line"><span class="keyword">for</span> (var prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">    console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">//<span class="string">"q"</span></span><br><span class="line"></span><br><span class="line">delete o.p</span><br><span class="line">//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//创建一个可写的，可枚举的，可配置的属性p</span><br><span class="line">o2 = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    p: &#123;</span><br><span class="line">        value: 42, </span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="与使用关键字new对象的区别"><a href="#与使用关键字new对象的区别" class="headerlink" title="与使用关键字new对象的区别"></a>与使用关键字new对象的区别</h4><ul><li>使用<code>Object.create()</code>是将对象继承到<code>__proto__</code>属性上：</li><li><code>new Object()</code>方法的实质是，<strong>使用引用类型Object的构造函数创建了一个新的实例</strong>，<strong>这个实例拥有Object默认的方法</strong>如<code>toString</code>、<code>toLocaleString</code>等：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">test</span> = Object.create(&#123;x:123,y:345&#125;);</span><br><span class="line">console.log(<span class="built_in">test</span>);// &#123;&#125;</span><br><span class="line">console.log(test.x);// 123</span><br><span class="line">console.log(test.__proto__.x);// 3</span><br><span class="line">console.log(test.__proto__.x === test.x);// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var test1 = new Object(&#123;x:123,y:345&#125;);</span><br><span class="line">console.log(test1);// &#123;x:123,y:345&#125;</span><br><span class="line">console.log(test1.x);// 123</span><br><span class="line">console.log(test1.__proto__.x);// undefined</span><br><span class="line">console.log(test1.__proto__.x === test1.x);// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">var test2 = &#123;x:123,y:345&#125;;</span><br><span class="line">console.log(test2);// &#123;x:123,y:345&#125;;</span><br><span class="line">console.log(test2.x);// 123</span><br><span class="line">console.log(test2.__proto__.x);// undefined</span><br><span class="line">console.log(test2.__proto__.x === test2.x);// <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.create()&lt;/code&gt;是Object的内置方法，可以创建一个新对象，&lt;strong&gt;使用现有的对象&lt;/strong&gt;来&lt;strong&gt;提供新创建的对象的&lt;code&gt;__proto__&lt;/code&gt;&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>前端路由的两种实现原理</title>
    <link href="https://chongtianhong.github.io/2018/05/15/frontEndRouting/"/>
    <id>https://chongtianhong.github.io/2018/05/15/frontEndRouting/</id>
    <published>2018-05-15T07:14:00.000Z</published>
    <updated>2018-08-20T14:38:25.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在<strong>单页应用</strong>上，前端路由并不陌生。单页应用是指<strong>在浏览器中运行的应用，在使用期间页面不会重新加载</strong>。</li><li>早期的路由都是后端实现的，直接<strong>根据url来重载页面</strong>，当页面变得越来越复杂时，服务器端压力变大。</li><li>随着<strong>ajax</strong>的出现，页面实现<strong>非重载</strong>就能刷新数据，也给前端路由的出现奠定了基础。我们可以<strong>通过修改 url 来记录 ajax 的变化</strong>，从而实现<strong>前端路由</strong>。<a id="more"></a></li><li>从<strong>性能</strong>和<strong>用户体验</strong>的层面来比较的话，<strong>后端路由每次访问一个新页面的时候都要向服务器发送请求</strong>，然后<strong>服务器</strong>再<strong>响应请求</strong>，这个过程肯定会有延迟。而<strong>前端路由在访问一个新页面的时候仅仅是变换了一下路径</strong>而已，<strong>没有了网络延迟</strong>，对于<strong>用户体验</strong>来说会有<strong>相当大的提升</strong>。 </li><li>从<strong>用户的角度</strong>看，前端路由主要实现了两个功能（使用ajax更新页面状态的情况下）：<ul><li><strong>记录当前页面的状态</strong>（保存或分享当前页的url，再次打开该url时，网页还是保存（分享）时的状态）；</li><li><strong>可以使用浏览器的前进后退功能</strong>（如点击后退按钮，可以使页面回到使用ajax更新页面之前的状态，url也回到之前的状态）；</li></ul></li><li>作为<strong>开发者</strong>，要实现这两个功能，我们需要做到：<ul><li>改变url且不让浏览器向服务器发出请求；</li><li>监测 url 的变化；</li><li>截获 url 地址，并解析出需要的信息来匹配路由规则。</li></ul></li><li>路由常用的hash模式和history模式实际上就是实现了上面的功能。</li></ul><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><ul><li>history 是 HTML5 才有的新 API，可以用来<strong>操作浏览器的 session history (会话历史)</strong>。</li><li>History API 能让开发人员在<strong>不刷新整个页面的情况下修改站点的URL</strong>。这个功能很有用，例如通过一段JavaScript代码局部加载页面的内容，你希望<strong>通过改变当前页面的URL来反应出页面内容的变化</strong>，这时该功能可以派上用场。</li><li>举个例子，当用户从首页进入帮助页面时，我们<strong>通过Ajax来加载帮助页面的内容</strong>。然后这个用户又转到产品页面，我们需要再一次通<strong>过Ajax请求来替换页面的内容</strong>。当用户想分享页面的URL时，通过History API，我们可以改变页面的URL来反应内容的修改，这样不管是用户分享还是保存的URL都能和页面的内容对应起来。</li><li>要查看这个API提供了哪些功能非常简单，打开浏览器的开发者工具面板（F12），然后在控制台（console）中输入<code>history</code>。如果浏览器支持History API，将会看到这个对象下面附带了很多方法。关于每个API的用法，可以查看MDN的文档。<br><img src="/images/history.png" width="600" alt="History API提供的功能" style="border:none"></li><li>重点说其中的两个新增的API：<code>history.pushState</code>和<code>history.replaceState</code>。</li><li>这两个 API 都接收三个参数，分别是：<ul><li><strong>状态对象（state object）</strong>：一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。</li><li><strong>标题（title）</strong>：截止到目前，几乎所有的浏览器都忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。</li><li><strong>地址（URL）</strong>：<strong>新的历史记录条目的地址</strong>。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；<strong>不指定的话则为文档当前URL</strong>。</li></ul></li><li><strong>相同之处</strong>是两个 API 都会<strong>操作浏览器的历史记录</strong>，而<strong>不会引起页面的刷新</strong>。</li><li><strong>不同之处</strong>在于，<code>history.pushState</code>会<strong>增加一条新的历史记录</strong>，而<code>history.replaceState</code>则会<strong>替换当前的历史记录</strong>。</li><li><code>history.pushState</code>将我们传给它的URL添加到浏览器的历史记录中，从而改变了浏览器的history。</li><li><strong><code>history.replaceState</code>只是简单地替换了地址栏中的URL（当前的历史记录），不会产生新的记录</strong>。也就是说，<code>history.replaceState</code>改变了当前页面的URL，并没有发出任何request请求，当前窗口仍然停留在之前的页面。当我们点击浏览器的后退按钮时，页面并不会回退到我们通过<code>history.replaceState</code>修改之前的那个URL，而是直接回退到了上一个页面（即我们进入到这个页面之前的那个页面）。</li></ul><blockquote>举例说明</blockquote><ul><li><p>在<strong>百度首页</strong>打开控制台，在控制台输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, <span class="string">"https://www.baidu.com/?name=xbhong"</span>);</span><br></pre></td></tr></table></figure></li><li><p>观察此时的 url 变成了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/?name=xbhong</span><br></pre></td></tr></table></figure></li><li><p>其他用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, <span class="string">"https://www.baidu.com/name/xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name/xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"?name=xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com?name=xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"name=xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name=xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"/name/xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name/xbhong</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：这里的<strong>url不支持跨域</strong>，当我们把<code>www.baidu.com</code>换成<code>baidu.com</code>时就会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught DOMException: Failed to execute <span class="string">'pushState'</span> on <span class="string">'History'</span>: A <span class="built_in">history</span> state object with URL <span class="string">'https://baidu.com/?name=xbhong'</span> cannot be created <span class="keyword">in</span> a document with origin <span class="string">'https://www.baidu.com'</span> and URL <span class="string">'https://www.baidu.com/?name=xbhong'</span>.</span><br></pre></td></tr></table></figure></li><li><p>从上面的例子可以看到，每次<strong>改变url页面并没有刷新</strong>，而浏览器会产生历史记录（可查询到历史记录），这就是<strong>实现页面无刷新情况下改变url</strong>的前提。</p></li></ul><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><ul><li>这里的 hash 就是指<strong>url尾巴后的 # 号以及后面的字符</strong>。这里的 # 和 css 里的 # 是一个意思。hash 也称作<strong>锚点</strong>，本身是用来做<strong>页面定位</strong>的，它可以<strong>使对应 id 的元素显示在可视区域内</strong>。</li><li><strong>基于hash的前端路由</strong>优点是：能<strong>兼容低版本的浏览器</strong>。大型框架的路由系统大多都是hash（哈希）实现的。</li><li><strong>基本原理</strong>：当 url 的 hash 发生改变时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。</li><li>使用到的api：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash = <span class="string">'qq'</span> // 设置 url 的 <span class="built_in">hash</span>，会在当前url后加上 <span class="string">'#qq'</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">hash</span> = window.location.hash // <span class="string">'#qq'</span>  </span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    // 监听<span class="built_in">hash</span>变化，点击浏览器的前进后退会触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote>hash 模式能兼容低版本的浏览器，为什么需要History API</blockquote><ul><li>hash 能兼容到IE8， History API只能兼容到 IE10，使用History API的原因是：<ul><li><strong>hash 本来是拿来做页面定位的</strong>，如果拿来做路由的话，原来的锚点功能就不能用了。</li><li>hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 <strong>history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中</strong>。</li><li>路由的 history 模式比较美观（没有#）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;单页应用&lt;/strong&gt;上，前端路由并不陌生。单页应用是指&lt;strong&gt;在浏览器中运行的应用，在使用期间页面不会重新加载&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;早期的路由都是后端实现的，直接&lt;strong&gt;根据url来重载页面&lt;/strong&gt;，当页面变得越来越复杂时，服务器端压力变大。&lt;/li&gt;
&lt;li&gt;随着&lt;strong&gt;ajax&lt;/strong&gt;的出现，页面实现&lt;strong&gt;非重载&lt;/strong&gt;就能刷新数据，也给前端路由的出现奠定了基础。我们可以&lt;strong&gt;通过修改 url 来记录 ajax 的变化&lt;/strong&gt;，从而实现&lt;strong&gt;前端路由&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="Router" scheme="https://chongtianhong.github.io/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>Promise 的链式调用与中止</title>
    <link href="https://chongtianhong.github.io/2018/05/14/promiseChain/"/>
    <id>https://chongtianhong.github.io/2018/05/14/promiseChain/</id>
    <published>2018-05-14T07:04:43.000Z</published>
    <updated>2018-08-19T08:45:53.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文主要讲的是如何<strong>实现 Promise 的链式调用</strong>，也就是<code>promise().then().then().catch()</code>的形式，然后讨论如何<strong>在某一个 then() 里面中止 Promise</strong>。<a id="more"></a></li><li>在程序中，只要<strong>返回了一个 promise 对象</strong>，只要<strong>该 promise 对象不是 Rejected 或 Fulfilled 状态，then 方法就会继续调用</strong>。利用这个特性，可以<strong>处理多个异步逻辑</strong>。</li><li>但有时候某个 then 方法的执行结果可能会决定是否需要执行下一个 then，这个时候就需中止 promise，主要思想就是<strong>使用 reject 来中止 promise 的 then 继续执行</strong>。</li></ul><h4 id="回顾Promise知识点"><a href="#回顾Promise知识点" class="headerlink" title="回顾Promise知识点"></a>回顾Promise知识点</h4><ul><li><p><strong>Promise</strong>其实很简单，就<strong>是一个处理异步的方法</strong>。一般可以通过 new 方法来调用 Promise 的构造器实例化一个 promise 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步处理</span><br><span class="line">    // 处理结束后，调用 resolve 或 reject</span><br><span class="line">    //      成功时就调用 resolve</span><br><span class="line">    //      失败时就调用 reject</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>用<code>new Promise</code>实例化的 promise 对象有以下三个状态：</p><ul><li>“has-resolution” - <strong>Fulfilled</strong>。resolve(成功)时，此时会调用 onFulfilled;</li><li>“has-rejection” - <strong>Rejected</strong>。reject(失败)时，此时会调用 onRejected;</li><li>“unresolved” - <strong>Pending</strong>。既不是resolve也不是reject的状态，也就是promise对象刚被创建后的初始化状态等。</li></ul></li><li>Promise对象的状态改变，只有两种可能：<strong>从Pending变为Fulfilled</strong>和<strong>从Pending变为Rejected</strong>。只要这两种情况发生，<strong>状态</strong>就<strong>凝固</strong>了，<strong>不会再变</strong>了，会一直保持这个结果。<br><img src="/images/promiseProcess.png" alt="promise的状态变化示意图" width="600" style="border:none"></li></ul><h4 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h4><ul><li><code>then()</code>方法的作用是<strong>为Promise实例添加解决（fulfillment）和拒绝（rejection）状态的回调函数</strong>。</li><li><code>then()</code>方法会<strong>返回一个新的Promise实例</strong>，所以<strong><code>then()</code>方法后面可以继续跟另一个<code>then()</code>方法进行链式调用</strong>。</li><li><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// promise start</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">        resolve(<span class="string">'start'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p1</span><br><span class="line"><span class="keyword">function</span> p1(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p2</span><br><span class="line"><span class="keyword">function</span> p2(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((reject)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        reject(2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p3</span><br><span class="line"><span class="keyword">function</span> p3(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        resolve(3);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p4</span><br><span class="line"><span class="keyword">function</span> p4(ex)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        resolve(4);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(p1)</span><br><span class="line">    .<span class="keyword">then</span>(p2)</span><br><span class="line">    .<span class="keyword">then</span>(p3)</span><br><span class="line">    .catch(p4)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // end</span><br><span class="line">        console.log(<span class="string">'result of p4: '</span>, data);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的代码最终会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result of start:  start</span><br><span class="line">result of p1:  1</span><br><span class="line">ex:  2</span><br><span class="line">result of p4:  4</span><br></pre></td></tr></table></figure></li><li><p>可以看到，代码的执行逻辑是<code>promise start –&gt; promise p1 –&gt; promise p3 –&gt; promise p4 –&gt; end</code>。所以可总结出以下几点：</p><ul><li>promise 的 <strong>then 方法里面</strong>可以<strong>继续返回一个新的 promise 对象</strong>;</li><li>下一个 <strong>then 方法的参数</strong>是<strong>上一个 promise 对象的 resolve 参数</strong>;</li><li><strong>catch 方法的参数</strong>是其<strong>之前某个 promise 对象的 rejecte 参数</strong>;</li><li>一旦某个 then 方法里面的 <strong>promise 状态改变为了 rejected</strong>，则promise 方法连会<strong>跳过后面的 then 直接执行 catch</strong>;</li><li><strong>catch 方法</strong>里面依旧<strong>可以返回一个新的 promise 对象</strong>。</li></ul></li></ul><h4 id="如何中指promise的链式调用"><a href="#如何中指promise的链式调用" class="headerlink" title="如何中指promise的链式调用"></a>如何中指promise的链式调用</h4><ul><li>通过上面的例子，我们可以知道<strong> promise 的状态改变为 rejected 后，promise 就会跳过后面的 then 方法</strong>。</li><li>也就是说，当<strong>某个 then 里面发生异常后</strong>，就会<strong>跳过 then 方法</strong>，<strong>直接执行 catch</strong>。</li><li><p>所以，当在构造的 promise 方法链中，如果<strong>在某个 then 后面，不需要再执行 then 方法了，就可以把它当作一个异常来处理</strong>，返回一个异常信息给 catch，其参数可自定义，比如该异常的参数信息为 { notRealPromiseException: true}，然后在 catch 里面判断一下 notRealPromiseException 是否为 true，如果为 true，就说明不是程序出现异常，而是在正常逻辑里面中止 then 方法的执行。代码示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise start</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(1); // p1</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p1</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.reject(&#123;</span><br><span class="line">            notRealPromiseException: <span class="literal">true</span>,</span><br><span class="line">        &#125;); // p2</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p2</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(3); // p3</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(ex =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        <span class="keyword">if</span> (ex.notRealPromiseException) &#123;</span><br><span class="line">            // 一切正常，只是通过 catch 方法来中止 promise chain</span><br><span class="line">            // 也就是中止 promise p2 的执行</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // 真正发生异常</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样的做法可能不符合<code>catch</code>的语义。不过从某种意义上来说，promise 方法链没有继续执行，也可以算是一种“异常”。</p></li></ul><h4 id="Promise-all-与-Promise-race"><a href="#Promise-all-与-Promise-race" class="headerlink" title="Promise.all 与 Promise.race"></a>Promise.all 与 Promise.race</h4><ul><li>其实 promise 方法链更好用的一点是，当<strong>下一个操作依赖于上一个操作的结果</strong>的时候，可以很方便地<strong>通过 then 方法的参数来传递数据</strong>。</li><li>前面也提到过，<strong>下一个 then 方法的参数就是上一个 then 方法里面 resolve 的参数</strong>，所以当然就可以<strong>把上一个 then 方法的执行结果作为参数传递给下一个 then 方法</strong>。</li><li><p>还有些时候，可能 then 方法的执行顺序也没有太多要求，只需要 promise 方法链中的两个或多个 promise 全部都执行正确。这时，如果依旧一个一个去写 then 可能就比较麻烦，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p2</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p3</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在<strong>只需要<code>p1</code>、<code>p2</code>、<code>p3</code>这三个 promise 都执行</strong>，并且 <strong>promise 最终状态都是 Fulfilled</strong>，那么如果还是使用链式调用，这时这样调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p1()</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p2();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p3();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>代码貌似就不那么精炼了。这个时候就有了 <code>Promise.all</code> 这个方法。</p></li><li><code>Promise.all</code> 接收一个<strong>promise对象的数组</strong>作为参数，当这个数组里的所有 promise 对象<strong>全部变为 resolve</strong> 或 <strong>reject 状态</strong>的时候，它才会去调用 then 方法。</li><li><p>于是，调用这几个 promise 的代码就可以这样写了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([p1, p2, p3]).<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;).catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>对于 <code>Promise.race</code>，其<strong>参数</strong>也跟 <code>Promise.all</code> 一样<strong>*是一个数组</strong>。只是<strong>数组中的任何一个 promise 对象如果变为 resolve 或者reject 的话，该函数就会返回</strong>，并<strong>使用这个 promise 对象的值进行 resolve 或者 reject</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本文主要讲的是如何&lt;strong&gt;实现 Promise 的链式调用&lt;/strong&gt;，也就是&lt;code&gt;promise().then().then().catch()&lt;/code&gt;的形式，然后讨论如何&lt;strong&gt;在某一个 then() 里面中止 Promise&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Promise" scheme="https://chongtianhong.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Ajax中返回数据的格式和处理方法分析</title>
    <link href="https://chongtianhong.github.io/2018/05/13/ajaxDataType/"/>
    <id>https://chongtianhong.github.io/2018/05/13/ajaxDataType/</id>
    <published>2018-05-13T05:51:23.000Z</published>
    <updated>2018-08-18T12:35:57.196Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Ajax中常见的<strong>返回数据的格式</strong>有三种：分别为<strong>文本</strong>，<strong>XML</strong>和<strong>JSON</strong>。<a id="more"></a></li></ul><h4 id="Text-HTML格式"><a href="#Text-HTML格式" class="headerlink" title="Text/HTML格式"></a>Text/HTML格式</h4><ul><li>通过Ajax对象的<code>responseText</code>属性就可以获取到返回的文本信息。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxText(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(oAjax.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="XML格式"><a href="#XML格式" class="headerlink" title="XML格式"></a>XML格式</h4><ul><li>通过Ajax对象的<code>responseXML</code>属性就可以获取到返回的<strong>XML DOM</strong>对象。</li><li><p>解析<strong>XML DOM</strong>的数据就类似于HTML DOM 编程. 比如<strong>通过TagName获取标签对象</strong>(数组形式)，再从该数组中获取需要的标签对象，再从标签对象中获取文本值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(XML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param tagName  要获取值的标签名</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxXML(url, jsonData, tagName, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   //拼 装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var oXml =  oAjax.responseXML; //返 回的是一个XML DOM对象</span><br><span class="line">            var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">            var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(tagValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>XML文件具有的几大特点：</p><ul><li>标签没有预定义，开发者根据自己的需求发明标签</li><li>结构清晰，具有自我描述性。从XML文档就可以看出数据的内容</li><li>都是双标签</li><li>和HTML相似，同样也具有树结构</li></ul></li></ul><h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><ul><li>由于JSON格式相比XML更小，传输更快，所以现在Ajax返回json数据格式的情况更多。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)，但是返回的是Json类型的文本数据</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据,利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxJson(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>); // 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var json = JSON.parse(oAjax.responseText);// 把传回来的字符串解析成json对象</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三种格式的函数封装"><a href="#三种格式的函数封装" class="headerlink" title="三种格式的函数封装"></a>三种格式的函数封装</h4><ul><li>为了方便使用，可以把三个函数合并，合并后的函数如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @<span class="keyword">function</span> 利用ajax动态交换数据</span><br><span class="line"> * @param url   要提交请求的页面</span><br><span class="line"> * @param jsonData  要提交的数据,利用Json传递</span><br><span class="line"> * @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line"> * @param <span class="built_in">type</span>    接受的数据类型,text/xml/json</span><br><span class="line"> * @param tagName <span class="built_in">type</span> = xml 的时候这个参数设置为要获取的文本的标签名</span><br><span class="line"> * @<span class="built_in">return</span> 无</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> ajax(url,jsonData,getMsg,<span class="built_in">type</span>,tagName)&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'text'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(oAjax.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'json'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var json = JSON.parse(oAjax.responseText); // 把传回来的字符串解析成json对象</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'xml'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var oXml =  oAjax.responseXML; // 返回的是一个XML DOM对象</span><br><span class="line">                var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">                var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(tagValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Ajax中常见的&lt;strong&gt;返回数据的格式&lt;/strong&gt;有三种：分别为&lt;strong&gt;文本&lt;/strong&gt;，&lt;strong&gt;XML&lt;/strong&gt;和&lt;strong&gt;JSON&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Ajax" scheme="https://chongtianhong.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>浅谈arguments与arguments的妙用</title>
    <link href="https://chongtianhong.github.io/2018/05/12/arguments/"/>
    <id>https://chongtianhong.github.io/2018/05/12/arguments/</id>
    <published>2018-05-12T12:41:53.000Z</published>
    <updated>2018-08-18T12:38:49.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>每个函数都有一个<strong>arguments属性</strong>，表示函数的<strong>实参集合</strong>，这里的实参是重点，就是<strong>执行函数时实际传入的参数的集合</strong>。<a id="more"></a></li><li><strong>arguments</strong>不是数组而是一个<strong>对象</strong>，但它和数组很相似，所以通常称为<strong>类数组对象</strong>，以后看到类数组其实就表示<strong>arguments</strong>。</li><li><p><strong>arguments有length属性</strong>，表示函数实参个数，可以用<code>arguments[index]</code>显式调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(var i=0; i&lt; arguments.length; i++)&#123;</span><br><span class="line">        console.log(arguments[i]);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">"a"</span>, 17, [1, 2, 3], &#123;name:<span class="string">"javascript"</span>, <span class="built_in">type</span>:<span class="string">"language"</span>&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">a</span><br><span class="line">17</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&#123;name: <span class="string">"javascript"</span>, <span class="built_in">type</span>: <span class="string">"language"</span>&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><strong>arguments</strong>还有一个叫做<code>callee</code>的属性，这个属性是表示的是<strong>当前函数的一个引用</strong>，简单点说，这个属性里面存储的我们调用的这个函数的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showcallee</span></span>() &#123;</span><br><span class="line">    var a = <span class="string">'这里是代码'</span>;</span><br><span class="line">    var b = <span class="string">'这是另一段代码'</span>;</span><br><span class="line">    var c = a + b;</span><br><span class="line"></span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">showcallee();</span><br><span class="line">// arguments.callee将完整地把这个函数的所有代码返回。</span><br></pre></td></tr></table></figure></li></ul><h4 id="arguments的妙用"><a href="#arguments的妙用" class="headerlink" title="arguments的妙用"></a>arguments的妙用</h4><h5 id="利用arguments实现方法的重载"><a href="#利用arguments实现方法的重载" class="headerlink" title="利用arguments实现方法的重载"></a>利用arguments实现方法的重载</h5><ul><li><p>由于<strong>Javascript</strong>是一种<strong>弱类型</strong>的语言，<strong>没有重载机制</strong>，当我们重写函数时，会将原来的函数直接覆盖，这里我们能<strong>利用arguments</strong>，来<strong>判断传入的实参类型与数量进行不同的操作</strong>，然后<strong>返回不同的数值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">doAdd</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(arguments.length == 1) &#123;</span><br><span class="line">        alert(arguments[0] + 5);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arguments.length == 2) &#123;</span><br><span class="line">        alert(arguments[0] + arguments[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(10);//输出 <span class="string">"15"</span></span><br><span class="line">doAdd(40, 20);//输出 <span class="string">"60"</span></span><br></pre></td></tr></table></figure></li><li><p>当只有一个参数时，<code>doAdd()</code>函数给参数加 5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，<code>doAdd(10)</code>输出的是 “15”，而<code>doAdd(40, 20)</code>输出的是 “60”。</p></li></ul><h5 id="利用arguments-callee实现递归"><a href="#利用arguments-callee实现递归" class="headerlink" title="利用arguments.callee实现递归"></a>利用arguments.callee实现递归</h5><ul><li><p>用之前的方法来实现一个<strong>计算阶乘</strong>的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * factorial(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是当这个函数变成了一个匿名函数时，我们就可以利用<code>callee</code>来递归这个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * arguments.callee(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：在<strong>严格模式</strong>中<code>arguments.callee</code>这个属性被<strong>禁止使用</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个函数都有一个&lt;strong&gt;arguments属性&lt;/strong&gt;，表示函数的&lt;strong&gt;实参集合&lt;/strong&gt;，这里的实参是重点，就是&lt;strong&gt;执行函数时实际传入的参数的集合&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="arguments" scheme="https://chongtianhong.github.io/tags/arguments/"/>
    
  </entry>
  
</feed>
