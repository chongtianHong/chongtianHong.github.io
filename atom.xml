<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-07-29T08:09:24.849Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器强缓存和协商缓存</title>
    <link href="https://chongtianhong.github.io/2018/04/15/browserCache/"/>
    <id>https://chongtianhong.github.io/2018/04/15/browserCache/</id>
    <published>2018-04-15T05:36:26.000Z</published>
    <updated>2018-07-29T08:09:24.849Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>浏览器缓存</strong>是浏览器在<strong>本地磁盘</strong>对用户<strong>最近请求过的文档</strong>进行存储，当访问者再次访问同一页面时，浏览器就可以直接<strong>从本地磁盘加载文档</strong>。</li><li>浏览器缓存有下面的优点：<ul><li>减少冗余的数据传输；</li><li>减少服务器负担；</li><li>加快客户端加载网页的速度。<a id="more"></a></li></ul></li></ul><h4 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h4><ul><li>根据<strong>是否需要重新向服务器发起请求</strong>来分类，浏览器缓存可以分为<strong>强缓存</strong>和<strong>协商缓存</strong>两大类。强缓存不发请求到服务器，协商缓存会发请求到服务器。</li><li>两类缓存规则<strong>可以同时存在</strong>，<strong>强缓存优先级高于协商缓存</strong>，也就是说，当执行强缓存的规则时，<strong>如果强缓存生效，直接使用强缓存，不再执行协商缓存规则</strong>。</li><li>对于<strong>强缓存</strong>，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存；不在时间内，则执行协商缓存策略。</li><li>对于<strong>协商缓存</strong>，将缓存信息中的<code>Etag</code>对应的<code>If-None-Match</code>和<code>Last-Modified</code>对应的<code>If-Modified-Since</code>通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li><li>浏览器<strong>第一次</strong>请求时：<br><img src="/images/firstRequest.png" alt="浏览器第一次请求" style="border:none"></li><li>由上图可以看到，在<strong>客户端第一次请求数据</strong>时，此时<strong>缓存数据库中没有对应的缓存数据</strong>，<strong>需要请求服务器</strong>，<strong>服务器返回后，将数据存储至缓存数据库中</strong>。</li><li>浏览器<strong>后续</strong>在进行请求时：<br><img src="/images/afterRequest.png" alt="浏览器后续请求" style="border:none"></li><li>可以看到，浏览器后续在进行请求时，<strong>如果资源已经被浏览器缓存下来</strong>，在缓存失效之前，再次请求时，默认的处理方式为：<ul><li>默认会<strong>先检查是否命中强缓存（cache-control和expires信息）</strong>，如果强缓存命中则直接读取缓存，包括缓存header信息；</li><li><strong>如果强缓存没有命中</strong>，则发请求到服务器，<strong>请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match）</strong>，由<strong>服务器</strong>根据请求中的相关header信息来<strong>检查是否命中协商缓存</strong>，若协商缓存命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并<strong>不返回资源内容</strong>，它会告知浏览器可以直接从缓存获取（返回304状态码）；</li><li>如果强缓存和协商缓存都没有命中，服务器则返回最新的资源。</li></ul></li><li>强缓存与协商缓存的<strong>共同点</strong>是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据。</li><li>强缓存与协商缓存的<strong>区别</strong>，可以用下表来进行描述：</li></ul><table><thead><tr><th style="text-align:center">&nbsp;</th><th style="text-align:center">获取资源形式</th><th style="text-align:center">状态码</th><th style="text-align:center">是否发请求到服务器</th></tr></thead><tbody><tr><td style="text-align:center">强缓存</td><td style="text-align:center">从缓存取</td><td style="text-align:center">200(from cache)</td><td style="text-align:center">否，直接从缓存取</td></tr><tr><td style="text-align:center">协商缓存</td><td style="text-align:center">从缓存取</td><td style="text-align:center">304(not modified)</td><td style="text-align:center">是，通过服务器来告知缓存是否可用</td></tr></tbody></table><h4 id="强缓存相关的header字段"><a href="#强缓存相关的header字段" class="headerlink" title="强缓存相关的header字段"></a>强缓存相关的header字段</h4><ul><li>当浏览器对某个资源的请求命中了强缓存时，返回的http状态码为200，在chrome的开发者工具的network里面size会显示为<code>from cache</code>。</li><li>强缓存<strong>直接从缓存中获取资源</strong>而不经过服务器。</li><li>与强缓存相关的header字段有两个：分别是<code>Expires</code>和<code>Cache-Control</code>，它们都用来表示<strong>资源在客户端缓存的有效期</strong>。</li></ul><blockquote>Expires</blockquote><ul><li><p><code>Expires</code>是http1.0提出的一个表示资源过期时间的header，它描述的是一个<strong>绝对时间</strong>，由服务器返回，用GMT格式的字符串表示，如：<code>Expires:Thu, 31 Dec 2037 23:55:55 GMT</code>，它的缓存原理是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；</span><br><span class="line">2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</span><br><span class="line">3.浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；</span><br><span class="line">4.如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</span><br></pre></td></tr></table></figure></li><li><p><code>Expires</code>是较老的强缓存管理header，由于它是<strong>服务器返回的一个绝对时间</strong>，在<strong>服务器时间与客户端时间相差较大</strong>时，<strong>缓存管理容易出现问题</strong>，比如随意修改下客户端时间，就能影响缓存命中的结果。</p></li></ul><blockquote>Cache-Control</blockquote><ul><li><p>由于<code>Expires</code>存在着缺陷，在http1.1的时候，提出了一个新的header，就是<code>Cache-Control</code>，主要是利用该字段的<code>max-age</code>值来进行判断，是一个<strong>相对时间</strong>，在配置缓存的时候，以秒为单位，用数值表示，如：<code>Cache-Control:max-age=315360000</code>，它的缓存原理是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；</span><br><span class="line">2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</span><br><span class="line">3.浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；</span><br><span class="line">4.如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</span><br></pre></td></tr></table></figure></li><li><p><code>Cache-Control</code>除了设置max-age值外，还有下面几个比较常用的设置值：</p><ul><li><code>no-cache</code>：<strong>不使用本地缓存</strong>。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li><li><code>no-store</code>：<strong>直接禁止浏览器缓存数据</strong>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li><code>public</code>：可以被<strong>所有的用户的浏览器缓存</strong>，包括终端用户和CDN等中间代理服务器。</li><li><code>private</code>：只能被<strong>终端用户的浏览器缓存</strong>，不允许CDN等中继缓存服务器对其缓存。<strong>如果<code>Cache-Control</code>仅指定了max-age，则默认为private</strong>。</li></ul></li><li><code>Cache-Control</code>描述的是一个<strong>相对时间</strong>，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<strong><code>Expires</code>，Cache-Control的缓存管理更有效，安全一些</strong>。</li><li>这两个header可以只启用一个，也可以同时启用，当response header中的<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>。</li></ul><h4 id="协商缓存相关的header字段"><a href="#协商缓存相关的header字段" class="headerlink" title="协商缓存相关的header字段"></a>协商缓存相关的header字段</h4><ul><li><strong>协商缓存</strong>都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而<strong>让服务器判断请求资源是否可以使用缓存访问</strong>。</li><li>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，<strong>如果协商缓存命中</strong>，<strong>请求响应返回的http状态码为304并且会显示一个Not Modified的字符串</strong>。</li><li><strong>协商缓存</strong>主要涉及到两组header字段，这两组搭档都是<strong>成对出现</strong>的，即第一次<strong>请求的响应头</strong>带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的<strong>请求字段</strong>（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</li></ul><blockquote>Last-Modified/If-Modified-Since</blockquote><ul><li><p>二者的值都是GMT格式的时间字符串，它们的<strong>控制缓存的原理</strong>是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</span><br><span class="line">2.浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时服务器返回的Last-Modified的值：</span><br><span class="line">3.服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间对比判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化则正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header(既然资源没有变化，那么Last-Modified也就不会改变)，这是服务器返回304时的response header：</span><br><span class="line">4.浏览器收到304的响应后，就会从缓存中加载资源。</span><br><span class="line">5.如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</span><br></pre></td></tr></table></figure></li><li><p>Last-Modified/If-Modified-Since都是<strong>根据服务器时间</strong>返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会存在<strong>服务器上资源其实有变化，但是最后修改时间却没有变化的情况</strong>，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会<strong>影响协商缓存的可靠性</strong>。</p></li></ul><blockquote>Etag/If-None-Match</blockquote><ul><li>这两个值是<strong>由服务器生成</strong>的每个资源的<strong>唯一标识字符串</strong>，只要<strong>资源有变化就这个值就会改变</strong>，<strong>跟最后修改时间没有关系</strong>，所以能很好的补充Last-Modified的问题。</li><li>其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，<strong>由于ETag重新生成过，response header中还会把这个ETag返回</strong>，即使这个ETag跟之前的没有变化。</li></ul><blockquote>既生Last-Modified何生Etag</blockquote><ul><li>HTTP1.1中Etag的出现主要是<strong>为了解决几个Last-Modified比较难解决的问题</strong>：<ul><li><strong>一些文件也许会周期性的更改</strong>，但是他的内容并不改变(<strong>仅仅改变的修改时间</strong>)，这个时候我们并<strong>不希望客户端认为这个文件被修改了，而重新请求</strong>；</li><li><strong>某些文件修改非常频繁，比如在秒以下的时间内进行修改</strong>，(比方说1s内修改了N次)，<strong>If-Modified-Since能检查到的粒度是秒级的</strong>，<strong>这种修改无法判断</strong>(或者说UNIX记录MTIME只能精确到秒)；</li><li><strong>某些服务器不能精确的得到文件的最后修改时间</strong>。</li></ul></li><li>这时，<strong>利用Etag能够更加准确的控制缓存</strong>，因为Etag是服务器自动生成或者由开发者生成的<strong>对应资源在服务器端的唯一标识符</strong>。</li><li>Last-Modified与ETag是可以一起使用的，服务器会<strong>优先验证ETag</strong>，一致的情况下，才会<strong>继续比对Last-Modified</strong>，最后才决定是否返回304。</li><li>然而，在<strong>性能</strong>上，<strong>Etag要逊于Last-Modified</strong>，毕竟Last-Modified只需要记录时间，而<strong>Etag需要服务器通过算法来计算出一个hash值</strong>。</li></ul><h4 id="用户的行为对缓存的影响"><a href="#用户的行为对缓存的影响" class="headerlink" title="用户的行为对缓存的影响"></a>用户的行为对缓存的影响</h4><ul><li>当使用<code>Ctrl + F5</code><strong>强制刷新网页</strong>时，直接从服务器加载，跳过强缓存和协商缓存。</li><li>当使用<code>F5</code><strong>刷新网页</strong>时，跳过强缓存，但是会检查协商缓存。</li></ul><h4 id="强缓存如何重新加载缓存缓存过的资源"><a href="#强缓存如何重新加载缓存缓存过的资源" class="headerlink" title="强缓存如何重新加载缓存缓存过的资源"></a>强缓存如何重新加载缓存缓存过的资源</h4><ul><li>上面说到，使用<strong>强缓存</strong>时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源。</li><li>可以通过<strong>更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源</strong>来解决这一情况。可采用附加特征参数的方法：<ul><li>在URL后面加上一个随机数：<code>“fresh=” + Math.random();。</code></li><li>在URL后面加上时间戳：<code>“nowtime=” + new Date().getTime();</code>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;浏览器缓存&lt;/strong&gt;是浏览器在&lt;strong&gt;本地磁盘&lt;/strong&gt;对用户&lt;strong&gt;最近请求过的文档&lt;/strong&gt;进行存储，当访问者再次访问同一页面时，浏览器就可以直接&lt;strong&gt;从本地磁盘加载文档&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;浏览器缓存有下面的优点：&lt;ul&gt;
&lt;li&gt;减少冗余的数据传输；&lt;/li&gt;
&lt;li&gt;减少服务器负担；&lt;/li&gt;
&lt;li&gt;加快客户端加载网页的速度。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="强缓存" scheme="https://chongtianhong.github.io/tags/%E5%BC%BA%E7%BC%93%E5%AD%98/"/>
    
      <category term="协商缓存" scheme="https://chongtianhong.github.io/tags/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    
      <category term="HTTP" scheme="https://chongtianhong.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>什么是无样式内容闪烁?如何避免?</title>
    <link href="https://chongtianhong.github.io/2018/04/14/FOUC/"/>
    <id>https://chongtianhong.github.io/2018/04/14/FOUC/</id>
    <published>2018-04-14T03:27:46.000Z</published>
    <updated>2018-07-29T03:57:02.657Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是FOUC-无样式内容闪烁"><a href="#什么是FOUC-无样式内容闪烁" class="headerlink" title="什么是FOUC(无样式内容闪烁)"></a>什么是FOUC(无样式内容闪烁)</h4><ul><li>如果使用<code>@import</code>方法对CSS进行导入，会导致某些页面在Windows下的Internet Explorer出现一些奇怪的现象：<strong>以无样式显示页面内容的瞬间闪烁</strong>，这种现象称之为<strong>文档样式短暂失效</strong>(Flash of Unstyled Content)，简称为FOUC。<a id="more"></a></li></ul><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul><li>原理：当<strong>样式表晚于结构性html加载</strong>，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将<strong>重新渲染页面</strong>，也就出现了<strong>短暂的花屏现象</strong>。</li><li>FOUC的产生主要是由于<strong>浏览器先显示已加载的HTML内容，等到CSS加载完成后重新对内容添加样式</strong>导致，主要代表有<strong>Firefox</strong>。导致FOUC的原因有以下三种：<ul><li>使用<code>@import</code>导入样式表。</li><li>将样式表放在页面底部。</li><li>有几个样式表，放在页面不同位置。</li></ul></li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>使用LINK标签将样式表放在文档HEAD中。</li></ul><h4 id="白屏和FOUC"><a href="#白屏和FOUC" class="headerlink" title="白屏和FOUC"></a>白屏和FOUC</h4><ul><li>白屏和FOUC（无样式内容闪烁）的产生主要<strong>与浏览器的渲染机制有关</strong>：<ul><li>有的浏览器是<strong>等待HTML和CSS全部加载完成后再进行渲染</strong>（白屏原因）；</li><li>有的浏览器是<strong>先显示已加载的HTML内容，等到CSS加载完成后再重新对内容添加样式</strong>（FOUC原因）。</li></ul></li></ul><blockquote>白屏的产生</blockquote><ul><li>白屏的产生有三种情况：<ul><li>将CSS文件放在HTML文档的最后。</li><li>使用<code>@import</code>导入样式表（通过<code>@import</code>引入的CSS文件会被最后加载）。</li><li>将JS文件放在头部，未使用defer或async延迟或异步加载JS文件，导致JS阻塞HTML和CSS的加载。</li></ul></li></ul><blockquote>白屏的原理分析</blockquote><ul><li>对于-webkit内核的浏览器（IE也会产生），在<strong>进行网页渲染时</strong>，会同时<strong>加载HTML和CSS</strong>分别<strong>构建DOM树和CSSOM树</strong>，等<strong>两者都构建完成后</strong>，再<strong>绘制渲染树</strong>，然后<strong>将页面显示出来</strong>。</li><li>如果在HTML中将CSS放置在文档最后，那么会导致<strong>CSSOM晚于DOM树的建立，浏览器需要等待CSSOM的建立，然后才进行网页内容的绘制</strong>，这个等待的过程，没有内容显示，就<strong>导致了白屏的产生</strong>。</li><li>因此，在开发中，需要<strong>使用LINK标签将样式表放在文档HEAD中，让其与HTML内容同时被加载</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是FOUC-无样式内容闪烁&quot;&gt;&lt;a href=&quot;#什么是FOUC-无样式内容闪烁&quot; class=&quot;headerlink&quot; title=&quot;什么是FOUC(无样式内容闪烁)&quot;&gt;&lt;/a&gt;什么是FOUC(无样式内容闪烁)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果使用&lt;code&gt;@import&lt;/code&gt;方法对CSS进行导入，会导致某些页面在Windows下的Internet Explorer出现一些奇怪的现象：&lt;strong&gt;以无样式显示页面内容的瞬间闪烁&lt;/strong&gt;，这种现象称之为&lt;strong&gt;文档样式短暂失效&lt;/strong&gt;(Flash of Unstyled Content)，简称为FOUC。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="浏览器渲染机制" scheme="https://chongtianhong.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>href和src的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/13/hrefAndSrc/"/>
    <id>https://chongtianhong.github.io/2018/04/13/hrefAndSrc/</id>
    <published>2018-04-13T02:48:03.000Z</published>
    <updated>2018-07-29T03:20:25.771Z</updated>
    
    <content type="html"><![CDATA[<ul><li>src和href之间存在区别：<ul><li><code>src</code>是引入，用于替换当前元素；</li><li><code>href</code>是引用，用于在当前文档和引用资源之间确立联系。 </li></ul></li><li><strong>注意</strong>：JS、CSS中如有重定义，后定义函数将覆盖前定义函数。<a id="more"></a></li></ul><blockquote>href</blockquote><ul><li><code>href</code>表示<strong>超文本引用</strong>（hypertext reference），用在link和a等元素上，<code>href</code>引用的内容与该页面有关联，是<strong>在当前元素和引用资源之间建立联系</strong>。</li><li><code>href</code>引用的内是外部资源而非网页不可或缺的一部分，因此在遇到<code>href</code>时浏览器会在下载CSS文件的<strong>同时去处理网页的其他部分</strong>。</li><li>注意：建议<strong>使用link方式来加载css</strong>而不是使用@import。</li></ul><blockquote>补充：link和@import的区别</blockquote><ul><li>两者都是外部引用CSS的方式，但是存在一定的区别：<ul><li>区别1：<strong>link是XHTML标签</strong>，除了加载CSS外，还可以定义RSS、定义rel连接属性等其他事务；<strong>@import属于CSS范畴，只能加载CSS</strong>。</li><li>区别2：<strong>link</strong>引用CSS时，在<strong>页面载入时同时加载</strong>；<strong>@import</strong>需要<strong>页面网页完全载入以后加载</strong>。</li><li>区别3：<strong>link是XHTML标签，无兼容问题</strong>；<strong>@import</strong>是在CSS2.1提出的，<strong>低版本的浏览器不支持</strong>。</li><li>区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul></li></ul><blockquote>src</blockquote><ul><li><code>src</code>表示<strong>外部资源引入</strong>，用于<strong>替换当前元素</strong>，用在img，script，iframe等元素上，<code>src</code>是<strong>页面内容不可缺少的一部分</strong>。</li><li>在遇到<code>src</code>时浏览器会<strong>等待这一部分下载运行结束</strong>才会继续处理下面的网页，这也是为什么&lt;script&gt;标签最好放在网页底部。（在加载js文件时，浏览器会阻止页面的渲染）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;src和href之间存在区别：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;是引入，用于替换当前元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;href&lt;/code&gt;是引用，用于在当前文档和引用资源之间确立联系。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：JS、CSS中如有重定义，后定义函数将覆盖前定义函数。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>querySelector与getElementBy等的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/12/querySelector/"/>
    <id>https://chongtianhong.github.io/2018/04/12/querySelector/</id>
    <published>2018-04-12T14:45:24.000Z</published>
    <updated>2018-07-29T02:39:41.222Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>常见的获取元素的方法有3种，分别是通过元素ID、通过标签名字和通过类名字来获取。</li><li><code>querySelector</code> 和 <code>querySelectorAll</code> 方法的作用是根据 CSS 选择器规范，使用和jquery查询方式一样，可以便捷定位文档中指定元素。<a id="more"></a></li></ul><blockquote>通过元素ID获取元素</blockquote><ul><li>DOM提供了一个名为<code>getElementById</code>的方法，这个方法将返回一个与之对应id属性的节点对象，它是<code>document</code>对象特有的函数，只能通过其来调用该方法，使用方法如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(<span class="string">'idName'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote>通过标签名字获取元素</blockquote><ul><li><code>getElementsByTagName</code>方法返回一个对象数组（准确的说是HTMLCollection集合）,返回元素的顺序是它们在文档中的顺序,传递给 <code>getElementsByTagName()</code> 方法的字符串可以不区分大小写,使用方法如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(tagName);</span><br></pre></td></tr></table></figure></li></ul><blockquote>通过类名字获取元素</blockquote><ul><li>DOM还提供了<code>getElementsByClassName</code>方法来获取指定class名的元素,该方法返回文档中所有指定类名的元素集合，作为 NodeList 对象。NodeList 对象代表一个有顺序的节点列表。NodeList 对象 我们可通过节点列表中的节点索引号来访问列表中的节点(索引号由0开始), 所以有时使用时要指定下标，使用方法如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByClassName(<span class="string">'className'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote>使用<code>querySelector</code> 和 <code>querySelectorAll</code> 方法更便捷地定位元素</blockquote><ul><li><code>querySelector()</code> 方法返回匹配指定 CSS 选择器元素的第一个元素。该方法<strong>只返回匹配指定选择器的第一个元素</strong>。</li><li>如果要返回所有匹配元素，需要使用 <code>querySelectorAll()</code> 方法替代．</li><li>由于<code>querySelector()</code>是按css规范来实现的，所以它<strong>传入的字符串中第一个字符不能是数字</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 获取文档中 id=<span class="string">"demo"</span> 的元素</span><br><span class="line">document.querySelector(<span class="string">"#demo"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中第一个 &lt;p&gt; 元素</span><br><span class="line">document.querySelector(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中 class=<span class="string">"example"</span> 的第一个元素</span><br><span class="line">document.querySelector(<span class="string">".example"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中 class=<span class="string">"example"</span> 的第一个 &lt;p&gt; 元素</span><br><span class="line">document.querySelector(<span class="string">"p.example"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中有 <span class="string">"target"</span> 属性的第一个 &lt;a&gt; 元素</span><br><span class="line">document.querySelector(<span class="string">"a[target]"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中class = <span class="string">"li"</span> 的div</span><br><span class="line">document.querySelectorAll(<span class="string">"div .li"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中id = <span class="string">"k"</span>的节点下的第一个span节点</span><br><span class="line">document.querySelector(<span class="string">"#k span"</span>);</span><br><span class="line"></span><br><span class="line">// 对于多个选择器，使用逗号隔开，只返回一个匹配的元素。</span><br><span class="line">document.querySelector(<span class="string">"h2, h3"</span>).style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">// 如果文档中 &lt;h2&gt; 元素位于 &lt;h3&gt; 元素之前，&lt;h2&gt; 元素将会被设置指定的背景颜色。</span><br><span class="line">// 如果文档中 &lt;h3&gt; 元素位于 &lt;h2&gt; 元素之前，&lt;h3&gt; 元素将会被设置指定的背景颜色。</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>query选择符选出来的元素及元素数组</strong>是<strong>静态</strong>的，而<strong>getElement</strong>这种方法<strong>选出的元素是动态的</strong>。<ul><li>静态的意思是，选出的所有元素的数组，<strong>不会随着文档操作而改变</strong>。</li></ul></li><li>在使用的时候<strong>getElement</strong>这种方法<strong>性能比较好</strong>，<strong>query选择符</strong>则<strong>比较方便</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;常见的获取元素的方法有3种，分别是通过元素ID、通过标签名字和通过类名字来获取。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;querySelector&lt;/code&gt; 和 &lt;code&gt;querySelectorAll&lt;/code&gt; 方法的作用是根据 CSS 选择器规范，使用和jquery查询方式一样，可以便捷定位文档中指定元素。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="CSS选择器" scheme="https://chongtianhong.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>理解JS中的call、apply、bind方法</title>
    <link href="https://chongtianhong.github.io/2018/04/11/bind/"/>
    <id>https://chongtianhong.github.io/2018/04/11/bind/</id>
    <published>2018-04-11T12:01:33.000Z</published>
    <updated>2018-07-28T12:28:09.092Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在JavaScript中，<code>call</code>、<code>apply</code>和<code>bind</code>是Function对象自带的三个方法，这三个方法的主要作用是<strong>改变函数中的this指向</strong>。</p><a id="more"></a></li><li><p><code>call</code>、<code>apply</code>和<code>bind</code>方法的<strong>共同点</strong>：</p><ul><li><code>call</code>、<code>apply</code>、<code>bind</code> 三者都是用来改变函数的this对象的指向的；</li><li><code>call</code>、<code>apply</code>、<code>bind</code> 三者<strong>第一个参数都是this要指向的对象</strong>，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值，即本次调用的上下文（context），这就是this关键字的值）；</li><li><code>call</code>、<code>apply</code>、<code>bind</code> 三者都可以<strong>利用后续参数传参</strong>。</li></ul></li><li><p><code>bind</code>方法与<code>call</code>、<code>apply</code>两个方法的区别：</p><ul><li><code>bind</code>方法是返回对应函数，便于<strong>稍后调用</strong>；</li><li><code>call</code>、<code>apply</code>则是<strong>立即调用</strong>。</li></ul></li><li>可见，当我们希望<strong>改变上下文环境之后并非立即执行</strong>，而是<strong>回调执行</strong>的时候，使用 <code>bind()</code>方法。而 <code>apply/call</code> 则会<strong>立即执行</strong>函数。</li></ul><blockquote>call()</blockquote><ul><li>语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])</li><li>定义：调用一个对象的一个方法，以另一个对象替换当前对象。</li><li>说明： call 方法可以用来<strong>代替另一个对象调用一个方法</strong>。</li><li>call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</li><li>thisObj的取值有以下4种情况：<br>（1） 不传，或者传null,undefined，函数中的this指向window对象；<br>（2） 传递另一个函数的函数名，函数中的this指向这个函数的引用；<br>（3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean；<br>（4） 传递一个对象，函数中的this指向这个对象。</li><li>例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;   </span><br><span class="line">  console.log(this);   //输出函数a中的this对象</span><br><span class="line">&#125;       </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;&#125;       </span><br><span class="line">var c=&#123;name:<span class="string">"call"</span>&#125;;    //定义对象c  </span><br><span class="line"></span><br><span class="line">a.call();   //window</span><br><span class="line">a.call(null);   //window</span><br><span class="line">a.call(undefined);   //window</span><br><span class="line">a.call(1);   //Number</span><br><span class="line">a.call(<span class="string">''</span>);   //String</span><br><span class="line">a.call(<span class="literal">true</span>);   //Boolean</span><br><span class="line">a.call(b);   //<span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;&#125;</span><br><span class="line">a.call(c);   //Object</span><br></pre></td></tr></table></figure></li></ul><blockquote>apply和call的区别</blockquote><ul><li>对于<code>call</code>、<code>apply</code>二者而言，<strong>作用完全一样</strong>，只是<strong>接受参数的方式不太一样</strong>。</li><li><code>call</code>需要<strong>把参数按顺序传递</strong>进去，而<code>apply</code>则是<strong>把参数放在数组里后将整个数组传入</strong>。</li><li>在JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话：<ul><li>当参数是明确知道数量时用<code>call</code>；</li><li>而不确定的时候用<code>apply</code>，然后把参数 push 进数组传递进去。</li><li>当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。</li></ul></li></ul><blockquote>bind()</blockquote><ul><li><code>bind</code>是在 ES5 中扩展的方法（IE6,7,8不支持）。<code>bind</code>方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 <code>bind</code>方法的第一个参数作为 this，传入 <code>bind</code> 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</li><li><p><code>bind</code>方法的返回值是函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">'李四'</span></span><br><span class="line">var foo = &#123;</span><br><span class="line">    name: <span class="string">"张三"</span>,</span><br><span class="line">    logName: <span class="keyword">function</span>(age) &#123;</span><br><span class="line">        console.log(this.name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fooNew = foo.logName;</span><br><span class="line">var fooNewBind = foo.logName.bind(foo);</span><br><span class="line">fooNew(10)//李四,10</span><br><span class="line">fooNewBind(11)//张三,11（因为<span class="built_in">bind</span>改变了fooNewBind里面的this指向）</span><br></pre></td></tr></table></figure></li><li><p>在Javascript中，多次使用<code>bind()</code>是无效的。更深层次的原因， <code>bind()</code>的实现，相当于使用函数在内部包了一个 <code>call</code>/<code>apply</code> ，第二次<code>bind()</code>相当于再包住第一次<code>bind()</code>,故第二次以后的<code>bind()</code>是无法生效的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bar = <span class="function"><span class="title">function</span></span>()&#123;   </span><br><span class="line">    console.log(this.x);   </span><br><span class="line">&#125;</span><br><span class="line">var foo=&#123; </span><br><span class="line">    x:3   </span><br><span class="line">&#125;   </span><br><span class="line">bar();  // undefined</span><br><span class="line"></span><br><span class="line">bar.bind(foo)(); // 3</span><br><span class="line"> /*或*/</span><br><span class="line">var func = bar.bind(foo);   </span><br><span class="line">func(); // 3</span><br></pre></td></tr></table></figure></li><li><p>由于<strong>箭头函数没有自己的this</strong>，所以当然也就<strong>不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变this的指向</strong>。</p></li><li>箭头函数的this总是指向词法作用域，也就是外层调用者。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;在JavaScript中，&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;和&lt;code&gt;bind&lt;/code&gt;是Function对象自带的三个方法，这三个方法的主要作用是&lt;strong&gt;改变函数中的this指向&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="this" scheme="https://chongtianhong.github.io/tags/this/"/>
    
      <category term="call" scheme="https://chongtianhong.github.io/tags/call/"/>
    
      <category term="apply" scheme="https://chongtianhong.github.io/tags/apply/"/>
    
      <category term="bind" scheme="https://chongtianhong.github.io/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6箭头函数中的this</title>
    <link href="https://chongtianhong.github.io/2018/04/10/arrowFunction/"/>
    <id>https://chongtianhong.github.io/2018/04/10/arrowFunction/</id>
    <published>2018-04-10T13:34:05.000Z</published>
    <updated>2018-07-28T14:14:53.021Z</updated>
    
    <content type="html"><![CDATA[<ul><li>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的<strong>区别</strong>：<ul><li>箭头函数内部的this是<strong>词法作用域，由上下文确定</strong>。</li><li>箭头函数中的this是在<strong>定义函数的时候绑定</strong>，而不是在执行函数的时候绑定。<a id="more"></a></li></ul></li><li>由于this在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>、<code>bind()</code>调用箭头函数时，无法对this进行绑定（无法使用<code>call()</code>或者<code>apply()</code>、<code>bind()</code>改变this的指向），即传入的第一个参数被忽略。内部的this指向<strong>父执行上下文</strong>里面的this。</li><li>箭头函数中，this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是<strong>箭头函数根本没有自己的this</strong>，导致内部的this就是<strong>外层代码块</strong>的this。正是因为它没有this，所以也就<strong>不能用作构造函数</strong>。</li><li><p>箭头函数中的this是在<strong>定义函数的时候绑定</strong>，看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 11;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    x: 22,</span><br><span class="line">    say: ()=&gt;&#123;</span><br><span class="line">        console.log(this.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();  //输出的值为11</span><br></pre></td></tr></table></figure></li><li><p>所谓的<strong>定义时候绑定</strong>，就是this是继承自<strong>父执行上下文中的this</strong>，比如这里的箭头函数中的this.x，箭头函数本身与say平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而<strong>obj的父执行上下文就是window</strong>，因此这里的this.x实际上表示的是window.x，因此输出的是11。</p></li><li><p>而对于下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</span><br><span class="line">        <span class="built_in">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); // 25</span><br></pre></td></tr></table></figure></li><li><p>例子中箭头函数本身是在getAge方法中定义的，因此，getAge方法的<strong>父执行上下文</strong>是obj，因此这里的this指向则为obj对象。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的&lt;strong&gt;区别&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;箭头函数内部的this是&lt;strong&gt;词法作用域，由上下文确定&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;箭头函数中的this是在&lt;strong&gt;定义函数的时候绑定&lt;/strong&gt;，而不是在执行函数的时候绑定。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="箭头函数" scheme="https://chongtianhong.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
      <category term="this" scheme="https://chongtianhong.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>JS原型链</title>
    <link href="https://chongtianhong.github.io/2018/04/09/prototype/"/>
    <id>https://chongtianhong.github.io/2018/04/09/prototype/</id>
    <published>2018-04-09T11:07:52.000Z</published>
    <updated>2018-07-28T11:51:39.828Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JavaScript可以通过<strong>构造函数</strong>和<strong>原型链</strong>实现继承。</li><li><strong>所有的实例对象</strong>都可以<strong>继承构造函数中的属性和方法</strong>，但是，<strong>同一个构造函数</strong>的<strong>实例对象之间无法共享属性或方法</strong>。</li><li>为了解决构造函数的这个缺点，JavaScript提供了<strong>prototype属性</strong>。<a id="more"></a></li></ul><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h4><ul><li>JavaScript中每个数据类型都是对象（除了null和undefined），而每个对象都继承自另外一个对象（原型对象），只有<strong>null</strong>除外，它<strong>没有自己的原型对象</strong>。</li><li><strong>原型对象上的所有属性和方法，都会被对象实例所共享</strong>。原型对象的作用，就是定义所有对象实例所<strong>共享</strong>的属性和方法。</li><li><strong>通过构造函数生成对象实例</strong>时，会<strong>将对象实例的原型（_proto_属性）指向构造函数的prototype属性</strong>。<strong>每一个构造函数都有一个prototype属性</strong>，这个属性就是<strong>对象实例的原型对象</strong>。prototype既是属性，又是对象：<ul><li>对于<strong>构造函数</strong>来说，<strong>prototype是作为构造函数的属性</strong>；</li><li>对于<strong>对象实例</strong>来说，<strong>prototype是对象实例的原型对象</strong>。</li></ul></li><li>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象上。如果<strong>实例对象自身有某个属性或方法</strong>，就<strong>不会去原型对象上查找</strong>。当某个<strong>对象实例没有该属性和方法时</strong>，就会<strong>到原型对象上去查找</strong>。</li></ul><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul><li>由于<strong>原型对象本身对于对象实例来说也是对象</strong>，它<strong>也有自己的原型</strong>，所以形成了一条<strong>原型链（prototype chain）</strong>。</li><li>即每个对象和原型都有原型，对象的原型指向原型对象，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。</li><li>所有一切的对象的<strong>原型顶端</strong>，都是<strong>Object.prototype</strong>，即Object构造函数的prototype属性指向的那个对象。</li><li><strong>Object.prototype对象</strong>也有自己的<strong>原型对象</strong>，即<strong>null对象</strong>（没有任何属性和方法），而null对象<strong>没有自己的原型</strong>。</li></ul><h4 id="原型链（prototype-chain）的特点"><a href="#原型链（prototype-chain）的特点" class="headerlink" title="原型链（prototype chain）的特点"></a>原型链（prototype chain）的特点</h4><ul><li>读取对象的某个属性时，JavaScript引擎先寻找<strong>对象本身</strong>的属性，如果找不到，就到它的<strong>原型</strong>去找，如果还是找不到，就到<strong>原型的原型</strong>去找。如果直到<strong>最顶层的Object.prototype</strong>还是找不到，则<strong>返回undefined</strong>。</li><li>如果<strong>对象自身</strong>和它的<strong>原型</strong>，都定义了一个<strong>同名属性</strong>，那么<strong>优先读取对象自身的属性</strong>，这叫做“覆盖”（overiding）。</li><li>一级级向上<strong>在原型链寻找某个属性，对性能是有影响的</strong>。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</li></ul><h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><ul><li>prototype对象有一个constructor属性，默认指向<strong>prototype对象所在的构造函数</strong>。</li><li><p>prototype是构造函数的属性，而constructor则是原型对象的属性。关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数.prototype.constructor===构造函数</span><br><span class="line">console.log(A.hasOwnProperty(<span class="string">'prototype'</span>)); //<span class="literal">true</span></span><br><span class="line">console.log(A.prototype.hasOwnProperty(<span class="string">'constructor'</span>)); //<span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>另外，实例的构造函数属性（constructor）指向构造函数。</p></li></ul><h4 id="hasOwnProperty-函数"><a href="#hasOwnProperty-函数" class="headerlink" title="hasOwnProperty()函数"></a>hasOwnProperty()函数</h4><ul><li><code>hasOwnProperty()</code>函数用于指示一个<strong>对象自身(不包括原型链)是否具有指定名称的属性</strong>。如果有，返回true，否则返回false。</li><li>该方法属于Object对象，由于所有的对象都”继承”了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。</li><li>语法:<code>object.hasOwnProperty(propertyName)</code></li><li>此方法<strong>不会检查对象的原型链</strong>中是否存在该属性，该属性只有是<strong>对象本身的一个成员才会返回true</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;JavaScript可以通过&lt;strong&gt;构造函数&lt;/strong&gt;和&lt;strong&gt;原型链&lt;/strong&gt;实现继承。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有的实例对象&lt;/strong&gt;都可以&lt;strong&gt;继承构造函数中的属性和方法&lt;/strong&gt;，但是，&lt;strong&gt;同一个构造函数&lt;/strong&gt;的&lt;strong&gt;实例对象之间无法共享属性或方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为了解决构造函数的这个缺点，JavaScript提供了&lt;strong&gt;prototype属性&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="原型链" scheme="https://chongtianhong.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS中的进制转换</title>
    <link href="https://chongtianhong.github.io/2018/04/08/numBaseConversion/"/>
    <id>https://chongtianhong.github.io/2018/04/08/numBaseConversion/</id>
    <published>2018-04-08T10:21:18.000Z</published>
    <updated>2018-07-28T14:28:12.408Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JavaScript可以很简单地实现任意进制的转化，核心函数是全局函数<code>parseInt(str, radix)</code>与<code>Number.toString(radix)</code>。</li><li><code>parseInt(str, radix)</code>可以实现<strong>把任意进制字符串转为十进制返回</strong>。</li><li><code>Number.toString(radix)</code>可以实现<strong>2、8、10、16进制的数据相互转换</strong>，并<strong>以字符串形式输出</strong>。<a id="more"></a></li></ul><h4 id="parseInt-str-radix"><a href="#parseInt-str-radix" class="headerlink" title="parseInt(str,radix)"></a>parseInt(str,radix)</h4><ul><li><code>parseInt(str, radix)</code>将字符串str按照radix进制编码方式<strong>转换为十进制</strong>返回</li><li>如果省略radix参数，则数字将以 10 为基数来解析。</li><li>radix参数值介于 2 ~ 36 之间。如果该参数小于 2 或者大于 36，则<code>parseInt(str, radix)</code>的结果将返回 NaN。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//2进制到10进制</span><br><span class="line">parseInt(<span class="string">'10'</span>,2) // 2</span><br><span class="line"></span><br><span class="line">//2进制到10进制</span><br><span class="line">parseInt(<span class="string">'100'</span>,2) // 4</span><br><span class="line"></span><br><span class="line">//16进制到10进制</span><br><span class="line">parseInt(<span class="string">'12'</span>, 16) // 18</span><br><span class="line"></span><br><span class="line">//8进制到10进制</span><br><span class="line">parseInt(<span class="string">'12'</span>,8); // 10</span><br><span class="line">parseInt(<span class="string">'23'</span>,8) // 19</span><br></pre></td></tr></table></figure></li></ul><h4 id="Number-toString-radix"><a href="#Number-toString-radix" class="headerlink" title="Number.toString(radix)"></a>Number.toString(radix)</h4><ul><li>Number的一个方法：<code>toString(radix)</code>返回<strong>表示该数字</strong>的<strong>指定进制形式</strong>的<strong>字符串</strong>。</li><li>可以实现<strong>2进制，8进制，10进制，16进制之间的相互转换</strong>，并<strong>以字符串形式输出</strong>。</li><li><p>radix支持 [2, 36] 之间的整数，默认为10。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//10进制转为16进制</span><br><span class="line">(66).toString(16) // <span class="string">"42"</span></span><br><span class="line">(10).toString(16) // <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">//8进制转为16进制</span><br><span class="line">(012).toString(16) // <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">//16进制转为10进制</span><br><span class="line">(0x16).toString(10) // <span class="string">"22"</span></span><br><span class="line"></span><br><span class="line">//16进制转为8进制</span><br><span class="line">(0x16).toString(8) // =&gt;<span class="string">"26"</span></span><br><span class="line"></span><br><span class="line">//10进制转为2进制 </span><br><span class="line">(1111).toString(2) // <span class="string">"10001010111"</span></span><br><span class="line"></span><br><span class="line">//8进制转为2进制</span><br><span class="line">(01111).toString(2) // <span class="string">"1001001001"</span></span><br><span class="line"></span><br><span class="line">//16进制转为2进制</span><br><span class="line">(0x16).toString(2) // <span class="string">"10110"</span></span><br></pre></td></tr></table></figure></li><li><p>一个笔试题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n = (2).toString();</span><br><span class="line">console.log(typeof(n));</span><br><span class="line">//<span class="string">'string'</span></span><br></pre></td></tr></table></figure></li><li><p>数字2通过<code>toString()</code>方法转为字符串，没有参数，默认转为10进制。最后n变成”2’，类型为字符串。</p></li></ul><h4 id="实现把m进制的数字转为n进制"><a href="#实现把m进制的数字转为n进制" class="headerlink" title="实现把m进制的数字转为n进制"></a>实现把m进制的数字转为n进制</h4><ul><li><p>实现把m进制的数字num转为n进制的方法是：先用<code>parseInt(str,radix)</code>将m进制的数字转化为十进制，再把十进制的数字用<code>toString()</code>方法返回n进制的形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> main(num, m, n)&#123;</span><br><span class="line">    var s = num + <span class="string">''</span>;</span><br><span class="line">    var result = parseInt(s, m).toString(n); </span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(main(36, 8, 6)); // 50</span><br></pre></td></tr></table></figure></li><li><p>注意：Number类型下的<code>toString()</code>函数容易忽略。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;JavaScript可以很简单地实现任意进制的转化，核心函数是全局函数&lt;code&gt;parseInt(str, radix)&lt;/code&gt;与&lt;code&gt;Number.toString(radix)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parseInt(str, radix)&lt;/code&gt;可以实现&lt;strong&gt;把任意进制字符串转为十进制返回&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.toString(radix)&lt;/code&gt;可以实现&lt;strong&gt;2、8、10、16进制的数据相互转换&lt;/strong&gt;，并&lt;strong&gt;以字符串形式输出&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="进制转换" scheme="https://chongtianhong.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript强制类型转换与隐式类型转换</title>
    <link href="https://chongtianhong.github.io/2018/04/07/typeConversion/"/>
    <id>https://chongtianhong.github.io/2018/04/07/typeConversion/</id>
    <published>2018-04-07T13:44:51.000Z</published>
    <updated>2018-07-27T15:16:54.743Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在JavaScript中<strong>声明变量不需指定类型</strong>，<strong>对变量赋值</strong>也<strong>没有类型检查</strong>，同时JavaScript<strong>允许隐式类型转换</strong>。这些特征说明JavaScript属于<strong>弱类型的语言</strong>。<a id="more"></a></li></ul><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li>通过手动进行类型转换，Javascript提供了以下转型函数：<ul><li>转换为<strong>数值</strong>类型：<code>Number(mix)</code>、<code>parseInt(string,radix)</code>、<code>parseFloat(string)</code></li><li>转换为<strong>字符串</strong>类型：<code>toString(radix)</code>、<code>String(mix)</code></li><li>转换为<strong>布尔</strong>类型：<code>Boolean(mix)</code></li></ul></li><li>注意：<strong>NaN</strong>是JavaScript中唯一一个<strong>不等于自己</strong>的值。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(NaN == NaN) === <span class="literal">false</span></span><br><span class="line">Boolean(0)                // =&gt; <span class="literal">false</span> - 零</span><br><span class="line">Boolean(new object())     // =&gt; <span class="literal">true</span> - 对象</span><br><span class="line">Number(undefined)         // =&gt;   NaN</span><br><span class="line">Number(null)              // =&gt; 0</span><br><span class="line">String(null)              // =&gt; <span class="string">"null"</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>1、Number(mix)函数</blockquote><ul><li><p><code>Number(mix)</code>函数可以将任意类型的参数mix转换为数值类型。其规则为：<br>（1）如果是<strong>布尔值</strong>，true和false分别被转换为1和0。<br>（2）如果是<strong>数字值</strong>，返回本身。<br>（3）如果是<strong>null</strong>，返回0.<br>（4）如果是<strong>undefined</strong>，返回NaN。<br>（5）如果是<strong>字符串</strong>，遵循以下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 如果字符串中只包含数字，则将其转换为十进制（忽略前导0）。</span><br><span class="line">· 如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0）。</span><br><span class="line">· 如果是空字符串，将其转换为0。</span><br><span class="line">· 如果字符串中包含非以上格式，则将其转换为NaN。</span><br></pre></td></tr></table></figure><p>（6）如果是<strong>对象</strong>，则调用对象的<code>valueOf()</code>方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。</p></li><li>下表列出了对象的valueOf()的返回值：</li></ul><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">Array</td><td style="text-align:center">数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">Boolean 值。</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td></tr><tr><td style="text-align:center">Function</td><td style="text-align:center">函数本身。</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">数字值。</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">对象本身。这是默认情况。</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">字符串值。</td></tr></tbody></table><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">"hello CSSer!"</span>); // NaN</span><br><span class="line">Number(<span class="string">"0×8"</span>); // NaN</span><br><span class="line">Number(<span class="string">""</span>); // 0</span><br><span class="line">Number(<span class="string">"020dd"</span>); NaN</span><br><span class="line">Number(<span class="string">"070"</span>); // 70</span><br><span class="line">Number(<span class="literal">true</span>); // 1</span><br></pre></td></tr></table></figure></li></ul><blockquote>2、parseInt(string, radix)函数</blockquote><ul><li><code>parseInt(string, radix)函数</code>可将字符串转换为整数类型的数值，它也有一定的规则：<br>（1）忽略字符串前面的空格，直至找到第一个非空字符。<br>（2）如果<strong>第一个字符不是数字符号或者负号</strong>，返回NaN。<br>（3）如果<strong>第一个字符是数字</strong>，则<strong>继续解析直至字符串解析完毕</strong>或者<strong>遇到一个非数字符号</strong>为止。<br>（4）如果<strong>指定radix参数</strong>，则<strong>以radix为基数进行解析</strong>。</li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parseInt(<span class="string">"hello CSSer!"</span>); // NaN</span><br><span class="line">parseInt(<span class="string">"0×8"</span>); // 0</span><br><span class="line">parseInt(<span class="string">""</span>); // NaN</span><br><span class="line">parseInt(<span class="string">"020dd"</span>); // 20</span><br><span class="line">parseInt(<span class="string">"070"</span>); // 70</span><br><span class="line">parseInt(<span class="string">"22.5"</span>); // 22</span><br></pre></td></tr></table></figure></li></ul><blockquote>3、parseFloat(string)函数</blockquote><ul><li><code>parseFloat(string)</code>函数可将字符串转换为浮点数类型的数值。它的规则与parseInt基本相同，但也有点区别：<ul><li>字符串中<strong>第一个小数点符号是有效的</strong>，另外parseFloat会<strong>忽略所有前导0</strong>，如果字符串包含一个可解析为整数的数，则<strong>返回整数值</strong>而不是浮点数值。</li></ul></li></ul><blockquote>4、toString(radix)函数</blockquote><ul><li><strong>除undefined和null之外</strong>的所有类型的值<strong>都具有toString()方法</strong>，其作用是<strong>返回对象的字符串表示</strong>。</li></ul><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">Array</td><td style="text-align:center">将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">返回日期的文字表示法。</td></tr><tr><td style="text-align:center">Error</td><td style="text-align:center">返回一个包含相关错误信息的字符串。</td></tr><tr><td style="text-align:center">Function</td><td style="text-align:center">返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code] }</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">对象本身。这是默认情况。</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">返回 String 对象的值。</td></tr><tr><td style="text-align:center">默认</td><td style="text-align:center">返回 “[object objectname]”，其中 objectname 是对象类型的名称。</td></tr></tbody></table><blockquote>5、String(mix)函数</blockquote><ul><li><code>String(mix)</code>函数可将任何类型的值转换为字符串，其规则为：<br>（1）如果有<code>toString()</code>方法，则调用该方法（不传递radix参数）并返回结果。<br>（2）如果是<code>null</code>，返回”null”。<br>（3）如果是<code>undefined</code>，返回”undefined”。</li></ul><blockquote>6、Boolean(mix)函数</blockquote><ul><li><code>Boolean(mix)</code>函数会将任何类型的值转换为布尔值。</li><li>以下值会被转换为false：<code>false</code>、<code>“”</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>，其余任何值都会被转换为true。</li></ul><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><ul><li>在某些情况下，即使我们不提供显示转换， JavaScript会<strong>自动转换表达式中对象的类型</strong>以<strong>完成表达式求值</strong>，主要情况有以下几种：</li></ul><h5 id="用于检测是否为非数值的函数：isNaN-mix"><a href="#用于检测是否为非数值的函数：isNaN-mix" class="headerlink" title="用于检测是否为非数值的函数：isNaN(mix)"></a>用于检测是否为非数值的函数：isNaN(mix)</h5><ul><li><code>isNaN()</code>函数，经测试发现，该函数会尝试将参数值用<code>Number()</code>进行转换，如果结果为”非数值”则返回<code>true</code>，否则返回<code>false</code>。</li></ul><h5 id="加法运算操作符"><a href="#加法运算操作符" class="headerlink" title="加法运算操作符"></a>加法运算操作符</h5><ul><li><p>加号运算操作符在Javascript也用于字符串连接符，所以加号操作符的规则分两种情况：<br>如果两个操作值都是数值，其规则为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)如果一个操作数为NaN，则结果为NaN</span><br><span class="line">(2)如果是Infinity+Infinity，结果是Infinity</span><br><span class="line">(3)如果是-Infinity+(-Infinity)，结果是-Infinity</span><br><span class="line">(4)如果是Infinity+(-Infinity)，结果是NaN</span><br><span class="line">(5)如果是+0+(+0)，结果为+0</span><br><span class="line">(6)如果是(-0)+(-0)，结果为-0</span><br><span class="line">(7)如果是(+0)+(-0)，结果为+0</span><br></pre></td></tr></table></figure></li><li><p>如果有一个操作值为字符串，表达式的值便是一个String，且：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.如果两个操作值都是字符串，则将它们拼接起来</span><br><span class="line">b.如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来</span><br><span class="line">c.如果一个操作数是对象、数值或者布尔值，则调用toString()方法取得字符串值，然后再应用前面的字符串规则。对于undefined和null，分别调用String()显式转换为字符串。</span><br></pre></td></tr></table></figure></li></ul><h5 id="乘除、减号运算符、取模运算符"><a href="#乘除、减号运算符、取模运算符" class="headerlink" title="乘除、减号运算符、取模运算符"></a>乘除、减号运算符、取模运算符</h5><ul><li>这些操作符针对的是运算，所以他们具有共同性：如果操作值之一不是数值，则被隐式调用<code>Number()</code>函数进行转换。</li></ul><h5 id="逻辑操作符（-、-amp-amp-、-）"><a href="#逻辑操作符（-、-amp-amp-、-）" class="headerlink" title="逻辑操作符（!、&amp;&amp;、||）"></a>逻辑操作符（!、&amp;&amp;、||）</h5><ul><li><strong>逻辑非（!）操作符</strong>首先通过<code>Boolean()</code>函数将它的操作值转换为布尔值，然后求反。</li><li><p><strong>逻辑与（&amp;&amp;）操作符</strong>，如果一个操作值不是布尔值时，遵循以下规则进行转换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）如果第一个操作数经Boolean()转换后为<span class="literal">true</span>，则返回第二个操作值，否则返回第一个值（不是Boolean()转换后的值）</span><br><span class="line">（2）如果有一个操作值为null，返回null</span><br><span class="line">（3）如果有一个操作值为NaN，返回NaN</span><br><span class="line">（4）如果有一个操作值为undefined，返回undefined</span><br></pre></td></tr></table></figure></li><li><p><strong>逻辑或（||）操作符</strong>，如果一个操作值不是布尔值，遵循以下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）如果第一个操作值经Boolean()转换后为<span class="literal">false</span>，则返回第二个操作值，否则返回第一个操作值（不是Boolean()转换后的值）</span><br><span class="line">（2）对于undefined、null和NaN的处理规则与逻辑与（&amp;&amp;）相同</span><br></pre></td></tr></table></figure></li></ul><h5 id="关系操作符（-lt-gt-lt-gt-）"><a href="#关系操作符（-lt-gt-lt-gt-）" class="headerlink" title="关系操作符（&lt;, &gt;, &lt;=, &gt;=）"></a>关系操作符（&lt;, &gt;, &lt;=, &gt;=）</h5><ul><li><p>与上述操作符一样，<strong>关系操作符的操作值也可以是任意类型的</strong>，所以使用非数值类型参与比较时也需要系统进行隐式类型转换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）如果两个操作值都是数值，则进行数值比较。</span><br><span class="line">（2）如果两个操作值都是字符串，则比较字符串对应的字符编码值。</span><br><span class="line">（3）如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较。</span><br><span class="line">（4）如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较。</span><br><span class="line">（5）如果一个操作值是布尔值，则将其转换为数值，再进行比较。</span><br></pre></td></tr></table></figure></li><li><p>注：<strong>NaN</strong>是非常特殊的值，它<strong>不和任何类型的值相等</strong>，<strong>包括它自己</strong>，同时它<strong>与任何类型的值比较大小时都返回false</strong>。</p></li></ul><h5 id="相等操作符（-）"><a href="#相等操作符（-）" class="headerlink" title="相等操作符（==）"></a>相等操作符（==）</h5><ul><li>相等操作符会对操作值进行隐式转换后进行比较：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）如果一个操作值为布尔值，则在比较之前先将其转换为数值。</span><br><span class="line">（2）如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值。</span><br><span class="line">（3）如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较。</span><br><span class="line">（4）null与undefined是相等的。</span><br><span class="line">（5）如果一个操作值为NaN，则相等比较返回<span class="literal">false</span>。</span><br><span class="line">（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。</span><br></pre></td></tr></table></figure></li></ul><h5 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h5><ul><li>判断语句中的判断条件需要是<strong>Boolean类型</strong>，所以条件表达式会被隐式转换为Boolean。其转换规则同Boolean的构造函数。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在JavaScript中&lt;strong&gt;声明变量不需指定类型&lt;/strong&gt;，&lt;strong&gt;对变量赋值&lt;/strong&gt;也&lt;strong&gt;没有类型检查&lt;/strong&gt;，同时JavaScript&lt;strong&gt;允许隐式类型转换&lt;/strong&gt;。这些特征说明JavaScript属于&lt;strong&gt;弱类型的语言&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="类型转换" scheme="https://chongtianhong.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>vue之观察者watch</title>
    <link href="https://chongtianhong.github.io/2018/04/06/vueWatch/"/>
    <id>https://chongtianhong.github.io/2018/04/06/vueWatch/</id>
    <published>2018-04-06T02:56:27.000Z</published>
    <updated>2018-07-26T14:17:32.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言：computed和watch区别"><a href="#前言：computed和watch区别" class="headerlink" title="前言：computed和watch区别"></a>前言：computed和watch区别</h4><ul><li>computed：监听<strong>多个</strong>数据或者<strong>一个</strong>数据来维护返回一个状态值，<strong>只要其中一个或多个数据发生了变化</strong>，则会<strong>重新计算整个函数体</strong>，<strong>重新返回状态值</strong>。(computed中监听的值可以不在data中设置，而watch中监听的值则需要在data中定义)</li><li>watch：只能<strong>监听单个数据</strong>，只要这个<strong>数据发生变化</strong>，就会<strong>返回两个参数</strong>，第一个是<strong>当前的值</strong>，第二个是<strong>变化前的值</strong>。每当变化的时候，则会触发函数体的逻辑行为，根据逻辑行为做后续的操作。<a id="more"></a></li></ul><h4 id="Watch用法"><a href="#Watch用法" class="headerlink" title="Watch用法"></a>Watch用法</h4><ul><li>Watch：它用于<strong>观察Vue实例上的数据变动</strong>。对应一个对象，<strong>键</strong>是<strong>观察表达式</strong>，<strong>值</strong>是<strong>对应回调</strong>。值也可以是方法名，或者是对象，包含选项。具体的用法可以直接看下面的示例，简单直接。</li></ul><blockquote>用法一：数组与对象都用handler</blockquote><ul><li><p>数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        winChips: new Array(11).fill(0)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    winChips: &#123;</span><br><span class="line">        handler(newValue, oldValue) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; newValue.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldValue[i] != newValue[i]) &#123;</span><br><span class="line">                    console.log(newValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: <span class="literal">true</span>  // 开启深入监听，一般用于监听数组中的值；如果不开启，将只监听数组整体，而不会监听数组中的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        bet: &#123;</span><br><span class="line">            pokerState: 53,</span><br><span class="line">            pokerHistory: <span class="string">'local'</span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    bet: &#123;</span><br><span class="line">        handler(newValue, oldValue) &#123;</span><br><span class="line">            console.log(newValue)</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: <span class="literal">true</span>   // 开启深入监听，一般用于监听对象中的键对值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中如果要对对象中的键值进行监听，需要加引号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        bet: &#123;</span><br><span class="line">            pokerState: 53,</span><br><span class="line">            pokerHistory: <span class="string">'local'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    <span class="string">'bet.pokerHistory'</span>:<span class="keyword">function</span>(val,oldval)&#123; //键路径必须加上引号</span><br><span class="line">        console.log(val+<span class="string">"aaa"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    // 通过这个办法可以直接监听对象中的某个键对值而不用deep。</span><br><span class="line">    // 弊端是这里只能监听固定的键对值</span><br></pre></td></tr></table></figure></li></ul><blockquote>用法二：正常的值</blockquote><ul><li>当所要监听的值为基本类型时：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        frontPoints: 0    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    frontPoints(newValue, oldValue) &#123;</span><br><span class="line">        console.log(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="对handler方法和、immediate属性和deep属性的解析"><a href="#对handler方法和、immediate属性和deep属性的解析" class="headerlink" title="对handler方法和、immediate属性和deep属性的解析"></a>对handler方法和、immediate属性和deep属性的解析</h4><ul><li><code>handler</code>方法：其实<strong>watch方法里面</strong>，都是<strong>默认用handler方法</strong>，不管你是否写了handler方法，因为Vue.js会处理这个逻辑，然后<strong>最终编译为handler</strong>。</li><li><p><code>immediate</code>属性：watch 的一个特点是，最初绑定的时候是不会执行的，要等到 监听值改变时才执行监听计算。immediate属性一般和handler联用，当这个属性是true时，表示声明了handler所监听的元素在watch<strong>声明完了后就立即执行</strong>。如下面的例子中，当设置了immediate属性后，当该watch声明完firstName后，会立即执行，fullName被初始化为<code>“Dawei Lou”</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div id=<span class="string">"root"</span>&gt;</span><br><span class="line">    &lt;p&gt;FullName: &#123;&#123;fullName&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;FirstName:</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"firstName"</span>&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// JS</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#root'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: <span class="string">'Dawei'</span>,</span><br><span class="line">        lastName: <span class="string">'Lou'</span>,</span><br><span class="line">        fullName: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        firstName: &#123;</span><br><span class="line">            handler(newName, oldName) &#123;</span><br><span class="line">                this.fullName = newName + <span class="string">' '</span> + this.lastName;</span><br><span class="line">            &#125;,</span><br><span class="line">            immediate: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>deep</code>属性：当属性值为true时，为<strong>深入解析</strong>，<strong>一般用于数组与对象</strong>中。如果我们<strong>不用它</strong>，那么在一般情况下，我们<strong>只能监听到该对象的变化</strong>以及<strong>数组整体的变化</strong>，而<strong>不能深入监听对象里的键对值变化</strong>以及<strong>数组里的值的变化</strong>。</p></li></ul><h4 id="watch-API"><a href="#watch-API" class="headerlink" title="$watch API"></a>$watch API</h4><ul><li>该API可实现<strong>动态添加观察者watch</strong>以及<strong>动态删除</strong>。</li></ul><blockquote>动态添加</blockquote><ul><li><p>$watch的语法很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="variable">$watch</span>(expOrFn(要监听的属性), callback, [options])</span><br></pre></td></tr></table></figure></li><li><p>其中vm指的是Vue中的一个实例，就是我们的app。如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> watch = app.<span class="variable">$watch</span>(<span class="string">'count'</span>, <span class="keyword">function</span>(newValue, oldValue)&#123; </span><br><span class="line">    alert(<span class="string">'Count changed from '</span> + oldValue + <span class="string">' to '</span> + newValue + <span class="string">'!'</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>当我们要对data的对象中的键值进行监听时，有两种方法：</p></li><li><p>方法一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="variable">$watch</span>(<span class="string">'person.name.firstName'</span>, <span class="keyword">function</span>(newValue, oldValue)&#123; </span><br><span class="line">    alert(<span class="string">'firstName 从 '</span> + oldValue + <span class="string">' 变成 '</span> + newValue + <span class="string">'!'</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="variable">$watch</span>(<span class="string">'person.name'</span>, <span class="keyword">function</span>(newValue, oldValue)&#123; alert(<span class="string">'firstName从 '</span> + oldValue.firstName + <span class="string">' 变成 '</span> + <span class="string">'newValue.firstName'</span> + <span class="string">'!'</span>)&#125;, &#123;deep: <span class="literal">true</span>&#125;)</span><br><span class="line">    //这里我们只监听到对象中的name。</span><br><span class="line">    //但是如果我们想要监听到name中的firstname时，需要加个参数 deep: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>动态删除</blockquote><ul><li>为什么要注销 watch？因为我们的组件是经常要被销毁的，比如我们跳一个路由，从一个页面跳到另外一个页面，那么原来的页面的 watch 其实就没用了，这时候我们应该注销掉原来页面的 watch 的，不然的话可能会<strong>导致内置溢出</strong>。如果平时 watch 是写在组件的选项中的，它会随着组件的销毁而销毁。</li><li><p>而对于动态添加的watch，则需要手动注销：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const unWatch = app.<span class="variable">$watch</span>(<span class="string">'text'</span>, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;newVal&#125;</span> : <span class="variable">$&#123;oldVal&#125;</span>`);</span><br><span class="line">&#125;)</span><br><span class="line">// app.<span class="variable">$watch</span>调用后会返回一个值，就是unWatch方法</span><br><span class="line">// 注销 watch 只要调用unWatch方法就可以了。</span><br><span class="line">unWatch(); // 手动注销watch</span><br></pre></td></tr></table></figure></li><li><p>也可以把watch当做函数运行一遍就相当于删除观察者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//watch运作5秒后删除</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">    watch();  // 当成函数运行一遍</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言：computed和watch区别&quot;&gt;&lt;a href=&quot;#前言：computed和watch区别&quot; class=&quot;headerlink&quot; title=&quot;前言：computed和watch区别&quot;&gt;&lt;/a&gt;前言：computed和watch区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;computed：监听&lt;strong&gt;多个&lt;/strong&gt;数据或者&lt;strong&gt;一个&lt;/strong&gt;数据来维护返回一个状态值，&lt;strong&gt;只要其中一个或多个数据发生了变化&lt;/strong&gt;，则会&lt;strong&gt;重新计算整个函数体&lt;/strong&gt;，&lt;strong&gt;重新返回状态值&lt;/strong&gt;。(computed中监听的值可以不在data中设置，而watch中监听的值则需要在data中定义)&lt;/li&gt;
&lt;li&gt;watch：只能&lt;strong&gt;监听单个数据&lt;/strong&gt;，只要这个&lt;strong&gt;数据发生变化&lt;/strong&gt;，就会&lt;strong&gt;返回两个参数&lt;/strong&gt;，第一个是&lt;strong&gt;当前的值&lt;/strong&gt;，第二个是&lt;strong&gt;变化前的值&lt;/strong&gt;。每当变化的时候，则会触发函数体的逻辑行为，根据逻辑行为做后续的操作。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="Vue.js" scheme="https://chongtianhong.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>JS性能优化之函数去抖</title>
    <link href="https://chongtianhong.github.io/2018/04/05/debounce/"/>
    <id>https://chongtianhong.github.io/2018/04/05/debounce/</id>
    <published>2018-04-05T06:59:50.000Z</published>
    <updated>2018-07-26T14:04:44.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>概念</strong>：函数去抖是<strong>通过一个定时器</strong>，<strong>阻断连续重复的函数调用</strong>，从而一定程度上<strong>优化性能</strong>。</li><li><strong>用途</strong>：主要用于<strong>用户界面</strong>调用的函数，如：<strong>resize事件</strong>、<strong>mousemove事件</strong>、<strong>keyup事件</strong>的<strong>监听函数</strong>。 </li><li>这类监听函数的主要特征：<br>1、短时间内连续多次重复触发；<br>2、大量的DOM操作。</li><li><strong>意义</strong>：在用户察觉范围外，<strong>降低函数调用的频率</strong>，从而提升性能。<a id="more"></a></li></ul><h4 id="函数去抖的原理"><a href="#函数去抖的原理" class="headerlink" title="函数去抖的原理"></a>函数去抖的原理</h4><ul><li>某些代码不可以在没有间断的情况<strong>连续重复执行</strong>。</li><li>第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。</li><li>如果前一个定时器已经执行过了，这个操作就没有任何意义。</li><li>然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有<strong>在执行函数的请求停止了一段时间之后才执行</strong>。</li></ul><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><ul><li>例如： <ul><li>使用onresize事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。<strong>在onresize 事件处理程序内部</strong>如果<strong>尝试进行DOM操作</strong>，其<strong>高频率的更改</strong>可能会<strong>让浏览器崩溃</strong>。 </li><li>另一个常见的是搜索功能，我们一般是绑定keyup事件，每按下一次键盘就搜索一次。但是我们的目的主要是<strong>每输入一些内容搜索一次</strong>而已。</li></ul></li><li>为了解决这些问题，就可以<strong>使用定时器对函数进行去抖</strong>。</li><li>下面以keyup为例，对<strong>函数去抖</strong>的具体用法进行介绍。</li></ul><blockquote>1、不使用函数去抖的情况</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"search"</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"search"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> queryData(text)&#123;</span><br><span class="line">    console.log(<span class="string">"搜索："</span> + text);</span><br><span class="line">&#125;</span><br><span class="line">var input = document.getElementById(<span class="string">"search"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="keyword">function</span>(event)&#123; </span><br><span class="line">    queryData(this.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>结果如图：<br><img src="/images/search1.png" alt="不使用函数防抖的情况"></li></ul><blockquote>2、使用基本函数防抖的情况</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"search1"</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"search"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> queryData(text)&#123;</span><br><span class="line">    console.log(<span class="string">"搜索："</span> + text);</span><br><span class="line">&#125;</span><br><span class="line">var input = document.getElementById(<span class="string">"search"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    debounce(queryData, null, 500, this.value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> debounce(fn, context, delay, text)&#123;</span><br><span class="line">    clearTimeout(fn.timeoutId);</span><br><span class="line">    fn.timeoutId = setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        fn.call(context, text);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如图：<br><img src="/images/search2.png" alt="使用函数防抖的情况"></li><li>实际上，我们更希望的是，<strong>当达到某个时间值时，一定要执行一次这个搜索函数</strong>。所以，就有了函数防抖的<strong>改进模式</strong>。</li></ul><blockquote>3、函数防抖增强版</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"search"</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"search"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> queryData(text)&#123;</span><br><span class="line">    console.log(<span class="string">"搜索："</span> + text);</span><br><span class="line">&#125;</span><br><span class="line">var input = document.getElementById(<span class="string">"search"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    debounce(queryData, null, 500, this.value, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debounce(fn, context, delay, text, mustApplyTime)&#123;</span><br><span class="line">    clearTimeout(fn.timer);</span><br><span class="line">    fn._cur = Date.now(); //记录当前时间</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fn._start)&#123; //若该函数是第一次调用，则直接设置_start,即开始时间，为_cur，即此刻的时间</span><br><span class="line">        fn._start = fn._cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fn._cur-fn._start &gt; mustApplyTime)&#123; </span><br><span class="line">    //当前时间与上一次函数被执行的时间作差，与mustApplyTime比较，若大于，则必须执行一次函数，若小于，则重新设置计时器</span><br><span class="line">        fn.call(context, text);</span><br><span class="line">        fn._start = fn._cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fn.timer = setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            fn.call(context, text);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如图：<br><img src="/images/search3.png" alt="函数防抖增强版"></li><li>显然，连续的输入，到一定时间间隔之后，queryData函数必然会被调用，但是又不是频繁的调用。这既达到了防抖的目的，又不会影响用户体验。</li></ul><blockquote>4、进一步的优化</blockquote><ul><li>进一步的话，就是可以在调用debounce函数之前，先对输入的内容进行判断，若其值为空、值不变时都不用再调用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;概念&lt;/strong&gt;：函数去抖是&lt;strong&gt;通过一个定时器&lt;/strong&gt;，&lt;strong&gt;阻断连续重复的函数调用&lt;/strong&gt;，从而一定程度上&lt;strong&gt;优化性能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：主要用于&lt;strong&gt;用户界面&lt;/strong&gt;调用的函数，如：&lt;strong&gt;resize事件&lt;/strong&gt;、&lt;strong&gt;mousemove事件&lt;/strong&gt;、&lt;strong&gt;keyup事件&lt;/strong&gt;的&lt;strong&gt;监听函数&lt;/strong&gt;。 &lt;/li&gt;
&lt;li&gt;这类监听函数的主要特征：&lt;br&gt;1、短时间内连续多次重复触发；&lt;br&gt;2、大量的DOM操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;：在用户察觉范围外，&lt;strong&gt;降低函数调用的频率&lt;/strong&gt;，从而提升性能。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="函数去抖" scheme="https://chongtianhong.github.io/tags/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96/"/>
    
  </entry>
  
  <entry>
    <title>函数节流和函数防抖之间的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/04/throttleAndDebounce/"/>
    <id>https://chongtianhong.github.io/2018/04/04/throttleAndDebounce/</id>
    <published>2018-04-04T08:49:11.000Z</published>
    <updated>2018-07-26T14:16:57.600Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>函数节流和函数防抖，两者都是<strong>优化高频率执行js代码</strong>的一种手段。</li><li>在一些场景中，函数会因为一些用户操作被频繁触发，例如<strong>频繁操作DOM</strong>，<strong>重绘Layout</strong>，<strong>加载资源</strong>，<strong>请求数据</strong>，而导致浏览器<strong>卡顿</strong>或者<strong>崩溃</strong>。</li><li>常见场景有：<strong>输入监听</strong>，<strong>滚动监听</strong>，<strong>鼠标移入/移出/移动</strong>。这个时候就需要我们去优化，从而提高Javascript性能。<a id="more"></a></li></ul><h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><ul><li><strong>throttle</strong>：<strong>一定的时间间隔内执行</strong>，即设定一个时间间隔，当大于或等于时间间隔时，立即执行一次方法。</li><li>简而言之，指定时间间隔内<strong>只会执行一次任务</strong>。</li><li><p>比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> canRun = <span class="literal">false</span>;</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</span><br><span class="line">    // 判断是否已空闲，如果在执行中，则直接<span class="built_in">return</span></span><br><span class="line">    <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun = <span class="literal">true</span>;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'执行'</span>);</span><br><span class="line">        canRun = <span class="literal">false</span>;</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如上例子所示, 只要resize事件触发一次, 500ms之后立即触发函数一次, 在这其中不管resize方法再被触发了多少次都不理会, 反正500ms执行一次方法。</p></li><li><p>重新封装一下throttle方法，便于调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> throttle(fn, interval = 500) &#123;</span><br><span class="line">    <span class="built_in">let</span> canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        // 判断是否已空闲，如果在执行中，则直接<span class="built_in">return</span></span><br><span class="line">        <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        canRun = <span class="literal">true</span>;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">            canRun = <span class="literal">false</span>;</span><br><span class="line">        &#125;, interval);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, throttle(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'执行'</span>)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li><p><strong>函数节流</strong>的要点是，<strong>声明一个变量当标志位</strong>，<strong>记录当前代码是否在执行</strong>。</p><ul><li>如果空闲，则可以正常触发方法执行。</li><li>如果代码正在执行，则取消这次方法执行，直接return。</li></ul></li></ul><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><ul><li><strong>debounce</strong>：<strong>固定的时间间隔内</strong>，如果<strong>事件再次被触发</strong>，则<strong>重置时间</strong>，<strong>直到大于等于时间间隔</strong>才执行方法。</li><li>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</li><li><p>比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> timer = null;</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'执行'</span>);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如上例子所示，只要resize事件被触发一次就重置一次timeout，直到500ms后事件都没有被触发，才执行方法。</p></li><li><p>重新封装一下debounce方法，便于调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> debounce(fn, interval=500)&#123;</span><br><span class="line">    <span class="built_in">let</span> timer = null;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">        &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, debounce(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'执行'</span>)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li><p><strong>函数防抖</strong>的要点，也是需要一个setTimeout来辅助实现。延迟执行需要跑的代码。</p><ul><li>如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始计时。</li><li>如果计时完毕，没有方法进来访问触发，则执行代码。</li></ul></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><strong>throttle</strong>：一辆定时的地铁，每五分钟出发一辆，不管你有没有上到车，只要执行命令下来过五分钟之后就出发。</li><li><strong>debounce</strong>：就跟电梯的原理一样，只要10s之内有人来就重置时间，直到等待时间大于等于10s之后没人进来才出发。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>两个方法，两种原理，适用的范围和场景也不一样，看实际的看法需求和业务。在不影响用户体验的前提下，<strong>优化Javascript性能</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;函数节流和函数防抖，两者都是&lt;strong&gt;优化高频率执行js代码&lt;/strong&gt;的一种手段。&lt;/li&gt;
&lt;li&gt;在一些场景中，函数会因为一些用户操作被频繁触发，例如&lt;strong&gt;频繁操作DOM&lt;/strong&gt;，&lt;strong&gt;重绘Layout&lt;/strong&gt;，&lt;strong&gt;加载资源&lt;/strong&gt;，&lt;strong&gt;请求数据&lt;/strong&gt;，而导致浏览器&lt;strong&gt;卡顿&lt;/strong&gt;或者&lt;strong&gt;崩溃&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;常见场景有：&lt;strong&gt;输入监听&lt;/strong&gt;，&lt;strong&gt;滚动监听&lt;/strong&gt;，&lt;strong&gt;鼠标移入/移出/移动&lt;/strong&gt;。这个时候就需要我们去优化，从而提高Javascript性能。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="函数去抖" scheme="https://chongtianhong.github.io/tags/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96/"/>
    
      <category term="函数节流" scheme="https://chongtianhong.github.io/tags/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JS实现对象的深克隆</title>
    <link href="https://chongtianhong.github.io/2018/04/03/deepCopy/"/>
    <id>https://chongtianhong.github.io/2018/04/03/deepCopy/</id>
    <published>2018-04-03T12:02:44.000Z</published>
    <updated>2018-07-25T14:07:25.772Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>JavaScript中数据类型分为<strong>基本数据类型</strong>(number, string, boolean, null, undefined)和<strong>引用类型</strong>(对象, 数组, 函数)，这两类对象在<strong>复制克隆</strong>的时候是有很大区别的。 <a id="more"></a></li></ul><blockquote>基本数据类型</blockquote><ul><li>基本数据类型存储的是对象的实际数据，其值存放在<strong>栈内存</strong>中。</li></ul><blockquote>引用数据类型</blockquote><ul><li>引用数据类型值指保存在<strong>堆内存</strong>中的对象。也就是，变量中保存在栈内存的实际上的只是一个指针，这个指针指向内存中的另一个位置（堆内存），该位置保存着对象。访问方式是<strong>按引用访问</strong>。</li><li><p>于是克隆也会分为两类:</p><blockquote>浅度克隆</blockquote></li><li><p><strong>基本数据类型</strong>为<strong>值传递</strong>, <strong>引用类型</strong>仍为<strong>引用传递</strong>。</p></li><li>对于<strong>基本类型</strong>，浅复制是对<strong>值的复制</strong>，对于<strong>引用类型</strong>来说，浅复制是<strong>对对象地址的复制</strong>，并没有开辟新的栈，也就是复制的结果是<strong>两个对象指向同一个地址</strong>，修改其中一个对象的属性，则另一个对象的属性也会改变。</li></ul><blockquote>深度克隆</blockquote><ul><li><strong>所有元素或属性均完全复制, 与原对象完全脱离</strong>, 也就是说<strong>所有对于新对象的修改都不会反映到原对象中</strong>。</li><li>深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。<ul><li><strong>函数的克隆通过浅克隆即可实现</strong>。原因就是函数的克隆会在内存单独开辟一块空间，互不影响。</li><li><strong>数组和对象需要深克隆</strong>。</li></ul></li></ul><h4 id="深克隆的实现"><a href="#深克隆的实现" class="headerlink" title="深克隆的实现"></a>深克隆的实现</h4><h5 id="通过递归解析解决"><a href="#通过递归解析解决" class="headerlink" title="通过递归解析解决"></a>通过递归解析解决</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var china = &#123;</span><br><span class="line">    nation : <span class="string">'中国'</span>,</span><br><span class="line">    birthplaces:[<span class="string">'北京'</span>,<span class="string">'上海'</span>,<span class="string">'广州'</span>],</span><br><span class="line">    skincolor :<span class="string">'yellow'</span>,</span><br><span class="line">    friends:[<span class="string">'sk'</span>,<span class="string">'ls'</span>]</span><br><span class="line">&#125;</span><br><span class="line">//深复制，要想达到深复制就需要用递归</span><br><span class="line"><span class="keyword">function</span> deepCopy(o, c)&#123;</span><br><span class="line">    var c = c || &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(var i <span class="keyword">in</span> o)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof o[i] === <span class="string">'object'</span>)&#123;</span><br><span class="line">        //要考虑深复制问题了</span><br><span class="line">            <span class="keyword">if</span>(o[i].constructor === Array)&#123;</span><br><span class="line">                //这是数组</span><br><span class="line">                c[i] =[];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                //这是对象</span><br><span class="line">                c[i] = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            deepCopy(o[i],c[i]); // 递归调用</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c[i] = o[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">var result = &#123; name:<span class="string">'result'</span> &#125;;</span><br><span class="line">result = deepCopy(china, result);</span><br><span class="line">console.dir(result);</span><br></pre></td></tr></table></figure><h5 id="通过JSON解析解决"><a href="#通过JSON解析解决" class="headerlink" title="通过JSON解析解决"></a>通过JSON解析解决</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">test</span> =&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        xing:&#123; </span><br><span class="line">            first:<span class="string">'张'</span>,</span><br><span class="line">            second:<span class="string">'李'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ming:<span class="string">'老头'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age :40,</span><br><span class="line">    friend :[<span class="string">'隔壁老王'</span>,<span class="string">'宋经纪'</span>,<span class="string">'同事'</span>]</span><br><span class="line">&#125;</span><br><span class="line">var result = JSON.parse(JSON.stringify(<span class="built_in">test</span>));</span><br><span class="line">result.age = 30;</span><br><span class="line">result.name.xing.first = <span class="string">'往'</span>;</span><br><span class="line">result.friend.push(<span class="string">'fdagldf;ghad'</span>);</span><br><span class="line">console.dir(<span class="built_in">test</span>);</span><br><span class="line">console.dir(result);</span><br></pre></td></tr></table></figure><h5 id="es6之展开Object-assign"><a href="#es6之展开Object-assign" class="headerlink" title="es6之展开Object.assign"></a>es6之展开Object.assign</h5><ul><li>拷贝对象的内容到一个新的堆内存，copyObj存储新内存的引用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;name:<span class="string">'fiona-SUN'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> copyObj = Object.assign(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line">copyObj.name = <span class="string">'fiona'</span>;</span><br><span class="line">console.log(copyObj.name);  // <span class="string">'fiona'</span></span><br><span class="line">console.log(obj.name);     // <span class="string">'fiona-SUN'</span></span><br></pre></td></tr></table></figure><h5 id="es6之展开运算符"><a href="#es6之展开运算符" class="headerlink" title="es6之展开运算符"></a>es6之展开运算符</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3];</span><br><span class="line"><span class="built_in">let</span> copyArr = [...obj];</span><br><span class="line">copyArr[2] = 0;</span><br><span class="line">console.log(copyArr[2]);  // 0</span><br><span class="line">console.log(arr[2]);     // 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JavaScript中数据类型分为&lt;strong&gt;基本数据类型&lt;/strong&gt;(number, string, boolean, null, undefined)和&lt;strong&gt;引用类型&lt;/strong&gt;(对象, 数组, 函数)，这两类对象在&lt;strong&gt;复制克隆&lt;/strong&gt;的时候是有很大区别的。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="基本类型" scheme="https://chongtianhong.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="引用类型" scheme="https://chongtianhong.github.io/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="深克隆" scheme="https://chongtianhong.github.io/tags/%E6%B7%B1%E5%85%8B%E9%9A%86/"/>
    
      <category term="浅克隆" scheme="https://chongtianhong.github.io/tags/%E6%B5%85%E5%85%8B%E9%9A%86/"/>
    
  </entry>
  
  <entry>
    <title>实现跨域请求的方法整理</title>
    <link href="https://chongtianhong.github.io/2018/04/02/crossDomain/"/>
    <id>https://chongtianhong.github.io/2018/04/02/crossDomain/</id>
    <published>2018-04-02T06:47:49.000Z</published>
    <updated>2018-07-25T08:36:06.055Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这里说的JS跨域是指<strong>通过JS在<code>不同的域</code>之间进行数据传输或通信</strong>，比如：<ul><li>用ajax向一个不同的域请求数据</li><li>通过JS获取页面中不同域的框架中(iframe)的数据</li></ul></li><li>只要<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>有任何一个不同，都被当作是不同的域。<a id="more"></a></li></ul><h4 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h4><ul><li>只有当<strong>协议</strong>、<strong>端口</strong>、<strong>域名</strong>都相同的页面，则两个页面具有相同的源。</li><li>同源策略是指一段脚本只能读取来自同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合。只要这三个中的<strong>任意一个不同</strong>，网站间的数据请求与传输便构成了<strong>跨域调用</strong>，则受到<strong>同源策略</strong>的限制。 </li><li>同源策略限制从<strong>一个源加载的文档或脚本</strong>如何<strong>与来自另一个源的资源进行交互*</strong>。这是一个用于隔离潜在恶意文件的关键的安全机制。浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用（通常指使用XMLHttpRequest请求）。</li><li>默认情况下，<strong>XHR对象</strong>只能访问<strong>与包含它的页面位于同一个域中的资源</strong>。<strong>请求源</strong>和<strong>请求对象</strong>必须在一个域内。</li></ul><h4 id="跨域请求方式"><a href="#跨域请求方式" class="headerlink" title="跨域请求方式"></a>跨域请求方式</h4><ul><li>解决跨域问题，最简单的莫过于通过<code>nginx反向代理</code>进行实现，但是其需要在<strong>运维层面</strong>修改，且有可能请求的资源并不在我们控制范围内（第三方），所以该方式不能作为通用的解决方案，下面阐述了经常用到几种跨域方式：</li></ul><h5 id="图片ping或script标签跨域"><a href="#图片ping或script标签跨域" class="headerlink" title="图片ping或script标签跨域"></a>图片ping或script标签跨域</h5><ul><li><code>&lt;script&gt;</code><code>&lt;img&gt;</code><code>&lt;link&gt;</code>标签不会遇到跨域问题。严格意义上讲，这不是跨域，这只是<strong>跨站资源请求</strong>。</li><li>跨域是指<strong>在脚本代码中</strong>向<strong>非同源域</strong>发送<strong>HTTP请求</strong>。</li><li><p><strong>图片ping</strong>常用于跟踪用户点击页面或动态广告曝光次数。 </p><ul><li>使用<code>&lt;img&gt;</code>标签，因为网页可以从任何网页中加载图片，而不用担心跨域。</li><li>请求数据通过字符串形式发送，而响应可以是任何内容。</li><li>这种方法，1）只能发送<strong>get请求</strong>。2）浏览器无法获取服务器的响应数据。3）只适用于浏览器与服务器之间的<strong>单向通信</strong>。</li><li>图片ping的示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"跨域请求"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"result"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var add = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var counter = 0;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">btn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var sum = add();</span><br><span class="line">    var img = result.getElementsByTagName(<span class="string">'img'</span>)[0];</span><br><span class="line">    <span class="keyword">if</span>(!img)&#123;</span><br><span class="line">        var img = new Image();        </span><br><span class="line">    &#125;</span><br><span class="line">    img.height=<span class="string">"100"</span>;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        result.appendChild(img);</span><br><span class="line">        var oSpan = document.getElementById(<span class="string">'sum'</span>);</span><br><span class="line">        <span class="keyword">if</span>(!oSpan)&#123;</span><br><span class="line">            oSpan = document.createElement(<span class="string">'span'</span>);</span><br><span class="line">            oSpan.id=<span class="string">"sum"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        oSpan.innerHTML = <span class="string">'发送请求的次数：'</span> + sum;</span><br><span class="line">        result.appendChild(oSpan);</span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="keyword">if</span>(sum%2)&#123;</span><br><span class="line">        img.src = <span class="string">"http://7xpdkf.com1.z0.glb.clouddn.com/eg_bulboff.gif?sum="</span>+sum;    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        img.src = <span class="string">"http://7xpdkf.com1.z0.glb.clouddn.com/eg_bulbon.gif?sum="</span>+sum;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>script标签</strong>可以得到从其他来源数据，这也是<strong>JSONP依赖的根据</strong>。 </p><ul><li><strong>缺点</strong>：只能发送get请求 ，无法访问服务器的响应文本（单向请求）。</li></ul></li></ul><h5 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h5><ul><li>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。</li><li>通过动态&lt;script&gt;元素使用，使用时为src指定一个跨域url。有两部分：1）<strong>回调函数</strong>：响应到来时在页面中使用；2）<strong>数据</strong>：传入回调函数中的JSON数据。</li><li>JSONP将访问跨域请求变成了<strong>执行远程JS代码</strong>，服务端不再返回JSON格式的数据，而是<strong>返回了一段将JSON数据作为传入参数的函数执行代码</strong>。</li><li>所有<strong>JSONP发送的get请求</strong>都是<strong>js类型</strong>，而非XHR。 </li><li>缺点：<ul><li>只能使用get请求。</li><li>不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败。</li><li>JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保。</li></ul></li></ul><h5 id="服务器设置响应头-允许跨域（一般不建议）"><a href="#服务器设置响应头-允许跨域（一般不建议）" class="headerlink" title="服务器设置响应头, 允许跨域（一般不建议）"></a>服务器设置响应头, 允许跨域（一般不建议）</h5><ul><li>W3C推荐了一种新的跨域访问机制，即<strong>跨源资源共享(CORS)</strong>。可以让AJAX实现跨域访问。它允许一个域上的脚本向另一个域提交跨域 AJAX 请求。</li><li><p>与 JSONP 不同，CORS 除了 GET 请求方法以外也<strong>支持其他的 HTTP 请求方法</strong>。服务器一般需要增加如下响应头的一种或几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure></li><li><p>跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 服务端</span><br><span class="line"><span class="string">"Access-Control-Allow-Credentials"</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 客户端需要设置withCredentials</span><br><span class="line">// Ajax设置</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>跨源资源共享(CORS)是通过<strong>客户端 + 服务端协作声明</strong>的方式来确保请求安全的。</p><ul><li>服务端会在HTTP请求头中增加一系列HTTP请求参数(例如<code>Access-Control-Allow-Origin</code>等)，来限制哪些域的请求和哪些请求类型可以接受。</li><li>客户端<strong>在发起请求时</strong>必须<strong>声明自己的源(Orgin)</strong>，否则服务器将不予处理，如果客户端不作声明，请求甚至会被浏览器直接拦截都到不了服务端。(<strong>对于支持CORS的浏览器，请求头会自动添加Origin，值为当前host</strong>)</li><li>服务端收到HTTP请求后会<strong>进行域的比较</strong>，只有<strong>同域的请求</strong>才会处理。</li></ul></li></ul><h5 id="修改document-domain跨子域"><a href="#修改document-domain跨子域" class="headerlink" title="修改document.domain跨子域"></a>修改document.domain跨子域</h5><ul><li>前提条件：这两个域名<strong>必须属于同一个基础域名</strong>，而且<strong>所用的协议，端口都要一致</strong>，否则无法利用<code>document.domain</code>进行跨域，所以只能跨子域。</li><li>在根域范围内，允许把<code>domain</code>属性的值设置为它的上一级域。例如，在<code>aaa.xxx.com</code>域内，可以把<code>domain设置为 <code>xxx.com</code>但不能设置为 <code>xxx.org</code>或者<code>com</code>。<blockquote>现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.domain不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.domain = ‘xxx.com’;设置一致，来达到互相访问的作用。</blockquote></code></li></ul><h5 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h5><ul><li><strong>WebSocket protocol</strong> 是HTML5一种新的协议。它实现了<strong>浏览器与服务器全双工通信</strong>，同时<strong>允许跨域通讯</strong>，是server push技术的一种很棒的实现。</li><li><strong>需要注意</strong>：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</li></ul><h5 id="后台代理"><a href="#后台代理" class="headerlink" title="后台代理"></a>后台代理</h5><ul><li>同源策略是针对浏览器端进行的限制，可以<strong>通过服务器端</strong>来解决该问题。</li><li><strong>将后台作为代理</strong>，每次对其它域的请求转交给本域的后台，本域的后台通过模拟http请求去访问其它域，再将返回的结果返回给前台，但是不会携带cookie。</li><li>即，<strong>DomainA客户端（浏览器）</strong>将对域B的请求转发给<strong>DomainA服务器</strong>，<strong>DomainA服务器</strong>通过模拟http请求去访问<strong>DomainB服务器</strong>，然后将结果返回给<strong>DomainA客户端（浏览器）</strong>。</li></ul><h4 id="JSONP的优缺点"><a href="#JSONP的优缺点" class="headerlink" title="JSONP的优缺点"></a>JSONP的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP<strong>可以跨越同源策略</strong>；</li><li><strong>兼容性更好</strong>，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持。</li><li>在请求完毕后可以<strong>通过调用callback的方式回传结果</strong>。将回调方法的权限给了调用方。这个就相当于将controller层和view层终于分开了。提供的jsonp服务只提供纯服务的数据，至于提供服务以后的页面渲染和后续view操作都由调用者自己定义。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑即可，逻辑都可以使用同一个jsonp服务。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>它<strong>只支持GET请求</strong>，而不支持POST等其它类型的HTTP请求。</li><li>它<strong>只支持跨域HTTP请求</strong>这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li><li>jsonp在<strong>调用失败时</strong>不会返回各种HTTP状态码。</li><li><strong>缺乏安全性</strong>。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。结果是所有调用这个jsonp的网站都会存在漏洞。于是无法把危险控制在一个域名下，所以<strong>在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;这里说的JS跨域是指&lt;strong&gt;通过JS在&lt;code&gt;不同的域&lt;/code&gt;之间进行数据传输或通信&lt;/strong&gt;，比如：&lt;ul&gt;
&lt;li&gt;用ajax向一个不同的域请求数据&lt;/li&gt;
&lt;li&gt;通过JS获取页面中不同域的框架中(iframe)的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只要&lt;strong&gt;协议&lt;/strong&gt;、&lt;strong&gt;域名&lt;/strong&gt;、&lt;strong&gt;端口&lt;/strong&gt;有任何一个不同，都被当作是不同的域。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="交互" scheme="https://chongtianhong.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="AJAX" scheme="https://chongtianhong.github.io/tags/AJAX/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="跨域" scheme="https://chongtianhong.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSS居中的方式</title>
    <link href="https://chongtianhong.github.io/2018/04/01/centerElement/"/>
    <id>https://chongtianhong.github.io/2018/04/01/centerElement/</id>
    <published>2018-04-01T03:17:00.000Z</published>
    <updated>2018-07-25T05:55:44.536Z</updated>
    
    <content type="html"><![CDATA[<h4 id="实现div的水平居中和垂直居中"><a href="#实现div的水平居中和垂直居中" class="headerlink" title="实现div的水平居中和垂直居中"></a>实现div的水平居中和垂直居中</h4><ul><li>实现元素居中的主要思路有以下三种：<ul><li>使用<code>position</code>，相对父元素做绝对定位；</li><li>使用<code>flex</code>属性；</li><li>使用<code>transform</code>做相对位移的调节。<a id="more"></a></li></ul></li></ul><blockquote>1)    只适用: 宽高已定</blockquote><ul><li>父元素设置<strong>相对定位</strong>。</li><li>子元素设置<strong>绝对定位</strong>，<code>top</code>和<code>left</code>值均设置为50%，再设置<code>margin-left</code>为负的自身宽度/2，<code>margin-top</code>设置为负的自身高度/2。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: relative;     /*很重要,不能忘*/</span><br><span class="line">    width:500px;</span><br><span class="line">    height:500px;</span><br><span class="line">    border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.children&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-left: -150px; /*-自身宽度/2*/</span><br><span class="line">    margin-top: -100px; /*-自身高度/2*/</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>2) 只适用: 固定宽高; 如果宽高随意,想靠内部撑开的话, 会占满整个父div </blockquote><ul><li>父元素设置相对定位。</li><li>子元素设置绝对定位，子div的<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>都设置成0，然后margin设置auto。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: relative;     /*很重要,不能忘*/</span><br><span class="line">    width:500px;</span><br><span class="line">    height:500px;</span><br><span class="line">    border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.children&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width:300px;</span><br><span class="line">    height:200px;</span><br><span class="line">    margin:auto;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    top:0;</span><br><span class="line">    left:0;</span><br><span class="line">    right:0;</span><br><span class="line">    background: yellow;</span><br></pre></td></tr></table></figure></li></ul><blockquote>3) 适用: 不论是否固定宽高都可用. 问题在于兼容性. ie9及以下不支持</blockquote><ul><li>父级设置<code>flex</code>属性，同时<code>justify-content</code>和<code>align-items</code>值设置为center。</li><li>这种方法在子级div有多个时也可以实现居中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;/*使水平居中*/</span><br><span class="line">    align-items:center;/*使垂直居中*/</span><br><span class="line">    width:500px;</span><br><span class="line">    height:500px;</span><br><span class="line">    border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.children&#123;</span><br><span class="line">    background: yellow;</span><br><span class="line">    /*width:300px;</span><br><span class="line">    height:200px;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>4)    适用: 可不指定宽高</blockquote><ul><li>使用<code>transform</code>属性实现水平居中。</li><li>父级元素设置相对定位。</li><li>子级元素设置绝对定位，然后<code>top</code>和<code>left</code>值均设置为50%，并设置<code>transform:translate(-50%,-50%)</code>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width:500px;</span><br><span class="line">    height:500px;</span><br><span class="line">    border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.children&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top:50%;</span><br><span class="line">    left:50%;</span><br><span class="line">    transform:translate(-50%,-50%);</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>5)    适用: 指定宽高百分比</blockquote><ul><li>保证left和right的百分数一样就可以实现水平居中，保证<code>top</code>和<code>bottom</code>的百分数一样就可以实现垂直居中。</li><li>但是这种方法不能由内部元素自动调节div的宽高，而是<strong>通过父元素大小控制</strong>的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width:500px;</span><br><span class="line">    height:500px;</span><br><span class="line">    border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.children&#123;</span><br><span class="line">    position: absolute;        </span><br><span class="line">    left: 30%;</span><br><span class="line">    right: 30%;</span><br><span class="line">    top:40%;</span><br><span class="line">    bottom: 40%;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多元素水平居中"><a href="#多元素水平居中" class="headerlink" title="多元素水平居中"></a>多元素水平居中</h4><blockquote>1) 使用inline-block</blockquote><ul><li>把子级div设置成<code>display:inline-block;</code>，然后父级div设置<code>text-align:center;</code>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**base style**/</span><br><span class="line">div&#123;</span><br><span class="line">  background:<span class="comment">#000;</span></span><br><span class="line">  color:<span class="comment">#fff;</span></span><br><span class="line">  height:50px;</span><br><span class="line">  width:50px;</span><br><span class="line">  text-align:center;</span><br><span class="line">  line-height:50px;</span><br><span class="line">  margin-left:10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**start here**/</span><br><span class="line">.parent&#123;</span><br><span class="line">  text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">.children&#123;</span><br><span class="line">  display:inline-block;</span><br><span class="line">  *display:inline;/*hack IE*/</span><br><span class="line">  *zoom:1;/*hack IE*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>2) 使用flex-box</blockquote><ul><li>更方便灵活的做法还是使用<code>flex-box</code>，设置水平居中 <code>justify-content: center</code>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;实现div的水平居中和垂直居中&quot;&gt;&lt;a href=&quot;#实现div的水平居中和垂直居中&quot; class=&quot;headerlink&quot; title=&quot;实现div的水平居中和垂直居中&quot;&gt;&lt;/a&gt;实现div的水平居中和垂直居中&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;实现元素居中的主要思路有以下三种：&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;position&lt;/code&gt;，相对父元素做绝对定位；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;flex&lt;/code&gt;属性；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;transform&lt;/code&gt;做相对位移的调节。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="布局" scheme="https://chongtianhong.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用CSS实现三栏自适应布局</title>
    <link href="https://chongtianhong.github.io/2018/03/31/threeColumnAdaptiveLayout/"/>
    <id>https://chongtianhong.github.io/2018/03/31/threeColumnAdaptiveLayout/</id>
    <published>2018-03-31T01:30:28.000Z</published>
    <updated>2018-07-25T03:07:39.130Z</updated>
    
    <content type="html"><![CDATA[<ul><li>三栏自适应布局指的是<strong>两边栏定宽，中间栏宽度自适应</strong>。</li><li>实现方法主要可以分为两大类：<ul><li>一类是基于传统的<strong>position</strong>和<strong>margin</strong>等属性实现</li><li>一类是基于css3新特性<strong>弹性盒模型（flex）布局</strong>实现<a id="more"></a></li></ul></li></ul><h4 id="基于传统的position和margin等属性进行布局"><a href="#基于传统的position和margin等属性进行布局" class="headerlink" title="基于传统的position和margin等属性进行布局"></a>基于传统的position和margin等属性进行布局</h4><ul><li>这里也分为三种方法，分别为<strong>绝对定位法</strong>，<strong>自身浮动法</strong>，<strong>圣杯布局</strong>。</li></ul><blockquote>1) 绝对定位法</blockquote><ul><li>绝对定位法原理是将<strong>左右两栏使用绝对定位</strong>（<code>position: absolute</code>），因为设置了绝对定位的元素脱离文档流，在它们之后的元素（中间栏）会自然流动到他们上面，然后<strong>中间栏使用margin属性，留出左右元素的宽度</strong>，即可以使中间元素自适应屏幕宽度。</li><li><p>代码如下：<br>html代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;layout_box&lt;/title&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"../css/layout_box.css"</span>&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">&lt;h3&gt;实现三栏宽度自适应布局&lt;/h3&gt;</span><br><span class="line">    &lt;div id = <span class="string">"left"</span>&gt;我是左边栏&lt;/div&gt;</span><br><span class="line">    &lt;div id = <span class="string">"right"</span>&gt;我是右边栏&lt;/div&gt;</span><br><span class="line">    &lt;div id = <span class="string">"center"</span>&gt;我是中间栏&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>CSS代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">html, body&#123; </span><br><span class="line">    margin: 0px;</span><br><span class="line">    width: 100%; </span><br><span class="line">&#125;</span><br><span class="line">h3&#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 20px 0 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#left, #right&#123;</span></span><br><span class="line">    position: absolute; // 相对于文档进行定位</span><br><span class="line">    top:120px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px; </span><br><span class="line">    background-color: <span class="comment">#ffe6b8;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#left&#123;</span></span><br><span class="line">    left: 0px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#right&#123;</span></span><br><span class="line">    right: 0px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#center&#123;</span></span><br><span class="line">    margin: 0px 210px;</span><br><span class="line">    background-color: <span class="comment">#eee;</span></span><br><span class="line">    height: 200px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上则是使用<strong>绝对定位</strong>的方式实现了中间栏的宽度随着屏幕大小伸缩。</p></li><li>该法布局的<strong>好处</strong>，三个div顺序可以任意改变。</li><li><strong>不足</strong>是因为绝对定位，所以如果页面上还有其他内容，top的值需要小心处理。另外，随着浏览器窗口缩小，小于200px的时候，会发生压缩。</li><li>所以，为了安全起见，最好还是给body加一个最小宽度。</li></ul><blockquote>2) 使用自身浮动法</blockquote><ul><li><p>自身浮动法的原理就是使用对左右两栏使用分别使用<code>float:left</code>和<code>float:right</code>，float属性使左右两个元素脱离文档流，中间元素正常在正常文档流中，使用margin指定左右外边距对其进行一个定位。<br>HTML代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;使用自身浮动法定位&lt;/h3&gt;</span><br><span class="line">&lt;div id = <span class="string">"left_self"</span>&gt;我是左边&lt;/div&gt;</span><br><span class="line">&lt;div id = <span class="string">"right_self"</span>&gt;我是右边&lt;/div&gt;</span><br><span class="line">&lt;div id = <span class="string">"center_self"</span>&gt;我是中间&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#left_self, #right_self&#123; </span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px; </span><br><span class="line">    background-color: <span class="comment">#ffe6b8; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#left_self &#123;</span></span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#right_self&#123;</span></span><br><span class="line">    <span class="built_in">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#center_self&#123;</span></span><br><span class="line">    margin: 0 210px;</span><br><span class="line">    height: 200px; </span><br><span class="line">    background-color: <span class="comment">#a0b3d6;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该布局法的好处是<strong>受外界影响小</strong>。</p></li><li>不足是规定了三个元素的放置顺序，<strong>center一定要放在最后</strong>，这是和绝对定位不一样的地方，center占据文档流位置，所以一定要放在最后，左右两个元素位置没有关系。当浏览器窗口很小的时候，右边元素会被击到下一行。</li><li>所以，为了安全起见，最好还是给body加一个最小宽度。</li></ul><blockquote>3) 圣杯布局</blockquote><ul><li>圣杯布局的原理是使用<strong>margin负值</strong>。</li><li>使用圣杯布局首先需要在center元素外部包含一个div，外层div需要设置float属性使其形成一个BFC，并设置宽度为100%（自适应），并且这个宽度要和left块的margin负值进行配合。</li><li>需要设置其左边距为<strong>负的中间盒子的宽度</strong>（即margin-left:-100%;），这样左盒子才可以往最左边移动。</li><li>需要设置其左边距为<strong>负的自己的宽度</strong>（即margin-left：-200px;），这样右盒子才可以在一行的最右边显示出自己。</li><li><p>实现代码：<br>HTML代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;使用margin负值法进行布局&lt;/h3&gt;</span><br><span class="line">&lt;div id = <span class="string">"wrap"</span>&gt;</span><br><span class="line">&lt;div id = <span class="string">"center"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id = <span class="string">"left_margin"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id = <span class="string">"right_margin"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#wrap&#123; </span></span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100px; </span><br><span class="line">    background-color: <span class="comment">#fff;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#wrap #center&#123; </span></span><br><span class="line">    margin:0 210px; </span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: <span class="comment">#ffe6b8; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#left_margin, #right_margin&#123; </span></span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#left_margin &#123;</span></span><br><span class="line">    margin-left: -100%; </span><br><span class="line">    background-color: lightpink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#right_margin&#123;</span></span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    background-color: darkorange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该方法在网站布局中非常常见，也是面试常考点，优点是三栏相互关联，有一定的抗性。</p></li><li>需要注意的是，<strong>布局中间部分一定要放在前面，左右顺序不限制</strong>。对于<strong>left块的margin负值</strong>一定要<strong>等于wrap的宽度</strong>。</li></ul><h4 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h4><ul><li><p>在外围包裹一层div，设置为<code>display：flex;</code>，中间栏设置<code>flex：1;</code>，但是盒模型默认紧紧挨着，可以<strong>使用margin控制外边距</strong>。<br>html代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = <span class="string">"box"</span>&gt;</span><br><span class="line">&lt;div id = <span class="string">"left_box"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id = <span class="string">"center_box"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id = <span class="string">"right_box"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#box&#123;</span></span><br><span class="line">    display: flex; </span><br><span class="line">    width:100%;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#left_box,#right_box&#123;</span></span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px; </span><br><span class="line">    margin: 10px; </span><br><span class="line">    background-color: lightpink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#center_box&#123; </span></span><br><span class="line">    flex: 1; </span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 10px; </span><br><span class="line">    background-color: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：center一定要放到中间。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;三栏自适应布局指的是&lt;strong&gt;两边栏定宽，中间栏宽度自适应&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;实现方法主要可以分为两大类：&lt;ul&gt;
&lt;li&gt;一类是基于传统的&lt;strong&gt;position&lt;/strong&gt;和&lt;strong&gt;margin&lt;/strong&gt;等属性实现&lt;/li&gt;
&lt;li&gt;一类是基于css3新特性&lt;strong&gt;弹性盒模型（flex）布局&lt;/strong&gt;实现
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="布局" scheme="https://chongtianhong.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
      <category term="自适应" scheme="https://chongtianhong.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>行内块元素存在的问题及解决方案</title>
    <link href="https://chongtianhong.github.io/2018/03/30/inlineBlock/"/>
    <id>https://chongtianhong.github.io/2018/03/30/inlineBlock/</id>
    <published>2018-03-30T10:00:29.000Z</published>
    <updated>2018-07-24T14:55:59.710Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>inline</code>和<code>inline-block</code>的元素之间会有一个字符的间隙（元素节点有文本节点，在缩进代码时会占据宽度），这个间隙导致了（按照百分比分配宽度之后）最后一个元素会掉下来。</li><li>给元素设置display：inline-block，是基于baseline对齐的，当元素大小不一会导致上下不齐，所以设置的时候最好设置vertical-align属性。<a id="more"></a></li></ul><blockquote>解决行内块元素之间存在间隙</blockquote><ul><li>产生原因：浏览器在解析HTML代码时，将上一行的结束标签和下一行的开始标签，解析为空格。</li><li><p>解决方法：<br>1.将父元素字体大小设置为0，行内块元素内的字体单独设置<br>2.取消换行符，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;aaaa&lt;/span&gt;&lt;span&gt;aaaa&lt;/span&gt;&lt;span&gt;aaaa&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>3.使用margin负值<br>4.使用浮动。（块元素同行显示：①display：inline-block②float：left）<br>5.使用letter-spacing、word-spacing等方法。</p></li><li>图片的间隙问题也是因为行内元素有一个字符的间隙，解决方法:给放置图片的div设置<code>font-size:0;</code>。</li></ul><blockquote>解决行内块元素之间的上下错位问题</blockquote><ul><li>产生原因：行内块元素是基于baseline对齐的，大小不一会导致上下不齐。</li><li>解决方法：给行内块元素设置vertical-align属性</li></ul><blockquote>vertical-align属性</blockquote><ul><li>vertical-align 属性设置元素的垂直对齐方式。</li><li>该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。</li><li>可能的值：</li></ul><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">baseline</td><td style="text-align:center">默认。元素放置在父元素的基线上</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">垂直对齐文本的下标</td></tr><tr><td style="text-align:center">super</td><td style="text-align:center">垂直对齐文本的上标</td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">把元素的顶端与行中最高元素的顶端对齐</td></tr><tr><td style="text-align:center">text-top</td><td style="text-align:center">把元素的顶端与父元素字体的顶端对齐</td></tr><tr><td style="text-align:center">middle</td><td style="text-align:center">把此元素放置在父元素的中部</td></tr><tr><td style="text-align:center">bottom</td><td style="text-align:center">把元素的顶端与行中最低的元素的顶端对齐</td></tr><tr><td style="text-align:center">text-bottom</td><td style="text-align:center">把元素的底端与父元素字体的底端对齐</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。</td></tr><tr><td style="text-align:center">inherit</td><td style="text-align:center">规定应该从父元素继承 vertical-align 属性的值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;和&lt;code&gt;inline-block&lt;/code&gt;的元素之间会有一个字符的间隙（元素节点有文本节点，在缩进代码时会占据宽度），这个间隙导致了（按照百分比分配宽度之后）最后一个元素会掉下来。&lt;/li&gt;
&lt;li&gt;给元素设置display：inline-block，是基于baseline对齐的，当元素大小不一会导致上下不齐，所以设置的时候最好设置vertical-align属性。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="inline-block" scheme="https://chongtianhong.github.io/tags/inline-block/"/>
    
  </entry>
  
  <entry>
    <title>Git远程操作详解</title>
    <link href="https://chongtianhong.github.io/2018/03/29/git/"/>
    <id>https://chongtianhong.github.io/2018/03/29/git/</id>
    <published>2018-03-29T07:32:52.000Z</published>
    <updated>2018-07-24T14:28:57.541Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。</li><li>Git有很多优势，其中之一就是<strong>远程操作非常简便</strong>。</li><li>本文将详细介绍5个Git命令的概念和用法，理解了这些内容，就能完全掌握Git远程操作：<ul><li>git clone</li><li>git remote</li><li>git fetch</li><li>git pull</li><li>git push<a id="more"></a></li></ul></li></ul><p><img src="/images/git.jpg" width="600" alt="Git的基本用法" style="border:none"></p><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><ul><li><p>远程操作的第一步，通常是<strong>从远程主机克隆一个版本库</strong>，这时就要用到<code>git clone</code>命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure></li><li><p>比如，克隆jQuery的版本库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure></li><li><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要<strong>指定不同的目录名</strong>，可以将目录名作为<code>git clone</code>命令的第二个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>git clone</code>支持多种协议，除了<strong>HTTP(s)</strong>以外，还支持<strong>SSH、Git、本地文件协议</strong>等，下面是一些例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http[s]://example.com/path/to/repo.git/</span><br><span class="line">git <span class="built_in">clone</span> ssh://example.com/path/to/repo.git/</span><br><span class="line">git <span class="built_in">clone</span> git://example.com/path/to/repo.git/</span><br><span class="line">git <span class="built_in">clone</span> /opt/git/project.git </span><br><span class="line">git <span class="built_in">clone</span> file:///opt/git/project.git</span><br><span class="line">git <span class="built_in">clone</span> ftp[s]://example.com/path/to/repo.git/</span><br><span class="line">git <span class="built_in">clone</span> rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure></li><li><p><strong>SSH协议</strong>还有另一种写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [user@]example.com:path/to/repo.git/</span><br></pre></td></tr></table></figure></li><li><p>通常来说，<strong>Git协议下载速度最快</strong>，<strong>SSH协议</strong>用于<strong>需要用户认证</strong>的场合。</p></li></ul><h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><ul><li>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</li><li><p>不带选项的时候，<code>git remote</code>命令<strong>列出所有远程主机</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></li><li><p>使用<code>-v</code>选项，可以参看远程主机的网址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class="line">origin  git@github.com:jquery/jquery.git (push)</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p></li><li><p>克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -o jQuery https://github.com/jquery/jquery.git</span><br><span class="line">$ git remote</span><br><span class="line">jQuery</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p></li><li><p><code>git remote show</code>命令加上主机名，可以查看该主机的详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show &lt;主机名&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>git remote add</code>命令用于添加远程主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;主机名&gt; &lt;网址&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>git remote rm</code>命令用于删除远程主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm &lt;主机名&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>git remote rename</code>命令用于远程主机的改名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><ul><li><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure></li><li><p>上面命令将某个远程主机的更新，全部取回本地。</p></li><li><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</li><li><p>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>比如，取回<code>origin</code>主机的<code>master</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure></li><li><p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。</p></li><li><p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p></li><li><p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkoutr</code>命令创建一个新的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p></li><li><p>此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示在当前分支上，合并<code>origin/master</code>。</p></li></ul><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><ul><li><p><code>git pull</code>命令的作用是，<strong>取回远程主机某个分支的更新</strong>，<strong>再与本地的指定分支合并</strong>。它的完整格式稍稍有点复杂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next:master</span><br></pre></td></tr></table></figure></li><li><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这<strong>等同于先做<code>git fetch</code>，再做<code>git merge</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git merge origin/next</span><br></pre></td></tr></table></figure></li><li><p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p></li><li><p>Git也允许手动建立追踪关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream master origin/next</span><br></pre></td></tr></table></figure></li><li><p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p></li><li><p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p></li><li><p>如果当前分支只有一个追踪分支，连远程主机名都可以省略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p></li><li><p>如果合并需要采用rebase模式，可以使用<code>–rebase</code>选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p></li><li>但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull -p</span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line">$ git fetch --prune origin </span><br><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure></li></ul><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><ul><li><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>:分支推送顺序的写法是<strong>&lt;来源地&gt;:&lt;目的地&gt;</strong>，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p></li><li><p>如果<strong>省略远程分支名</strong>，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该<strong>远程分支不存在</strong>，则会<strong>被新建</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p></li><li><p>如果<strong>省略本地分支名</strong>，则表示<strong>删除指定的远程分支</strong>，因为这等同于推送一个空的本地分支到远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ git push origin --delete master</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p></li><li><p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。</p></li><li><p>如果当前分支只有一个追踪分支，那么主机名都可以省略:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure></li><li><p>如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></li><li><p>上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p></li><li><p>不带任何参数的<code>git push</code>，默认<strong>只推送当前分支</strong>，这叫做<strong>simple方式</strong>。此外，还有一种<strong>matching方式</strong>，会<strong>推送所有有对应的远程分支的本地分支</strong>。Git 2.0版本之前，默认采用matching方法，现在改为<strong>默认采用simple方式</strong>。如果要修改这个设置，可以采用<code>git config</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global push.default matching</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ git config --global push.default simple</span><br></pre></td></tr></table></figure></li><li><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>–all</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --all origin</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，将所有本地分支都推送到<code>origin</code>主机。</p></li><li><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>–force</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push --force origin</span><br></pre></td></tr></table></figure></li><li><p>上面命令使用<code>–force</code>选项，结果导致<strong>远程主机上更新的版本被覆盖</strong>。除非你很确定要这样做，否则应该<strong>尽量避免</strong>使用<code>–force</code>选项。</p></li><li>最后，<code>git push</code>不会推送标签（tag），除非使用<code>–tags</code>选项：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。&lt;/li&gt;
&lt;li&gt;Git有很多优势，其中之一就是&lt;strong&gt;远程操作非常简便&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;本文将详细介绍5个Git命令的概念和用法，理解了这些内容，就能完全掌握Git远程操作：&lt;ul&gt;
&lt;li&gt;git clone&lt;/li&gt;
&lt;li&gt;git remote&lt;/li&gt;
&lt;li&gt;git fetch&lt;/li&gt;
&lt;li&gt;git pull&lt;/li&gt;
&lt;li&gt;git push
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="Github" scheme="https://chongtianhong.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>同步、异步和事件循环(Event Loop)</title>
    <link href="https://chongtianhong.github.io/2018/03/28/eventLoop/"/>
    <id>https://chongtianhong.github.io/2018/03/28/eventLoop/</id>
    <published>2018-03-28T14:44:05.000Z</published>
    <updated>2018-07-23T14:59:47.399Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单线程的JavaScript"><a href="#单线程的JavaScript" class="headerlink" title="单线程的JavaScript"></a>单线程的JavaScript</h4><ul><li>JavaScript是单线程的，指在<strong>JS引擎</strong>中负责<strong>解析和执行JavaScript代码</strong>的线程（<strong>主线程</strong>）<strong>只有一个</strong>。</li><li><strong>实际上还存在其他的线程（工作线程）</strong>。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。<a id="more"></a><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4></li><li><strong>同步交互</strong>：指<strong>发送一个请求</strong>，<strong>需要</strong>等待返回，然后<strong>才能够发送下一个请求</strong>，<strong>有个等待过程</strong>。</li><li><strong>异步交互</strong>：指<strong>发送一个请求</strong>，<strong>不需要</strong>等待返回，<strong>随时可以再发送下一个请求</strong>，即<strong>不需要等待</strong>。</li><li><strong>同步可以保证顺序一致</strong>，但是容易导致<strong>阻塞</strong>；<strong>异步可以解决阻塞问题</strong>，但是<strong>会改变顺序性</strong>。</li><li>正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以<strong>在JavaScript中对于耗时的操作或者时间不确定的操作</strong>，<strong>使用异步</strong>就成了必然的选择。</li></ul><h4 id="异步过程的构成要素"><a href="#异步过程的构成要素" class="headerlink" title="异步过程的构成要素"></a>异步过程的构成要素</h4><ul><li><strong>异步函数</strong>实际上很快就调用完成了。但是后面还有<strong>工作线程执行异步任务</strong>、<strong>通知主线程</strong>、<strong>主线程调用回调函数</strong>等很多步骤。我们把整个过程叫做<strong>异步过程</strong>。<strong>异步函数的调用在整个异步过程中，只是一小部分</strong>。</li><li>一个<strong>异步过程</strong>通常是这样的：<ul><li>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；</li><li><strong>主线程可以继续执行后面的（同步）代码</strong>，同时<strong>工作线程执行异步任务</strong>；</li><li><strong>工作线程完成工作后，通知主线程</strong>；</li><li><strong>主线程收到通知后，执行一定的动作(调用回调函数)</strong>。</li></ul></li></ul><h4 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h4><ul><li>异步过程中，<strong>工作线程</strong>在<strong>异步操作完成后</strong>需要<strong>通知主线程</strong>。那么这个<strong>通知机制</strong>是利用<strong>消息队列</strong>和<strong>事件循环（EventLoop）</strong>。</li><li>即：<strong>工作线程将消息放到消息队列，主线程通过事件循环过程去获取消息</strong>。<br>• <strong>消息队列</strong>：消息队列是一个<strong>先进先出</strong>的队列，它里面存放着各种消息。<br>• <strong>事件循环</strong>：事件循环是指<strong>主线程重复从消息队列中取消息、执行</strong>的过程。</li><li>实际上，<strong>主线程只会做一件事情</strong>，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且<strong>主线程只有在将当前的消息执行完成后，才会去取下一个消息</strong>。这种机制就叫做<strong>事件循环机制</strong>，<strong>取一个消息并执行的过程</strong>叫做<strong>一次循环</strong>。</li><li><strong>浏览器有一个内部大消息循环Event Loop（事件循环），会轮询事件队列并处理事件</strong>。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：input onchange），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了才能执行下一个。</li><li><strong>异步过程的回调函数，一定不在当前这一轮事件循环中执行</strong>。</li></ul><h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><ul><li><strong>工作线程</strong>是<strong>生产者</strong>，主线程是<strong>消费者</strong>(只有一个消费者)。</li><li><strong>工作线程执行异步任务</strong>，执行完成后<strong>把对应的回调函数封装成一条消息</strong>放到消息队列中；</li><li><strong>主线程</strong>不断地<strong>从消息队列中取消息并执行</strong>，当<strong>消息队列空时主线程阻塞</strong>，<strong>直到消息队列再次非空</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;单线程的JavaScript&quot;&gt;&lt;a href=&quot;#单线程的JavaScript&quot; class=&quot;headerlink&quot; title=&quot;单线程的JavaScript&quot;&gt;&lt;/a&gt;单线程的JavaScript&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JavaScript是单线程的，指在&lt;strong&gt;JS引擎&lt;/strong&gt;中负责&lt;strong&gt;解析和执行JavaScript代码&lt;/strong&gt;的线程（&lt;strong&gt;主线程&lt;/strong&gt;）&lt;strong&gt;只有一个&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实际上还存在其他的线程（工作线程）&lt;/strong&gt;。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="同步" scheme="https://chongtianhong.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="异步" scheme="https://chongtianhong.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="事件循环" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP知识点总结</title>
    <link href="https://chongtianhong.github.io/2018/03/27/http/"/>
    <id>https://chongtianhong.github.io/2018/03/27/http/</id>
    <published>2018-03-27T15:45:24.000Z</published>
    <updated>2018-07-23T14:42:53.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><ul><li>超文本传输协议（Hyper Text Transfer Protocol, HTTP）是用于从万维网（WWW:World Wide Web）<strong>服务器传输超文本到本地浏览器</strong>的<strong>应用层传送协议</strong>。它被设计用于<strong>Web浏览器</strong>和<strong>Web服务器</strong>之间的<strong>通信</strong>，但它也可以用于其他目的。 </li><li>HTTP是一个<strong>基于TCP/IP通信协议</strong>来传递数据（HTML 文件, 图片文件, 查询结果等）。一个完整的web文档是由不同的子文档重新组建而成的，例如文本、布局描述、图片、视频、脚本等。</li><li>HTTP是一个属于<strong>应用层的面向对象的协议</strong>，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<a id="more"></a></li><li>HTTP遵循经典的<strong>客户端-服务端模型</strong>。浏览器作为<strong>HTTP客户端</strong>通过URL向<strong>HTTP服务端即WEB服务器</strong>发送所有请求。<strong>Web服务器</strong>根据接收到的请求后，向<strong>客户端</strong>发送响应信息。（请求通常是由像浏览器这样的接受方发起的。）</li><li>客户端和服务端通过交换各自的消息（与数据流正好相反）来进行交互。通常由像浏览器这样的<strong>客户端发出的消息叫做requests</strong>，那么<strong>被服务端回应的消息就叫做 responses</strong>。<br><img src="/images/csModel.jpg" width="600" alt="http请求-响应模型" style="border:none"></li><li>HTTP是<strong>无状态</strong>协议，意味着<strong>服务器不会在两个请求之间保留任何数据（状态）</strong>。</li><li>它是<strong>应用层</strong>的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过<strong>TCP</strong>，或者是TLS－加密的TCP连接来发送。（由于UDP不可靠，不使用UDP）</li><li>要渲染出一个网页，浏览器首先要发送第一个请求来获取这个页面的HTML文档，再解析它并根据文档中的资源信息发送其他的请求来获取脚本信息，或者CSS来进行页面布局渲染，还有一些其它的页面资源（如图片和视频等）。然后，它把这些资源结合到一起，展现出来一个完整的文档，也就是网页。打开一个网页后，浏览器还可以根据脚本内容来获取更多的资源来更新网页。</li></ul><h3 id="HTTP-的基本性质"><a href="#HTTP-的基本性质" class="headerlink" title="HTTP 的基本性质"></a>HTTP 的基本性质</h3><h4 id="1-简单快速："><a href="#1-简单快速：" class="headerlink" title="1. 简单快速："></a>1. 简单快速：</h4><ul><li>客户向服务器<strong>请求服务时，只需传送请求方法和路径</strong>。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于<strong>HTTP协议简单</strong>，使得<strong>HTTP服务器的程序规模小</strong>，因而<strong>通信速度很快</strong>。</li></ul><h4 id="2-可扩展："><a href="#2-可扩展：" class="headerlink" title="2. 可扩展："></a>2. 可扩展：</h4><ul><li>在 HTTP/1.0 中出现的<strong>HTTP headers让协议扩展变得非常容易</strong>。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。</li></ul><h4 id="3-灵活："><a href="#3-灵活：" class="headerlink" title="3. 灵活："></a>3. 灵活：</h4><ul><li>HTTP允许<strong>传输任意类型的数据对象</strong>。正在传输的类型由Content-Type加以标记。</li></ul><h4 id="4-无状态，有会话："><a href="#4-无状态，有会话：" class="headerlink" title="4. 无状态，有会话："></a>4. 无状态，有会话：</h4><ul><li>HTTP协议本质是无状态协议，使用Cookies可以创建有状态的会话。<ul><li>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>使用<strong>HTTP的头部扩展</strong>，HTTP Cookies就可以解决HTTP无状态的问题。<strong>把Cookies添加到头部</strong>中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</li></ul></li></ul><h4 id="5-无连接："><a href="#5-无连接：" class="headerlink" title="5. 无连接："></a>5. 无连接：</h4><ul><li>无连接的含义是<strong>限制每次连接只处理一个请求</strong>。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li></ul><h3 id="HTTP-URL"><a href="#HTTP-URL" class="headerlink" title="HTTP URL"></a>HTTP URL</h3><ul><li>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</li><li>统一资源定位符（Uniform Resource Locator, URL）是互联网上用来标识某一处资源的地址。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。</li><li>以下面这个URL为例，介绍下普通URL的各部分组成：<br><code><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></code></li><li>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.<code><strong>协议</strong>部分</code>：该URL的协议部分为“http:”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。<br>2.<code><strong>域名</strong>部分</code>：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。<br>3.<code><strong>端口</strong>部分</code>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口<br>4.<code><strong>虚拟目录</strong>部分</code>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”。<br>5.<code><strong>文件名</strong>部</code>分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。<br>6.<code><strong>参数</strong>部分</code>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。<br>7.<code><strong>锚</strong>部分</code>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。</li></ul><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><blockquote>统一资源标识符（URI）用来唯一的标识一个资源。</blockquote><ul><li>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的。</li><li>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源</li></ul><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><blockquote>统一资源定位器（URL）是一种具体的URI，可以用来标识一个资源，而且指明了如何定位这个资源。</blockquote><ul><li>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</li><li>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</li></ul><h4 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h4><blockquote>统一资源命名（uniform resource name，URN）通过名字来标识资源，比如mailto:java-net@java.sun.com。</blockquote><ul><li>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。</li><li>每个 URL 都是 URI，但不一定每个 URI 都是 URL。因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</li></ul><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><ul><li>有两种HTTP报文的类型，<strong>请求报文</strong>与<strong>响应报文</strong>，每种都有其特定的格式。</li></ul><h4 id="HTTP-请求消息Request"><a href="#HTTP-请求消息Request" class="headerlink" title="HTTP 请求消息Request"></a>HTTP 请求消息Request</h4><ul><li>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<br><code>请求行（request line）</code>、<code>请求头部（header）</code>、<code>空行</code>和<code>请求数据</code>四个部分组成。<br><img src="/images/request.png" width="400" alt="Http请求消息结构" style="border:none"></li><li>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</li></ul><blockquote>Get请求例子，使用Charles抓取的request：</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br><span class="line"></span><br><span class="line">//请求数据为空</span><br></pre></td></tr></table></figure><ul><li>第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本。<ul><li>GET说明请求类型为GET，[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</li></ul></li><li>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。<ul><li>从第二行起为请求头部，HOST将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送等等。</li></ul></li><li>第三部分：空行，请求头部后面的空行是必须的。<ul><li>即使第四部分的请求数据为空，也必须有空行。</li></ul></li><li>第四部分：请求数据也叫主体，可以添加任意的其他数据。<ul><li>这个例子的请求数据为空。</li></ul></li></ul><blockquote>POST请求例子，使用Charles抓取的request：</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><ul><li>第一部分：请求行，第一行指明了是post请求，以及http1.1版本。</li><li>第二部分：请求头部，第二行至第六行。</li><li>第三部分：空行，第七行的空行。</li><li>第四部分：请求数据，第八行。</li></ul><h4 id="HTTP-响应消息Response"><a href="#HTTP-响应消息Response" class="headerlink" title="HTTP 响应消息Response"></a>HTTP 响应消息Response</h4><ul><li>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</li><li>HTTP响应也由四个部分组成，分别是：<code>状态行</code>、<code>消息报头</code>、<code>空行</code>和<code>响应正文</code>。<br><img src="/images/respond.jpg" width="600" alt="http响应消息格式" style="border:none"></li></ul><blockquote>响应消息例子：</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<ul><li>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</li></ul></li><li>第二部分：消息报头，用来说明客户端要使用的一些附加信息。<ul><li>第二行和第三行为消息报头</li><li>Date:生成响应的日期和时间；Content-Type：指定了MIME类型的HTML(text/html)，编码类型是UTF-8</li></ul></li><li>第三部分：空行，消息报头后面的空行是必须的。</li><li>第四部分：响应正文，服务器返回给客户端的文本信息。<ul><li>空行后面的html部分为响应正文。</li></ul></li></ul><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><ul><li>状态代码由三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br><code>1xx：指示信息–表示请求已接收，继续处理</code><br><code>2xx：成功–表示请求已被成功接收、理解、接受</code><br><code>3xx：重定向–要完成请求必须进行更进一步的操作</code><br><code>4xx：客户端错误–请求有语法错误或请求无法实现</code><br><code>5xx：服务器端错误–服务器未能实现合法的请求</code></li><li>常见状态码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><ul><li>根据HTTP标准，HTTP请求可以使用多种请求方法。</li><li>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</li><li>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET       //请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD      //类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST      //向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。</span><br><span class="line">PUT       //从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE    //请求服务器删除指定的页面。</span><br><span class="line">CONNECT   //HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS   //允许客户端查看服务器的性能。</span><br><span class="line">TRACE     //回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><ul><li>HTTP协议定义<strong>Web客户端如何从Web服务器请求Web页面</strong>，以及<strong>服务器如何把Web页面传送给客户端</strong>。HTTP协议采用了请求/响应模型。</li><li><strong>客户端</strong>向服务器发送一个<strong>请求报文</strong>，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。</li><li><strong>服务器</strong>以一个<strong>状态行作为响应</strong>，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</li><li><p>以下是 HTTP 请求/响应的步骤：</p><blockquote><strong>1、客户端连接到Web服务器</strong></blockquote><ul><li>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn。" target="_blank" rel="noopener">http://www.oakcms.cn。</a></li></ul><blockquote><strong>2、发送HTTP请求</strong></blockquote><ul><li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li></ul><blockquote><strong>3、服务器接受请求并返回HTTP响应</strong></blockquote><ul><li>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li></ul><blockquote><strong>4、释放连接TCP连接</strong></blockquote><ul><li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li></ul><blockquote><strong>5、客户端浏览器解析HTML内容</strong></blockquote><ul><li>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li></ul></li><li>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：<br>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;<br>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;<br>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;<br>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;<br>5、释放 TCP连接;<br>6、浏览器对该 html 文本进行解析，根据文档中的资源信息请求资源，完成资源整合后显示页面内容。</li></ul><h3 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a>GET和POST请求的区别</h3><ul><li>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET，POST，PUT，DELETE。一个URL地址用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</li></ul><blockquote>GET请求</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /books/?sex=man&amp;name=Professional HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">//请求数据为空，最后一行为空行</span><br></pre></td></tr></table></figure><blockquote>POST请求</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.wrox.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><ul><li><strong>GET请求</strong>和<strong>POST请求</strong>的区别：</li></ul><ol><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456，即数据会在地址栏中显示出来，而POST提交是把提交的数据放在HTTP包的Body中，地址栏不会改变。</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.<ul><li>首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有：</li><li>GET：<strong>特定浏览器和服务器对URL长度有限制</strong>，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。</li><li>POST：由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</li></ul></li><li>安全性：<strong>POST的安全性</strong>要比GET的安全性<strong>高</strong>。<ul><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</li></ul></li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP简介&quot;&gt;&lt;a href=&quot;#HTTP简介&quot; class=&quot;headerlink&quot; title=&quot;HTTP简介&quot;&gt;&lt;/a&gt;HTTP简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;超文本传输协议（Hyper Text Transfer Protocol, HTTP）是用于从万维网（WWW:World Wide Web）&lt;strong&gt;服务器传输超文本到本地浏览器&lt;/strong&gt;的&lt;strong&gt;应用层传送协议&lt;/strong&gt;。它被设计用于&lt;strong&gt;Web浏览器&lt;/strong&gt;和&lt;strong&gt;Web服务器&lt;/strong&gt;之间的&lt;strong&gt;通信&lt;/strong&gt;，但它也可以用于其他目的。 &lt;/li&gt;
&lt;li&gt;HTTP是一个&lt;strong&gt;基于TCP/IP通信协议&lt;/strong&gt;来传递数据（HTML 文件, 图片文件, 查询结果等）。一个完整的web文档是由不同的子文档重新组建而成的，例如文本、布局描述、图片、视频、脚本等。&lt;/li&gt;
&lt;li&gt;HTTP是一个属于&lt;strong&gt;应用层的面向对象的协议&lt;/strong&gt;，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
  </entry>
  
</feed>
