<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-09-04T14:16:18.926Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试题整理三（JS部分）</title>
    <link href="https://chongtianhong.github.io/2018/09/03/interviewMap3/"/>
    <id>https://chongtianhong.github.io/2018/09/03/interviewMap3/</id>
    <published>2018-09-03T12:52:04.000Z</published>
    <updated>2018-09-04T14:16:18.926Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS-Part"><a href="#JS-Part" class="headerlink" title="JS Part"></a>JS Part</h4><h5 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h5><ul><li><p>先看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> b = a</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 2</span><br></pre></td></tr></table></figure></li><li><p>从上述例子中我们可以发现，如果给一个<strong>变量赋值一个对象</strong>，那么<strong>两者的值会是同一个引用</strong>，其中一方改变，另一方也会相应改变。</p></li><li>通常在开发中我们不希望出现这样的问题，我们可以使用<strong>浅拷贝</strong>来解决这个问题。</li></ul><h6 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h6><ul><li><p>首先可以通过<code>Object.assign</code>来解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> b = Object.assign(&#123;&#125;, a)</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 1</span><br></pre></td></tr></table></figure></li><li><p>也可以通过<strong>展开运算符（…）</strong>来解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 1</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JS-Part&quot;&gt;&lt;a href=&quot;#JS-Part&quot; class=&quot;headerlink&quot; title=&quot;JS Part&quot;&gt;&lt;/a&gt;JS Part&lt;/h4&gt;&lt;h5 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Object.assign()的使用</title>
    <link href="https://chongtianhong.github.io/2018/06/04/ObjectAssign/"/>
    <id>https://chongtianhong.github.io/2018/06/04/ObjectAssign/</id>
    <published>2018-06-04T12:02:51.000Z</published>
    <updated>2018-09-05T00:04:58.775Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>Object.assign()</code>方法用于将所有<strong>可枚举属性的值</strong>从一个或多个源对象<strong>复制到目标对象</strong>。它将<strong>返回目标对象</strong>。<a id="more"></a></li><li>语法：<code>Object.assign(target, …sources)</code></li><li>该方法有两个参数：<ul><li>第一个<strong>target</strong>为<strong>目标对象</strong>；</li><li>后面的<strong>参数sources</strong>为<strong>源对象</strong>。</li></ul></li><li><p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。<strong>后来的源的属性将类似地覆盖早先的属性</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);</span><br><span class="line"></span><br><span class="line">console.log(object2.c, object2.d);</span><br><span class="line">// expected output: 3 5</span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的<code>[[Get]]</code>和目标对象的<code>[[Set]]</code>，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。</p></li><li>注意：<code>Object.assign</code>不会跳过那些值为<code>null</code>或<code>undefined</code>的源对象。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li><p>复制一个对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1 &#125;;</span><br><span class="line">var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); // &#123; a: 1 &#125;</span><br></pre></td></tr></table></figure></li><li><p>针对<strong>深拷贝</strong>，需要使用其他方法，因为<strong><code>Object.assign()</code>拷贝的是属性值</strong>。假如<strong>源对象的属性值是一个指向对象的引用</strong>，它也<strong>只拷贝那个引用值</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class="line">    <span class="built_in">let</span> obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    obj1.a = 1;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    obj2.a = 2;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    obj2.b.c = 3;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    // Deep Clone</span><br><span class="line">    obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class="line">    <span class="built_in">let</span> obj3 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">    obj1.a = 4;</span><br><span class="line">    obj1.b.c = 4;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 4, b: &#123; c: 4&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br></pre></td></tr></table></figure></li><li><p>合并对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span><br></pre></td></tr></table></figure></li><li><p>合并具有相同属性的对象，属性被后续参数中具有相同属性的其他对象覆盖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure></li><li><p>拷贝 symbol 类型的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; [Symbol(<span class="string">'foo'</span>)]: 2 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, o1, o2);</span><br><span class="line">console.log(obj); // &#123; a : 1, [Symbol(<span class="string">"foo"</span>)]: 2 &#125;</span><br><span class="line">Object.getOwnPropertySymbols(obj); // [Symbol(foo)]</span><br></pre></td></tr></table></figure></li><li><p><strong>继承属性</strong>和<strong>不可枚举属性</strong>是<strong>不能拷贝</strong>的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。</span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: 2  // bar 是个不可枚举属性。</span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        enumerable: <span class="literal">true</span>  // baz 是个自身可枚举属性。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); // &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure></li><li><p>原始类型会被包装为对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var v1 = <span class="string">"abc"</span>;</span><br><span class="line">var v2 = <span class="literal">true</span>;</span><br><span class="line">var v3 = 10;</span><br><span class="line">var v4 = Symbol(<span class="string">"foo"</span>)</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">// 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">// 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); // &#123; <span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>: <span class="string">"b"</span>, <span class="string">"2"</span>: <span class="string">"c"</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异常会打断后续拷贝任务</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var target = Object.defineProperty(&#123;&#125;, <span class="string">"foo"</span>, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;); // target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is <span class="built_in">read</span>-only</span><br><span class="line">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法用于将所有&lt;strong&gt;可枚举属性的值&lt;/strong&gt;从一个或多个源对象&lt;strong&gt;复制到目标对象&lt;/strong&gt;。它将&lt;strong&gt;返回目标对象&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用ES6新特性优化代码</title>
    <link href="https://chongtianhong.github.io/2018/06/03/codeOptimizationUsingES6/"/>
    <id>https://chongtianhong.github.io/2018/06/03/codeOptimizationUsingES6/</id>
    <published>2018-06-03T09:00:46.000Z</published>
    <updated>2018-09-05T00:03:49.302Z</updated>
    
    <content type="html"><![CDATA[<h4 id="声明变量的新姿势"><a href="#声明变量的新姿势" class="headerlink" title="声明变量的新姿势"></a>声明变量的新姿势</h4><h5 id="用let不用var"><a href="#用let不用var" class="headerlink" title="用let不用var"></a>用let不用var</h5><ul><li>ES6之前我们用<code>var</code>声明一个变量，但是它有很多弊病：<a id="more"></a><ul><li>因为没有块级作用域，很容易声明全局变量</li><li>变量提升</li><li>可以重复声明</li></ul></li><li><p>一道熟悉的面试题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br><span class="line">a[7](); // 10</span><br><span class="line">a[8](); // 10</span><br><span class="line">a[9](); // 10</span><br></pre></td></tr></table></figure></li><li><p>为了使得调用不同的数组元素输出对应的index，既可以使用闭包，也可以对代码做以下修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    // 对于 <span class="built_in">let</span> 来说，它会创建一个块级作用域</span><br><span class="line">    a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br><span class="line">a[7](); // 7</span><br><span class="line">a[8](); // 8</span><br><span class="line">a[9](); // 9</span><br></pre></td></tr></table></figure></li></ul><h5 id="有时候const比let更好"><a href="#有时候const比let更好" class="headerlink" title="有时候const比let更好"></a>有时候const比let更好</h5><ul><li><code>const</code>和<code>let</code>的唯一区别就是，<strong><code>const</code>不可以被更改</strong>，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用<code>const</code>。</li><li><code>const</code>的优势在于：<ul><li>更好的代码语义化，一眼看到就是常量。</li><li>另一个原因是<strong>JavaScript编译器对<code>const</code>的优化要比<code>let</code>好</strong>，多使用<code>const</code>，有利于<strong>提高程序的运行效率</strong>。</li></ul></li><li>所有的<strong>函数</strong>都应该<strong>设置为常量</strong>。</li></ul><h4 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h4><ul><li>不要使用“双引号”，一律用单引号或反引号：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const a = <span class="string">"foobar"</span>;</span><br><span class="line">const b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">const a = <span class="string">'foobar'</span>;</span><br><span class="line">const b = `foo<span class="variable">$&#123;a&#125;</span>bar`;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解构赋值的骚操作"><a href="#解构赋值的骚操作" class="headerlink" title="解构赋值的骚操作"></a>解构赋值的骚操作</h4><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><ul><li>在<strong>用到数组成员对变量赋值</strong>时，尽量使用<strong>解构赋值</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// low</span><br><span class="line">const first = arr[0];</span><br><span class="line">const second = arr[1];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const [first, second] = arr;</span><br></pre></td></tr></table></figure></li></ul><h5 id="函数传对象"><a href="#函数传对象" class="headerlink" title="函数传对象"></a>函数传对象</h5><ul><li><p><strong>函数的参数</strong>如果是<strong>对象的成员</strong>，优先使用<strong>解构赋值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> getFullName(user) &#123;</span><br><span class="line">    const firstName = user.firstName;</span><br><span class="line">    const lastName = user.lastName;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> getFullName(&#123; firstName, lastName &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>函数返回多个值，优先使用对象的解构赋值</strong>，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> processInput(input) &#123;</span><br><span class="line">    <span class="built_in">return</span> [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> processInput(input) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; left, right &#125; = processInput(input);</span><br></pre></td></tr></table></figure></li></ul><h4 id="关于对象的细节"><a href="#关于对象的细节" class="headerlink" title="关于对象的细节"></a>关于对象的细节</h4><h5 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h5><ul><li><p>单行定义的对象结尾不要逗号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const a = &#123; k1: v1, k2: v2, &#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const a = &#123; k1: v1, k2: v2 &#125;;</span><br></pre></td></tr></table></figure></li><li><p>多行定义的对象要保留逗号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const b = &#123;</span><br><span class="line">    k1: v1,</span><br><span class="line">    k2: v2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const b = &#123;</span><br><span class="line">    k1: v1,</span><br><span class="line">    k2: v2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="一次性初始化完全"><a href="#一次性初始化完全" class="headerlink" title="一次性初始化完全"></a>一次性初始化完全</h5><ul><li><p>不要声明之后又给对象添加新属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const a = &#123;&#125;;</span><br><span class="line">a.x = 3;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const a = &#123; x: null &#125;;</span><br><span class="line">a.x = 3;</span><br></pre></td></tr></table></figure></li><li><p>如果一定非要加请使用<code>Object.assign</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = &#123;&#125;;</span><br><span class="line">Object.assign(a, &#123; x: 3 &#125;);</span><br></pre></td></tr></table></figure></li><li><p>如果对象的属性名是动态的，可以<strong>在创造对象的时候，使用属性表达式定义</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const obj = &#123;</span><br><span class="line">  id: 5,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj[getKey(<span class="string">'enabled'</span>)] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const obj = &#123;</span><br><span class="line">  id: 5,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">  [getKey(<span class="string">'enabled'</span>)]: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="尽量简洁表达"><a href="#尽量简洁表达" class="headerlink" title="尽量简洁表达"></a>尽量简洁表达</h5><ul><li>在定义对象时，能简洁表达尽量简洁表达：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var ref = <span class="string">'some value'</span>;</span><br><span class="line"></span><br><span class="line">// low</span><br><span class="line">const atom = &#123;</span><br><span class="line">    ref: ref,</span><br><span class="line"></span><br><span class="line">    value: 1,</span><br><span class="line"></span><br><span class="line">    addValue: <span class="keyword">function</span> (value) &#123;</span><br><span class="line">        <span class="built_in">return</span> atom.value + value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const atom = &#123;</span><br><span class="line">    ref,</span><br><span class="line"></span><br><span class="line">    value: 1,</span><br><span class="line"></span><br><span class="line">    addValue(value) &#123;</span><br><span class="line">        <span class="built_in">return</span> atom.value + value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="扩展运算符（…）"><a href="#扩展运算符（…）" class="headerlink" title="扩展运算符（…）"></a>扩展运算符（…）</h5><ul><li>使用扩展运算符（…）拷贝数组：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const len = items.length;</span><br><span class="line">const itemsCopy = [];</span><br><span class="line"><span class="built_in">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// cool </span><br><span class="line">const itemsCopy = [...items];</span><br></pre></td></tr></table></figure></li></ul><h5 id="将类数组转化为数组"><a href="#将类数组转化为数组" class="headerlink" title="将类数组转化为数组"></a>将类数组转化为数组</h5><ul><li>用<code>Array.from</code>方法，将类似数组的对象转为数组：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo = document.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line">const nodes = Array.from(foo);</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数=&gt;"></a>箭头函数=&gt;</h5><ul><li><p>立即执行函数可以写成箭头函数的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'Welcome to the Internet.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>尽量写箭头函数使你的代码看起来简洁优雅：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">[1, 2, 3].map(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// cool !</span><br><span class="line">[1, 2, 3].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure></li></ul><h5 id="不要再用arguments（类数组）"><a href="#不要再用arguments（类数组）" class="headerlink" title="不要再用arguments（类数组）"></a>不要再用arguments（类数组）</h5><ul><li>使用 rest 运算符（…）代替，rest 运算符可以提供一个真正的数组。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">concatenateAll</span></span>() &#123;</span><br><span class="line">    const args = Array.prototype.slice.call(arguments);</span><br><span class="line">    <span class="built_in">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> concatenateAll(...args) &#123;</span><br><span class="line">    <span class="built_in">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="传参时可设置默认值"><a href="#传参时可设置默认值" class="headerlink" title="传参时可设置默认值"></a>传参时可设置默认值</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> handleThings(opts) &#123;</span><br><span class="line">    opts = opts || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> handleThings(opts = &#123;&#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单的键值对优先Map"><a href="#简单的键值对优先Map" class="headerlink" title="简单的键值对优先Map"></a>简单的键值对优先Map</h4><ul><li>如果只是简单的key: value结构，建议<strong>优先使用Map</strong>，因为Map提供方便的遍历机制。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map(arr);</span><br><span class="line">// 遍历key值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of map.keys()) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历value值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of map.values()) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历key和value值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of map.entries()) &#123;</span><br><span class="line">    console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更加简洁直观class语法"><a href="#更加简洁直观class语法" class="headerlink" title="更加简洁直观class语法"></a>更加简洁直观class语法</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> Queue(contents = []) &#123;</span><br><span class="line">    this._queue = [...contents];</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.pop = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    const value = this._queue[0];</span><br><span class="line">    this._queue.splice(0, 1);</span><br><span class="line">    <span class="built_in">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Queue &#123;</span><br><span class="line">    constructor(contents = []) &#123;</span><br><span class="line">        this._queue = [...contents];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        const value = this._queue[0];</span><br><span class="line">        this._queue.splice(0, 1);</span><br><span class="line">        <span class="built_in">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><h5 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h5><ul><li>使用<code>import</code>取代require，因为<strong>Module是Javascript模块的标准写法</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const moduleA = require(<span class="string">'moduleA'</span>);</span><br><span class="line">const func1 = moduleA.func1;</span><br><span class="line">const func2 = moduleA.func2;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import &#123; func1, func2 &#125; from <span class="string">'moduleA'</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="输出模块"><a href="#输出模块" class="headerlink" title="输出模块"></a>输出模块</h5><ul><li><p>使用<code>export</code>输出变量，拒绝<code>module.exports</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">class Breadcrumbs extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;nav /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Breadcrumbs;</span><br></pre></td></tr></table></figure></li><li><p>输出单个值，使用<code>export default</code>。</p></li><li>输出多个值，使用<code>export</code>。</li><li><code>export default</code>与普通的<code>export</code>不要同时使用。</li></ul><h5 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h5><ul><li><p>模块<strong>输出一个函数</strong>，首字母应该小写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getData</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default getData;</span><br></pre></td></tr></table></figure></li><li><p>模块<strong>输出一个对象</strong>，首字母应该大写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Person = &#123;</span><br><span class="line">    someCode: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Person;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;声明变量的新姿势&quot;&gt;&lt;a href=&quot;#声明变量的新姿势&quot; class=&quot;headerlink&quot; title=&quot;声明变量的新姿势&quot;&gt;&lt;/a&gt;声明变量的新姿势&lt;/h4&gt;&lt;h5 id=&quot;用let不用var&quot;&gt;&lt;a href=&quot;#用let不用var&quot; class=&quot;headerlink&quot; title=&quot;用let不用var&quot;&gt;&lt;/a&gt;用let不用var&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;ES6之前我们用&lt;code&gt;var&lt;/code&gt;声明一个变量，但是它有很多弊病：
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 错误 - Throw、Try 和 Catch</title>
    <link href="https://chongtianhong.github.io/2018/06/02/tryAndCatch/"/>
    <id>https://chongtianhong.github.io/2018/06/02/tryAndCatch/</id>
    <published>2018-06-02T08:15:39.000Z</published>
    <updated>2018-09-04T14:22:11.436Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>try</code>语句<strong>测试代码块的错误</strong>。</li><li><code>catch</code>语句<strong>处理错误</strong>。</li><li><code>throw</code>语句<strong>创建自定义错误</strong>。</li><li><code>finally</code>语句在code&gt;try和<code>catch</code>之后<strong>无论有无异常都会执行</strong>。<a id="more"></a></li></ul><h4 id="错误一定会发生"><a href="#错误一定会发生" class="headerlink" title="错误一定会发生"></a>错误一定会发生</h4><ul><li>当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误：<ul><li>可能是<strong>语法错误</strong>，通常是程序员造成的编码错误或错别字。</li><li>可能是<strong>拼写错误</strong>或<strong>语言中缺少的功能</strong>（可能由于浏览器差异）。</li><li>可能是<strong>由于来自服务器或用户的错误输出而导致的错误</strong>。</li><li>当然，也可能是由于许多其他<strong>不可预知的因素</strong>。</li></ul></li></ul><h4 id="JavaScript-抛出错误"><a href="#JavaScript-抛出错误" class="headerlink" title="JavaScript 抛出错误"></a>JavaScript 抛出错误</h4><ul><li>当错误发生时，<strong>JavaScript 引擎通常会停止</strong>，并生成一个错误消息。</li><li>描述这种情况的技术术语是：<strong>JavaScript 将抛出一个错误</strong>。</li></ul><h4 id="JavaScript-测试和捕捉"><a href="#JavaScript-测试和捕捉" class="headerlink" title="JavaScript 测试和捕捉"></a>JavaScript 测试和捕捉</h4><ul><li><strong>try</strong>语句允许我们定义在<strong>执行时进行错误测试</strong>的代码块。</li><li><strong>catch</strong>语句允许我们定义当<strong>try</strong>代码块<strong>发生错误时，所执行的代码块</strong>。</li><li>JavaScript 语句<strong>try</strong>和<strong>catch</strong>是<strong>成对出现</strong>的。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">  &#123;</span><br><span class="line">    //在这里运行代码</span><br><span class="line">  &#125;</span><br><span class="line">catch(err)</span><br><span class="line">  &#123;</span><br><span class="line">    //在这里处理错误</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>实例：在下面的例子中，我们故意在<strong>try</strong>块的代码中写了一个错字。该实例本应该提醒”欢迎光临！”，但弹出的是拼写错误信息。<strong>catch</strong>块会捕捉到<strong>try</strong>块中的错误，并执行代码来处理它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;try 语句块中的函数未定义：&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">"demo"</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">try &#123;</span><br><span class="line">    adddlert(<span class="string">"欢迎光临！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch(err) &#123;</span><br><span class="line">    document.getElementById(<span class="string">"demo"</span>).innerHTML = err.message;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Throw-语句"><a href="#Throw-语句" class="headerlink" title="Throw 语句"></a>Throw 语句</h4><ul><li><strong>throw</strong>语句允许我们<strong>创建自定义错误</strong>。正确的<strong>技术术语</strong>是：<strong>创建或抛出异常（exception）</strong>。</li><li>如果把<strong>throw</strong>与<strong>try</strong>和<strong>catch</strong>一起使用，那么我们能够控制程序流，并生成自定义的错误消息。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw exception</span><br></pre></td></tr></table></figure></li><li><p>异常可以是 JavaScript 字符串、数字、逻辑值或对象。</p></li><li><p>检测输入变量的值。如果值是错误的，会抛出一个异常（错误）。catch 会捕捉到这个错误，并显示一段自定义的错误消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>()&#123;</span><br><span class="line">                try&#123; </span><br><span class="line">                    var x=document.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line">                    <span class="keyword">if</span>(x==<span class="string">""</span>)    throw <span class="string">"值为空"</span>;</span><br><span class="line">                    <span class="keyword">if</span>(isNaN(x)) throw <span class="string">"不是数字"</span>;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;10)     throw <span class="string">"太大"</span>;</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;5)      throw <span class="string">"太小"</span>;</span><br><span class="line">                &#125; catch(err)&#123;</span><br><span class="line">                    var y=document.getElementById(<span class="string">"mess"</span>);</span><br><span class="line">                    y.innerHTML=<span class="string">"错误："</span> + err + <span class="string">"。"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h1&gt;我的第一个 JavaScript 程序&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;请输入 5 到 10 之间的数字：&lt;/p&gt;</span><br><span class="line">        &lt;input id=<span class="string">"demo"</span> <span class="built_in">type</span>=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;测试输入值&lt;/button&gt;</span><br><span class="line">        &lt;p id=<span class="string">"mess"</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：如果<code>getElementById</code>函数出错，上面的例子也会抛出一个错误。</p></li></ul><h4 id="Finally-语句"><a href="#Finally-语句" class="headerlink" title="Finally 语句"></a>Finally 语句</h4><ul><li><code>finally</code>语句在code&gt;try和<code>catch</code>之后<strong>无论有无异常都会执行</strong>。</li><li><strong>注意</strong>：<code>catch</code>和<code>finally</code>语句都是可选的，但<strong>在使用<code>try</code>语句时必须至少使用一个</strong>。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    tryCode - 尝试执行代码块</span><br><span class="line">&#125;</span><br><span class="line">catch(err) &#123;</span><br><span class="line">    catchCode - 捕获错误的代码块</span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">    finallyCode - 无论 try / catch 结果如何都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;请输入 5 到 10 之间的数:&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input id=<span class="string">"demo"</span> <span class="built_in">type</span>=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;检测输入&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p id=<span class="string">"message"</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">            var message, x;</span><br><span class="line">            message = document.getElementById(<span class="string">"message"</span>);</span><br><span class="line">            message.innerHTML = <span class="string">""</span>;</span><br><span class="line">            x = document.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line">            try &#123; </span><br><span class="line">                <span class="keyword">if</span>(x == <span class="string">""</span>)  throw <span class="string">"为空"</span>;</span><br><span class="line">                <span class="keyword">if</span>(isNaN(x)) throw <span class="string">"不是一个数字"</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &gt; 10)   throw <span class="string">"太大"</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; 5)    throw <span class="string">"太小"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            catch(err) &#123;</span><br><span class="line">                message.innerHTML = <span class="string">"输入的值 "</span> + err;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                document.getElementById(<span class="string">"demo"</span>).value = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;try&lt;/code&gt;语句&lt;strong&gt;测试代码块的错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;catch&lt;/code&gt;语句&lt;strong&gt;处理错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;throw&lt;/code&gt;语句&lt;strong&gt;创建自定义错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finally&lt;/code&gt;语句在code&amp;gt;try和&lt;code&gt;catch&lt;/code&gt;之后&lt;strong&gt;无论有无异常都会执行&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout中被遗忘的第三个参数</title>
    <link href="https://chongtianhong.github.io/2018/06/01/theThridParamOfSetTimeOut/"/>
    <id>https://chongtianhong.github.io/2018/06/01/theThridParamOfSetTimeOut/</id>
    <published>2018-06-01T10:11:44.000Z</published>
    <updated>2018-09-03T11:49:38.038Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最熟悉的地方，往往会忽略一些细节。就比如 setTimeout 函数，做前端开发的同学都会很熟悉这个函数，经常使用这个函数，但是知道这个函数还有第三个参数的小伙伴可能就不多了。<a id="more"></a></li><li><p>阮老师的es6的primise章节里有这样一段代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>((value) =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>仔细查看MDN中的定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var timeoutID = scope.setTimeout(<span class="keyword">function</span>[, delay, param1, param2, ...]);</span><br><span class="line">var timeoutID = scope.setTimeout(<span class="keyword">function</span>[, delay]);</span><br><span class="line">var timeoutID = scope.setTimeout(code[, delay]);</span><br></pre></td></tr></table></figure></li><li><p>定时器启动时候，第三个以后的参数是作为第一个<code>func()</code>的参数传进去。</p></li><li><p>另外一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// HTML content</span><br><span class="line">&lt;p&gt;Live Example&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"delayedAlert();"</span>&gt;Show an alert box after two seconds&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"clearAlert();"</span>&gt;Cancel alert before it happens&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">// JavaScript content</span><br><span class="line">var timeoutID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">delayedAlert</span></span>() &#123;</span><br><span class="line">    timeoutID = window.setTimeout(window.alert, 2000, <span class="string">'That was really slow!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">clearAlert</span></span>() &#123;</span><br><span class="line">    window.clearTimeout(timeoutID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：这种传参方式在<strong>IE9及更低的版本下</strong>是不起作用的，需要使用<code>polyfill</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;最熟悉的地方，往往会忽略一些细节。就比如 setTimeout 函数，做前端开发的同学都会很熟悉这个函数，经常使用这个函数，但是知道这个函数还有第三个参数的小伙伴可能就不多了。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式括号的作用</title>
    <link href="https://chongtianhong.github.io/2018/05/31/regExp2/"/>
    <id>https://chongtianhong.github.io/2018/05/31/regExp2/</id>
    <published>2018-05-31T07:32:32.000Z</published>
    <updated>2018-09-02T10:20:11.124Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>不管哪门语言中都有括号。<strong>正则表达式</strong>也是一门语言，而括号的存在使这门语言更为强大。</li><li>对<strong>括号的使用</strong>是否得心应手，是衡量对正则的掌握水平的一个侧面标准。<a id="more"></a></li><li><strong>正则表达式中的括号</strong>提供了<strong>分组</strong>，便于我们引用它。</li><li>引用某个分组，会有两种情形：在<strong>JavaScript里引用（使用相应API）</strong>，在<strong>正则表达式里引用</strong>。</li></ul><h4 id="分组和分支结构"><a href="#分组和分支结构" class="headerlink" title="分组和分支结构"></a>分组和分支结构</h4><ul><li>这二者是括号最直接的作用，也是最原始的功能。</li></ul><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><ul><li>我们知道<code>/a+/</code>匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用<code>/(ab)+/</code>。其中<strong>括号是提供分组功能</strong>，使量词<code>“+”</code>作用于<code>“ab”</code>这个整体，测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(ab)+/g;</span><br><span class="line">var string = <span class="string">"ababa abbb ababab"</span>;</span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"abab"</span>, <span class="string">"ab"</span>, <span class="string">"ababab"</span>]</span><br></pre></td></tr></table></figure></li></ul><h5 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h5><ul><li><p>在<strong>多选分支结构</strong><code>(p1|p2)</code>中，此处括号的作用也是不言而喻的，提供了<strong>子表达式的所有可能</strong>。比如，要匹配如下的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I love JavaScript</span><br><span class="line"></span><br><span class="line">I love Regular Expression</span><br></pre></td></tr></table></figure></li><li><p>可以使用正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^I love (JavaScript|Regular Expression)$/;</span><br><span class="line">var string1 = <span class="string">"I love JavaScript"</span>;</span><br><span class="line">var string2 = <span class="string">"I love Regular Expression"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">string1.match(regex) // [<span class="string">"I love JavaScript"</span>, <span class="string">"JavaScript"</span>, index: 0, input: <span class="string">"I love JavaScript"</span>]</span><br><span class="line">string2.match(regex) // [<span class="string">"I love Regular Expression"</span>, <span class="string">"Regular Expression"</span>, index: 0, input: <span class="string">"I love Regular Expression"</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果去掉正则中的括号，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^I love JavaScript|Regular Expression$/;</span><br><span class="line">var string1 = <span class="string">"I love JavaScript"</span>;</span><br><span class="line">var string2 = <span class="string">"I love Regular Expression"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">string1.match(regex) // [<span class="string">"I love JavaScript"</span>, index: 0, input: <span class="string">"I love JavaScript"</span>]</span><br><span class="line">string2.match(regex) // [<span class="string">"Regular Expression"</span>, index: 7, input: <span class="string">"I love Regular Expression"</span>]</span><br></pre></td></tr></table></figure></li><li><p>可以看到，匹配字符串是<code>“I love JavaScript”</code>和<code>“Regular Expression”</code>，当然这不是我们想要的。</p></li></ul><h4 id="引用分组"><a href="#引用分组" class="headerlink" title="引用分组"></a>引用分组</h4><ul><li>这是括号一个<strong>重要的作用</strong>，有了它，我们就可以进行<strong>数据提取</strong>，以及更强大的<strong>替换操作</strong>。而要使用它带来的好处，必须配合使用实现环境的API。</li><li><p>以日期为例。假设格式是<code>yyyy-mm-dd</code>的，我们可以先写一个简单的正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/;</span><br></pre></td></tr></table></figure></li><li><p>然后再修改成括号版的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br></pre></td></tr></table></figure></li><li><p>使用括号版的正则，能方便地实现<strong>数据的提取和替换</strong>功能。</p></li></ul><h5 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h5><ul><li><p>比如提取出年、月、日，可以这么做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">console.log( string.match(regex) ); </span><br><span class="line">// =&gt; [<span class="string">"2017-06-12"</span>, <span class="string">"2017"</span>, <span class="string">"06"</span>, <span class="string">"12"</span>, index: 0, input: <span class="string">"2017-06-12"</span>]</span><br></pre></td></tr></table></figure></li><li><p>match返回的一个数组，第一个元素是<strong>整体匹配结果</strong>，然后是<strong>各个分组（括号里）匹配的内容</strong>，然后是<strong>匹配下标(index)</strong>，最后是<strong>输入的文本(input)</strong>。</p></li><li><strong>注意</strong>：如果正则是否有修饰符<code>g</code>，match返回的数组格式是不一样的。</li><li><p>另外也可以使用正则对象的exec方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">console.log( regex.exec(string) ); </span><br><span class="line">// =&gt; [<span class="string">"2017-06-12"</span>, <span class="string">"2017"</span>, <span class="string">"06"</span>, <span class="string">"12"</span>, index: 0, input: <span class="string">"2017-06-12"</span>]</span><br></pre></td></tr></table></figure></li><li><p>同时，也可以使用构造函数的全局属性<code>$1</code>至<code>$9</code>来获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line"></span><br><span class="line">regex.test(string); // 正则操作即可，例如</span><br><span class="line">// regex.exec(string);</span><br><span class="line">// string.match(regex);</span><br><span class="line"></span><br><span class="line">console.log(RegExp.<span class="variable">$1</span>); // <span class="string">"2017"</span></span><br><span class="line">console.log(RegExp.<span class="variable">$2</span>); // <span class="string">"06"</span></span><br><span class="line">console.log(RegExp.<span class="variable">$3</span>); // <span class="string">"12"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul><li><p>比如，想把<code>yyyy-mm-dd</code>格式，替换成<code>mm/dd/yyyy</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="string">"<span class="variable">$2</span>/<span class="variable">$3</span>/<span class="variable">$1</span>"</span>);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li><li><p>其中replace中的<strong>第二个参数</strong>里用<code>$1</code>、<code>$2</code>、<code>$3</code>指代相应的分组。等价于如下的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> RegExp.<span class="variable">$2</span> + <span class="string">"/"</span> + RegExp.<span class="variable">$3</span> + <span class="string">"/"</span> + RegExp.<span class="variable">$1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li><li><p>也等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="keyword">function</span>(match, year, month, day) &#123;</span><br><span class="line"><span class="built_in">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><ul><li>除了使用<strong>相应API</strong>来引用分组，也可以在<strong>正则本身里引用分组</strong>。但<strong>只能引用之前出现的分组</strong>，即<strong>反向引用</strong>。</li><li><p>还是以日期为例。比如要写一个正则支持匹配如下三种格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-06-12</span><br><span class="line"></span><br><span class="line">2016/06/12</span><br><span class="line"></span><br><span class="line">2016.06.12</span><br></pre></td></tr></table></figure></li><li><p>最先可能想到的正则是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/;</span><br><span class="line">var string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line">var string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line">var string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string4) ); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>其中/和.需要转义。虽然匹配了要求的情况，但也匹配<code>“2016-06/12”</code>这样的数据。</p></li><li><p>如果<strong>要求分割符前后一致</strong>则需要<strong>使用反向引用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br><span class="line">var string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line">var string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line">var string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string4) ); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>注意正则表达式里面的<code>\1</code>，表示的引用之前的那个分组<code>(-|\/|.)</code>。不管它匹配到什么（比如<code>-</code>），<code>\1</code>都<strong>匹配</strong>那个<strong>同样的具体某个字符</strong>。</p></li><li>知道了<code>\1</code>的含义后，那么<code>\2</code>和<code>\3</code>的概念也就理解了，即分别指代<strong>第二个</strong>和<strong>第三个分组</strong>。</li></ul><h5 id="括号嵌套怎么办？"><a href="#括号嵌套怎么办？" class="headerlink" title="括号嵌套怎么办？"></a>括号嵌套怎么办？</h5><ul><li>以<strong>左括号（开括号）</strong>为准。比如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</span><br><span class="line">var string = <span class="string">"1231231233"</span>;</span><br><span class="line">console.log( regex.test(string) ); // <span class="literal">true</span></span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"1231231233"</span>, <span class="string">"123"</span>, <span class="string">"1"</span>, <span class="string">"23"</span>, <span class="string">"3"</span>, index: 0, input: <span class="string">"1231231233"</span>]</span><br><span class="line">console.log( RegExp.<span class="variable">$1</span> ); // 123</span><br><span class="line">console.log( RegExp.<span class="variable">$2</span> ); // 1</span><br><span class="line">console.log( RegExp.<span class="variable">$3</span> ); // 23</span><br><span class="line">console.log( RegExp.<span class="variable">$4</span> ); // 3</span><br></pre></td></tr></table></figure></li></ul><h5 id="10表示什么？"><a href="#10表示什么？" class="headerlink" title="\10表示什么？"></a>\10表示什么？</h5><ul><li>有可能会产生这样的疑问，即<code>\10</code>是表示第10个分组，还是<code>\1</code>和<code>0</code>呢？答案是<strong>前者</strong>，虽然一个正则里出现\10比较罕见。测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(<span class="comment">#) \10+/;</span></span><br><span class="line">var string = <span class="string">"123456789# ######"</span></span><br><span class="line">console.log( regex.test(string) ); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="引用不存在的分组会怎样？"><a href="#引用不存在的分组会怎样？" class="headerlink" title="引用不存在的分组会怎样？"></a>引用不存在的分组会怎样？</h5><ul><li>因为<strong>反向引用</strong>是<strong>引用前面的分组</strong>，但我们在正则里<strong>引用了不存在的分组时</strong>，此时正则<strong>不会报错</strong>，只是<strong>匹配反向引用的字符本身</strong>。例如<code>\2</code>，就匹配<code>“\2”</code>。注意<code>“\2”</code>表示<strong>对2进行了转义</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\1\2\3\4\5\6\7\8\9/;</span><br><span class="line">console.log( regex.test(<span class="string">"\1\2\3\4\5\6\7\8\9"</span>) ); </span><br><span class="line">console.log( <span class="string">"\1\2\3\4\5\6\7\8\9"</span>.split(<span class="string">""</span>) ); //  [<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"8"</span>, <span class="string">"9"</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h4><ul><li>之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是<strong>捕获型分组</strong>。</li><li><p>如果<strong>只想要括号最原始的功能</strong>，但<strong>不会引用它</strong>，即，既不在API里引用，也不在正则里反向引用。此时可以<strong>使用非捕获分组<code>(?:p)</code></strong>，例如本文第一个例子可以修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(?:ab)+/g;</span><br><span class="line">var string = <span class="string">"ababa abbb ababab"</span>;</span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"abab"</span>, <span class="string">"ab"</span>, <span class="string">"ababab"</span>]</span><br></pre></td></tr></table></figure></li><li><p>这样使用括号匹配到的数据，将不能在API里或正则里反向引用。</p></li></ul><h4 id="相关案例"><a href="#相关案例" class="headerlink" title="相关案例"></a>相关案例</h4><h5 id="字符串trim方法模拟"><a href="#字符串trim方法模拟" class="headerlink" title="字符串trim方法模拟"></a>字符串trim方法模拟</h5><ul><li><code>trim</code>方法是<strong>去掉字符串的开头和结尾的空白符</strong>。有两种思路去做。</li><li><p><strong>第一种</strong>，匹配到开头和结尾的空白符，然后替换成空字符。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trim(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/^\s+|\s+$/g, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(<span class="string">"  foobar   "</span>) ); // <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>第二种</strong>，匹配整个字符串，然后<strong>用引用来提取出相应的数据</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trim(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/^\s*(.*?)\s*$/g, <span class="string">"<span class="variable">$1</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(<span class="string">"  foobar   "</span>) ); // <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></li><li><p>这里使用了惰性匹配<code><em>?</em></code>，不然也会<em>*匹配最后一个空格之前的所有空格</em>。</p></li><li>第一种方法效率高。</li></ul><h5 id="将每个单词的首字母转换为大写"><a href="#将每个单词的首字母转换为大写" class="headerlink" title="将每个单词的首字母转换为大写"></a>将每个单词的首字母转换为大写</h5><ul><li>思路是<strong>找到每个单词的首字母</strong>，当然这里<strong>不使用非捕获匹配也是可以的</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> titleize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.toLowerCase().replace(/(?:^|\s)\w/g, <span class="keyword">function</span>(c) &#123;</span><br><span class="line"><span class="built_in">return</span> c.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( titleize(<span class="string">'my name is epeli'</span>) ); // <span class="string">"My Name Is Epeli"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="驼峰化"><a href="#驼峰化" class="headerlink" title="驼峰化"></a>驼峰化</h5><ul><li><p>比如对<code>‘-moz-transform’</code>进行驼峰化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> camelize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/[-_\s]+(.)?/g, <span class="keyword">function</span>(match, firstLetter) &#123;</span><br><span class="line"><span class="built_in">return</span> firstLetter ? firstLetter.toUpperCase() : <span class="string">''</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( camelize(<span class="string">'-moz-transform'</span>) ); // MozTransform</span><br></pre></td></tr></table></figure></li><li><p>其中<strong>分组<code>(.)</code>表示首字母</strong>，单词的界定，<strong>前面的字符</strong>可以是多个连字符、下划线以及空白符（中括号规定）。正则后面的<code>?</code>的目的，是为了应对str尾部的字符可能不是单词字符，比如str是<code>‘-moz-transform ‘</code>。</p></li></ul><h5 id="中划线化"><a href="#中划线化" class="headerlink" title="中划线化"></a>中划线化</h5><ul><li>驼峰化的逆过程，比如对<code>‘MozTransform’</code>进行中划线化：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dasherize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/([A-Z])/g, <span class="string">'-$1'</span>).replace(/[-_\s]+/g, <span class="string">'-'</span>).toLowerCase();</span><br><span class="line">    // 前一个replace结果：-Moz-Transform</span><br><span class="line">    // 后一个replace结果：-Moz-Transform</span><br><span class="line">    // 最后使用toLowerCase：-moz-transform</span><br><span class="line">&#125;</span><br><span class="line">console.log( dasherize(<span class="string">'MozTransform'</span>) ); // -moz-transform</span><br></pre></td></tr></table></figure></li></ul><h5 id="匹配成对标签"><a href="#匹配成对标签" class="headerlink" title="匹配成对标签"></a>匹配成对标签</h5><ul><li><p>要求匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;regular expression&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;laoyao <span class="built_in">bye</span> <span class="built_in">bye</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>不匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;wrong!&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>匹配一个开标签，可以使用正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;[^&gt;]+&gt;</span><br></pre></td></tr></table></figure></li><li><p>匹配一个闭标签，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;\/[^&gt;]+&gt;</span><br></pre></td></tr></table></figure></li><li><p>但是要求<strong>匹配成对标签</strong>，那就需要<strong>使用反向引用</strong>，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</span><br><span class="line">var string1 = <span class="string">"&lt;title&gt;regular expression&lt;/title&gt;"</span>;</span><br><span class="line">var string2 = <span class="string">"&lt;p&gt;laoyao bye bye&lt;/p&gt;"</span>;</span><br><span class="line">var string3 = <span class="string">"&lt;title&gt;wrong!&lt;/p&gt;"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>其中开标签增加括号版，使用括号的目的是为了后面<strong>使用反向引用</strong>，而提供分组。闭标签使用了反向引用。</p></li><li>另外，<code>[\d\D]</code>的意思是，这个字符是数字或者不是数字，因此，也就是<strong>匹配任意字符</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不管哪门语言中都有括号。&lt;strong&gt;正则表达式&lt;/strong&gt;也是一门语言，而括号的存在使这门语言更为强大。&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;括号的使用&lt;/strong&gt;是否得心应手，是衡量对正则的掌握水平的一个侧面标准。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="正则表达式" scheme="https://chongtianhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Express使用进阶：cookie-parser中间件实现深入剖析</title>
    <link href="https://chongtianhong.github.io/2018/05/30/cookieParse/"/>
    <id>https://chongtianhong.github.io/2018/05/30/cookieParse/</id>
    <published>2018-05-30T08:12:21.000Z</published>
    <updated>2018-09-01T11:56:04.082Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><code>cookie-parser</code>是Express的中间件，用来<strong>实现cookie的解析</strong>，是官方脚手架内置的中间件之一。</li><li>它的使用非常简单，但在使用过程中偶尔也会遇到问题。一般都是因为对<code>Express + cookie-parser</code>的<strong>签名、验证机制</strong>不了解导致的。</li><li>本文深入讲解<code>Express + cookie-parser</code>的<strong>签名和验证</strong>的实现机制，以及cookie签名是如何<strong>增强网站的安全性</strong>的。<a id="more"></a></li></ul><h4 id="cookie特点"><a href="#cookie特点" class="headerlink" title="cookie特点"></a>cookie特点</h4><ul><li>cookie 保存在<strong>浏览器</strong>本地；</li><li>正常设置的 cookie 是不加密的，用户可以自由看到；</li><li>用户可以删除 cookie，或者禁用它；</li><li>cookie 可以<strong>被篡改</strong>；</li><li>cookie 可以用于XSS攻击；</li><li>cookie <strong>存储量很小</strong>。</li></ul><h4 id="cookie的创建"><a href="#cookie的创建" class="headerlink" title="cookie的创建"></a>cookie的创建</h4><ul><li><p>Express直接提供了api，只需要在需要使用的地方调用如下api即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(name, value [, options]);</span><br><span class="line"></span><br><span class="line">// name: 类型为String</span><br><span class="line">// value: 类型为String和Object，如果是Object会在cookie.serialize()之前自动调用JSON.stringify对其进行处理</span><br><span class="line">// Option: 类型为对象，可使用的属性如下:</span><br><span class="line">domain：cookie在什么域名下有效，类型为String,。默认为网站域名</span><br><span class="line">expires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。</span><br><span class="line">httpOnly: 只能被web server访问，类型Boolean，默认<span class="literal">false</span>，设置为<span class="literal">true</span>时不允许客户端脚本访问，能有效的防止XSS攻击。</span><br><span class="line">maxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。</span><br><span class="line">path: cookie在什么路径下有效，默认为<span class="string">'/'</span>，类型为String</span><br><span class="line">secure：只能被HTTPS使用，类型Boolean，默认为<span class="literal">false</span></span><br><span class="line">signed：使用签名，类型Boolean，默认为<span class="literal">false</span>。`express会使用req.secret来完成签名，需要cookie-parser配合使用`</span><br></pre></td></tr></table></figure></li><li><p>Express就会将其填入<code>Response Header</code>中的<code>Set-Cookie</code>，达到<strong>在浏览器中设置cookie</strong>的作用。</p></li><li>用例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(<span class="string">'name'</span>, <span class="string">'koby'</span>, &#123; domain: <span class="string">'.example.com'</span>, path: <span class="string">'/admin'</span>, secure: <span class="literal">true</span> &#125;);</span><br><span class="line">//cookie的有效期为900000ms</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>, <span class="string">'1'</span>, &#123; expires: new Date(Date.now() + 900000), httpOnly: <span class="literal">true</span> &#125;);</span><br><span class="line">//cookie的有效期为900000ms</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>, <span class="string">'1'</span>, &#123; maxAge: 900000, httpOnly: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">//cookie的value为对象</span><br><span class="line">res.cookie(<span class="string">'cart'</span>, &#123; items: [1,2,3] &#125;);</span><br><span class="line">res.cookie(<span class="string">'cart'</span>, &#123; items: [1,2,3] &#125;, &#123; maxAge: 900000 &#125;);</span><br><span class="line"></span><br><span class="line">res.cookie(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; signed: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="cookie的删除"><a href="#cookie的删除" class="headerlink" title="cookie的删除"></a>cookie的删除</h4><ul><li>Express直接提供了api，只需要在需要使用的地方调用如下api即可：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.clearCookie(name [, options]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="入门例子：cookie设置与解析"><a href="#入门例子：cookie设置与解析" class="headerlink" title="入门例子：cookie设置与解析"></a>入门例子：cookie设置与解析</h4><ul><li>先从最简单的例子来看下<code>cookie-parser</code>的使用，这里采用默认配置：<br>1、<strong>cookie设置</strong>：使用Express的内置方法<code>res.cookie()</code>。<br>2、<strong>cookie解析</strong>：使用<code>cookie-parser</code>中间件。</li><li><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var cookieParser = require(<span class="string">'cookie-parser'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">    console.log(req.cookies.nick); // 第二次访问，输出hongxb</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;  </span><br><span class="line">    res.cookie(<span class="string">'nick'</span>, <span class="string">'hongxb'</span>);</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li><li><p>在当前场景下，<code>cookie-parser</code>中间件大致实现如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">  req.cookies = cookie.parse(req.headers.cookie);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="进阶例子：cookie签名与解析"><a href="#进阶例子：cookie签名与解析" class="headerlink" title="进阶例子：cookie签名与解析"></a>进阶例子：cookie签名与解析</h4><ul><li>出于安全的考虑，我们通常需要<strong>对cookie进行签名</strong>。</li><li>改写例子有几个注意点：<br>1、<code>cookieParser</code>初始化时，传入<code>secret</code>作为签名的<strong>密钥</strong>。<br>2、设置cookie时，将<code>signed</code>设置为<code>true</code>，表示<strong>对即将设置的cookie进行签名</strong>。<br>3、获取cookie时，可以通过<code>req.cookies</code>获取<strong>未签名的cookie</strong>，也可以通过<code>req.signedCookies</code>获取<strong>使用签名的cookie</strong>。<br>4、当然如果想拿到<strong>浏览器传过来的cookie原始数据</strong>，总是可以通过express中的<code>req.headers.cookie</code>获得：</li><li><p>例子改写如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var cookieParser = require(<span class="string">'cookie-parser'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// 初始化中间件，传入的第一个参数为singed secret</span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">    console.log(req.cookies.nick); // undefined</span><br><span class="line">    console.log(req.signedCookies.nick); // hongxb</span><br><span class="line">    console.log(req.headers.cookie); // nick=s%3Ahongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;  </span><br><span class="line">    // 传入第三个参数 &#123;signed: <span class="literal">true</span>&#125;，表示要对cookie进行摘要计算</span><br><span class="line">    res.cookie(<span class="string">'nick'</span>, <span class="string">'hongxb'</span>, &#123;signed: <span class="literal">true</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li><li><p>可以看到，签名前的cookie值为<code>chyingp</code>，签名后的cookie值为<code>s%3Ahongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</code>，decode后为<code>s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</code>。</p></li><li>下面就来分析下，cookie的签名、解析是如何实现的。</li></ul><h4 id="cookie签名、验证实现剖析"><a href="#cookie签名、验证实现剖析" class="headerlink" title="cookie签名、验证实现剖析"></a>cookie签名、验证实现剖析</h4><ul><li>Express的内置方法<code>res.cookie()</code>完成cookie值的签名，中间件<code>cookie-parser</code>（<code>req.signedCookies</code>）实现签名cookie的解析。两者<strong>共用同一个密钥</strong>。</li></ul><h5 id="cookie签名"><a href="#cookie签名" class="headerlink" title="cookie签名"></a>cookie签名</h5><ul><li>Express对<strong>cookie的设置（包括签名）</strong>，都是通过<code>res.cookie()</code>这个方法实现的。</li><li><p>精简后的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res.cookie = <span class="keyword">function</span> (name, value, options) &#123;  </span><br><span class="line">    var secret = this.req.secret; // cookie-parser初始化的时候传入的</span><br><span class="line">    var signed = opts.signed;</span><br><span class="line"></span><br><span class="line">    // 如果 options.signed 为<span class="literal">true</span>，则对cookie进行签名</span><br><span class="line">    <span class="keyword">if</span> (signed) &#123;</span><br><span class="line">        val = <span class="string">'s:'</span> + sign(val, secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.append(<span class="string">'Set-Cookie'</span>, cookie.serialize(name, String(val), opts));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sign</code>为<strong>签名函数</strong>。伪代码如下，其实就是<strong>把cookie的原始值，跟hmac后的值拼接起来</strong>。</p></li><li><p><strong>注意</strong>：签名后的cookie值，包含了原始值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sign (val, secret) &#123;</span><br><span class="line">    <span class="built_in">return</span> val + <span class="string">'.'</span> + hmac(val, secret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码中的<code>req.secret</code>是<code>cookie-parser</code>初始化的时候传入的。如下伪代码所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var cookieParser = <span class="keyword">function</span> (secret) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">        req.secret = secret;</span><br><span class="line">        // ...</span><br><span class="line">        next();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>));</span><br></pre></td></tr></table></figure></li></ul><h5 id="签名cookie解析"><a href="#签名cookie解析" class="headerlink" title="签名cookie解析"></a>签名cookie解析</h5><ul><li>“解析”签名cookie这个阶段，中间件主要做了两件事：<br>1、将签名cookie对应的<strong>原始值提取</strong>出来；<br>2、<strong>验证签名cookie是否合法</strong>。</li><li><p>实现代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// str：签名后的cookie，比如 <span class="string">"s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA"</span></span><br><span class="line">// secret：密钥，比如 <span class="string">"secret"</span></span><br><span class="line"><span class="keyword">function</span> signedCookie(str, secret) &#123;</span><br><span class="line"></span><br><span class="line">    // 检查是否 s: 开头，确保只对签过名的cookie进行解析</span><br><span class="line">    <span class="keyword">if</span> (str.substr(0, 2) !== <span class="string">'s:'</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 校验签名的值是否合法，如合法，返回<span class="literal">true</span>，否则，返回<span class="literal">false</span></span><br><span class="line">    var isValid = unsign(str.slice(2), secret);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断、提取cookie原始值比较简单。只是<code>unsign</code>方法名比较有迷惑性，该方法用于<strong>对签名进行合法校验</strong>。</p></li><li><code>unsign</code>方法主要做了以下三件事：<br>1、从传入的cookie值中，分别提取出原始值A1、签名值B1。<br>2、用同样的密钥对A1进行签名，得到A2。<br>3、根据A2、B1是否相等，判断签名是否合法。</li><li>大致代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> unsign(val, secret)&#123;</span><br><span class="line">    var A1 = val.slice(0, val.lastIndexOf(<span class="string">'.'</span>)),  // hongxb</span><br><span class="line">        B1 = val, // hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br><span class="line">        A2 = sign(A1, secret); // hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> B1 == A2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="cookie签名的作用"><a href="#cookie签名的作用" class="headerlink" title="cookie签名的作用"></a>cookie签名的作用</h4><ul><li>主要是出于安全考虑，<strong>防止cookie被篡改</strong>，增强安全性。</li><li>举个小例子来看下cookie签名是如何实现防篡改的。</li><li><p>基于前面的例子展开。假设网站通过<code>nick</code>这个cookie来<strong>区分当前登录的用户</strong>。在前面例子中，登录用户的cookie中，<code>nick</code>对应的值如下：(decode后的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br></pre></td></tr></table></figure></li><li><p>此时，有人试图修改这个cookie值，来达到伪造身份的目的。比如修改成<code>xiaoming</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:xiaoming.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br></pre></td></tr></table></figure></li><li><p>当网站收到请求，对签名cookie进行解析，发现签名验证不通过。由此可判断，cookie是伪造的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmac(<span class="string">"xiaoming"</span>, <span class="string">"secret"</span>) !== <span class="string">"2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA"</span></span><br></pre></td></tr></table></figure></li><li><p>cookie签名缺点：<br>1、cookie值依然能被看到。<br>2、读取签名过的cookie必须进行解签。<br>3、增加cookie大小，浪费空间。</p></li></ul><h4 id="签名就一定能够确保安全吗"><a href="#签名就一定能够确保安全吗" class="headerlink" title="签名就一定能够确保安全吗"></a>签名就一定能够确保安全吗</h4><ul><li>上个小节的例子，仅通过<code>nick</code>这个cookie的值来判断登录的是哪个用户，这是一个非常糟糕的设计。虽然<strong>在密钥未知的情况下，很难伪造签名cookie</strong>。但<strong>用户名相同的情况下，签名也是相同的</strong>。这种情况下，其实是很容易伪造的。</li><li>另外，开源组件的算法是公开的，因此密钥的安全性就成了关键，要<strong>确保密钥不泄露</strong>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>发送cookie：使用res.cookie直接设置cookie。</li><li>获取cookie时，可以通过<code>req.cookies</code>获取<strong>未签名的cookie</strong>，也可以通过<code>req.signedCookies</code>获取<strong>使用签名的cookie</strong>。</li><li>使用签名cookie可防止cookie被修改，通过在<strong>设置cookie的时候</strong>配置<code>signed</code>属性值为<code>true</code>。</li><li>配置<code>cookie-parser</code>中间件的时候需要传参，作为签名的密钥。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cookie-parser&lt;/code&gt;是Express的中间件，用来&lt;strong&gt;实现cookie的解析&lt;/strong&gt;，是官方脚手架内置的中间件之一。&lt;/li&gt;
&lt;li&gt;它的使用非常简单，但在使用过程中偶尔也会遇到问题。一般都是因为对&lt;code&gt;Express + cookie-parser&lt;/code&gt;的&lt;strong&gt;签名、验证机制&lt;/strong&gt;不了解导致的。&lt;/li&gt;
&lt;li&gt;本文深入讲解&lt;code&gt;Express + cookie-parser&lt;/code&gt;的&lt;strong&gt;签名和验证&lt;/strong&gt;的实现机制，以及cookie签名是如何&lt;strong&gt;增强网站的安全性&lt;/strong&gt;的。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://chongtianhong.github.io/tags/Express/"/>
    
      <category term="cookie-parser" scheme="https://chongtianhong.github.io/tags/cookie-parser/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化（CommonJs、AMD和CMD）</title>
    <link href="https://chongtianhong.github.io/2018/05/29/frontEndModule/"/>
    <id>https://chongtianhong.github.io/2018/05/29/frontEndModule/</id>
    <published>2018-05-29T12:27:50.000Z</published>
    <updated>2018-08-31T15:34:37.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>前端模块规范有三种，分别是<code>CommonJs</code>、<code>AMD</code>和<code>CMD</code>。</li><li><code>CommonJs</code>用在服务器端，<code>AMD</code>和<code>CMD</code>用在浏览器环境。</li><li><code>AMD</code>是<strong>RequireJS</strong>在推广过程中对模块定义的规范化产出。</li><li><code>CMD</code>是<strong>SeaJS</strong>在推广过程中对模块定义的规范化产出。<a id="more"></a></li><li><code>AMD</code>：提前执行（异步加载：依赖先执行）/ 延迟执行（RequireJS 从 2.0 开始，也改成可以延迟执行）。</li><li><code>CMD</code>：延迟执行（运行到需加载，根据顺序执行）。</li></ul><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h5 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h5><ul><li>模块就是实现特定功能的一组方法。</li><li><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m1</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m2</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，组成一个模块。使用的时候，直接调用就行了。</p></li><li>这种做法的<strong>缺点</strong>很明显：<strong>“污染”了全局变量</strong>，<strong>无法保证不与其他模块发生变量名冲突</strong>，而且<strong>模块成员之间看不出直接关系</strong>。</li></ul><h5 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h5><ul><li><p>为了解决上面的缺点，可以<strong>把模块写成一个对象</strong>，所有的<strong>模块成员都放到</strong>这个<strong>对象里面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var module1 = new Object(&#123;</span><br><span class="line"></span><br><span class="line">　　_count : 0,</span><br><span class="line"></span><br><span class="line">　　m1 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;,</span><br><span class="line"></span><br><span class="line">　　m2 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，都封装在module1对象里。使用的时候，就是<strong>调用这个对象的属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure></li><li><p>但是，这样的写法会<strong>暴露所有模块成员</strong>，<strong>内部状态可以被外部改写</strong>。比如，外部代码可以直接改变内部计数器的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1._count = 5;</span><br></pre></td></tr></table></figure></li></ul><h5 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h5><ul><li><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到<strong>不暴露私有成员</strong>的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    var _count = 0;</span><br><span class="line"></span><br><span class="line">    var m1 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var m2 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">    　　m1 : m1,</span><br><span class="line">    　　m2 : m2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>使用上面的写法，<strong>外部代码无法读取内部的</strong><code>_count</code><strong>变量</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.info(module1._count); //undefined</span><br></pre></td></tr></table></figure></li><li><p><code>module1</code>就是Javascript模块的基本写法。</p></li></ul><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ul><li><p><code>CommonJs</code>是<strong>服务器端模块</strong>的规范，由Node推广使用。由于服务端编程的复杂性，如果没有模块很难与操作系统及其他应用程序互动。使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">    <span class="built_in">return</span> add(val, 1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">var increment = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">var a = increment(1); //2</span><br></pre></td></tr></table></figure></li><li><p>根据CommonJS规范：</p><ul><li>一个单独的文件就是一个模块。<strong>每一个模块都是一个单独的作用域</strong>，也就是说，在该<strong>模块内部定义的变量，无法被其他模块读取</strong>，除非定义为<code>global</code>对象的属性。<br>-<strong> 输出模块变量</strong>的最好方法是<strong>使用<code>module.exports</code>对象</strong>。</li><li><strong>加载模块</strong>使用<code>require</code>方法，该方法读取一个文件并执行，返回文件内部的<code>module.exports</code>对象。</li></ul></li><li>仔细看上面的代码，可以发现<strong><code>require</code>是同步的</strong>。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。</li><li>然而，这在浏览器端就会有很大问题。因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，<strong>浏览器处于”假死”状态</strong>。因此，<strong>浏览器端的模块，不能采用”同步加载”（synchronous）</strong>，只能采用”异步加载”（asynchronous）。</li><li><strong>浏览器端</strong>，加载 JavaScript 最佳、最容易的方式是在 document 中插入<code>&lt;script&gt;</code>标签。但<strong>脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载</strong>。</li><li><strong>解决思路之一</strong>是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</li><li><p><strong>另一种解决思路</strong>是，用一套标准模板来封装模块定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  // The module code goes here</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这套模板代码为模块加载器提供了机会，使其能在<strong>模块代码执行之前</strong>，对模块代码进行<strong>静态分析</strong>，并<strong>动态生成依赖列表</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">            sum += args[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">    exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">        <span class="built_in">return</span> add(val, 1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var inc = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">    inc(1); // 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ul><li>AMD是<code>“Asynchronous Module Definition”</code>的缩写，意思就是”异步模块定义”。由于不是JavaScript原生支持，<strong>使用AMD规范进行页面开发需要用到对应的库函数</strong>，也就是<code>RequireJS</code>，实际上AMD 是<code>RequireJS</code>在推广过程中对模块定义的规范化的产出。</li><li>AMD采用<strong>异步方式</strong>加载模块，模块的加载不影响它后面语句的运行。所有<strong>依赖这个模块的语句，都定义在一个回调函数中</strong>，等到加载完成之后，这个回调函数才会运行。</li><li><code>RequireJS</code>主要解决两个问题：<ul><li><strong>多个JS文件可能有依赖关系</strong>，被依赖的文件需要早于依赖它的文件加载到浏览器；</li><li><strong>JS加载的时候浏览器会停止页面渲染</strong>，加载文件越多，页面失去响应时间越长。</li></ul></li><li><code>RequireJS</code>也采用<code>require()</code>语句加载模块，但是<strong>不同于CommonJS，它要求两个参数</strong>，语法：<code>require([module], callback)</code>:<ul><li>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；</li><li>第二个参数callback，则是加载成功之后的回调函数。</li></ul></li><li><p>将使用<strong>不适用于浏览器环境的CommonJS规范</strong>的代码改成<strong>符合AMD规范</strong>的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* CommonJS */</span><br><span class="line">var math = require(<span class="string">'math'</span>);</span><br><span class="line">math.add(2, 3);</span><br><span class="line"></span><br><span class="line">/* AMD */</span><br><span class="line">require([<span class="string">'math'</span>], <span class="keyword">function</span> (math) &#123;</span><br><span class="line">    math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>math.add()</code>与<code>math</code>模块加载不是同步的，浏览器不会发生假死。所以很显然，<strong>AMD比较适合浏览器环境</strong>。</p></li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><ul><li>CMD(Common Module Definition)即<strong>通用模块定义</strong>，CMD规范是国内发展出来的，就像AMD有个<code>RequireJS</code>，CMD有个浏览器的实现<code>SeaJS</code>，<code>SeaJS</code>要解决的问题和<code>RequireJS</code>一样，只不过在<strong>模块定义方式</strong>和<strong>模块加载（可以说运行、解析）时机</strong>上有所不同。</li><li><p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    // require是可以把其他模块导入进来的一个参数;</span><br><span class="line">    // exports是可以把模块内的一些属性和方法导出的;</span><br><span class="line">    // module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</span><br><span class="line"></span><br><span class="line">    // 模块代码</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>AMD是<strong>依赖关系前置</strong>，在定义模块的时候就要声明其依赖的模块；</p></li><li><p>CMD是<strong>按需加载依赖就近</strong>，只有在用到某个模块的时候再去require：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    var b = require(<span class="string">'./b'</span>) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">    // ... </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD 默认推荐的是</span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    b.doSomething()</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>seajs使用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义模块  myModule.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var $ = require(<span class="string">'jquery.js'</span>)</span><br><span class="line">    $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">    exports.data = 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="keyword">function</span>(my)&#123;</span><br><span class="line">    var star = my.data;</span><br><span class="line">    console.log(star);  // 1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/frontEndModule.png" alt="模块方案" style="border:none" width="300"></p><ul><li>AMD和CMD的区别：<ul><li>CMD 推崇<strong>依赖就近</strong>；AMD 推崇<strong>依赖前置</strong>；</li><li>CMD 是<strong>延迟执行</strong>；AMD 是<strong>提前执行</strong>；</li><li>CMD <strong>性能好</strong>，因为只有用户需要的时候才执行；AMD<strong>用户体验好</strong>，因为没有延迟，依赖模块提前执行了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前端模块规范有三种，分别是&lt;code&gt;CommonJs&lt;/code&gt;、&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CommonJs&lt;/code&gt;用在服务器端，&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;用在浏览器环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AMD&lt;/code&gt;是&lt;strong&gt;RequireJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMD&lt;/code&gt;是&lt;strong&gt;SeaJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="CommonJs" scheme="https://chongtianhong.github.io/tags/CommonJs/"/>
    
      <category term="AMD规范" scheme="https://chongtianhong.github.io/tags/AMD%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>SeaJS中use函数用法实例分析</title>
    <link href="https://chongtianhong.github.io/2018/05/28/SeaJS/"/>
    <id>https://chongtianhong.github.io/2018/05/28/SeaJS/</id>
    <published>2018-05-28T09:34:57.000Z</published>
    <updated>2018-08-30T13:31:19.807Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这篇文章主要介绍了<strong>SeaJS</strong>中<strong>use函数</strong>的用法，结合实例形式分析了<strong>use函数</strong>加载模块的使用方法与相关操作技巧。<a id="more"></a></li><li><p>有了<code>define</code>等<strong>模块定义规范</strong>的实现，我们可以开发出很多模块。但光有一堆模块不管用，我们还得让它们能跑起来。在 SeaJS 里，要<strong>启动模块系统</strong>很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>seajs.use</code>用来<strong>在页面中加载模块</strong>。通过<code>use</code>方法，可以在页面中加载任意模块。</p></li><li><p>语法：<code>seajs.use seajs.use(id, callback?)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 加载模块 main，并在加载完成时，执行指定回调</span><br><span class="line">seajs.use(<span class="string">'./main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>use</code>方法还可以<strong>一次加载多个模块</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 并发加载模块 a 和模块 b，并在都加载完成时，执行指定回调</span><br><span class="line">seajs.use([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123;</span><br><span class="line">    a.init();</span><br><span class="line">    b.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>callback</code>参数可选</strong>。当<strong>只加载一个模块，且不需要<code>callback</code>时</strong>，可以用<code>data-main</code>属性来简化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-main=<span class="string">"./main"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>上面的代码等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>SeaJS</strong>还提供<code>data-config</code>来<strong>加载配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-config=<span class="string">"path/to/config"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>data-config</code>等价：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">    preload: [<span class="string">'path/to/config'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>路径解析规则</strong>与<code>seajs.use</code>一致。</p></li><li><p>再看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/js/lib/sea.js"</span> data-config=<span class="string">"/js/config.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">seajs.use(<span class="string">'/js/main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.banner_focus(<span class="string">'#focus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>main</code>为<strong>模块名</strong>，<code>main.method</code>为<strong>模块定义的函数</strong>，<strong>可以传递参数</strong>过去。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;这篇文章主要介绍了&lt;strong&gt;SeaJS&lt;/strong&gt;中&lt;strong&gt;use函数&lt;/strong&gt;的用法，结合实例形式分析了&lt;strong&gt;use函数&lt;/strong&gt;加载模块的使用方法与相关操作技巧。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="SeaJS" scheme="https://chongtianhong.github.io/tags/SeaJS/"/>
    
  </entry>
  
  <entry>
    <title>Node.js使用MySQL数据库时对RowDataPacket对象的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/27/RowDataPacket/"/>
    <id>https://chongtianhong.github.io/2018/05/27/RowDataPacket/</id>
    <published>2018-05-27T03:30:12.000Z</published>
    <updated>2018-08-29T13:57:00.970Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>使用Node.js连接数据库查询表后</strong>，拿到的<strong>数据是一个数组</strong>，数组里面是<strong>JSON格式的数据</strong>，但是每个JSON前面都有一个<strong>RowDataPacket</strong>，这就导致<strong>前端获取到这些数据</strong>后不得不<strong>进行一些格式处理</strong>。<a id="more"></a></li><li><p>未处理前是这个样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">  RowDataPacket &#123;</span><br><span class="line">    contractname: <span class="string">'datatime'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdfsd'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: null,</span><br><span class="line">    uploaddate: <span class="string">'2018-07-16 16:36:08'</span>,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  RowDataPacket &#123;</span><br><span class="line">    contractname: <span class="string">'sd'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdf'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: <span class="string">''</span>,</span><br><span class="line">    uploaddate: null,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>我们可以在拿到数据后，进行一个<strong>JSON的格式化处理</strong>，即利用<code>JSON.stringify()</code>把对象转为对象字符串，可<strong>去掉RowDataPacket</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataString = JSON.stringify(results);</span><br><span class="line">var data = JSON.parse(dataString);</span><br></pre></td></tr></table></figure></li><li><p>其中<code>results</code>就是<strong>从数据库拿到的数据</strong>，通过这样的格式化后，我们得到最终的数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">  &#123; </span><br><span class="line">    contractname: <span class="string">'datatime'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdfsd'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: null,</span><br><span class="line">    uploaddate: <span class="string">'2018-07-16 16:36:08'</span>,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; </span><br><span class="line">    contractname: <span class="string">'sd'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdf'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: <span class="string">''</span>,</span><br><span class="line">    uploaddate: null,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用Node.js连接数据库查询表后&lt;/strong&gt;，拿到的&lt;strong&gt;数据是一个数组&lt;/strong&gt;，数组里面是&lt;strong&gt;JSON格式的数据&lt;/strong&gt;，但是每个JSON前面都有一个&lt;strong&gt;RowDataPacket&lt;/strong&gt;，这就导致&lt;strong&gt;前端获取到这些数据&lt;/strong&gt;后不得不&lt;strong&gt;进行一些格式处理&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="MySQL" scheme="https://chongtianhong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题整理二（JS部分）</title>
    <link href="https://chongtianhong.github.io/2018/05/26/interviewMap2/"/>
    <id>https://chongtianhong.github.io/2018/05/26/interviewMap2/</id>
    <published>2018-05-26T11:35:34.000Z</published>
    <updated>2018-09-03T09:51:51.707Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS-Part"><a href="#JS-Part" class="headerlink" title="JS Part"></a>JS Part</h4><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><ul><li>每个对象都有<code>__proto__</code>属性，指向了<strong>创建该对象的构造函数的原型</strong>。其实这个属性指向了<code>[[prototype]]</code>，但是<strong><code>[[prototype]]</code>是内部属性</strong>，我们并<strong>不能访问到</strong>，所以使用<code>__proto__</code>来访问。<a id="more"></a></li><li><strong>对象</strong>可以<strong>通过<code>__proto__</code>来寻找不属于该对象的属性</strong>，<code>__proto__</code><strong>将对象连接起来</strong>组成了<strong>原型链</strong>。</li></ul><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><ul><li><strong>new操作符创建对象</strong>可以分为四个步骤：<br>1、创建一个空对象，这个对象的类型是<code>object</code>；<br>2、将<strong>所创建的实例对象</strong>的<code>__proto__</code>属性值设成<strong>构造函数</strong>的<code>prototype</code>属性值（关系：<code>instance.constructor.prototype = instance.__proto__</code>）；<br>3、执行<strong>构造函数</strong>中的代码，构造函数中的this指向新创建的对象；<br>4、返回该对象（如果构造器函数有返回值，则以该对象作为返回值。若没有return或return了基本类型，则将上述的新对象作为返回值）。</li><li>对于实例对象来说，都是通过<code>new</code>产生的，无论是<strong>使用构造函数创建对象</strong><code>function Foo()</code>还是<strong>使用字面量的方式创建对象</strong><code>let a = { b : 1 }</code>。</li><li><p>对于<strong>创建一个对象</strong>来说，<strong>更推荐使用字面量的方式创建对象</strong>（无论性能上还是可读性）。因为<strong>使用<code>new Object()</code>的方式创建对象</strong>需要<strong>通过作用域链一层层找到 Object</strong>，但是如果使用字面量的方式就没这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;&#125;</span><br><span class="line">// <span class="keyword">function</span> 就是个语法糖</span><br><span class="line">// 内部等同于 new Function()</span><br><span class="line"><span class="built_in">let</span> a = &#123; b: 1 &#125;</span><br><span class="line">// 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure></li><li><p>对于<code>new</code>来说，还需要<strong>注意运算符优先级</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Foo.getName();   // -&gt; 1</span><br><span class="line">new Foo().getName(); // -&gt; 2</span><br></pre></td></tr></table></figure></li><li><p><code>new Func()</code>的优先级大于<code>new Func</code>，所以对于上述代码来说可以这样划分执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new (Foo.getName());   </span><br><span class="line">(new Foo()).getName();</span><br></pre></td></tr></table></figure></li><li><p>对于第一个函数来说，先执行了<code>Foo.getName()</code>，所以结果为<code>1</code>；</p></li><li>对于第二个函数来说，先执行<code>new Foo()</code>产生了一个实例，然后通过原型链找到了<code>Foo</code>上的<code>getName</code>函数，所以结果为<code>2</code>。</li></ul><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><ul><li><code>instanceof</code>可以正确的判断对象的类型，因为内部机制是通过<strong>判断对象的原型链中是否能找到构造函数的<code>prototype</code></strong>。</li><li>试着实现一下<code>instanceof</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> instanceOf(left, right) &#123;</span><br><span class="line">    // 获得构造函数的原型</span><br><span class="line">    <span class="built_in">let</span> prototype = right.prototype</span><br><span class="line">    // 判断对象的类型是否等于构造函数的原型</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === null)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        // 获得实例对象的原型</span><br><span class="line">        left = left.__proto__</span><br><span class="line">    <span class="keyword">if</span> (prototype === left)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h5><ul><li>当执行 JS 代码时，会产生三种执行上下文：<ul><li>全局执行上下文；</li><li>函数执行上下文；</li><li>eval执行上下文。</li></ul></li><li>每个执行上下文中都有三个重要的属性：<ul><li><strong>变量对象（VO）</strong>，包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问；</li><li><strong>作用域链</strong>，JS 采用词法作用域，也就是说<strong>变量的作用域是在定义时就决定了</strong>；</li><li><strong>this</strong>。</li></ul></li><li><p>接下来看一个老生常谈的例子，<code>var</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() // call b</span><br><span class="line">console.log(a) // undefined</span><br><span class="line"></span><br><span class="line">var a = <span class="string">'Hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'call b'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这是因为函数和变量提升的原因。在生成执行上下文时，会有两个阶段。</p><ul><li>第一个阶段是创建<strong>变量对象（VO）</strong>的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，<strong>函数</strong>的话会<strong>将整个函数存入内存中</strong>，<strong>变量只声明并且赋值为 undefined</strong>；</li><li>所以在第二个阶段，也就是<strong>代码执行阶段</strong>，我们可以<strong>直接提前使用函数和变量</strong>。</li></ul></li><li><p>在提升的过程中，相同的函数会覆盖上一个函数，并且<strong>函数优先于变量提升</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() // call b second</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'call b fist'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">console.log(<span class="string">'call b second'</span>)</span><br><span class="line">&#125;</span><br><span class="line">var b = <span class="string">'Hello world'</span></span><br></pre></td></tr></table></figure></li><li><p><code>var</code>会产生很多错误，所以在 ES6中引入了<code>let</code>。<strong><code>let</code>不能在声明前使用</strong>，但是这并不是常说的 <code>let</code>不会提升，<strong><code>let</code>提升了声明但没有赋值</strong>，因为<strong>临时死区导致了并不能在声明前使用</strong>。</p></li><li><p>对于<strong>非匿名的立即执行函数</strong>需要注意以下一点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1</span><br><span class="line">(<span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    foo = 10</span><br><span class="line">    console.log(foo)</span><br><span class="line">&#125;()) // -&gt; ƒ <span class="function"><span class="title">foo</span></span>() &#123; foo = 10 ; console.log(foo) &#125;</span><br></pre></td></tr></table></figure></li><li><p>因为<strong>当 JS 解释器在遇到非匿名的立即执行函数时</strong>，会创建一个<strong>辅助的特定对象</strong>，然后<strong>将函数名称作为这个对象的属性</strong>，因此<strong>函数内部才可以访问到 foo</strong>，但是<strong>这个值又是只读的</strong>，所以<strong>对它的赋值并不生效</strong>，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p></li></ul><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><ul><li><p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> a = 1</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">B</span></span>() &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题：为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为函数 A 中的变量这时候是存储在堆上的。</span><br><span class="line">现在的 JS 引擎可以通过逃逸分析</span><br><span class="line">辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</span><br></pre></td></tr></table></figure></li><li><p>经典面试题，循环中使用闭包解决 var 定义函数的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">setTimeout( <span class="keyword">function</span> <span class="function"><span class="title">timer</span></span>() &#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;, i * 1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先因为<code>setTimeout</code>是个<strong>异步函数</strong>，所有会<strong>先把循环全部执行完毕</strong>，这时候 i 就是 6 了，所以会输出一堆 6（输出6的间隔是1秒）。</p></li><li><p>解决办法有三种，<strong>第一种使用闭包</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(j)&#123;</span><br><span class="line">        setTimeout( <span class="keyword">function</span> <span class="function"><span class="title">timer</span></span>() &#123;</span><br><span class="line">            console.log( j );</span><br><span class="line">        &#125;, j*1000 );</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种就是使用<code>setTimeout</code>的第三个参数，作为第一个<code>func()</code>的参数传进去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">setTimeout( <span class="keyword">function</span> timer(j) &#123;</span><br><span class="line">console.log( j );</span><br><span class="line">&#125;, i*1000, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三种就是使用<code>let</code>定义<code>i</code>了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="built_in">let</span> i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">setTimeout( <span class="keyword">function</span> <span class="function"><span class="title">timer</span></span>() &#123;</span><br><span class="line">console.log( i );</span><br><span class="line">&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因为对于<code>let</code>来说，它会创建一个块级作用域。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JS-Part&quot;&gt;&lt;a href=&quot;#JS-Part&quot; class=&quot;headerlink&quot; title=&quot;JS Part&quot;&gt;&lt;/a&gt;JS Part&lt;/h4&gt;&lt;h5 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;每个对象都有&lt;code&gt;__proto__&lt;/code&gt;属性，指向了&lt;strong&gt;创建该对象的构造函数的原型&lt;/strong&gt;。其实这个属性指向了&lt;code&gt;[[prototype]]&lt;/code&gt;，但是&lt;strong&gt;&lt;code&gt;[[prototype]]&lt;/code&gt;是内部属性&lt;/strong&gt;，我们并&lt;strong&gt;不能访问到&lt;/strong&gt;，所以使用&lt;code&gt;__proto__&lt;/code&gt;来访问。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题整理一（JS部分）</title>
    <link href="https://chongtianhong.github.io/2018/05/25/interviewMap1/"/>
    <id>https://chongtianhong.github.io/2018/05/25/interviewMap1/</id>
    <published>2018-05-25T05:42:04.000Z</published>
    <updated>2018-08-30T13:31:02.087Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS-Part"><a href="#JS-Part" class="headerlink" title="JS Part"></a>JS Part</h4><h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><ul><li>JS 中分为<strong>七种内置类型</strong>，七种内置类型<strong>又分为两大类型</strong>：<strong>基本类型</strong>和<strong>对象（Object）</strong>。</li><li>基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</li><li>其中 <strong>JS 的数字类型是浮点类型的，没有整型</strong>。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。</li><li><code>NaN</code> 也属于 number 类型，并且<strong><code>NaN</code> 不等于自身</strong>。</li><li><p>对于<strong>基本类型</strong>来说，如果<strong>使用字面量的方式</strong>，那么<strong>这个变量只是个字面量</strong>，只有<strong>在必要的时候才会转换为对应的类型</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 111 // 这只是字面量，不是 number 类型</span><br><span class="line">a.toString() // 使用时候才会转换为对象类型</span><br></pre></td></tr></table></figure></li><li><p>对<strong>象（Object）</strong>是<strong>引用类型</strong>，在使用过程中会遇到<strong>浅拷贝</strong>和<strong>深拷贝</strong>的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123; name: <span class="string">'FE'</span> &#125;</span><br><span class="line"><span class="built_in">let</span> b = a</span><br><span class="line">b.name = <span class="string">'EF'</span></span><br><span class="line">console.log(a.name) // EF</span><br></pre></td></tr></table></figure></li></ul><h5 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h5><ul><li><p><code>typeof</code>对于<strong>基本类型</strong>，<strong>除了<code>null</code></strong>都可以显示正确的类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // <span class="string">'number'</span></span><br><span class="line">typeof <span class="string">'1'</span> // <span class="string">'string'</span></span><br><span class="line">typeof undefined // <span class="string">'undefined'</span></span><br><span class="line">typeof <span class="literal">true</span> // <span class="string">'boolean'</span></span><br><span class="line">typeof Symbol() // <span class="string">'symbol'</span></span><br><span class="line">typeof b // b 没有声明，但是还会显示 undefined</span><br></pre></td></tr></table></figure></li><li><p><code>typeof</code>对于<strong>对象</strong>，<strong>除了函数</strong>都会显示<code>object</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] // <span class="string">'object'</span></span><br><span class="line">typeof &#123;&#125; // <span class="string">'object'</span></span><br><span class="line">typeof console.log // <span class="string">'function'</span></span><br></pre></td></tr></table></figure></li><li><p>对于<code>null</code>来说，虽然它是<strong>基本类型</strong>，但是会<strong>显示 <code>object</code></strong>，这是一个存在很久了的 Bug：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof null // <span class="string">'object'</span></span><br><span class="line">/* 原因：</span><br><span class="line">因为在 JS 的最初版本中，使用的是 32 位系统，</span><br><span class="line">为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，</span><br><span class="line">然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class="line">虽然现在的内部类型判断代码已经改变了，</span><br><span class="line">但是对于这个 Bug 却是一直流传下来。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>如果我们想获得一个变量的正确类型，可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似<code>[object Type]</code>的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">type</span> = Object.prototype.toString;</span><br><span class="line">console.log(type.call(<span class="string">''</span>));//object String</span><br><span class="line">console.log(type.call([]));//object Array</span><br><span class="line">console.log(type.call(&#123;&#125;));//object Object</span><br><span class="line">console.log(type.call(<span class="literal">false</span>));//object Boolean</span><br><span class="line">console.log(type.call(null));//object Null</span><br><span class="line">console.log(type.call(undefined));//object Undefined</span><br><span class="line">console.log(type.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;));//object Function</span><br></pre></td></tr></table></figure></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><h5 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h5><ul><li>在条件判断时，除了<code>undefined</code>，<code>null</code>，<code>false</code>，<code>NaN</code>，<code>‘’</code>，<code>0</code>，<code>-0</code>，<strong>其他所有值都转为<code>true</code>，包括所有对象</strong>。</li></ul><h5 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h5><ul><li><p><strong>对象在转换基本类型</strong>时，首先会<strong>调用<code>valueOf</code></strong>，然后<strong>调用<code>toString</code></strong>。并且这两个方法是<strong>可以重写</strong>的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">    <span class="function"><span class="title">valueOf</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当然也<strong>可以重写<code>Symbol.toPrimitive</code></strong>，该方法<strong>在转基本类型时调用优先级最高</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'1'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    <span class="built_in">return</span> 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 + a // =&gt; 3</span><br><span class="line"><span class="string">'1'</span> + a // =&gt; <span class="string">'12'</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h5><ul><li>只有当<strong>加法运算</strong>时，其中<strong>一方是字符串类型</strong>，就会<strong>把另一个也转为字符串类型</strong>。</li><li>并且<strong>加法运算会触发三种类型转换</strong>：将值转换为原始值，转换为数字，转换为字符串。</li><li><p><strong>其他运算</strong>只要其中一方是数字，那么另一方就转为数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 + <span class="string">'1'</span> // <span class="string">'11'</span></span><br><span class="line">2 * <span class="string">'2'</span> // 4</span><br><span class="line">[1, 2] + [2, 1] // <span class="string">'1,22,1'</span></span><br><span class="line">// [1, 2].toString() -&gt; <span class="string">'1,2'</span></span><br><span class="line">// [2, 1].toString() -&gt; <span class="string">'2,1'</span></span><br><span class="line">// <span class="string">'1,2'</span> + <span class="string">'2,1'</span> = <span class="string">'1,22,1'</span></span><br></pre></td></tr></table></figure></li><li><p>对于加号需要注意这个表达式 ‘a’ + + ‘b’，<strong>一元加操作符</strong>可以<strong>实现与<code>Number</code>相同的作用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> // -&gt; <span class="string">"aNaN"</span></span><br><span class="line">// 因为 + <span class="string">'b'</span> -&gt; NaN</span><br></pre></td></tr></table></figure></li></ul><h5 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a>== 操作符</h5><ul><li><p>比较运算<code>x==y</code>，其中<code>x</code>和<code>y</code>是值，比较运算产生<code>true</code>或<code>false</code>。这样的比较按如下方式进行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 若Type(x)与Type(y)相同，则</span><br><span class="line">    a. 若Type(x)为Undefined，返回<span class="literal">true</span>。</span><br><span class="line">    b. 若Type(x)为Null，返回<span class="literal">true</span>。</span><br><span class="line">    c. 若Type(x)为Number，则</span><br><span class="line">        i. 若x为NaN，返回<span class="literal">false</span>。</span><br><span class="line">       ii. 若y为NaN，返回<span class="literal">false</span>。</span><br><span class="line">      iii. 若x与为为相同数值，返回<span class="literal">true</span>。</span><br><span class="line">       iv. 若x为+0且y为-0，返回<span class="literal">true</span>。</span><br><span class="line">        v. 若x为-0且y为+0，返回<span class="literal">true</span>。</span><br><span class="line">       vi. 返回<span class="literal">false</span>。</span><br><span class="line">    d. 若Type(x)为String，则当x和y为完全相同的字符串序列（长度相等且相同字符在相同位置）时返回ture，否则返回<span class="literal">false</span>。</span><br><span class="line">    e. 若Type(x)为Boolean，当x和y同为<span class="literal">true</span>或者同为<span class="literal">false</span>时返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">    f. 当x和y引用同一对象时返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">2. 若x为null且y为undefined，返回<span class="literal">true</span>。</span><br><span class="line">3. 若x为undefined且y为null，返回ture。</span><br><span class="line">4. 若Type(x)为Number且Type(y)为String，返回x==Number(y)的结果。</span><br><span class="line">5. 若Type(x)为String且Type(y)为Number，返回Number(x)==y的结果。</span><br><span class="line">6. 若Type(x)为Boolean，返回比较Number(x)==y的结果。</span><br><span class="line">7. 若Type(y)为Boolean，返回比较X==Number(y)的结果。</span><br><span class="line">8. 若Type(x)为String或Number，且Type(y)为Object，返回比较x==ToPrimitive(y)的结果。</span><br><span class="line">9. 若Type(x)为Object，且Type(y)为String或Number，返回比较ToPrimitive(x)==y的结果。</span><br><span class="line">10.其余情况返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure></li><li><p>上面提到的<code>toPrimitive</code>就是<strong>对象转基本类型</strong>。</p></li><li>解析一道题目<code>[] == ![] // -&gt; true</code>，下面是这个表达式为何为 true 的步骤：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// [] 转成 <span class="literal">true</span>，然后取反变成 <span class="literal">false</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line">// 根据第 8 条得出</span><br><span class="line">[] == ToNumber(<span class="literal">false</span>)</span><br><span class="line">[] == 0</span><br><span class="line">// 根据第 10 条得出</span><br><span class="line">ToPrimitive([]) == 0</span><br><span class="line">// [].toString() -&gt; <span class="string">''</span></span><br><span class="line"><span class="string">''</span> == 0</span><br><span class="line">// 根据第 6 条得出</span><br><span class="line">0 == 0 // -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><ul><li>如果是<strong>对象</strong>，就<strong>通过<code>toPrimitive<code>将对象转换为基本类型</code></code></strong>。</li><li>如果是<strong>字符串</strong>，就<strong>通过<code>unicode<code>字符索引</code></code></strong>来比较。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JS-Part&quot;&gt;&lt;a href=&quot;#JS-Part&quot; class=&quot;headerlink&quot; title=&quot;JS Part&quot;&gt;&lt;/a&gt;JS Part&lt;/h4&gt;&lt;h5 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的 NaN 与 isNaN</title>
    <link href="https://chongtianhong.github.io/2018/05/24/NaN/"/>
    <id>https://chongtianhong.github.io/2018/05/24/NaN/</id>
    <published>2018-05-24T05:53:29.000Z</published>
    <updated>2018-08-27T06:22:30.911Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><ul><li><code>NaN</code> 即 <strong>Not a Number</strong>，不是一个数字。 在 JavaScript 中，<strong>整数和浮点数都统称为 <code>Number</code> 类型</strong>。</li><li><p>除此之外，<code>Number</code> 类型类型还有一个很特殊的值，即 <strong><code>NaN</code></strong> 。它<strong>是 <code>Number</code> 对象上的一个静态属性，可以通过 Number.NaN 来访问</strong>：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在 ECMAScript v1 和其后的版本中，还可以用<strong>预定义的全局属性 <code>NaN</code> 代替 <code>Number.NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在以下两种场景中，可能会产生 NaN 值：</p></li></ul><blockquote>表达式计算</blockquote><ul><li><p>一个表达式中如果有<strong>减号 (-)</strong>、<strong>乘号 (*)</strong>或 <strong>除号 (/) </strong>等运算符时，JS 引擎在计算之前，会试图<strong>将表达式的每个分项转化为 <code>Number</code> 类型（使用 <code>Number(x)</code> 做转换）</strong>。如果<strong>转换失败，表达式将返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100 - <span class="string">'2a'</span> ;    // NaN</span><br><span class="line"><span class="string">'100'</span> / <span class="string">'20a'</span>;  // NaN</span><br><span class="line"><span class="string">'20a'</span> * 5 ;     // NaN</span><br><span class="line">undefined - 1;  // NaN, Number(undefined) == NaN</span><br><span class="line">[] * 20 ;       // 0, Number([]) == 0</span><br><span class="line">null - 5;       // -5, Number(null) == 0</span><br></pre></td></tr></table></figure></li><li><p>而<strong>加号 (+)</strong>不会将其两边的变量转化为 Number 类型，这是因为JS表达式的执行顺序是按照运算符的优先级从左到右依次进行的：</p><ul><li><strong>如果加号 (+) 两边的变量都是 Number 类型时，才会做数字相加运算</strong>;</li><li>如果<strong>其中有一个变量是字符串</strong>，则会<strong>将两边都作为字符串相加</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 + 4 + <span class="string">'6'</span> = <span class="string">'96'</span>;</span><br><span class="line">1 + <span class="string">'2'</span> + 3 =  <span class="string">'123'</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>类型转换</blockquote><ul><li><p>直接使用<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code><strong>将一个非数字的值转化为数字</strong>时，<strong>表达式返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span> - 3   // NaN</span><br><span class="line">parseInt(<span class="string">'abc'</span>)  // NaN</span><br><span class="line">parseFloat(<span class="string">'abc'</span>) // NaN</span><br><span class="line">Number(<span class="string">'abc'</span>)    // NaN</span><br></pre></td></tr></table></figure></li><li><p>对于<strong>数字+字符</strong>的值，其转化结果会有所不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">'123abc'</span>); // NaN</span><br><span class="line">parseInt(<span class="string">'123abc'</span>); // 123</span><br><span class="line">parseInt(<span class="string">'123abc45'</span>); // 123</span><br><span class="line">parseFloat(<span class="string">'123.45abc'</span>);// 123.45</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Number</code>转换的是整个值</strong>，而不是部分值；<strong><code>parseInt</code>和 <code>parseFloat</code>只转化第一个无效字符之前的字符串</strong>。</p></li><li><p>另外，<strong>一元加操作符</strong>也可以<strong>实现与<code>Number</code>相同的作用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">'12abc'</span>; // NaN</span><br><span class="line">+ <span class="string">'123'</span>; // 123</span><br><span class="line">+ <span class="string">'123.78'</span>; // 123.78</span><br><span class="line">+ <span class="string">'abc'</span>; // NaN</span><br></pre></td></tr></table></figure></li><li><p>因此，<strong>当一个字符串不能被<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code>成功转换时</strong>，就<strong>返回 <code>NaN</code></strong>，表示<strong>该字符串无法被识别为数字类型</strong>，这是一个<strong>异常状态</strong>，并<strong>不是一个确切的值</strong>。</p></li></ul><h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h4><ul><li><code>isNaN()</code>是一个全局方法，它的作用是<strong>检查一个值是否能被<code>Number()</code>成功转换</strong>。</li><li><p>如果<strong>能转换成功</strong>，就<strong>返回<code>false</code></strong>，否则返回<code>true</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)          // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123'</span>)        // <span class="literal">false</span> 能转换</span><br><span class="line">isNaN(<span class="string">'abc'</span>)        // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123ab'</span>)      // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123.45abc'</span>)  // <span class="literal">true</span> 不能转换</span><br></pre></td></tr></table></figure></li><li><p>可以看出，<strong><code>isNaN()</code>没有办法判断某个值本身是否为<code>NaN</code></strong>。</p></li><li><p>如果<strong>想要知道某个值本身是否为<code>NaN</code></strong>，可以利用<strong>NaN 不等于自身</strong>这一特性来判断：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selfIsNaN(value)&#123;</span><br><span class="line">    <span class="built_in">return</span> value !== value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另外，ES6 在<strong><code>Number</code>对象上</strong>也<strong>提供了<code>isNaN()</code>方法</strong>，和全局方法<code>isNaN()</code><strong>不同的是</strong>，它<strong>用于判断某个值本身是否为<code>NaN</code></strong>，而<strong>不需要进行类型转换</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(<span class="string">'123'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(<span class="string">'abc'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(NaN);      // <span class="literal">true</span>　本身是NaN</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NaN&quot;&gt;&lt;a href=&quot;#NaN&quot; class=&quot;headerlink&quot; title=&quot;NaN&quot;&gt;&lt;/a&gt;NaN&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NaN&lt;/code&gt; 即 &lt;strong&gt;Not a Number&lt;/strong&gt;，不是一个数字。 在 JavaScript 中，&lt;strong&gt;整数和浮点数都统称为 &lt;code&gt;Number&lt;/code&gt; 类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除此之外，&lt;code&gt;Number&lt;/code&gt; 类型类型还有一个很特殊的值，即 &lt;strong&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/strong&gt; 。它&lt;strong&gt;是 &lt;code&gt;Number&lt;/code&gt; 对象上的一个静态属性，可以通过 Number.NaN 来访问&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动的四种方式及其原理理解</title>
    <link href="https://chongtianhong.github.io/2018/05/23/clearFloat/"/>
    <id>https://chongtianhong.github.io/2018/05/23/clearFloat/</id>
    <published>2018-05-23T06:25:03.000Z</published>
    <updated>2018-09-01T12:18:09.371Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文介绍了四种清除浮动的方法，并尝试解释其原理。</li><li>在理解了各种清除浮动的原理之后，我们会发现，很多<strong>清除浮动的方法本质上其实是一样的</strong>。<a id="more"></a></li></ul><h4 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h4><ul><li><p>在讲清除浮动的方法之前，我们先来了解一下<strong>为什么要清除浮动</strong>，清除浮动的目的是什么，即，要解决什么样的问题。来看一个浮动的例子(略去了文字内容)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>其样式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在chrome中渲染的效果如下图所示：<br><img src="images/clearFloat1.png" stype="border:none" alt="浮动效果"></p></li><li>这肯定不是我们想要的渲染效果，它可能存在如下问题：<br>① <strong>文字围绕浮动元素排版</strong>，但我们可能希望文字（<code>.textDiv</code>）排列在浮动元素下方，或者，我们并不希望<code>.textDiv</code>两边有浮动元素存在。<br>② 浮动元素排版超出了其父级元素（<code>.topDiv</code>），<strong>父元素的高度出现了塌缩</strong>，若没有文字高度的支撑，不考虑边框，父级元素高度会塌缩成零。<br>③ <strong>浮动元素甚至影响到了其父元素的兄弟元素（<code>.bottomDiv</code>）排版</strong>。因为浮动元素脱离了文档流，<code>.bottomDiv</code>在计算元素位置的时候会忽略其影响，紧接着上一个元素的位置继续排列。</li><li>解决第一个问题，需要<strong>清除<code>.textDiv</code>周围的浮动</strong>。</li><li>解决第二、第三个问题，因为父元素的兄弟元素位置只受父元素位置的影响，就<strong>需要一种方法将父级元素的高度撑起来，将浮动元素包裹在其中</strong>，避免浮动元素影响父元素外部的元素排列。</li><li>接下来就开始介绍清除浮动的方法。</li></ul><h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><h5 id="利用clear样式"><a href="#利用clear样式" class="headerlink" title="利用clear样式"></a>利用clear样式</h5><ul><li><p>还是开篇的例子，我们给<strong>需要清除浮动的元素</strong>添加如下样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">    clear: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清除浮动后的渲染效果如下：<br><img src="images/clearFloat2.png" stype="border:none" alt="清除浮动后的渲染效果"></p></li><li>解析：<ul><li>通过上面的样式，<code>.textDiv</code>告诉浏览器，我的<strong>左边不允许有浮动的元素存在</strong>，请清除掉我左边的浮动元素。</li><li>然而，因为<strong>浮动元素（.floatDiv）位置已经确定</strong>，浏览器在计算<code>.textDiv</code>的位置时，<strong>为满足其需求，将<code>.textDiv</code>渲染在浮动元素下方</strong>，保证了<code>.textDiv</code>左边没有浮动元素。</li><li>同时可以看出，<strong>父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响</strong>，这是因为<strong><code>.textDiv</code>仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的</strong>。</li><li>设置样式为<code>clear: both</code>也有相同的效果，即<strong>两边都不允许有浮动元素</strong>，clear就是对应方向的值，两边都不允许就是both。</li></ul></li><li><strong>注意</strong>：这个规则<strong>只能影响使用清除的元素本身，不能影响其他元素</strong>。</li><li><p>但是，如果我们把HTML中的<code>.floatDiv</code>和<code>.textDiv</code>55：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>无论<code>.textDiv</code>是否应用清除浮动，情况都是下面的样子：<br><img src="images/clearFloat3.png" stype="border:none" alt="交换位置后的结果"></p></li><li><strong><code>.textDiv</code>的位置先确定了</strong>，于是<strong>浮动元素就紧接着<code>.textDiv</code>下方渲染在父元素的左侧</strong>。然而，父元素的高度并没有被撑起来，没有将浮动影响“内化”，导致浮动影响到了接下来的元素排版。</li><li>看来，为达到撑起父元素高度的目的，<strong>使用clear清除浮动的方法</strong>还是<strong>有适用范围</strong>的。我们需要更加通用和可靠的方法。</li></ul><h5 id="父元素结束标签之前插入清除浮动的块级元素"><a href="#父元素结束标签之前插入清除浮动的块级元素" class="headerlink" title="父元素结束标签之前插入清除浮动的块级元素"></a>父元素结束标签之前插入清除浮动的块级元素</h5><ul><li><p>HTML结构如下，在<strong>有浮动的父级元素的末尾</strong>插入了一个<strong>没有内容的块级元素div</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"blankDiv"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>应用样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">// 区别在这里</span><br><span class="line">.blankDiv &#123;</span><br><span class="line">    clear: both; // or left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>渲染效果如下：<br><img src="images/clearFloat4.png" stype="border:none" alt="父元素结束标签之前插入清除浮动的块级元素渲染效果"></p></li><li>和第一个例子里<code>.textDiv</code>应用clear清除浮动，撑起父级元素高度的原理完全一样。这里强调一点，即，<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</li></ul><h5 id="利用伪元素（clearfix）"><a href="#利用伪元素（clearfix）" class="headerlink" title="利用伪元素（clearfix）"></a>利用伪元素（clearfix）</h5><ul><li><p>HTML结构如下，在<code>.topDiv</code>的div上再添加一个<code>clearfix</code>类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv clearfix"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 省略基本的样式</span><br><span class="line">// 区别在这里</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: <span class="string">'.'</span>;       /*生成内容作为最后一个元素，至于content里面是点还是其他都是可以的*/</span><br><span class="line">    height: 0;          /*避免生成内容破坏原有布局的高度*/</span><br><span class="line">    visibility:hidden;  /*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互*/</span><br><span class="line">    display: block;     /*使生成的元素以块级元素显示,占满剩余空间*/</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该样式在<code>.clearfix</code>，即父级元素的最后，添加了一个:after伪元素，<strong>通过清除伪元素的浮动，达到撑起父元素高度的目的</strong>。</p></li><li>注意到该伪元素的<code>display</code>值为<code>block</code>，即，它是一个<strong>不可见的块级元素</strong>。你可能已经意识到，这也只不过是前一种清除浮动方法（添加空白div）的另一种变形，其底层逻辑也是完全一样的。这三种方法，其本质上是一样的。</li></ul><h5 id="利用overflow清除浮动"><a href="#利用overflow清除浮动" class="headerlink" title="利用overflow清除浮动"></a>利用overflow清除浮动</h5><ul><li>首先直观地看看，<code>overflow</code>是如何清除浮动的。</li><li><p>HTML结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用CSS后的渲染效果如下：<br>&lt;img src=”images/clearFloat5.png” stype=”border:none” alt=”利用overflow清除浮动后的渲染效果&gt;</p></li><li>仅仅只<strong>在父级元素上添加了一个值为<code>auto</code>的<code>overflow</code>属性，父元素的高度立即被撑起</strong>，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染。</li><li>其实，<strong>这里的<code>overflow</code>值</strong>，还可以是<strong>除了”visible”之外的任何有效值，它们都能达到撑起父元素高度，清除浮动的目的</strong>。</li><li>不过，<strong>有的值可能会带来副作用</strong>，比如，scroll值会导致滚动条始终可见，hidden会使得超出边框部分不可见等。</li><li><strong>原理</strong>：当<strong>元素设置了<code>overflow</code>样式，且值不为<code>visible</code>时</strong>，该<strong>元素就建构了一个BFC</strong>。</li><li>在上面的例子中，<code>.topDiv</code>因设置了值为<code>auto</code>的<code>overflow</code>样式，所以<strong>该元素建构出一个BFC</strong>，按照第三个特点，<strong>BFC的高度是要包括浮动元素的</strong>，所以<code>.topDiv</code>的高度被撑起来，<strong>达到了清除浮动影响的目的</strong>。</li><li><strong>注意</strong>：这里<strong><code>overflow</code>的作用就是为了构建一个BFC区域，让内部浮动的影响都得以“内化”</strong>。而<strong>构建一个BFC区域的方法有很多种，<code>overflow</code>只是其中的一种</strong>，因此，我们也<strong>可以利用其它的方式构建BFC，且同样能达到清除浮动的目的</strong>。</li><li><p>BFC定义中说，<code>inline-block</code>同样也能构建BFC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">// 其他样式相同，省略</span><br></pre></td></tr></table></figure></li><li><p>渲染效果和使用<code>overflow</code>的效果完全一样。</p></li></ul><h5 id="另外一些方法"><a href="#另外一些方法" class="headerlink" title="另外一些方法"></a>另外一些方法</h5><blockquote>给浮动元素父级设置高度</blockquote><ul><li>使用浮动后，<strong>父元素高度塌陷</strong>是因为<strong>给浮动元素的父级高度是自适应导致的</strong>，因此，可以<strong>给它设置适当的高度</strong>来解决这一问题，然而，缺点是<strong>在浮动元素高度不确定的时候不适用</strong>。</li></ul><blockquote>父级也设置浮动</blockquote><ul><li>缺点：需要给每个浮动元素父级添加浮动，浮动多了容易出现问题。</li></ul><blockquote>使用br清浮动</blockquote><ul><li><p><strong>br标签自带clear属性</strong>，将它的<strong>clear属性设置成both</strong>其实和<strong>添加空div</strong>原理是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"top"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;br clear=<span class="string">"both"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>缺点：<strong>不符合工作中结构、样式、行为，三者分离的要求</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文介绍了四种清除浮动的方法，并尝试解释其原理。&lt;/li&gt;
&lt;li&gt;在理解了各种清除浮动的原理之后，我们会发现，很多&lt;strong&gt;清除浮动的方法本质上其实是一样的&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="浮动" scheme="https://chongtianhong.github.io/tags/%E6%B5%AE%E5%8A%A8/"/>
    
      <category term="清除浮动" scheme="https://chongtianhong.github.io/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6 类(Class)基本用法与静态属性 + 静态方法</title>
    <link href="https://chongtianhong.github.io/2018/05/22/ES6Class/"/>
    <id>https://chongtianhong.github.io/2018/05/22/ES6Class/</id>
    <published>2018-05-22T06:33:15.000Z</published>
    <updated>2018-08-24T14:41:56.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类-Class-的基本用法"><a href="#类-Class-的基本用法" class="headerlink" title="类(Class)的基本用法"></a>类(Class)的基本用法</h4><ul><li>在 ES6 规范中，引入了<code>Class</code>的概念。使得 JS 开发者终于告别了<strong>直接使用原型对象模仿面向对象中的类</strong>和<strong>类继承</strong>时代。</li><li>但是JS 中并没有一个真正的<code>Class</code>原始类型，<strong><code>Class</code></strong>仅仅只是对原型对象运用语法糖，<strong>作为对象的模板</strong>。所以，只有理解如何<strong>使用原型对象实现类和类继承</strong>，才能真正地用好<code>Class</code>。<a id="more"></a></li><li><p>下面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是<strong>构造方法</strong>，而<code>this</code>关键字则代表实例对象。也就是说，<strong>ES5的构造函数</strong><code>Point</code>，<strong>对应ES6的<code>Point</code>类的构造方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ES6定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    // prototype属性</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">// ES5的构造函数</span><br><span class="line"><span class="keyword">function</span> Point(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype = <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义“类”的方法</strong>的时候，<strong>前面不需要加上<code>function</code>这个关键字</strong>，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔</strong>，加了会报错。</p></li><li><p><strong>构造函数的prototype属性</strong>，在ES6的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的prototype属性上面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>方法可以很方便地<strong>一次向类添加多个方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Point.prototype, &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>类的内部所有定义的方法</strong>，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与ES5的行为不一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES5可枚举，ES6不可枚举</span><br><span class="line">Object.keys(Point.prototype)</span><br></pre></td></tr></table></figure></li><li><p>constructor方法是类的默认方法，<strong>通过new命令生成对象实例时，自动调用该方法</strong>。一个类必须有constructor方法，如果<strong>没有显式定义，一个空的constructor方法会被默认添加</strong>。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p></li><li><strong>类的构造函数，不使用new是没法调用的</strong>，会报错。</li><li><p>可以<strong>通过实例的<code>__proto__</code>属性</strong>为Class添加方法，<strong>可被所有的实例所共享</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3);</span><br><span class="line">var p2 = new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // <span class="string">"Oops"</span></span><br><span class="line">p2.printName() // <span class="string">"Oops"</span></span><br><span class="line"></span><br><span class="line">var p3 = new Point(4,2);</span><br><span class="line">p3.printName() // <span class="string">"Oops"</span></span><br></pre></td></tr></table></figure></li><li><p>可见，<strong>使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎</strong>，不推荐使用，因为这<strong>会改变Class的原始定义，影响到所有实例</strong>。</p></li><li><code>Class</code><strong>不存在变量提升（hoist）</strong>。</li></ul><h4 id="typeof-class-“function”"><a href="#typeof-class-“function”" class="headerlink" title="typeof class == “function”"></a>typeof class == “function”</h4><ul><li>使用<code>Class</code>的语法，让开发者告别了使用 prototype 模仿面向对象的时代。但是，<strong><code>Class</code></strong>并不是 ES6 引入的全新概念，它的<strong>原理依旧是原型继承</strong>。</li><li>通过类型判断，我们可以得知，<strong><code>Class</code></strong>的并不是什么全新的数据类型，它<strong>实际只是 function (或者说 object)</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeof Person // <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><ul><li>在传统面向对象中，<strong>类</strong>是<strong>可以继承类</strong>的。这样子<strong>类</strong>就<strong>可以复制父类的方法，达到代码复用的目的</strong>。</li><li><p>ES6 也提供了类继承的语法<code>extends</code>，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        this.me = who;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">identify</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"I am "</span> + this.me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        // super() 指的是调用父类</span><br><span class="line">        // 调用的同时，会绑定 this 。</span><br><span class="line">        // 如：Foo.call(this, who)</span><br><span class="line">        super(who);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">speak</span></span>()&#123;</span><br><span class="line">        alert( <span class="string">"Hello, "</span> + this.identify() + <span class="string">"."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b1 = new Bar( <span class="string">"b1"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br></pre></td></tr></table></figure></li><li><p>当实例<code>b1</code>调用<code>speak</code>方法时，<code>b1</code>本身没有 <code>speak</code>，所以会到<code>Bar.prototype</code>原型对象上查找，并且调用原型对象上的<code>speak</code>方法。调用<code>identify</code>方式时，由于<code>this</code>指向的是<code>b1</code>对象。所以也会先在<code>b1</code>本身查找，然后沿着原型链，查找<code>Bar.prototype</code>，最后在<code>Foo.prototype</code>原型对象上找到<code>identify</code>方法，然后调用。</p></li><li>实际上，在 JavaScript 中，<strong>类继承的本质依旧是原型对象</strong>。</li></ul><h4 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h4><ul><li><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果<strong>在一个方法前，加上static关键字，就表示该方法不会被实例继承</strong>，而是<strong>直接通过类来调用</strong>，这就称为<strong>“静态方法”</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line">// 定义静态方法</span><br><span class="line">static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 通过类名直接调用</span><br><span class="line">console.log(StaticMethod.getAge());</span><br></pre></td></tr></table></figure></li><li><p><strong>静态方法只能在静态方法中调用，不能在实例方法中调用</strong>。</p></li></ul><h4 id="Class的静态属性和实例属性"><a href="#Class的静态属性和实例属性" class="headerlink" title="Class的静态属性和实例属性"></a>Class的静态属性和实例属性</h4><ul><li><p><strong>静态属性</strong>指的是<strong>Class本身的属性</strong>，即<code>Class.propname</code>，而不是定义在实例对象（this）上的属性。ES6使用静态属性和实例属性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line"></span><br><span class="line">// 定义实例属性</span><br><span class="line">// ES6实例属性只能在constructor构造函数中定义</span><br><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.width = <span class="string">'40cm'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">&#125;</span><br><span class="line">// 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">width;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：目前ES6，只有这种写法可行，<strong>因为ES6明确规定，Class内部只有静态方法，没有静态属性</strong>。</p></li><li><p><strong>ES7</strong>有一个<strong>静态属性的提案</strong>，目前Babel转码器支持。安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，不同的stage封装了不同的插件，官方推荐是使用stage-1安装命令(根据自己的需求调整):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-preset-stage-0</span><br></pre></td></tr></table></figure></li><li><p>ES7使用<strong>静态属性</strong>和<strong>实例属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// ES7提案 定义静态属性</span><br><span class="line">static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"></span><br><span class="line">// ES7定义实例属性</span><br><span class="line">height = <span class="string">'150cm'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：<strong>ES7和ES6的静态属性和实例属性</strong>只是<strong>定义不一样</strong>，<strong>调用的方式是一样的</strong>。</p></li><li>Class的<strong>静态方法/Class静态属性</strong>和<strong>实例属性</strong>的整个案例:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethodParent.js</span><br><span class="line"><span class="built_in">export</span> default class StaticMethodParent&#123;</span><br><span class="line">    static <span class="function"><span class="title">getCommon</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'父类的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// StaticMethod.js</span><br><span class="line">import StaticMethodParent from <span class="string">'./StaticMethodParent'</span></span><br><span class="line"> </span><br><span class="line">// 定义静态属性和静态方法</span><br><span class="line">class StaticMethod extends StaticMethodParent&#123;</span><br><span class="line">    // 因为ES6明确规定，Class内部只有静态方法，没有静态属性,所以ES6在类中定义静态属性都是错误的。</span><br><span class="line">    // static lastName = <span class="string">'pcaca'</span>;ES6错误</span><br><span class="line"> </span><br><span class="line">    // ES7提案 定义静态属性</span><br><span class="line">    // 安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，</span><br><span class="line">    // 不同的stage封装了不同的插件，官方推荐是使用stage-1</span><br><span class="line">    static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"> </span><br><span class="line">    // ES7定义实例属性</span><br><span class="line">    height = <span class="string">'150cm'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getHeight</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.height;//ES7的使用也要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // ES6实例属性只能在constructor构造函数中定义</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.width = <span class="string">'40cm'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">    width;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 定义静态方法</span><br><span class="line">    static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">        // 子类可以调用父类的静态方法</span><br><span class="line">        console.log(super.getCommon());</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">export</span> &#123;StaticMethod&#125;;</span><br><span class="line"> </span><br><span class="line">// index.js</span><br><span class="line">import &#123;StaticMethod&#125; from <span class="string">'./StaticMethod'</span>;</span><br><span class="line">console.log(StaticMethod.getAge());</span><br><span class="line">console.log(StaticMethod.getCommon());</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line">console.log(StaticMethod.lastName);</span><br><span class="line"><span class="built_in">let</span> staticMethod = new StaticMethod();</span><br><span class="line">console.log(staticMethod.height);</span><br><span class="line">console.log(staticMethod.getHeight());</span><br><span class="line">console.log(staticMethod.width);</span><br><span class="line">console.log(staticMethod.getWidth());</span><br><span class="line">//staticMethod.getAge();//bundle.js:7906 Uncaught TypeError: staticMethod.getAge is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类-Class-的基本用法&quot;&gt;&lt;a href=&quot;#类-Class-的基本用法&quot; class=&quot;headerlink&quot; title=&quot;类(Class)的基本用法&quot;&gt;&lt;/a&gt;类(Class)的基本用法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在 ES6 规范中，引入了&lt;code&gt;Class&lt;/code&gt;的概念。使得 JS 开发者终于告别了&lt;strong&gt;直接使用原型对象模仿面向对象中的类&lt;/strong&gt;和&lt;strong&gt;类继承&lt;/strong&gt;时代。&lt;/li&gt;
&lt;li&gt;但是JS 中并没有一个真正的&lt;code&gt;Class&lt;/code&gt;原始类型，&lt;strong&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/strong&gt;仅仅只是对原型对象运用语法糖，&lt;strong&gt;作为对象的模板&lt;/strong&gt;。所以，只有理解如何&lt;strong&gt;使用原型对象实现类和类继承&lt;/strong&gt;，才能真正地用好&lt;code&gt;Class&lt;/code&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Class" scheme="https://chongtianhong.github.io/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>使用Javascript监控前端相关数据</title>
    <link href="https://chongtianhong.github.io/2018/05/21/frontEndMonitor/"/>
    <id>https://chongtianhong.github.io/2018/05/21/frontEndMonitor/</id>
    <published>2018-05-21T12:40:59.000Z</published>
    <updated>2018-08-23T15:06:44.798Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。<strong>项目上线前期的粒度较大的错误</strong>我们都会<strong>在自测和QA测试中发现</strong>，然而<strong>上线之后的错误不是那么好发现</strong>。同时<strong>移动端的开发</strong>也面临着一个问题就是<strong>不好调试</strong>，所以<strong>web开发的错误监控</strong>是一个非常有用的措施。<a id="more"></a></li></ul><h4 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h4><ul><li>常见的web错误主要分为两类：<br>① <strong>运行时错误</strong>：这个错误往往是我们在代码书写时造成的，比如语法错误、逻辑错误，这样的错误通常在测试阶段就会被发现，但是也可能存在“漏网之鱼”。<br>② <strong>资源加载错误</strong>：这个错误通常是找不到文件或者是文件加载超时造成的。</li></ul><h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><ul><li>基于上面两种的错误类型，也有不同的错误捕获方式：</li></ul><blockquote>代码错误捕获：</blockquote><ul><li><p>使用<code>try…catch…</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">    // 运行可能出错的代码</span><br><span class="line"></span><br><span class="line">&#125;catch&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>windown.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>资源加载错误：</blockquote><ul><li><p><code>bject.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var img =document.getElementById(<span class="string">'#img'</span>);</span><br><span class="line"></span><br><span class="line">img.onerror = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用window的Error事件代理，但是需要注意的是<strong>Error事件是不冒泡的</strong>，我们可以<strong>使用事件捕获进行代理</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">"error"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h4><ul><li>常见错误上报有两种： <strong>ajax</strong>、<strong>image对象</strong>推荐）。</li><li><strong>ajax上报</strong>就是在上文注释错误捕获的地方发起ajax请求，来向服务器发送错误信息。</li><li>利用<strong>image对象</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src =<span class="string">"http://post.error.com?"</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="跨域js文件错误获取"><a href="#跨域js文件错误获取" class="headerlink" title="跨域js文件错误获取"></a>跨域js文件错误获取</h4><ul><li><strong>跨域js文件获取是有限制的</strong>，如果想<strong>获取其他域下的js错误</strong>需要<strong>在script标签里添加crossorigin属性</strong>，然后<strong>服务器端要设置</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">'Access-Control-Allow-Origin: *'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="前端监控系统模块实现"><a href="#前端监控系统模块实现" class="headerlink" title="前端监控系统模块实现"></a>前端监控系统模块实现</h4><ul><li>项目开发完成外发后，没有一个监控系统，我们很难了解到发布出去的代码在用户机器上执行是否正确，所以需要建立<strong>前端代码性能相关的监控系统</strong>。</li><li>所以我们需要做以下的一些模块：</li></ul><h5 id="收集脚本执行错误"><a href="#收集脚本执行错误" class="headerlink" title="收集脚本执行错误"></a>收集脚本执行错误</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> error(msg, url, line)&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi"</span>; // 收集上报数据的信息</span><br><span class="line">    var m =[msg, url, line, navigator.userAgent, +new Date];// 收集错误信息，发生错误的脚本文件网络地址，用户代理信息，时间</span><br><span class="line">    var url = REPORT_URL + m.join(<span class="string">'||'</span>);// 组装错误上报信息内容URL</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = url;// 发送数据到后台cgi</span><br><span class="line">&#125;</span><br><span class="line">// 监听错误上报</span><br><span class="line">window.onerror = <span class="keyword">function</span>(msg,url,line)&#123;</span><br><span class="line">    error(msg,url,line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<strong>管理后台系统</strong>，我们可以看到页面上每次错误的信息，通过这些信息我们可以很快定位并且解决问题。</li></ul><h5 id="收集页面执行性能信息"><a href="#收集页面执行性能信息" class="headerlink" title="收集页面执行性能信息"></a>收集页面执行性能信息</h5><ul><li>performance包含<strong>页面加载到执行完成</strong>的整个生命周期中<strong>不同执行步骤的执行时间</strong>。</li><li><p>计算不同步骤时间相对于navigationStart的时间差，可以通过相应后台CGI收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_performance</span></span>()&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi?perf="</span>;</span><br><span class="line">    var perf = (window.webkitPerformance ? window.webkitPerformance : window.msPerformance ),</span><br><span class="line">        points = [<span class="string">'navigationStart'</span>,<span class="string">'unloadEventStart'</span>,<span class="string">'unloadEventEnd'</span>,<span class="string">'redirectStart'</span>,<span class="string">'redirectEnd'</span>,<span class="string">'fetchStart'</span>,<span class="string">'domainLookupStart'</span>,<span class="string">'connectStart'</span>,<span class="string">'requestStart'</span>,<span class="string">'responseStart'</span>,<span class="string">'responseEnd'</span>,<span class="string">'domLoading'</span>,<span class="string">'domInteractive'</span>,<span class="string">'domContentLoadedEventEnd'</span>,<span class="string">'domComplete'</span>,<span class="string">'loadEventStart'</span>,<span class="string">'loadEventEnd'</span>];</span><br><span class="line">    var timing = pref.timing;</span><br><span class="line">    perf = perf  ? perf : window.performance;</span><br><span class="line">    <span class="keyword">if</span>( perf  &amp;&amp; timing ) &#123;</span><br><span class="line">        var arr = [];</span><br><span class="line">        var navigationStart = timing[points[0]];</span><br><span class="line">        <span class="keyword">for</span>(var i=0,l=points.length;i&lt;l;i++)&#123;</span><br><span class="line">            arr[i] = timing[points[i]] - navigationStart;</span><br><span class="line">        &#125;</span><br><span class="line">    var url = REPORT_URL + arr.join(<span class="string">"-"</span>);</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img=null;</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过后台接口收集和统计，我们可以对<strong>页面执行性能</strong>有很详细的了解。</p></li></ul><h5 id="统计每个页面的JS和CSS加载时间"><a href="#统计每个页面的JS和CSS加载时间" class="headerlink" title="统计每个页面的JS和CSS加载时间"></a>统计每个页面的JS和CSS加载时间</h5><ul><li>在<strong>JS或者CSS加载之前打上时间戳，加载之后打上时间戳</strong>，并且将数据（时间差）上报到后台。<strong>加载时间</strong>反映了<strong>页面白屏</strong>，<strong>可操作的等待时间</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;var cssLoadStart = +new Date&lt;/script&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx1.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx2.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;sript&gt;</span><br><span class="line">    var cssLoadTime = (+new Date) - cssLoadStart;</span><br><span class="line">    var jsLoadStart = +new Date;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx1.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx2.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx3.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var jsLoadTime = (+new Date) - jsLoadStart;</span><br><span class="line">    var REPORT_URL = <span class="string">'xxx/cgi?data='</span></span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = REPORT_URL + cssLoadTime + <span class="string">'-'</span> + jsLoadTime;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><h5 id="new-Date"><a href="#new-Date" class="headerlink" title="+new Date"></a>+new Date</h5><ul><li>JavaScript中可以在某个元素前使用 ‘+’ 号，这个操作是<strong>将该元素转换成Number类型</strong>，如果<strong>转换失败</strong>，那么<strong>将得到 NaN</strong>。</li><li>所以，<code>+new Date</code>将会调用<code>Date.prototype</code>上的 <code>valueOf</code>方法，而根据 MDN 文档，<code>Date.prototype.valueOf</code>方法等同于<code>Date.prototype.getTime()</code>，得到毫秒。</li><li>所以下列代码效果相同：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(+new Date);</span><br><span class="line"> </span><br><span class="line">console.log(new Date().getTime());</span><br><span class="line"> </span><br><span class="line">console.log(new Date().valueOf());</span><br><span class="line"> </span><br><span class="line">console.log(new Date() * 1);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。&lt;strong&gt;项目上线前期的粒度较大的错误&lt;/strong&gt;我们都会&lt;strong&gt;在自测和QA测试中发现&lt;/strong&gt;，然而&lt;strong&gt;上线之后的错误不是那么好发现&lt;/strong&gt;。同时&lt;strong&gt;移动端的开发&lt;/strong&gt;也面临着一个问题就是&lt;strong&gt;不好调试&lt;/strong&gt;，所以&lt;strong&gt;web开发的错误监控&lt;/strong&gt;是一个非常有用的措施。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端监控" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Javascript" scheme="https://chongtianhong.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript定义类（class）的三种方法</title>
    <link href="https://chongtianhong.github.io/2018/05/20/ClassDefinition/"/>
    <id>https://chongtianhong.github.io/2018/05/20/ClassDefinition/</id>
    <published>2018-05-20T03:13:53.000Z</published>
    <updated>2018-08-23T15:09:25.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在<strong>面向对象编程</strong>中，<strong>类（class）是对象（object）的模板</strong>，定义了<strong>同一组对象（又称”实例”）共有的属性和方法</strong>。</li><li>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。</li><li>本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。<a id="more"></a><h4 id="构造函数法"><a href="#构造函数法" class="headerlink" title="构造函数法"></a>构造函数法</h4></li><li>这是经典方法，也是教科书必教的方法。</li><li><p>它用<strong>构造函数模拟”类”</strong>，在其内部用<code>this</code>关键字指代实例对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Cat</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"大毛"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成实例的时候，使用<code>new</code>关键字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = new Cat();</span><br><span class="line">alert(cat1.name); // 大毛</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法，还可以<strong>定义在构造函数的prototype对象之上</strong>，<strong>实现不同实例属性和方法的共享</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.makeSound = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(<span class="string">"喵喵喵"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法的主要缺点是，比较复杂，用到了<code>this</code>和<code>prototype</code>，编写和阅读都很费力。</p></li></ul><h4 id="Object-create-法"><a href="#Object-create-法" class="headerlink" title="Object.create()法"></a>Object.create()法</h4><ul><li>为了解决”构造函数法”的缺点，<strong>更方便地生成对象</strong>，Javascript的国际标准ECMAScript第五版，提出了一个新的方法<code>Object.create()</code>。</li><li><p>用这个方法，<strong>“类”</strong>就<strong>是一个对象</strong>，不是函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    name: <span class="string">"大毛"</span>,</span><br><span class="line">    makeSound: <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">        alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，直接用<code>Object.create()</code>生成实例，不需要用到<code>new</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Object.create(Cat);</span><br><span class="line">alert(cat1.name); // 大毛</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Object.create) &#123;</span><br><span class="line">    Object.create = <span class="keyword">function</span> (o) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="built_in">return</span> new F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法<strong>比”构造函数法”简单</strong>，但是<strong>不能实现私有属性和私有方法</strong>，<strong>实例对象之间也不能共享数据</strong>，<strong>对”类”的模拟不够全面</strong>。</p></li></ul><h4 id="极简主义法（推荐）"><a href="#极简主义法（推荐）" class="headerlink" title="极简主义法（推荐）"></a>极简主义法（推荐）</h4><ul><li>荷兰程序员Gabor de Mooij提出了一种比<code>Object.create()</code>更好的新方法，他称这种方法为”极简主义法”（minimalist approach）。这也是<strong>本文推荐的方法</strong>。</li><li>接下来介绍该方法的特点。</li></ul><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul><li>这种方法<strong>不使用<code>this</code>和<code>prototype</code></strong>，<strong>代码部署起来非常简单</strong>，这大概也是它被叫做”极简主义法”的原因。</li><li><p>首先，它也是<strong>用一个对象模拟”类”</strong>。在这个类里面，定义一个构造函数（方法）<code>createNew()</code>，用来生成实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // some code here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，<strong>在<code>createNew()</code>里面，定义一个实例对象</strong>，把这个<strong>实例对象作为返回值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用的时候，<strong>调用<code>createNew()</code>方法，就可以得到实例对象</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这种方法的好处是，<strong>容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</strong>，因此可以方便地部署下面的特性。</p></li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li><strong>让一个类继承另一个类</strong>，实现起来很方便。只要<strong>在前者（继承者）的<code>createNew()</code>方法中，调用后者（被继承者）的<code>createNew()</code>方法</strong>即可。</li><li><p>先定义一个Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Animal = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var animal = &#123;&#125;;</span><br><span class="line">        animal.sleep = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"睡懒觉"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，在Cat的<code>createNew()</code>方法中，调用Animal的<code>createNew()</code>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var cat = Animal.createNew();</span><br><span class="line">    cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">    cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"喵喵喵"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>这样得到的Cat实例，就会同时继承Cat类和Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.sleep(); // 睡懒觉</span><br></pre></td></tr></table></figure></li></ul><h5 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h5><ul><li><p>在<code>createNew()</code>方法中，只要不是定义在cat对象上的方法和属性，都是私有的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        var sound = <span class="string">"喵喵喵"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上例的内部变量<code>sound</code>，外部无法读取，只有通过cat的公有方法<code>makeSound()</code>来读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">alert(cat1.sound); // undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h5><ul><li><p>有时候，我们<strong>需要所有实例对象，能够读写同一项内部数据</strong>。这个时候，只要<strong>把这个内部数据，封装在类对象的里面、createNew()方法的外面</strong>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    sound : <span class="string">"喵喵喵"</span>,</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(Cat.sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        cat.changeSound = <span class="keyword">function</span>(x)&#123; </span><br><span class="line">            Cat.sound = x; </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，生成两个实例对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">var cat2 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这时，如果有一个<strong>实例对象，修改了共享的数据，另一个实例对象也会受到影响</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat2.changeSound(<span class="string">"啦啦啦"</span>);</span><br><span class="line">cat1.makeSound(); // 啦啦啦</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;面向对象编程&lt;/strong&gt;中，&lt;strong&gt;类（class）是对象（object）的模板&lt;/strong&gt;，定义了&lt;strong&gt;同一组对象（又称”实例”）共有的属性和方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。&lt;/li&gt;
&lt;li&gt;本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>defer和async的区别</title>
    <link href="https://chongtianhong.github.io/2018/05/19/asyncAndDefer/"/>
    <id>https://chongtianhong.github.io/2018/05/19/asyncAndDefer/</id>
    <published>2018-05-19T10:35:46.000Z</published>
    <updated>2018-08-22T14:42:14.840Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>script</code>标签用于<strong>加载脚本与执行脚本</strong>，直接使用<code>script</code>标签（不加<code>defer</code>或<code>async</code>属性）的话，<strong>HTML会按照顺序来加载并执行脚本</strong>，在<strong>脚本加载&amp;执行的过程中</strong>，会<strong>阻塞后续的DOM渲染</strong>。<a id="more"></a></li><li><p>使用<code>async</code>属性，<strong>加载和渲染后续文档元素的过程</strong>将和 script.js 的<strong>加载与执行</strong>并行进行（异步）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=<span class="string">"script.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>defer</code>属性，<strong>加载后续文档元素的过程</strong>将和script.js的<strong>加载</strong>并行进行（异步），但是<strong>script.js的执行要在所有元素解析完成之后</strong>、<strong>DOMContentLoaded 事件触发之前</strong>完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"myscript.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>从实用角度来说，<strong>把所有脚本都丢到HTML文档最后、&lt;/body&gt;之前</strong>是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可<strong>保证非脚本的其他一切元素</strong>能够<strong>以最快的速度得到加载和解析</strong>。</p></li><li>下图中，蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。<br><img src="/images/asyncAndDefer1.png" alt="脚本加载和执行过程" width="600" style="border:none"></li><li>此图告诉我们以下几个要点：<br>1.<code>defer</code> 和 async 在<strong>网络读取（下载）时都是异步的</strong>（相较于 HTML 解析）。<br>2.它们差别在于脚本下载完之后何时执行，显然<strong><code>defer</code>是最接近我们对于应用脚本加载和执行的要求的</strong>。<br>3.关于<code>defer</code>，HTML5规范要求脚本执行应该按照脚本出现的先后顺序执行，但<strong>实际情况下，延迟脚本不一定按照先后顺序执行</strong>。<br>4.<strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>，与声明顺序无关。<br>5.<code>async</code>对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它<strong>对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适</strong>的，最典型的例子：谷歌/百度统计。</li></ul><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li>如果<code>script</code>标签设置了<code>defer</code>属性，则浏览器会<strong>异步的下载该文件</strong>并且<strong>不会影响到后续DOM的渲染</strong>；</li><li>如果有<strong>多个设置了<code>defer</code>的<code>script</code>标签</strong>存在，则会<strong>按照顺序执行所有的<code>script</code></strong>；</li><li><code>defer</code>脚本会<strong>在文档渲染完毕后，DOMContentLoaded事件调用前执行</strong>。</li></ul><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul><li><code>async</code>的设置，会使得<strong><code>script</code>脚本异步的加载</strong>并在允许的情况下执行。</li><li><strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>。</li><li><strong>DOMContentLoaded事件的触发并不受设置了<code>async</code>属性的脚本加载的影响</strong>，也就是说，<strong><code>async</code>属性脚本的加载不计入DOMContentLoaded事件统计</strong>。在脚本加载完之前，有可能已经触发了DOMContentLoaded。如果给设置了<code>async</code>属性的脚本一定的时间，是<strong>有可能在DOMContentLoaded事件之前就执行</strong>的。</li><li>设置了<code>async</code>属性的脚本的执行是<strong>加载完成就会去执行</strong>，而不像defer那样要等待所有的脚本加载完后按照顺序执行。</li></ul><h4 id="图例分析"><a href="#图例分析" class="headerlink" title="图例分析"></a>图例分析</h4><ul><li>拿四个不同的颜色来标明各自代表的含义，蓝色为文档解析，紫色为脚本渲染，黄色为脚本执行，绿色为DOMContentLoaded。</li></ul><h5 id="普通script"><a href="#普通script" class="headerlink" title="普通script"></a>普通script</h5><ul><li>文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载（但是Chrome会做一个优化，如果遇到script脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载script所对应的资源，这样能够节省一部分下载的时间）。</li><li><strong>资源的下载是在解析过程中进行</strong>的，虽说script1脚本会很快的加载完毕，但是如果它前边的script2并没有加载&amp;执行，所以它只能处于一个挂起的状态，等待script2执行完毕后再执行。</li><li>当这两个脚本都执行完毕后，才会继续解析页面。<br><img src="/images/asyncAndDefer2.png" alt="普通script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="defer-1"><a href="#defer-1" class="headerlink" title="defer"></a>defer</h5><ul><li>文档解析时，遇到设置了<code>defer</code>的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。</li><li>会<strong>等到所有的<code>defer</code>脚本加载完毕并按照顺序执行，执行完毕后</strong>会<strong>触发DOMContentLoaded事件</strong>。<br><img src="/images/asyncAndDefer3.png" alt="设置defer属性script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="async-1"><a href="#async-1" class="headerlink" title="async"></a>async</h5><ul><li><code>async</code>脚本会在<strong>加载完毕后立即执行</strong>。</li><li><code>async</code>脚本的加载<strong>不计入DOMContentLoaded事件统计</strong>，也就是说下图两种情况都是有可能发生的。</li><li>情况一：<br><img src="/images/asyncAndDefer4.png" alt="设置async属性script的加载和执行过程情况1" width="600" style="border:none"></li><li>情况二：<br><img src="/images/asyncAndDefer5.png" alt="设置async属性script的加载和执行过程情况2" width="600" style="border:none"></li></ul><h4 id="推荐的应用场景"><a href="#推荐的应用场景" class="headerlink" title="推荐的应用场景"></a>推荐的应用场景</h4><h5 id="defer-2"><a href="#defer-2" class="headerlink" title="defer"></a>defer</h5><ul><li>如果<strong>脚本代码依赖于页面中的DOM元素</strong>（文档是否解析完毕），或者<strong>被其他脚本文件依赖</strong>。例：<ul><li>评论框</li><li>代码语法高亮</li><li>polyfill.js</li></ul></li></ul><h5 id="async-2"><a href="#async-2" class="headerlink" title="async"></a>async</h5><ul><li>如果<strong>脚本并不关心页面中的DOM元素</strong>（文档是否解析完毕），并且<strong>也不会产生其他脚本需要的数据</strong>。例：<ul><li>谷歌/百度统计</li></ul></li><li>如果不太能确定的话，用defer总是会比async稳定（保证脚本执行顺序性、文档渲染完成后才执行）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;script&lt;/code&gt;标签用于&lt;strong&gt;加载脚本与执行脚本&lt;/strong&gt;，直接使用&lt;code&gt;script&lt;/code&gt;标签（不加&lt;code&gt;defer&lt;/code&gt;或&lt;code&gt;async&lt;/code&gt;属性）的话，&lt;strong&gt;HTML会按照顺序来加载并执行脚本&lt;/strong&gt;，在&lt;strong&gt;脚本加载&amp;amp;执行的过程中&lt;/strong&gt;，会&lt;strong&gt;阻塞后续的DOM渲染&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Object.getOwnPropertyNames的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/"/>
    <id>https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/</id>
    <published>2018-05-18T02:11:02.000Z</published>
    <updated>2018-08-22T14:30:04.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.getOwnPropertyNames()</code>方法返回一个由<strong>指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><code>Object.getOwnPropertyNames()</code>返回的数组中，<strong>枚举属性</strong>的顺序与通过<code>for…in</code>循环（或 Object.keys）迭代该对象属性时一致。数组中<strong>不可枚举属性的顺序未定义</strong>。</li><li><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">console.log(Object.getOwnPropertyNames(arr).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"length"</span>]</span><br><span class="line"></span><br><span class="line">// 类数组对象</span><br><span class="line">var obj = &#123; 0: <span class="string">"a"</span>, 1: <span class="string">"b"</span>, 2: <span class="string">"c"</span>&#125;;</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line"></span><br><span class="line">// 使用Array.forEach输出属性名和属性值</span><br><span class="line">Object.getOwnPropertyNames(obj).forEach(<span class="keyword">function</span>(val, idx, array) &#123;</span><br><span class="line">    console.log(val + <span class="string">" -&gt; "</span> + obj[val]);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出</span><br><span class="line">// 0 -&gt; a</span><br><span class="line">// 1 -&gt; b</span><br><span class="line">// 2 -&gt; c</span><br><span class="line"></span><br><span class="line">//不可枚举属性</span><br><span class="line">var my_obj = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    getFoo: &#123;</span><br><span class="line">        value: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.foo; &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">my_obj.foo = 1;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(my_obj).sort()); // [<span class="string">"foo"</span>, <span class="string">"getFoo"</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>只要获取到可枚举属性</strong>，可使用<code>Object.keys</code>或用<code>for…in</code>循环（<code>for…in</code>还会获取到原型链上的可枚举属性，不过<strong>可以使用<code>hasOwnProperty()</code>方法过滤掉</strong>）。</p></li><li>下面的例子演示了<code>Object.getOwnPropertyNames()</code>方法<strong>不会获取到原型链上的属性</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ParentClass</span></span>() &#123;&#125;</span><br><span class="line">ParentClass.prototype.inheritedMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ChildClass</span></span>() &#123;</span><br><span class="line">  this.prop = 5;</span><br><span class="line">  this.method = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildClass.prototype = new ParentClass;</span><br><span class="line">ChildClass.prototype.prototypeMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Object.getOwnPropertyNames(</span><br><span class="line">    new ChildClass()  // [<span class="string">"prop"</span>, <span class="string">"method"</span>]</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><blockquote>只获取不可枚举的属性</blockquote><ul><li><p>下面的例子使用了<code>Array.prototype.filter()</code>方法，从所有的属性名数组（使用<code>Object.getOwnPropertyNames()</code>方法获得）中去除可枚举的属性（使用<code>Object.keys()</code>方法获得），剩余的属性便是不可枚举的属性了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var target = myObject;</span><br><span class="line">var enum_and_nonenum = Object.getOwnPropertyNames(target);</span><br><span class="line">var enum_only = Object.keys(target);</span><br><span class="line">var nonenum_only = enum_and_nonenum.filter(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">    var indexInEnum = enum_only.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (indexInEnum == -1) &#123;</span><br><span class="line">        // 没有发现在enum_only键集中意味着这个键是不可枚举的,</span><br><span class="line">        // 因此返回<span class="literal">true</span> 以便让它保持在过滤结果中</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(nonenum_only);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>Array.filter(filt_func)</code>方法<strong>创建一个新数组</strong>, 其包含<strong>通过</strong>所提供函数实现的<strong>测试的所有元素</strong>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在 ES5 中，如果参数不是一个原始对象类型，将抛出一个 TypeError  异常。</li><li>在 ES2015 中，非对象参数被强制转换为对象 。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// [<span class="string">'length'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]  (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;方法返回一个由&lt;strong&gt;指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Object.keys的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/17/ObejectKeys/"/>
    <id>https://chongtianhong.github.io/2018/05/17/ObejectKeys/</id>
    <published>2018-05-17T01:44:26.000Z</published>
    <updated>2018-08-22T14:30:10.432Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.keys()</code>方法会返回一个由一个<strong>给定对象的自身可枚举属性（不包括可枚举属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><p>看下面的题目，输出对象中值大于2的key的数组，即期待输出的结果为：<code>[“c”,”d”]</code>请问xxx处填什么？：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> xxx ;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>正确答案：xxx处应该填入<code>data[x] &lt; 2</code>，即代码修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> data[x] &gt; 2;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>Object.keys()</code>是ES5中新增的方法，用来<strong>获取对象自身所有的可枚举的属性名</strong>，但<strong>不包括原型中的属性</strong>，然后返回一个<strong>由属性名组成的数组</strong>。</p></li><li>注意它同<code>for..in</code>一样<strong>不能保证属性按对象原来的顺序输出</strong>。数组中<strong>属性名的排列顺序和使用<code>for..in</code>循环遍历该对象时返回的顺序一致</strong>。</li><li><code>Array.filter(function)</code>对数组进行过滤返回符合条件的数组。</li><li><p>更多例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// simple array</span><br><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">console.log(Object.keys(arr)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object</span><br><span class="line">var obj = &#123; 0: <span class="string">'a'</span>, 1: <span class="string">'b'</span>, 2: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(obj)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object with random key ordering</span><br><span class="line">var anObj = &#123; 100: <span class="string">'a'</span>, 2: <span class="string">'b'</span>, 7: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(anObj)); // console: [<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'100'</span>]</span><br><span class="line"></span><br><span class="line">// getFoo is a property <span class="built_in">which</span> isn<span class="string">'t enumerable</span></span><br><span class="line"><span class="string">var myObj = Object.create(&#123;&#125;, &#123;</span></span><br><span class="line"><span class="string">    getFoo: &#123;</span></span><br><span class="line"><span class="string">        value: function () &#123; return this.foo; &#125;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">myObj.foo = 1;</span></span><br><span class="line"><span class="string">console.log(Object.keys(myObj)); // console: ['</span>foo<span class="string">']</span></span><br></pre></td></tr></table></figure></li><li><p>如果想获取一个对象的所有属性，甚至包括不可枚举的，应使用<code>Object.getOwnPropertyNames</code>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在ES5里，如果<strong>此方法的参数不是对象（而是一个原始值）</strong>，那么它<strong>会抛出 TypeError</strong>。</li><li>在ES2015中，非对象的参数将被强制转换为一个对象。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]                   (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.keys()&lt;/code&gt;方法会返回一个由一个&lt;strong&gt;给定对象的自身可枚举属性（不包括可枚举属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
</feed>
