<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-09-14T14:28:59.643Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript事件（二）事件处理程序</title>
    <link href="https://chongtianhong.github.io/2018/06/16/eventHandler/"/>
    <id>https://chongtianhong.github.io/2018/06/16/eventHandler/</id>
    <published>2018-06-16T03:44:32.000Z</published>
    <updated>2018-09-14T14:28:59.643Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><ul><li><a href="http://xbhong.top/2018/06/15/eventFlow/#more" target="_blank" rel="noopener">JavaScript事件（一）事件流</a>中提到，事件是<strong>用户</strong>或<strong>浏览器自身</strong>执行的某种动作，如<code>click</code>，<code>load</code>和<code>mouseover</code>都是事件的名字。</li><li><strong>响应某个事件的函数</strong>就叫<strong>事件处理程序</strong>（也叫事件处理函数、事件句柄）。<a id="more"></a></li><li>事件处理程序的名字以”on”开头，因此<code>click</code>事件的事件处理程序就是<strong>onclick</strong>，<code>load</code>事件的事件处理程序就是<strong>onload</strong>。</li><li><strong>为事件指定事件处理程序的方法</strong>主要有3种，分别是<strong>HTML事件处理程序</strong>、<strong>DOM0级事件处理程序</strong>和<strong>DOM2级事件处理程序</strong>。</li></ul><h5 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h5><ul><li>事件直接加在HTML元素上。这种方式也有两种方法，都很简单：</li><li><p>第一种：直接<strong>在HTML元素中定义事件处理程序及包含的动作</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span> onclick=<span class="string">"alert('clicked!')"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二种：HTML元素中定义事件处理程序，<strong>执行的动作</strong>则<strong>调用其他地方定义的脚本</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span> onclick=<span class="string">"showMessage()"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">showMessage</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>知识点：<br>1）通过<strong>event变量</strong>可以<strong>直接访问事件本身</strong>，比如<code>onclick=”alert(event.type)”</code>会弹出<code>click</code>事件。<br>2）<strong>this值等于事件的目标元素</strong>，这里目标元素是input。比如<code>onclick=”alert(this.value)”</code>可以得到input元素的value值。</p></li></ul><h5 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h5><ul><li>把一个<strong>函数赋值</strong>给一个<strong>事件处理程序属性</strong>。**</li><li>这种方法简单而且跨浏览器，但是<strong>只能为一个元素添加一个事件处理函数</strong>，即这种方法<strong>无法为元素添加多个相同事件的事件处理函数</strong>，则<strong>后面的会覆盖前面的</strong>。</li><li><p><strong>添加</strong>事件处理程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">/*</span><br><span class="line">    第一步：myBtn = document.getElementById(<span class="string">"myBtn"</span>);取得btn对象</span><br><span class="line">    第二步：myBtn.onclick其实相当于给myBtn添加了一个onclick的属性。</span><br><span class="line">    第三步：myBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    把函数赋值给onclick事件处理程序属性。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong>事件处理程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myBtn.onclick = null;</span><br></pre></td></tr></table></figure></li></ul><h5 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h5><ul><li>DOM2级事件处理程序可以<strong>为一个元素添加多个事件处理程序</strong>。其定义了两个方法用于添加和删除事件处理程序：<code>addEventListener()</code>和<code>removeEventListener()</code>。</li><li><strong>所有的DOM节点都包含这2个方法</strong>。</li><li>这两个方法都需要3个参数：事件名，事件处理函数，布尔值。布尔值为<code>true</code>时，在捕获阶段处理事件；为<code>false</code>时，在冒泡阶段处理事件。布尔值默认为<code>false</code>。</li><li><p><strong>添加事件处理程序</strong>：现在为按钮添加两个事件处理函数，一个弹出“hello”，一个弹出“world”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"world"</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除事件处理程序</strong>：通过<code>addEventListener()</code>添加的事件处理程序必须通过<code>removeEventListener()</code>删除，且<strong>参数一致</strong>。</p></li><li><p><strong>注意</strong>：通过<code>addEventListener()</code>添加的<strong>匿名函数将无法删除</strong>。下面这段代码将不起作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myBtn.removeEventListener(<span class="string">"click"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(<span class="string">"world"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>看似该<code>removeEventListener()</code>与上面的<code>addEventListener()</code>参数一致，实则<strong>第二个参数中匿名函数是完全不同的</strong>。所以<strong>为了能删除事件处理程序</strong>，代码可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handler = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">    myBtn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4><h5 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h5><ul><li><strong>IE8及以下浏览器不支持<code>addEventListener()</code></strong>，在实际开发中如果要兼容到IE8及以下浏览器。</li><li><p>如果用原生的绑定事件，需要做兼容处理，可利用jquery的bind代替。语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).<span class="built_in">bind</span>(event, data, <span class="keyword">function</span>)</span><br></pre></td></tr></table></figure></li><li><p>其中：</p><ul><li>event是必需的。规定添加到元素的一个或多个事件。可由空格分隔多个事件。必须是有效的事件。</li><li>data是可选的。规定传递到函数的额外数据。</li><li>function是必需的。规定当事件发生时运行的函数。</li></ul></li><li>例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).<span class="built_in">bind</span>(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    $(<span class="string">"p"</span>).slideToggle();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h5 id="IE8事件绑定"><a href="#IE8事件绑定" class="headerlink" title="IE8事件绑定"></a>IE8事件绑定</h5><ul><li>IE8及以下版本浏览器实现了与DOM中类似的两个方法：<code>attachEvent()</code>和<code>detachEvent()</code>。</li><li>这两个方法都需要两个参数：<strong>事件处理程序名称</strong>和<strong>事件处理程序函数</strong>。由于<strong>IE8及更早版本只支持事件冒泡</strong>，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。</li><li><strong>注意</strong>是<strong>事件处理程序名称</strong>而不是事件名称，所以要加上on，是<strong>onclick</strong>而不是click。</li><li>知识点：<ul><li>IE11只支持<code>addEventListener</code>。</li><li>IE9，IE10对<code>attachEvent</code>和<code>addEventListener</code>都支持。</li><li>IE8及以下版本只支持<code>attachEvent</code>。</li></ul></li><li><p>可以拿下面代码在IE各个版本浏览器中进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handlerIE = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"helloIE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    var handlerDOM = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(<span class="string">"helloDOM"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, handlerDOM, <span class="literal">false</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, handlerIE);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加事件处理程序</strong>：现在为按钮添加两个事件处理函数，一个弹出“hello”，一个弹出“world”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"world"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>这里运行效果值得注意一下：</p><ul><li><strong>IE8以下浏览器</strong>中先弹出“world”，再弹出“hello”。<strong>和DOM中事件触发顺序相反</strong>。</li><li><strong>IE9及以上浏览器</strong>先弹出“hello”，再弹出“world”。<strong>和DOM中事件触发顺序相同</strong>。</li></ul></li><li><strong>删除事件处理程序</strong>：通过<code>attachEvent</code>添加的事件处理程序必须通过<code>detachEvent</code>方法删除，且参数一致。</li><li><p>和DOM事件一样，<strong>添加的匿名函数将无法删除</strong>。所以为了能删除事件处理程序，代码可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handler = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">    myBtn.detachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>IE事件处理程序中还有一个地方需要注意：<strong>作用域</strong>。</p></li><li>使用<code>attachEvent</code>方法，事件处理程序会在全局作用域中运行，因此<strong>this等于window</strong>。在编写跨浏览器的代码时，需牢记这点。</li><li>而DOM2或DOM20级的方法<strong>作用域都是在元素内部，this值为目标元素</strong>。</li><li>下面例子会弹出true：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(this === window);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件处理程序&quot;&gt;&lt;a href=&quot;#事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;事件处理程序&quot;&gt;&lt;/a&gt;事件处理程序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://xbhong.top/2018/06/15/eventFlow/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript事件（一）事件流&lt;/a&gt;中提到，事件是&lt;strong&gt;用户&lt;/strong&gt;或&lt;strong&gt;浏览器自身&lt;/strong&gt;执行的某种动作，如&lt;code&gt;click&lt;/code&gt;，&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;mouseover&lt;/code&gt;都是事件的名字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应某个事件的函数&lt;/strong&gt;就叫&lt;strong&gt;事件处理程序&lt;/strong&gt;（也叫事件处理函数、事件句柄）。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（一）事件流</title>
    <link href="https://chongtianhong.github.io/2018/06/15/eventFlow/"/>
    <id>https://chongtianhong.github.io/2018/06/15/eventFlow/</id>
    <published>2018-06-15T02:09:33.000Z</published>
    <updated>2018-09-14T14:09:43.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul><li>事件是在<strong>文档</strong>或者<strong>浏览器窗口</strong>中发生的，特定的交互瞬间。</li><li>事件是<strong>用户</strong>或<strong>浏览器自身</strong>执行的某种动作，如<code>click</code>，<code>load</code>和<code>mouseover</code>都是事件的名字。<a id="more"></a></li><li>事件是<strong>JavaScript</strong>和<strong>DOM</strong>之间<strong>交互的桥梁</strong>。</li><li>事件发生，调用它的处理函数执行相应的JavaScript代码给出响应（你若触发，我便执行）。</li><li>典型的例子有：<strong>页面加载完毕</strong>触发<code>load</code>事件；<strong>用户单击元素</strong>触发<code>click</code>事件。</li></ul><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><ul><li>事件流描述的是<strong>从页面中接收事件的顺序</strong>。</li></ul><h5 id="事件流感性认识"><a href="#事件流感性认识" class="headerlink" title="事件流感性认识"></a>事件流感性认识</h5><ul><li><strong>问题</strong>：单击页面元素，什么样的元素能感应到这样一个事件？</li><li><strong>答案</strong>：单击元素的同时，也单击了元素的容器元素，甚至整个页面。</li><li><strong>例子</strong>：有三个同心圆， 给每个圆添加对应的事件处理函数，弹出对应的文字。单击最里面的圆，同时也单击了外面的圆，所以外面圆的<code>click</code>事件也会被触发。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="comment">#outer&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 400px;</span><br><span class="line">                height: 400px;</span><br><span class="line">                top:0;</span><br><span class="line">                left: 0;</span><br><span class="line">                bottom:0;</span><br><span class="line">                right: 0;</span><br><span class="line">                margin: auto;</span><br><span class="line">                background-color: deeppink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#middle&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height:300px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left: 50%;</span><br><span class="line">                margin-left: -150px;</span><br><span class="line">                margin-top: -150px;</span><br><span class="line">                background-color: deepskyblue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#inner&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height:100px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left:50%;</span><br><span class="line">                margin-left: -50px;</span><br><span class="line">                margin-top: -50px;;</span><br><span class="line">                background-color: darkgreen;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">                color:white;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#outer,#middle,#inner&#123;</span></span><br><span class="line">                border-radius:100%;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">            &lt;div id=<span class="string">"middle"</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">"inner"</span>&gt;</span><br><span class="line">                    click me!</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var innerCircle = document.getElementById(<span class="string">"inner"</span>);</span><br><span class="line">            innerCircle.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"innerCircle"</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            var middleCircle = document.getElementById(<span class="string">"middle"</span>);</span><br><span class="line">            middleCircle.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                alert(<span class="string">"middleCircle"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            var outerCircle = document.getElementById(<span class="string">"outer"</span>);</span><br><span class="line">            outerCircle.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"outerCircle"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="事件流-1"><a href="#事件流-1" class="headerlink" title="事件流"></a>事件流</h5><ul><li>事件发生时会在<strong>元素节点</strong>与<strong>根节点</strong>之间<strong>按照特定的顺序传播</strong>，<strong>路径所经过的所有节点</strong>都会<strong>收到该事件</strong>，这个传播过程即<strong>DOM事件流</strong>。</li></ul><h6 id="两种事件流模型"><a href="#两种事件流模型" class="headerlink" title="两种事件流模型"></a>两种事件流模型</h6><ul><li><strong>事件传播的顺序</strong>对应<strong>浏览器的两种事件流模型</strong>：<strong>捕获型</strong>事件流和<strong>冒泡型</strong>事件流。</li><li><strong>冒泡型</strong>事件流：事件的传播是从<strong>最特定的事件目标</strong>到最不特定的事件目标。即从DOM树的叶子到根。【推荐】</li><li><strong>捕获型</strong>事件流：事件的传播是从<strong>最不特定的事件目标</strong>到最特定的事件目标。即从DOM树的根到叶子。</li><li><p><strong>事件捕获</strong>的思想就是<strong>不太具体的节点应该更早接收到事件</strong>，而<strong>最具体的节点最后接收到事件</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"myDiv"</span>&gt;Click me!&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>上面这段html代码中，单击了页面中的&lt;div&gt;元素，</p></li><li>在<strong>冒泡型事件流</strong>中<code>click</code>事件传播顺序为：&lt;div&gt;—》&lt;body&gt;—》&lt;html&gt;—》document</li><li>在<strong>捕获型事件流</strong>中<code>click</code>事件传播顺序为：document—》&lt;html&gt;—》&lt;body&gt;—》&lt;div&gt;<br><img src="/images/eventflow1.png" alt="两种事件流模型" width="600" style="border:none"></li><li>总结：<br>1）<strong>所有现代浏览器都支持事件冒泡</strong>，但在<strong>具体实现中略有差别</strong>：<br>IE5.5及更早版本中事件冒泡会跳过<html>元素(从body直接跳到document)。<br>IE9、Firefox、Chrome、和Safari则将事件一直冒泡到window对象。<br>2）IE9、Firefox、Chrome、Opera、和Safari都支持事件捕获。尽管DOM标准要求事件应该从document对象开始传播，但这些浏览器<strong>都是从window对象开始捕获事件的</strong>。<br>3）由于老版本浏览器不支持，很少有人使用事件捕获。<strong>建议使用事件冒泡</strong>。</html></li></ul><h6 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h6><ul><li>DOM标准采用<strong>捕获+冒泡</strong>。两种事件流都会触发DOM的所有对象，<strong>从document对象开始</strong>，也<strong>在document对象结束</strong>。<br><img src="/images/eventflow2.png" alt="DOM事件流" width="400" style="border:none"></li><li>DOM标准规定<strong>事件流包括三个阶段</strong>：事件捕获阶段、处于目标阶段和事件冒泡阶段。<ul><li><strong>事件捕获阶段</strong>：实际目标（&lt;div&gt;）在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。上图中为1~3。</li><li><strong>处于目标阶段</strong>：事件在&lt;div&gt;上发生并处理。<strong>绑定在目标元素上的事件按绑定顺序依次触发</strong>。</li><li><strong>冒泡阶段</strong>：事件又传播回文档。</li></ul></li><li><strong>注意</strong>：并非所有的事件都会经过冒泡阶段。<strong>所有的事件</strong>都要经过<strong>捕获阶段</strong>和<strong>处于目标阶段</strong>，但是<strong>有些事件会跳过冒泡阶段</strong>：如，获得输入焦点的<code>focus</code>事件和失去输入焦点的<code>blur</code>事件。</li><li><p>DOM事件流例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="comment">#outer&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 400px;</span><br><span class="line">                height: 400px;</span><br><span class="line">                top:0;</span><br><span class="line">                left: 0;</span><br><span class="line">                bottom:0;</span><br><span class="line">                right: 0;</span><br><span class="line">                margin: auto;</span><br><span class="line">                background-color: deeppink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#middle&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height:300px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left: 50%;</span><br><span class="line">                margin-left: -150px;</span><br><span class="line">                margin-top: -150px;</span><br><span class="line">                background-color: deepskyblue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#inner&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height:100px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left:50%;</span><br><span class="line">                margin-left: -50px;</span><br><span class="line">                margin-top: -50px;;</span><br><span class="line">                background-color: darkgreen;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">                color:white;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#outer,#middle,#inner&#123;</span></span><br><span class="line">                border-radius:100%;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">            &lt;div id=<span class="string">"middle"</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">"inner"</span>&gt;</span><br><span class="line">                    click me!</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var innerCircle = document.getElementById(<span class="string">"inner"</span>);</span><br><span class="line">            innerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"innerCircle的click事件在捕获阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            innerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"innerCircle的click事件在冒泡阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line">            var middleCircle = document.getElementById(<span class="string">"middle"</span>);</span><br><span class="line">            middleCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"middleCircle的click事件在捕获阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            middleCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"middleCircle的click事件在冒泡阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line">            var outerCircle = document.getElementById(<span class="string">"outer"</span>);</span><br><span class="line">            outerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"outerCircle的click事件在捕获阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            outerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"outerCircle的click事件在冒泡阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>当点击id为inner的圆时，运行效果就是会陆续弹出6个框，结果如下图所示：<br><img src="/images/eventflow3.png" alt="运行结果" width="600" style="border:none"></p><h6 id="事件流的典型应用：事件代理"><a href="#事件流的典型应用：事件代理" class="headerlink" title="事件流的典型应用：事件代理"></a>事件流的典型应用：事件代理</h6></li><li><strong>传统的事件处理</strong>中，需要为<strong>每个元素</strong>添加事件处理器。</li><li>JS<strong>事件代理</strong>则是一种简单有效的技巧，通过它可以<strong>把事件处理器添加到一个父级元素上</strong>，从而<strong>避免把事件处理器添加到多个子级元素上</strong>。</li></ul><blockquote>事件代理</blockquote><ul><li><strong>事件代理的原理</strong>用到的就是事件冒泡和目标元素，<strong>把事件处理器添加到父元素，等待子元素事件冒泡</strong>，并<strong>且父元素能够通过target（IE为srcElement）判断是哪个子元素</strong>，从而<strong>做相应处理</strong>。</li><li><p>传统事件处理，为每个元素添加事件处理器，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul id=<span class="string">"color-list"</span>&gt;</span><br><span class="line">        &lt;li&gt;red&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;orange&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;yellow&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;green&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;blue&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;indigo&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;purple&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            var colorList = document.getElementById(<span class="string">"color-list"</span>);</span><br><span class="line">            var colors = colorList.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">            <span class="keyword">for</span>(var i  = 0; i &lt; colors.length; i++) &#123;</span><br><span class="line">                colors[i].addEventListener(<span class="string">'click'</span>, showColor, <span class="literal">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">function</span> showColor(e) &#123;</span><br><span class="line">                e = e || window.event;</span><br><span class="line">                var targetElement = e.target || e.srcElement;</span><br><span class="line">                alert(targetElement.innerHTML);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件代理</strong>的处理方式，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul id=<span class="string">"color-list"</span>&gt;</span><br><span class="line">        &lt;li&gt;red&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;orange&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;yellow&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;green&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;blue&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;indigo&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;purple&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            var colorList = document.getElementById(<span class="string">"color-list"</span>);</span><br><span class="line">            colorList.addEventListener(<span class="string">'click'</span>, showColor, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">function</span> showColor(e) &#123;</span><br><span class="line">                e = e || window.event;</span><br><span class="line">                var targetElement = e.target || e.srcElement;</span><br><span class="line">                <span class="keyword">if</span>(targetElement.nodeName.toLowerCase() === <span class="string">"li"</span>)&#123;</span><br><span class="line">                    alert(targetElement.innerHTML);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>事件代理的好处</blockquote><ul><li>在<strong>传统的事件处理</strong>中，需要<strong>为每一个元素添加</strong>或者是<strong>删除事件处理器</strong>。然而，事件处理器<strong>将有可能导致内存泄露或者是性能下降</strong>（用得越多这种风险就越大）。</li><li><strong>事件代理的好处</strong>总结如下：<ul><li><strong>将多个事件处理器减少到一个</strong>，因为事件处理器要驻留内存，这样就<strong>提高了性能</strong>。想象如果有一个100行的表格，对比传统的为每个单元格绑定事件处理器的方式和事件代理（即table上添加一个事件处理器），不难得出结论，事件代理确实避免了一些潜在的风险，提高了性能。</li><li><strong>DOM更新无需重新绑定事件处理器</strong>，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a, span, div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历。</li></ul></li></ul><blockquote>事件代理的问题</blockquote><ul><li><p>代码如下：事件代理同时绑定了li和span，当点击span的时候，li和span都会冒泡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;</span><br><span class="line">    &lt;span&gt;li中的span的内容&lt;/span&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(document).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">        alert(<span class="string">'li li'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(document).on(<span class="string">'click'</span>, <span class="string">'span'</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">        alert(<span class="string">'li span'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>解决方法一：span的事件处理程序中阻止冒泡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(<span class="string">'click'</span>, <span class="string">'span'</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">    alert(<span class="string">'li span'</span>);</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>解决方法二：li的事件处理程序中检测target元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.target.nodeName == <span class="string">'SPAN'</span>) &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'li li'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote>事件代理的一个有趣应用</blockquote><ul><li>点击一个列表时，输出对应的索引：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var ul = document.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">    var lis = ul.querySelectorAll(<span class="string">'ul li'</span>);</span><br><span class="line">    ul.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">        var target = e.target;</span><br><span class="line">        <span class="keyword">if</span>(target.nodeName.toUpperCase() === <span class="string">'LI'</span>)&#123;</span><br><span class="line">            alert([].indexOf.call(lis, target));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><div class="note info">参考链接：<a href="http://www.cnblogs.com/starof/p/4066381.html" target="_blank" rel="noopener">http://www.cnblogs.com/starof/p/4066381.html</a></div>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;事件是在&lt;strong&gt;文档&lt;/strong&gt;或者&lt;strong&gt;浏览器窗口&lt;/strong&gt;中发生的，特定的交互瞬间。&lt;/li&gt;
&lt;li&gt;事件是&lt;strong&gt;用户&lt;/strong&gt;或&lt;strong&gt;浏览器自身&lt;/strong&gt;执行的某种动作，如&lt;code&gt;click&lt;/code&gt;，&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;mouseover&lt;/code&gt;都是事件的名字。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Cookie知识点整理</title>
    <link href="https://chongtianhong.github.io/2018/06/14/cookie/"/>
    <id>https://chongtianhong.github.io/2018/06/14/cookie/</id>
    <published>2018-06-14T11:40:07.000Z</published>
    <updated>2018-09-13T15:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Cookie 是<strong>服务器保存在浏览器</strong>的一小段文本信息。<strong>浏览器每次向服务器发出请求</strong>，就会<strong>自动附上这段信息</strong>。<a id="more"></a></li></ul><h5 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h5><ul><li>Cookie 主要用来<strong>分辨两个请求是否来自同一个浏览器</strong>。</li><li>Cookie 可用来<strong>保存一些状态信息</strong>，例如：<ul><li>对话（session）管理：保存<strong>登录</strong>、<strong>购物车</strong>等需要记录的信息。</li><li>个性化：<strong>保存用户的偏好</strong>，比如网页的字体大小、背景色等等。</li><li>追踪：<strong>记录和分析用户行为</strong>。</li></ul></li><li><strong>不推荐</strong>使用Cookie作为<strong>客户端存储</strong>，原因：<ul><li>它的容量很小（4KB）</li><li>缺乏数据操作接口</li><li>影响性能</li></ul></li><li>客户端储存应该使用<strong>Web storage API</strong>和<strong>IndexedDB</strong>。</li></ul><h5 id="Cookie的组成"><a href="#Cookie的组成" class="headerlink" title="Cookie的组成"></a>Cookie的组成</h5><ul><li>Cookie 包含以下几方面的信息：<ul><li>Cookie 的<strong>名字Name</strong></li><li>Cookie 的<strong>值Value</strong>（真正的数据写在这里面）(1、2两点就是键值对)</li><li><strong>到期时间Expire</strong>[属性]</li><li><strong>所属域名Domain</strong>（默认是当前域名）[属性]</li><li><strong>生效的路径Path</strong>（默认是当前网址）[属性]</li><li>Cookie 的<strong>容量</strong>[属性]</li></ul></li></ul><h5 id="Cookie的作用过程"><a href="#Cookie的作用过程" class="headerlink" title="Cookie的作用过程"></a>Cookie的作用过程</h5><ul><li>举例来说：<ul><li>当用户访问网址<code>www.example.com</code>，<strong>服务器</strong>就会<strong>在浏览器写入一个 Cookie</strong>。这个<strong>Cookie</strong>就会<strong>包含</strong><code>www.example.com</code>这个<strong>域名</strong>，以及<strong>根路径</strong>。(这意味着，这个 Cookie 对该域名的根路径和它的所有子路径都有效。如果路径设为/forums，那么这个 Cookie 只有在访问www.example.com/forums及其子路径时才有效。)</li><li>浏览器存储了Cookie以后，一旦<strong>再次访问</strong>这个<strong>路径</strong>，<strong>浏览器就会附上这段 Cookie 发送给服务器</strong>。</li></ul></li></ul><h5 id="Cookies作用范围"><a href="#Cookies作用范围" class="headerlink" title="Cookies作用范围"></a>Cookies作用范围</h5><ul><li><strong>浏览器的同源政策</strong>规定，两个网址只要<strong>域名相同</strong>和<strong>端口相同</strong>，就可以<strong>共享 Cookie</strong>。</li><li><strong>注意</strong>：这里<strong>不要求协议相同</strong>。也就是说，通过<code><a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></code>设置的 Cookie，可以被<code><a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></code>读取。</li></ul><h4 id="HTTP-协议中的Cookie"><a href="#HTTP-协议中的Cookie" class="headerlink" title="HTTP 协议中的Cookie"></a>HTTP 协议中的Cookie</h4><h5 id="HTTP-响应：Cookie-的生成-服务器端生成cookies"><a href="#HTTP-响应：Cookie-的生成-服务器端生成cookies" class="headerlink" title="HTTP 响应：Cookie 的生成(服务器端生成cookies)"></a>HTTP 响应：Cookie 的生成(服务器端生成cookies)</h5><ul><li><p>服务器如果希望在浏览器保存 Cookie，就要在<strong>HTTP 响应</strong>的<strong>头信息</strong>里面，放置一个<code>Set-Cookie</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:foo=bar</span><br></pre></td></tr></table></figure></li><li><p>上面代码会在浏览器保存一个名为<code>foo</code>的 Cookie，它的值为<code>bar</code>。(设置的格式为:<code>&lt;键(名)&gt;=&lt;值&gt;</code>)</p></li><li><p>HTTP 响应<strong>可以包含多个<code>Set-Cookie</code>字段</strong>，即在浏览器生成多个 Cookie。下面是一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure></li><li><p>除了 Cookie 的值，<code>Set-Cookie</code>字段还可以<strong>附加 Cookie 的属性</strong>。</p></li><li>一个<code>Set-Cookie</code>字段里面，可以同时包括多个属性，<strong>没有次序的要求</strong>。</li><li><p>下面是设置一个Cookie的例子：除了名与它的值，还包含<code>Domain</code>属性<code>Secure</code>属性和<code>HttpPnly</code>属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnly</span><br></pre></td></tr></table></figure></li><li><p>除了<code>键=值</code>来设置cookie的名字和值之外，还可以设置属性：</p><ul><li><code>Expires</code>，<code>Max-Age</code>用来<strong>设置cookie持续时间</strong>。</li><li><code>Domain</code>，<code>Path</code>设置<strong>发送http请求时</strong>哪些<strong>域名</strong>和<strong>路径</strong>需要附带这个Cookie。</li><li><code>Secure</code>属性指定浏览器只有在<strong>加密协议 HTTPS</strong>下才能发送。</li><li><code>HttpOnly</code>属性指定该 Cookie 无法通过<strong>JavaScript 脚本</strong>拿到。</li></ul></li></ul><h5 id="HTTP-请求：Cookie-的发送-浏览器发送Cookie"><a href="#HTTP-请求：Cookie-的发送-浏览器发送Cookie" class="headerlink" title="HTTP 请求：Cookie 的发送(浏览器发送Cookie)"></a>HTTP 请求：Cookie 的发送(浏览器发送Cookie)</h5><ul><li><p>浏览器向服务器<strong>发送 HTTP 请求</strong>时，每个请求都会<strong>带上相应的 Cookie</strong>。也就是说，把<strong>服务器早前保存在浏览器</strong>的这段信息，再发回服务器。这时要使用<strong>HTTP 头信息的Cookie字段</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: foo=bar</span><br></pre></td></tr></table></figure></li><li><p>上面代码会向服务器发送名为<code>foo</code>的 Cookie，值为<code>bar</code>。</p></li><li><p><strong>Cookie字段</strong>可以<strong>包含多个 Cookie</strong>，使用分号（;）分隔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: name=value; name2=value2; name3=value3</span><br></pre></td></tr></table></figure></li><li><p>下面是一个Http请求的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure></li><li><p>服务器收到浏览器发来的 Cookie 时，有两点是无法知道的(因为这些<strong>Cookie的属性只保存在浏览器上</strong>)：</p><ul><li>Cookie 的<strong>各种属性</strong>，比如何时过期。</li><li><strong>哪个域名设置的 Cookie</strong>，到底是一级域名设的，还是某一个二级域名设的。</li></ul></li></ul><h4 id="document-cookie读写当前网页的Cookie"><a href="#document-cookie读写当前网页的Cookie" class="headerlink" title="document.cookie读写当前网页的Cookie"></a>document.cookie读写当前网页的Cookie</h4><h5 id="读Cookie"><a href="#读Cookie" class="headerlink" title="读Cookie"></a>读Cookie</h5><ul><li><strong>读取的时候</strong>，它会返回当前网页的所有 Cookie，前提是<strong>该 Cookie 不能有<code>HTTPOnly</code>属性</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie // <span class="string">"foo=bar;baz=bar"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="写Coookie"><a href="#写Coookie" class="headerlink" title="写Coookie"></a>写Coookie</h5><ul><li><code>document.cookie</code>属性是可写的，可以通过它<strong>为当前网站添加 Cookie</strong>。</li><li><p>但是，<code>document.cookie</code><strong>一次只能写入一个 Cookie</strong>，而且<strong>写入</strong>并不是覆盖，而<strong>是添加</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">'test1=hello'</span>;</span><br><span class="line">document.cookie = <span class="string">'test2=world'</span>;</span><br><span class="line">document.cookie</span><br><span class="line">// test1=hello;test2=world</span><br></pre></td></tr></table></figure></li><li><p>写入 Cookie 的时候，可以一起写入 Cookie 的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">"foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT"</span>;</span><br></pre></td></tr></table></figure></li><li><p>各个属性的写入注意点如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path属性必须为绝对路径，默认为当前路径。</span><br><span class="line">domain属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是example.com，就不能将其设为foo.com。该属性默认为当前的一级域名（不含二级域名）。</span><br><span class="line">max-age属性的值为秒数。</span><br><span class="line">expires属性的值为 UTC 格式，可以使用Date.prototype.toUTCString()进行日期格式转换。</span><br></pre></td></tr></table></figure></li><li><p><code>document.cookie</code>写入 Cookie 的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">'fontSize=14; '</span></span><br><span class="line">  + <span class="string">'expires='</span> + someDate.toGMTString() + <span class="string">'; '</span></span><br><span class="line">  + <span class="string">'path=/subdirectory; '</span></span><br><span class="line">  + <span class="string">'domain=*.example.com'</span>;</span><br></pre></td></tr></table></figure></li><li><p>Cookie 的属性一旦设置完成，就<strong>没有办法读取这些属性的值</strong>。</p></li></ul><h5 id="Cookie-的删除"><a href="#Cookie-的删除" class="headerlink" title="Cookie 的删除"></a>Cookie 的删除</h5><ul><li><p>使用<code>document.cookie</code>实现<strong>删除一个现存 Cookie</strong>的唯一方法，是<strong>设置</strong>它的<strong><code>expires</code>属性</strong>为一个<strong>过去的日期</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">'fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT'</span>;</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，名为<code>fontSize</code>的 Cookie 的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Cookie 是&lt;strong&gt;服务器保存在浏览器&lt;/strong&gt;的一小段文本信息。&lt;strong&gt;浏览器每次向服务器发出请求&lt;/strong&gt;，就会&lt;strong&gt;自动附上这段信息&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="cookie" scheme="https://chongtianhong.github.io/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>循环下的正则匹配？说说正则中的lastIndex</title>
    <link href="https://chongtianhong.github.io/2018/06/13/regExpMatchingUnderCycles/"/>
    <id>https://chongtianhong.github.io/2018/06/13/regExpMatchingUnderCycles/</id>
    <published>2018-06-13T01:40:12.000Z</published>
    <updated>2018-09-12T02:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><ul><li><p>最近在使用正则匹配的时候，我遇到一个非常有意思的现象，代码如下所示：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/g;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'test2.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'test4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item)));</span><br></pre></td></tr></table></figure></li><li><p>这段代码很好理解：它的规则就是判断字符串中是否含有<code>.jpg</code>，然后再循环地和数组中的字符串进行匹配，打印出结果。</p></li><li><p>一开始认为输出的结果应该全为<code>true</code>，然而，它的结果是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>代码的执行结果非常神奇：它并没有全部打印<code>true</code>，而是<strong>交替打印</strong><code>true</code>和<code>false</code>值，这到底是为什么？</p></li><li>为了查清楚到底是怎么回事，我开始上网搜索相关资料，经过一番搜索后，发现正则并没有我们想象的那么简单…</li></ul><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><ul><li>首先正则有一个<code>lastIndex</code>属性，它表示<strong>正则下一次匹配时的起始位置</strong>。一般情况下我们是使用不到它的，但<strong>在正则中包含全局标志g时，正则的test和exec方法就会使用到它</strong>，具体规则如下：<ul><li>初始状态下<code>lastIndex</code>的值为0；</li><li>若成功匹配，<code>lastIndex</code>的值就被更新成<strong>被匹配字符串后面的第一个字符的<code>index</code></strong>，或者可理解为被匹配字符串的最后一个字符<code>index + 1</code>；</li><li>若匹配失败，<code>lastIndex</code>则被重置为0；</li><li>如果我们<strong>继续使用原先的正则进行下一轮匹配</strong>，它则会<strong>从字符串<code>lastIndex</code>的位置开始进行</strong>。</li></ul></li><li>为验证这个结论，我特意做了三个实验：</li></ul><blockquote>实验一</blockquote><ul><li><p>直接将正则的<code>lastIndex</code>打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/g;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'test2.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'test4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item), reg.lastIndex));</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> 9</span><br><span class="line"><span class="literal">false</span> 0</span><br><span class="line"><span class="literal">true</span> 9</span><br><span class="line"><span class="literal">false</span> 0</span><br><span class="line"><span class="literal">true</span> 9</span><br></pre></td></tr></table></figure></li><li><p>从实验结果可以看到，由于数组中字符串的长度都是一致的，成功匹配后<code>lastIndex</code>的值直接更新为9，下次匹配的时候直接从第10个字符开始，因此<strong>匹配失败，<code>lastIndex</code>重置为0</strong>。以此类推，最终以9、0、9的形式<strong>交替打印</strong>。</p></li></ul><blockquote>实验二</blockquote><ul><li><p>对数组中的字符串稍作修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/g;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item), reg.lastIndex));</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> 9</span><br><span class="line"><span class="literal">true</span> 13</span><br><span class="line"><span class="literal">false</span> 0</span><br><span class="line"><span class="literal">true</span> 13</span><br><span class="line"><span class="literal">false</span> 0</span><br></pre></td></tr></table></figure></li><li><p>从实验结果可以看到，由于我们增加了部分字符串的长度，因此对于第2、4个字符串而言，即使从第9个字符开始匹配，依然能匹配到后边的<code>.jpg</code>，故<code>lastIndex</code>继续更新到13。</p></li></ul><blockquote>实验三</blockquote><ul><li><p>对正则表达式进行修改，去掉全局匹配模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item), reg.lastIndex));</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br></pre></td></tr></table></figure></li><li><p>可以看到，<strong>当正则中不包含全局标志g时</strong>，正则的<code>test</code>方法的<code>lastIndex</code>每一次判断时都为0，即不起作用，因此都能匹配到结果。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>使用正则的时候还是要多加小心，对于<code>test</code>和<code>exec</code>方法，最好还是<strong>不要随意加上全局标志g</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最近在使用正则匹配的时候，我遇到一个非常有意思的现象，代码如下所示：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="正则表达式" scheme="https://chongtianhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离内容介绍</title>
    <link href="https://chongtianhong.github.io/2018/06/12/frontEndSeparation/"/>
    <id>https://chongtianhong.github.io/2018/06/12/frontEndSeparation/</id>
    <published>2018-06-12T06:20:54.000Z</published>
    <updated>2018-09-11T07:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>由于Node.js的逐渐成熟和日趋稳定，越来越多的公司中的前端团队开始尝试使用Node.js来练一下手，尝一尝鲜。</li><li>一般的做法都是将<strong>原本属于后端的一部分相对于业务不是很重要的功能</strong>迁移到Node.js上面来，也有一些公司<strong>将Node.js作为前后端分离的一个解决方案</strong>去施行。而像淘宝网这类的大型网站也很早的完成了前后端的分离，给我们这样的后来者提供了宝贵的经验。<a id="more"></a></li><li>接下来将对前后端分离的内容进行介绍。</li></ul><h4 id="认识前后端分离"><a href="#认识前后端分离" class="headerlink" title="认识前后端分离"></a>认识前后端分离</h4><ul><li>在<strong>传统的web应用开发</strong>中，大多数的程序员会<strong>将浏览器作为前后端的分界线</strong>。将<strong>浏览器中为用户进行页面展示的部分</strong>称之为<strong>前端</strong>，而将<strong>运行在服务器，为前端提供业务逻辑和数据准备的所有代码</strong>统称为<strong>后端</strong>。</li><li>由于前后端分离这个概念相对来说刚出现不久，很多人都是只闻其声，不见其形，所以可能会对它产生一些误解，误以为前后端分离只是一种web应用开发模式，只要在web应用的开发期进行了前后端开发工作的分工就是前后端分离。</li><li>其实<strong>前后端分离并不只是开发模式，还是web应用的一种架构模式</strong>。在开发阶段，前后端工程师约定好数据交互接口，实现<strong>并行开发和测试</strong>；在运行阶段前后端分离模式需要对web应用进行<strong>分离部署</strong>，前后端之间使用HTTP或者其他协议进行交互请求。然而作为一种<strong>架构模式</strong>，我们在实施的过程中主要对以下四个方面来进行比较和重新认识。</li><li>前后端分离大概可以从四个方面来理解：<br>1、交互形式<br>2、代码组织方式<br>3、开发模式<br>4、数据接口规范流程</li></ul><h5 id="交互形式"><a href="#交互形式" class="headerlink" title="交互形式"></a>交互形式</h5><ul><li>在前后端分离架构中，<strong>后端</strong>只需要负责<strong>按照约定的数据格式向前端提供可调用的API服务</strong>即可。<strong>前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的组装和渲染，最终返回给浏览器</strong>。<br><img src="/images/frontEndSeparation1.jpg" width="600" alt="交互形式" style="border:none"></li></ul><h5 id="代码组织方式"><a href="#代码组织方式" class="headerlink" title="代码组织方式"></a>代码组织方式</h5><ul><li>在<strong>传统架构模式</strong>中，前后端代码存放于<strong>同一个代码库</strong>中，甚至是<strong>同一工程目录</strong>下。页面中还夹杂着后端代码。前后端工程师进行开发时，都必须把整个项目导入到开发工具中。<br><img src="/images/frontEndSeparation2.jpg" width="600" alt="代码组织方式" style="border:none"></li><li>而前后端分离模式在代码组织形式上有以下两种：<ul><li><strong>半分离</strong><br><strong>前后端共用一个代码库，但是代码分别存放在两个工程中</strong>。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例。</li><li><strong>分离</strong><br><strong>前后端代码库分离</strong>，前端代码中有可以进行Mock测试(通过构造虚拟测试对象以简化测试环境的方法)的伪后端，能支持前端的独立开发和测试。而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险。</li></ul></li></ul><h5 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h5><ul><li><strong>传统的MVC架构，整体没有进行前后端分离</strong>。在项目的开发阶段，前端工程师负责编写HTML，完成前端的页面设计并套页面，然后再使用模板技术将写好的前端代码转换为Smarty脚本，同时内嵌一些后端提供的模板变量和一些逻辑操作。应用运行期，将全部代码进行打包，和后端代码部署到同一服务器上，同时会进行简单的动静态分离部署。</li><li>此时，应用的开发流程如下图所示：<br><img src="/images/frontEndSeparation3.jpg" width="600" alt="开发模式1" style="border:none"></li><li>而在<strong>实现前后端分离架构之后</strong>，前端工程师只需要编写HTML、js、CSS等前端资源，然后通过HTTP请求调用后端提供的服务即可。除了<strong>开发期的分离</strong>，在<strong>运行期前后端资源</strong>也会<strong>进行分离部署</strong>。</li><li>前后端分离之后，开发流程将如下图所示。<br><img src="/images/frontEndSeparation4.jpg" width="600" alt="开发模式2" style="border:none"></li><li>通过上面的两幅流程图，不难发现，在开发模式上，前后端分离不仅仅只是工程师的分工开发，更重要的意义在于<strong>实现了前后端的并行开发，简化了开发流程</strong>。</li></ul><h5 id="数据接口规范流程"><a href="#数据接口规范流程" class="headerlink" title="数据接口规范流程"></a>数据接口规范流程</h5><ul><li>在<strong>开发期间</strong>前后端共同商定好数据接口的交互形式和数据格式。然后实现<strong>前后端的并行开发</strong>，其中前端工程师再开发完成之后可以独自进行mock测试，而后端也可以使用接口测试平台进行接口自测，然后<strong>前后端一起进行功能联调并校验格式</strong>，最终进行<strong>自动化测试</strong>。<br><img src="/images/frontEndSeparation5.jpg" width="600" alt="数据接口规范流程" style="border:none"></li></ul><h4 id="分离的四个好处"><a href="#分离的四个好处" class="headerlink" title="分离的四个好处"></a>分离的四个好处</h4><ul><li>前后端分离模式和传统的web应用架构相比有很大的不同，从目前应用软件开发的发展趋势来看，主要有两方面需要注意：<br>1、越来越<strong>注重用户体验</strong>，随着互联网的发展，开始<strong>多终端化</strong>。<br>2、大型应用架构模式正在向<strong>云化、微服务化</strong>发展。</li><li>通过前后端分离架构，可以为我们带来以下四个方面的提升：<ul><li><strong>为优质产品打造精益团队</strong><br>通过将开发团队前后端分离化，让前后端工程师只需要专注于前端或后端的开发工作，是的前后端工程师实现自治，培养其独特的技术特性，然后构建出一个全栈式的精益开发团队。</li><li><strong>提升开发效率</strong><br>前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。与此同时，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。如此一来整个应用的开发效率必然会有质的提升。</li><li><strong>完美应对复杂多变的前端需求</strong><br>如果开发团队能完成前后端分离的转型，打造优秀的前后端团队，开发独立化，让开发人员做到专注专精，开发能力必然会有所提升，能够完美应对各种复杂多变的前端需求。</li><li><strong>增强代码可维护性</strong><br>前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系。</li></ul></li><li>应用代码将会变得整洁清晰，不论是代码阅读还是代码维护都会比以前轻松。</li></ul><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><ul><li>前后端分离并非仅仅只是前后端开发的分工，而是<ul><li>在<strong>开发期</strong>进行<strong>代码存放分离</strong>、<strong>前后端开发职责分离</strong>，<strong>前后端能够独立进行开发测试</strong>；</li><li>在<strong>运行期</strong>进行<strong>应用部署分离</strong>，<strong>前后端之间通过HTTP请求进行通讯</strong>。</li></ul></li><li>前后端分离的开发模式与传统模式相比，能为我们<strong>提升开发效率、增强代码可维护性</strong>，让我们有规划地打造一个前后端并重的精益开发团队，更好地应对越来越复杂多变的Web应用开发需求。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;由于Node.js的逐渐成熟和日趋稳定，越来越多的公司中的前端团队开始尝试使用Node.js来练一下手，尝一尝鲜。&lt;/li&gt;
&lt;li&gt;一般的做法都是将&lt;strong&gt;原本属于后端的一部分相对于业务不是很重要的功能&lt;/strong&gt;迁移到Node.js上面来，也有一些公司&lt;strong&gt;将Node.js作为前后端分离的一个解决方案&lt;/strong&gt;去施行。而像淘宝网这类的大型网站也很早的完成了前后端的分离，给我们这样的后来者提供了宝贵的经验。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="前后端分离" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端有用网址收藏</title>
    <link href="https://chongtianhong.github.io/2018/06/11/webStudyLink/"/>
    <id>https://chongtianhong.github.io/2018/06/11/webStudyLink/</id>
    <published>2018-06-11T13:00:10.000Z</published>
    <updated>2018-09-12T02:22:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Web方面"><a href="#Web方面" class="headerlink" title="Web方面"></a>Web方面</h4><ul><li>JS注释规范：<a href="http://usejsdoc.org/" target="_blank" rel="noopener">http://usejsdoc.org/</a></li><li>查看HTML5是否符合大纲：<a href="https://gsnedders.html5.org/outliner/" target="_blank" rel="noopener">https://gsnedders.html5.org/outliner/</a></li><li>浏览器CSS支持情况查询：<a href="http://www.caniuse.com" target="_blank" rel="noopener">http://www.caniuse.com</a><a id="more"></a></li><li>TGideas整体WEB解决方案：<a href="http://tguide.qq.com/main/index.htm" target="_blank" rel="noopener">http://tguide.qq.com/main/index.htm</a></li><li>在线API文档：<a href="http://tool.oschina.net/apidocs/api" target="_blank" rel="noopener">http://tool.oschina.net/apidocs/api</a></li><li>剖析Vue原理：<a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006599500</a></li></ul><h4 id="学习教程或文档"><a href="#学习教程或文档" class="headerlink" title="学习教程或文档"></a>学习教程或文档</h4><ul><li>Vue.js：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></li><li>React.js：<a href="https://react.bootcss.com/" target="_blank" rel="noopener">https://react.bootcss.com/</a></li><li>MDN：<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a></li><li>w3school：<a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a></li><li>菜鸟教程：<a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a></li><li>易百教程：<a href="http://www.yiibai.com" target="_blank" rel="noopener">http://www.yiibai.com</a></li><li>瓢城WEB俱乐部：<a href="http://www.ycku.com/" target="_blank" rel="noopener">http://www.ycku.com/</a></li><li>coursera在线学习：<a href="https://www.coursera.org" target="_blank" rel="noopener">https://www.coursera.org</a></li><li>慕课网：<a href="https://www.imooc.com" target="_blank" rel="noopener">https://www.imooc.com</a></li><li>互联网工程任务组：<a href="https://tools.ietf.org" target="_blank" rel="noopener">https://tools.ietf.org</a></li></ul><h4 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h4><ul><li>牛客网：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></li><li>知乎：<a href="https://www.zhihu.com" target="_blank" rel="noopener">https://www.zhihu.com</a></li><li>掘金：<a href="https://juejin.im" target="_blank" rel="noopener">https://juejin.im</a></li><li>推酷网：<a href="http://www.tuicool.com/" target="_blank" rel="noopener">http://www.tuicool.com/</a></li><li>Vue.js中文论坛：<a href="https://forum.vuejs.org/c/chinese" target="_blank" rel="noopener">https://forum.vuejs.org/c/chinese</a></li><li>IM开发社区：<a href="http://www.52im.net/" target="_blank" rel="noopener">http://www.52im.net/</a></li><li>SegmentFault：<a href="https://segmentfault.com" target="_blank" rel="noopener">https://segmentfault.com</a></li><li>StackOverFlow：<a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li></ul><h4 id="关于图标"><a href="#关于图标" class="headerlink" title="关于图标"></a>关于图标</h4><ul><li>阿里图标：<a href="http://www.iconfont.cn" target="_blank" rel="noopener">http://www.iconfont.cn</a></li><li>IconFinder：<a href="https://www.iconfinder.com" target="_blank" rel="noopener">https://www.iconfinder.com</a></li><li>FontAwesome：<a href="https://fontawesome.com/" target="_blank" rel="noopener">https://fontawesome.com/</a></li></ul><h4 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h4><ul><li>S6教程：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li><li>Understanding ECMAScript 6：<a href="https://sagittarius-rev.gitbooks.io/understanding-ecmascript-6-zh-ver/content/" target="_blank" rel="noopener">https://sagittarius-rev.gitbooks.io/understanding-ecmascript-6-zh-ver/content/</a></li><li>Node入门：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">https://www.nodebeginner.org/index-zh-cn.html</a></li><li>Webpack入门：<a href="https://love2.io/@hfpp2012/doc/webpack-tutorial/README.md" target="_blank" rel="noopener">https://love2.io/@hfpp2012/doc/webpack-tutorial/README.md</a></li><li>Express框架：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></li><li>Koa框架：<a href="https://koa.bootcss.com/" target="_blank" rel="noopener">https://koa.bootcss.com/</a></li></ul><h4 id="色彩查询"><a href="#色彩查询" class="headerlink" title="色彩查询"></a>色彩查询</h4><ul><li>网页色彩常用搭配表：<a href="http://tool.c7sky.com/webcolor/" target="_blank" rel="noopener">http://tool.c7sky.com/webcolor/</a> </li><li>颜色表及html代码：<a href="http://xh.5156edu.com/page/z1015m9220j18754.html" target="_blank" rel="noopener">http://xh.5156edu.com/page/z1015m9220j18754.html</a> </li><li>rgb颜色查询对照表：<a href="http://www.999.com/tool/rgb.html" target="_blank" rel="noopener">http://www.999.com/tool/rgb.html</a></li></ul><h4 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h4><ul><li>阮一峰：<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/</a></li><li>刘哇勇：<a href="http://www.cnblogs.com/Wayou/" target="_blank" rel="noopener">http://www.cnblogs.com/Wayou/</a></li><li>胡孙杨：<a href="http://hcysun.me/" target="_blank" rel="noopener">http://hcysun.me/</a></li><li>郭锦荣：<a href="http://www.cnblogs.com/jr1993/" target="_blank" rel="noopener">http://www.cnblogs.com/jr1993/</a></li><li>张鑫旭：<a href="https://www.zhangxinxu.com/" target="_blank" rel="noopener">https://www.zhangxinxu.com/</a></li></ul><h4 id="测试调试"><a href="#测试调试" class="headerlink" title="测试调试"></a>测试调试</h4><ul><li>JSFiddle：<a href="https://jsfiddle.net/" target="_blank" rel="noopener">https://jsfiddle.net/</a></li><li>codeOpen：<a href="https://codepen.io/" target="_blank" rel="noopener">https://codepen.io/</a></li><li>在线正则表达式：<a href="http://tool.oschina.net/regex/" target="_blank" rel="noopener">http://tool.oschina.net/regex/</a></li><li>移动前端开发调试：<a href="http://yujiangshui.com/multidevice-frontend-debug/" target="_blank" rel="noopener">http://yujiangshui.com/multidevice-frontend-debug/</a></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>hexo博客搭建：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li><li>webstorm 2017 激活破解：<a href="http://blog.csdn.net/it_talk/article/details/52448597" target="_blank" rel="noopener">http://blog.csdn.net/it_talk/article/details/52448597</a></li><li>webstorm 2018 激活破解方法大全：<a href="https://blog.csdn.net/voke_/article/details/76418116" target="_blank" rel="noopener">https://blog.csdn.net/voke_/article/details/76418116</a></li><li>81道经典Vue面试题总结（长期更新）：<a href="https://segmentfault.com/a/1190000016351284" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016351284</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Web方面&quot;&gt;&lt;a href=&quot;#Web方面&quot; class=&quot;headerlink&quot; title=&quot;Web方面&quot;&gt;&lt;/a&gt;Web方面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JS注释规范：&lt;a href=&quot;http://usejsdoc.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://usejsdoc.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;查看HTML5是否符合大纲：&lt;a href=&quot;https://gsnedders.html5.org/outliner/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gsnedders.html5.org/outliner/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;浏览器CSS支持情况查询：&lt;a href=&quot;http://www.caniuse.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.caniuse.com&lt;/a&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="网址" scheme="https://chongtianhong.github.io/tags/%E7%BD%91%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>前端渲染与后端渲染的区别</title>
    <link href="https://chongtianhong.github.io/2018/06/10/diffBetweenFEandSE/"/>
    <id>https://chongtianhong.github.io/2018/06/10/diffBetweenFEandSE/</id>
    <published>2018-06-10T11:03:46.000Z</published>
    <updated>2018-09-10T12:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>渲染</strong>的本质：字符串的拼接，将<strong>数据</strong>渲染进<strong>固定格式的html代码</strong>中，形成最终的html显示在用户页面上。<a id="more"></a></li></ul><h4 id="前端渲染"><a href="#前端渲染" class="headerlink" title="前端渲染"></a>前端渲染</h4><ul><li>指的是前端向后端发起请求，<strong>后端返回JSON数据</strong>，前端利用预先写的html模板，循环读取JSON数据，拼接字符串（es6的模板字符串特性大大减少了拼接字符串的的成本），并插入页面。</li><li>也就是说，<strong>前端渲染</strong>就是后端返回的html是静态文件，作为纯文件形式的存在，<strong>后端直接吐给前端，不做任何涂抹</strong>，前端拿到后执行决定做什么。</li><li><strong>好处</strong>：<ul><li>网络传输数据量小。</li><li>不占用服务端运算资源（解析模板），模板在前端（很有可能仅部分在前端），改结构变交互都由前端自己完成。</li></ul></li><li><strong>坏处</strong>：<ul><li>前端耗时较多，对前端工作人员水平要求相对较高。</li><li>前端代码较多，因为部分以前在后台处理的交互逻辑交给了前端处理。</li><li>占用少部分客户端运算资源用于解析模板。</li></ul></li></ul><h4 id="后端渲染"><a href="#后端渲染" class="headerlink" title="后端渲染"></a>后端渲染</h4><ul><li>指的是前端发起请求，<strong>后端用后台模板引擎（例如ejs等）直接生成html</strong>，前端接受到html数据之后，直接插入页面。</li><li>也就是说，<strong>后端渲染</strong>就是<strong>html先被后端涂抹过一遍</strong>再给前端（前端拿到后是否要再涂抹则随意）。</li><li>好处：<ul><li>前端耗时少，即<strong>减少了首屏时间</strong>，模板统一在后端。</li><li>前端（相对）省事，不占用客户端运算资源（解析模板）。</li></ul></li><li>坏处：<ul><li>占用服务器资源，请求的数据量偏大，前端的交互样式更改需要联动修改。</li></ul></li></ul><h4 id="前端渲染与后端渲染对比"><a href="#前端渲染与后端渲染对比" class="headerlink" title="前端渲染与后端渲染对比"></a>前端渲染与后端渲染对比</h4><h5 id="后端渲染-1"><a href="#后端渲染-1" class="headerlink" title="后端渲染"></a>后端渲染</h5><ul><li><strong>页面呈现速度快</strong>，受限于用户的带宽。</li><li><strong>流量消耗少一点点</strong>（可以省去前端框架部分的代码）。</li><li><strong>可维护性差</strong>，不利于前后端分离。</li><li><strong>seo友好度好</strong>，因为后端已经渲染好了，所以加载体验相对较好，网速差时表现较差。</li><li><strong>编码效率低</strong>。</li><li>相对模块化，适用于片展示型的页面。</li></ul><h5 id="前端渲染-1"><a href="#前端渲染-1" class="headerlink" title="前端渲染"></a>前端渲染</h5><ul><li>页面呈现速度主要<strong>受限于带宽和客户端机器的好坏</strong>，优化得好可以逐步动态展开内容，感觉上会更快一点。</li><li><strong>流量消耗多一点点</strong>（一个前端框架大概50KB），当然，有的用后端渲染的项目前端部分也有在用框架。</li><li><strong>可维护性好</strong>，不必反复请求，理论上更加符合前后端分离。</li><li><strong>SEO友好度差</strong>，大量使用ajax，多数浏览器不能抓取ajax数据。</li><li><strong>编码效率高</strong>，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低。</li><li>比较灵活，适用于<strong>DOM操作比较频繁</strong>或<strong>交互复杂</strong>的业务场景。</li></ul><h5 id="从后端渲染到前端渲染的改变"><a href="#从后端渲染到前端渲染的改变" class="headerlink" title="从后端渲染到前端渲染的改变"></a>从后端渲染到前端渲染的改变</h5><blockquote>计算机任务的转移</blockquote><ul><li>原本由服务器渲染的任务交给客户端，当有大量用户访问时，大大减轻了后端的压力。性能大大提高，因为服务器做的事情确实减少了。而且随着客户端硬件的发展，也能处理好多数的渲染任务。</li></ul><blockquote>放弃前端权限</blockquote><ul><li>将页面整个UI逻辑交给客户端的话，一些有经验的用户可能会看到一些本不该看到的页面，违反了安全原则。所以<strong>后端不能轻信从前端传来的数据</strong>，一定要<strong>做好过滤与验证</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;渲染&lt;/strong&gt;的本质：字符串的拼接，将&lt;strong&gt;数据&lt;/strong&gt;渲染进&lt;strong&gt;固定格式的html代码&lt;/strong&gt;中，形成最终的html显示在用户页面上。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="渲染" scheme="https://chongtianhong.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Node.js之async异步编程</title>
    <link href="https://chongtianhong.github.io/2018/06/09/asyncProgrammingOfNodeJS/"/>
    <id>https://chongtianhong.github.io/2018/06/09/asyncProgrammingOfNodeJS/</id>
    <published>2018-06-09T07:12:58.000Z</published>
    <updated>2018-09-08T16:22:43.298Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>异步编程</strong>是指由于<strong>异步I/O</strong>等因素，<strong>无法同步获得执行结果</strong>时，在<strong>回调函数中进行下一步操作</strong>的代码编写风格，常见的如<code>setTimeout</code>函数、<code>ajax</code>请求等。<a id="more"></a></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt;= 3; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(i); </span><br><span class="line">    &#125;, 0); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>这里大部分人会认为输出<code>123</code>，或者<code>333</code>。其实它会输出<code>444</code>，这里就是我们要说的异步编程了。</p></li><li>解析：在正常情况下，for循环每次执行，在块级作用域结束后，这个i就会被回收。而由于<code>setTimeout</code>是异步的，引用的索引是最后的i，所以输出的都为4。</li><li><p>重新改写例子，使之输出我们想要的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i = 1; i &lt;= 3; i++) &#123; </span><br><span class="line">    (<span class="keyword">function</span>(j)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(j); </span><br><span class="line">        &#125;, 0); </span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>解析：加了<strong>立即执行函数后，形成了闭包</strong>，每次的i就会在内存中保留下来，不会立即回收，并且这个<strong>i是保存在堆中</strong>的。因此每个<code>setTimeout</code>就能找到自己要输出的i。当每次<code>setTimeout</code>输出完自己需要的i后，堆中的i就可以被回收了。</p></li></ul><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><ul><li><strong>async</strong>是JavaScript的扩展库。它可以简化Node.js异步操作的书写，使代码更容易被读懂，而不是嵌套一堆的括号让人难以理解。</li><li><p>我们可以使用Node.js的包管理器npm直接安装它，在shell中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install async</span><br></pre></td></tr></table></figure></li><li><p><strong>asyn</strong>c的流程控制相关函数有：</p><ul><li><code>series</code></li><li><code>waterfall</code></li><li><code>parallel</code></li><li><code>parallelLimit</code></li></ul></li></ul><h5 id="series函数"><a href="#series函数" class="headerlink" title="series函数"></a>series函数</h5><ul><li>语法：<code>async.series(tasks,callback)</code></li><li><code>series</code>函数：<strong>串行无关联</strong>，多个函数<strong>依次执行</strong>，函数之间没有数据交换，其中一个函数出错，后续函数不再执行。</li><li><p><code>series</code>函数的<strong>第一个参数</strong>可以是一个<strong>数组</strong>也可以是一个<strong>JSON对象</strong>，参数类型不同，影响的是返回数据的格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async.series(&#123;</span><br><span class="line">    one: <span class="keyword">function</span>(callback)&#123;</span><br><span class="line">        callback(null, 1);</span><br><span class="line">    &#125;,</span><br><span class="line">    two: <span class="keyword">function</span>(callback)&#123;</span><br><span class="line">        callback(null, 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">function</span>(err, results) &#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;one: 1, two: 2&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="waterfall函数"><a href="#waterfall函数" class="headerlink" title="waterfall函数"></a>waterfall函数</h5><ul><li><code>waterfall</code>函数：瀑布流，<strong>串行有关联</strong>。它和<code>series</code>函数有很多<strong>相似之处</strong>，都是<strong>按照顺序执行</strong>。</li><li><p><strong>不同之处</strong>是<code>waterfall</code>每个函数产生的值，都将传给下一个函数，而<code>series</code>则没有这个功能，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async.waterfall([</span><br><span class="line">    <span class="keyword">function</span>(callback)&#123;</span><br><span class="line">        callback(null, <span class="string">'one'</span>, <span class="string">'two'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(arg1, arg2, callback)&#123;</span><br><span class="line">      // arg1 now equals <span class="string">'one'</span> and arg2 now equals <span class="string">'two'</span></span><br><span class="line">        callback(null, <span class="string">'three'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(arg1, callback)&#123;</span><br><span class="line">        // arg1 now equals <span class="string">'three'</span></span><br><span class="line">        callback(null, <span class="string">'done'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="keyword">function</span> (err, result) &#123;</span><br><span class="line">   // result now equals <span class="string">'done'</span></span><br><span class="line">   console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>另外，<strong>需要注意</strong>的是<code>waterfall</code>的<strong>tasks参数只能是数组类型</strong>。当中途有函数出错，其<code>err</code>直接传给最终<code>callback</code>，<strong>结果被丢弃，后面的函数不再执行</strong>。</p></li></ul><h5 id="parallel函数"><a href="#parallel函数" class="headerlink" title="parallel函数"></a>parallel函数</h5><ul><li>async里的提供的<strong>并行无关联</strong>api是<code>parallel</code>函数。它的原理是<strong>同时并行处理每一个流程，最后汇总结果，如果某一个流程出错就退出</strong>。有点像Promise.all。</li><li>语法：<code>parallel(tasks, [callback])</code></li><li><p><code>parallel</code>函数是<strong>并行执行多个函数</strong>，每个函数都是立即执行，不需要等待其它函数先执行。传给最终<code>callback</code>的数组中的数据<strong>按照tasks中声明的顺序</strong>，而不是执行完成的顺序，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async.parallel([</span><br><span class="line">    <span class="keyword">function</span>(callback)&#123;</span><br><span class="line">        callback(null, <span class="string">'one'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(callback)&#123;</span><br><span class="line">        callback(null, <span class="string">'two'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"><span class="keyword">function</span>(err, results)&#123;</span><br><span class="line">    console.log(results); // [<span class="string">'one'</span>, <span class="string">'two'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>tasks参数(函数的第一个参数)</strong>可以是一个<strong>数组</strong>或是<strong>JSON对象</strong>，和series函数一样，参数类型不同，返回的results格式会不一样。</p></li></ul><h5 id="parallelLimit函数"><a href="#parallelLimit函数" class="headerlink" title="parallelLimit函数"></a>parallelLimit函数</h5><ul><li>语法：<code>parallelLimit(tasks, limit, [callback])</code></li><li><code>parallelLimit</code>函数和<code>parallel</code>类似，但是它多了一个参数<code>limit</code>。</li><li><code>limit</code>参数<strong>限制任务只能同时并发一定数量</strong>，而不是无限制并发，示例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async.parallelLimit([</span><br><span class="line">    <span class="keyword">function</span>(callback)&#123;</span><br><span class="line">        callback(null, <span class="string">'one'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(callback)&#123;</span><br><span class="line">        callback(null, <span class="string">'two'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">], 2, <span class="keyword">function</span>(err, results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;异步编程&lt;/strong&gt;是指由于&lt;strong&gt;异步I/O&lt;/strong&gt;等因素，&lt;strong&gt;无法同步获得执行结果&lt;/strong&gt;时，在&lt;strong&gt;回调函数中进行下一步操作&lt;/strong&gt;的代码编写风格，常见的如&lt;code&gt;setTimeout&lt;/code&gt;函数、&lt;code&gt;ajax&lt;/code&gt;请求等。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="async" scheme="https://chongtianhong.github.io/tags/async/"/>
    
      <category term="异步编程" scheme="https://chongtianhong.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Express中使用模板引擎</title>
    <link href="https://chongtianhong.github.io/2018/06/08/usingViewEngineInExpress/"/>
    <id>https://chongtianhong.github.io/2018/06/08/usingViewEngineInExpress/</id>
    <published>2018-06-08T07:03:23.000Z</published>
    <updated>2018-09-07T17:32:38.557Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文将介绍如何在express中设置模板引擎。<a id="more"></a></li></ul><h4 id="定义模板引擎"><a href="#定义模板引擎" class="headerlink" title="定义模板引擎"></a>定义模板引擎</h4><ul><li><p>通过以下方法注册指定的ejs模板引擎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'views'</span>, <span class="string">'./app/views'</span>); // 设置views的默认路径</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);   // 设置引擎扩展名</span><br><span class="line">app.engine(<span class="string">'.ejs'</span>, require(<span class="string">'ejs'</span>).__express); // 注册ejs模板引擎</span><br></pre></td></tr></table></figure></li><li><p>当然，如果想使用<strong>html后缀</strong>的文件，可以做以下修改，这样就可以支持了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.engine(<span class="string">'.html'</span>, require(<span class="string">'ejs'</span>).__express);</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'html'</span>);</span><br></pre></td></tr></table></figure></li><li><p>也可以在ejs模板文件中，使用模板语法引入<strong>html后缀</strong>的页面片：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% include header.html %&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="添加变量"><a href="#添加变量" class="headerlink" title="添加变量"></a>添加变量</h4><ul><li><p>我们可以使用<strong>app对象</strong>的<strong>locals属性</strong>来添加，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.locals.name = <span class="string">'App'</span>;</span><br><span class="line">app.locals.age = 13;</span><br></pre></td></tr></table></figure></li><li><p>这些变量会在<strong>渲染模板的时候填充到页面中</strong>去。</p></li><li>当然，<strong>locals</strong>也可以通过render的第二个参数直接传入。</li></ul><h4 id="渲染模板并显示"><a href="#渲染模板并显示" class="headerlink" title="渲染模板并显示"></a>渲染模板并显示</h4><ul><li><p>我们可以使用render方法来渲染页面，对应的api是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.render(view, [locals], callback)</span><br></pre></td></tr></table></figure></li><li><p>其中：</p><ul><li><code>view</code>：模板文件名，必须；</li><li><code>[locals]</code>：一个<strong>locals对象</strong>（相当于在<strong>app.locals</strong>中定义的<strong>locals属性</strong>），可选；</li><li><code>callback</code>：回调函数，在模板呈现后执行。第一个参数，err错误对象，第二个参数是 html，即呈现后的模板字符串。可选。</li></ul></li><li><p>直接调用app对象的<code>render</code>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res) &#123;</span><br><span class="line">    res.render(<span class="string">'index'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>用render的回调方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span>(req, res) &#123;</span><br><span class="line">    res.render(<span class="string">'index'</span>, <span class="keyword">function</span>(err, html) &#123;</span><br><span class="line">        res.send(html);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>直接传入<strong>locals对象</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.render(<span class="string">'/'</span>, &#123; name: <span class="string">'aaa'</span> &#125;, <span class="keyword">function</span>(err, html)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文将介绍如何在express中设置模板引擎。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://chongtianhong.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>GET和POST两种基本请求方法的区别</title>
    <link href="https://chongtianhong.github.io/2018/06/07/diffBetweenGetAndPost/"/>
    <id>https://chongtianhong.github.io/2018/06/07/diffBetweenGetAndPost/</id>
    <published>2018-06-07T01:32:58.000Z</published>
    <updated>2018-09-07T15:26:14.298Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>GET</strong>和<strong>POST</strong>是HTTP请求的两种基本方法，它们之间<strong>最直观的区别</strong>就是<strong>GET把参数包含在URL中</strong>，<strong>POST通过request body传递参数</strong>。<a id="more"></a></li><li>其余的区别有：<br>· <strong>GET在浏览器回退时是无害的（会使用缓存）</strong>，而POST会再次提交请求。即GET会将请求参数放在请求的url中，回退操作实际上浏览器会从之前的缓存中拿结果。而<strong>POST每次调用都会创建新的资源</strong>。<br>· GET产生的URL地址可以被Bookmark，而POST不可以。<br>· <strong>GET请求会被浏览器主动cache，而POST不会，除非手动设置</strong>。浏览器缓存又分为<strong>强缓存</strong>和<strong>协商缓存</strong>。<br>· <strong>GET请求只能进行url编码(urlEncode)</strong>，而<strong>POST支持多种编码方式</strong>(application/x-www-form-urlencoded、multipart/form-data、application/json、text/xml)。<br>· <strong>GET请求参数会被完整保留在浏览器历史记录里</strong>，而POST中的参数不会被保留。<br>· <strong>GET请求在URL中传送的参数是有长度限制</strong>的，而POST没有。<br>· 对<strong>参数的数据类型，GET只接受ASCII字符</strong>，而POST没有限制。URL 是 HTTP 的一个首部。既然作为一个首部，那么根据约定，一定是 ASCII 字符的。<br>· <strong>GET比POST更不安全</strong>，因为<strong>参数直接暴露在URL上</strong>，所以不能用来传递敏感信息。</li></ul><blockquote>GET和POST本质上没有区别</blockquote><ul><li>GET和POST是HTTP协议中的两种发送请求的方法。</li><li>HTTP是基于TCP/IP的<strong>关于数据如何在万维网中进行通信的协议</strong>。</li><li>HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP，也就是说，<strong>GET/POST都是TCP链接</strong>。GET和POST能做的事情是一样的。如果要给GET加上request body，给POST带上url参数，技术上是完全行的通的。但是由于<strong>HTTP的规定</strong>和<strong>浏览器/服务器的限制</strong>，导致它们在应用过程中体现出一些不同（以上提到的区别）。</li></ul><blockquote>GET和POST的一个重大区别</blockquote><ul><li><strong>GET</strong>产生<strong>一个</strong>TCP数据包；<strong>POST</strong>产生<strong>两个</strong>TCP数据包。</li><li>对于GET方式的请求，浏览器会<strong>把http header和data一并发送出去</strong>，服务器响应200（返回数据）；</li><li>而对于POST，浏览器<strong>先发送header</strong>，服务器响应100 continue，浏览器<strong>再发送data</strong>，服务器响应200 ok（返回数据）。</li></ul><blockquote>用GET替换POST的不现实想法</blockquote><ul><li>因为<strong>POST需要两步，时间上消耗的要多一点</strong>，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？<ol><li>GET与POST都有自己的语义，不能随便混用。</li><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而<strong>在网络环境差的情况下</strong>，<strong>两次包</strong>的TCP在<strong>验证数据包完整性</strong>上，<strong>有非常大的优点</strong>。</li><li><strong>并不是所有浏览器都会在POST中发送两次包</strong>，Firefox就只发送一次。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;和&lt;strong&gt;POST&lt;/strong&gt;是HTTP请求的两种基本方法，它们之间&lt;strong&gt;最直观的区别&lt;/strong&gt;就是&lt;strong&gt;GET把参数包含在URL中&lt;/strong&gt;，&lt;strong&gt;POST通过request body传递参数&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTP" scheme="https://chongtianhong.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的解构赋值</title>
    <link href="https://chongtianhong.github.io/2018/06/06/destructuringAssignment/"/>
    <id>https://chongtianhong.github.io/2018/06/06/destructuringAssignment/</id>
    <published>2018-06-06T08:19:19.000Z</published>
    <updated>2018-09-06T14:02:16.302Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>解构赋值</strong>，即<strong>对某种结构进行解析</strong>，然后<strong>将解析出来的值赋值给相关的变量</strong>，常见的有<strong>数组、对象、字符串的解构赋值</strong>等。<a id="more"></a></li></ul><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><ul><li><p>数组的解构赋值即<strong>解析返回的数组，取出值并赋给相应的变量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ids</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var [id1, id2, id3] = ids();</span><br><span class="line"></span><br><span class="line">console.log(id1, id2, id3); // 1 2 3</span><br></pre></td></tr></table></figure></li><li><p>还可以<strong>嵌套多层</strong>，只要<strong>相应的模式匹配</strong>了就能解析出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var [a, [b, [c]]] = [1, [2, [3]]];</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">c // 3</span><br></pre></td></tr></table></figure></li><li><p>如若<strong>模式不匹配则报错</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var [a, [b, [c]]] = [1, [2, 3]]; // Uncaught TypeError: [1,[2,3]] is not iterable</span><br></pre></td></tr></table></figure></li><li><p>其实，<strong>解构赋值内部的实现方式使用到了ES6的Iterator迭代器</strong>，通过层层遍历，保证了相应值的获取。</p></li><li><p>解构不成功，但模式匹配了，相应值为<code>undefined</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var [a, b] = [1];</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // undefined</span><br></pre></td></tr></table></figure></li><li><p>不需要匹配的位置可以置空：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [, b] = [1, 2];</span><br><span class="line"></span><br><span class="line">b // 2</span><br></pre></td></tr></table></figure></li><li><p>使用扩展运算符，匹配余下的所以值，形成一个数组（匹配不上则为[]），这个符号内部也用到了迭代器Iterator：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var [a, ...b] = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // [2, 3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var [a, ...b] = [1];</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // []</span><br></pre></td></tr></table></figure></li><li><p><strong>可以设置默认值</strong>，当相应的值<strong>严格等于undefined</strong>时，<strong>默认值会生效</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var [a, b = [2, 3]] = [1];</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // [2, 3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var [a, b = [2, 3]] = [1, undefined];</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // [2, 3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var [a, b = [2, 3]] = [1, null];</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // null</span><br></pre></td></tr></table></figure></li><li><p><strong>惰性求值</strong>，对于默认值中出现函数调用模式的，<strong>只有默认值生效，函数才会调用</strong>，如下，<code>foo</code>函数将不会被调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'hit'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var [str = foo()] = [1];</span><br><span class="line"></span><br><span class="line">str // 1</span><br></pre></td></tr></table></figure></li><li><p>可以方便的<strong>进行变量值的交换</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 1,</span><br><span class="line">    y = 2;</span><br><span class="line">   </span><br><span class="line">[x, y] = [y, x];</span><br><span class="line"></span><br><span class="line">x // 2</span><br><span class="line">y // 1</span><br></pre></td></tr></table></figure></li></ul><h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><ul><li><p>与数组类似，对象也可以进行解构赋值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var &#123;name, agee&#125; = &#123;</span><br><span class="line">    name: <span class="string">'jack'</span>,</span><br><span class="line">    age: 22,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">name // jack</span><br><span class="line">agee // undefined</span><br></pre></td></tr></table></figure></li><li><p>如上，<strong>对象的解构赋值要求属性名称匹配正确</strong>，agee不匹配则变成<code>undefined</code>。</p></li><li><p>我们<strong>可以自定义属性名称</strong>，但要注意的是<strong>被赋值的只是我们自定义的属性名称</strong>，<strong>匹配的模式（项）并未被赋值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var &#123;name, id: ID&#125; = &#123;</span><br><span class="line">    name: <span class="string">'jack'</span>,</span><br><span class="line">    id: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ID // 1</span><br><span class="line">id // Uncaught ReferenceError: id is not defined</span><br><span class="line"></span><br><span class="line">// 更复杂的如</span><br><span class="line">var &#123;</span><br><span class="line">    a0: &#123;</span><br><span class="line">        b0: &#123;</span><br><span class="line">            c0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">    a0: &#123;</span><br><span class="line">        b0: &#123;</span><br><span class="line">            c0: <span class="string">'cc'</span>,</span><br><span class="line">            d0: <span class="string">'dd'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a0 // Uncaught ReferenceError: a0 is not defined</span><br><span class="line">b0 // Uncaught ReferenceError: b0 is not defined</span><br><span class="line">c0 // cc</span><br></pre></td></tr></table></figure></li><li><p>类似于数组，也<strong>可使用默认值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var &#123;a:b = 2&#125; = &#123;&#125;;</span><br><span class="line">b // 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var &#123;a:b = 2&#125; = &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;;</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure></li><li><p>因为<strong>数组实际上也是个对象</strong>，所以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123;0: one, 1: two&#125; = [1, 2];</span><br><span class="line"></span><br><span class="line">two // 2</span><br></pre></td></tr></table></figure></li><li><p><strong>非声明时</strong>的<strong>解构赋值</strong>，这里是指纯粹的解构赋值，如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> node = &#123;</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">type</span> = <span class="string">"Literal"</span>,</span><br><span class="line">name = 5;</span><br><span class="line">// 使用解构来分配不同的值</span><br><span class="line">(&#123; <span class="built_in">type</span>, name &#125; = node);</span><br><span class="line">console.log(<span class="built_in">type</span>); // <span class="string">"Identifier"</span></span><br><span class="line">console.log(name); // <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></li><li><p>在这个示例中，声明变量<code>type</code>和<code>name</code>时初始化了一个值，在后面几行中，通过解构赋值的方法，从node对象读取相应的值<strong>重新为这两个变量赋值</strong>。</p></li><li><strong>一定要用一对小括号包裹解构赋值语句，JS引擎将一对开放的花括号视为一个代码块</strong>。<strong>语法规定，代码块语句不允许出现在赋值语句左侧</strong>，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值过程。</li></ul><h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><ul><li><strong>字符串也可进行解构赋值</strong>，因为此时的<strong>字符串被转换成了类数组的对象</strong>，模式能够匹配起来，如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var [a, b] = <span class="string">'str'</span>;</span><br><span class="line">a // s</span><br><span class="line">b // t</span><br><span class="line"></span><br><span class="line">var &#123;0:a, 1:b, length:len&#125; = <span class="string">'str'</span>;</span><br><span class="line">a // s</span><br><span class="line">b // t</span><br><span class="line">len // 3</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他类型的解构赋值"><a href="#其他类型的解构赋值" class="headerlink" title="其他类型的解构赋值"></a>其他类型的解构赋值</h4><ul><li><p><strong>解构赋值的规则是，只要等号右边的值不是对象，就先尝试将其转为对象</strong>。如果转换之后的对象或原对象拥有Iterator接口，则可以进行解构赋值，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123;toString: s&#125; = 1;</span><br><span class="line"></span><br><span class="line">var &#123;toString: s&#125; = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>以上的数组和布尔值会转换成对象，toString模式匹配上了对象的toString属性，所以解构成功，而<code>null</code>或<code>undefined</code>却不能转换成此类对象，所以报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var &#123;toString: s&#125; = null;</span><br><span class="line">s // Uncaught TypeError: Cannot match against <span class="string">'undefined'</span> or <span class="string">'null'</span>.</span><br></pre></td></tr></table></figure></li><li><p>ES6引入了Iterator迭代器，<strong>集合Set</strong>或<strong>Generator生成器函数</strong>等都部署了这个Iterator接口，所以也<strong>可以用来进行解构赋值</strong>：</p></li><li><p>比如<strong>Set</strong>的解构赋值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var [a, b, c] = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">c // 3</span><br></pre></td></tr></table></figure></li><li><p><strong>函数参数</strong>的解构赋值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> calc([a, b, c = 10]) &#123;</span><br><span class="line">    console.log(a + b + c); // 13</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calc([1, 2]);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解构赋值&lt;/strong&gt;，即&lt;strong&gt;对某种结构进行解析&lt;/strong&gt;，然后&lt;strong&gt;将解析出来的值赋值给相关的变量&lt;/strong&gt;，常见的有&lt;strong&gt;数组、对象、字符串的解构赋值&lt;/strong&gt;等。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6中扩展运算符和Rest运算符的用法比较</title>
    <link href="https://chongtianhong.github.io/2018/06/05/spreadAndRestOperator/"/>
    <id>https://chongtianhong.github.io/2018/06/05/spreadAndRestOperator/</id>
    <published>2018-06-05T06:11:41.000Z</published>
    <updated>2018-09-06T14:00:25.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>扩展运算符</strong>用三个点号表示，功能是<strong>把数组或类数组对象展开成</strong>一系列用逗号隔开的<strong>参数序列</strong>。</li><li><strong>Rest运算符</strong>也是三个点号，不过其功能与扩展运算符恰好相反，<strong>把逗号隔开的值序列组合成一个数组</strong>。<a id="more"></a></li><li>对于两者之间的区别，三点<strong>放在形参或者等号左边</strong>为<strong>Rest运算符</strong>；<strong>放在实参或者等号右边</strong>为<strong>扩展运算符</strong>，或者说，放在<strong>被赋值一方</strong>为<strong>Rest运算符</strong>，放在<strong>赋值一方</strong>为<strong>扩展运算符</strong>。</li></ul><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><ul><li><p><strong>扩展运算符</strong>是三个点（…）。它好比Rest运算符的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br><span class="line"></span><br><span class="line">var foo = <span class="keyword">function</span>(a, b, c) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">//传统写法</span><br><span class="line">foo(arr[0], arr[1], arr[2]);</span><br><span class="line"></span><br><span class="line">//使用扩展运算符</span><br><span class="line">foo(...arr);</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></li><li><p><strong>扩展运算符</strong>主要用于<strong>函数调用</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> push(array, items) &#123;</span><br><span class="line">    array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> add(x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">var numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，<code>array.push(…items)</code>和<code>add(…numbers)</code>这两行，都是函数的调用，它们都使用了扩展运算符。该运算符<strong>将一个数组，变为参数序列</strong>。</p></li><li><p><strong>扩展运算符</strong>与正常的函数参数可以结合使用，非常灵活：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">var args = [0, 1];</span><br><span class="line">f(-1, ...args, 2, ...[3]);</span><br></pre></td></tr></table></figure></li><li><p>特殊应用场景：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 数组深拷贝</span><br><span class="line">var arr2 = arr;</span><br><span class="line">var arr3 = [...arr];</span><br><span class="line">console.log(arr===arr2); // <span class="literal">true</span>, 说明arr和arr2指向同一个数组</span><br><span class="line">console.log(arr===arr3); // <span class="literal">false</span>, 说明arr3和arr指向不同数组</span><br><span class="line"></span><br><span class="line">// 把一个数组插入另一个数组字面量</span><br><span class="line">var arr4 = [...arr, 4, 5, 6];</span><br><span class="line">console.log(arr4);// [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">// 字符串转数组</span><br><span class="line">var str = <span class="string">'love'</span>;</span><br><span class="line">var arr5 = [...str];</span><br><span class="line">console.log(arr5);// [ <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'v'</span>, <span class="string">'e'</span> ]</span><br></pre></td></tr></table></figure></li></ul><h5 id="替代数组的-apply-方法"><a href="#替代数组的-apply-方法" class="headerlink" title="替代数组的 apply 方法"></a>替代数组的 apply 方法</h5><ul><li><p>由于<strong>扩展运算符可以展开数组</strong>，所以不再需要使用<code>apply</code>方法将数组转为函数的参数了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> f(x, y, z) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line"></span><br><span class="line">// ES5 的写法</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure></li><li><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line">// ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line">//  等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure></li><li><p>上面代码表示，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p></li><li><p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">// ES5 的写法</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></li><li><p>上面代码的 ES5 写法中，<strong><code>push</code>方法的参数不能是数组</strong>，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p></li></ul><h5 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h5><h6 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h6><ul><li>扩展运算符提供了数组合并的新写法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">[1, 2].concat(more)</span><br><span class="line">// ES6</span><br><span class="line">[1, 2, ...more]</span><br><span class="line"></span><br><span class="line">var arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">var arr2 = [<span class="string">'c'</span>];</span><br><span class="line">var arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line">// ES5 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br><span class="line">// ES6 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br></pre></td></tr></table></figure></li></ul><h6 id="将字符串转为数组"><a href="#将字符串转为数组" class="headerlink" title="将字符串转为数组"></a>将字符串转为数组</h6><ul><li><p>扩展运算符还可以将字符串转为真正的数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line">// [ <span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span> ]</span><br></pre></td></tr></table></figure></li><li><p>上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span>.length // 4</span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>].length // 3</span><br></pre></td></tr></table></figure></li><li><p>上面代码的第一种写法， JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> length(str) &#123;</span><br><span class="line">    <span class="built_in">return</span> [...str].length;</span><br><span class="line">&#125;</span><br><span class="line">length(<span class="string">'x\uD83D\uDE80y'</span>) // 3</span><br></pre></td></tr></table></figure></li><li><p>凡是<strong>涉及到操作 32 位 Unicode 字符的函数</strong>，都有这个问题。因此，<strong>最好都用扩展运算符改写</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> str = <span class="string">'x\uD83D\uDE80y'</span>;</span><br><span class="line">str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">// <span class="string">'y\uDE80\uD83Dx'</span></span><br><span class="line">[...str].reverse().join(<span class="string">''</span>)</span><br><span class="line">// <span class="string">'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure></li><li><p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p></li></ul><h6 id="实现了-Iterator-接口的对象"><a href="#实现了-Iterator-接口的对象" class="headerlink" title="实现了 Iterator 接口的对象"></a>实现了 Iterator 接口的对象</h6><ul><li><p>任何<strong>实现Iterator接口</strong>的对象，都可以用扩展运算符转为真正的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nodeList = document.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line">var array = [...nodeList];</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，<strong>扩展运算符可以将其转为真正的数组</strong>，原因就在于<strong>NodeList对象实现了 Iterator 接口</strong>。</p></li><li><p>对于那些<strong>没有部署 Iterator 接口的类似数组的对象</strong>，<strong>扩展运算符</strong>就<strong>无法将其转为真正的数组</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line">// TypeError: arrayLike is not iterable</span><br><span class="line"><span class="built_in">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为<strong>使用<code>Array.from</code>方法将arrayLike转为真正的数组</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line">arrayLike = Array.from(arrayLike);</span><br><span class="line"><span class="built_in">let</span> arr = [...arrayLike]; // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure></li></ul><h6 id="Map-和-Set-结构，-Generator-函数"><a href="#Map-和-Set-结构，-Generator-函数" class="headerlink" title="Map 和 Set 结构， Generator 函数"></a>Map 和 Set 结构， Generator 函数</h6><ul><li><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此<strong>只要具有 Iterator 接口的对象，都可以使用扩展运算符</strong>，比如 Map 结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map([</span><br><span class="line">[1, <span class="string">'one'</span>],</span><br><span class="line">[2, <span class="string">'two'</span>],</span><br><span class="line">[3, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">let</span> arr = [...map.keys()]; // [1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p><strong>Generator 函数运行后，返回一个遍历器对象</strong>，因此<strong>也可以使用扩展运算符</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var go = <span class="keyword">function</span>*()&#123;</span><br><span class="line">yield 1;</span><br><span class="line">yield 2;</span><br><span class="line">yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">[...go()] // [1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，<strong>变量<code>go</code></strong>是一个 Generator 函数，<strong>执行后返回的是一个遍历器对象</strong>，对这个遍历器对象执行扩展运算符，就会<strong>将内部遍历得到的值，转为一个数组</strong>。</p></li><li>如果对没有iterator接口的对象，使用扩展运算符，将会报错。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1, b: 2&#125;;</span><br><span class="line"><span class="built_in">let</span> arr = [...obj]; // TypeError: obj is not iterable</span><br></pre></td></tr></table></figure></li></ul><h4 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a>rest运算符</h4><ul><li><p>rest运算符也是三个点号，不过其功能与扩展运算符恰好相反，把逗号隔开的值序列组合成一个数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 主要用于不定参数，所以ES6开始可以不再使用arguments对象</span><br><span class="line">var bar = <span class="keyword">function</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> el of args) &#123;</span><br><span class="line">        console.log(el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(1, 2, 3, 4);</span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br><span class="line">//4</span><br><span class="line"></span><br><span class="line">bar = <span class="keyword">function</span>(a, ...args) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(1, 2, 3, 4);</span><br><span class="line">//1</span><br><span class="line">//[ 2, 3, 4 ]</span><br></pre></td></tr></table></figure></li><li><p>rest运算符配合解构使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [a, ...rest] = [1, 2, 3, 4];</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(rest); // [2, 3, 4]</span><br></pre></td></tr></table></figure></li><li><p>如果将<strong>rest运算符</strong>用于数组赋值，<strong>只能放在参数的最后一位</strong>，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br><span class="line">//  报错</span><br><span class="line">const [first, ...middle, last] = [1, 2, 3, 4, 5];</span><br><span class="line">//  报错</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>在调用第三方函数的时候，如果该函数接受多个参数，并且要传入的实参为数组，则使用<strong>扩展运算符</strong>。可以避免使用下标形式传入参数。也可以<strong>避免很多人习惯的使用apply方法传入数组</strong>。</li><li><strong>rest运算符</strong>使用场景应该稍少一些，主要是处理不定数量参数，可以<strong>避免arguments对象的使用</strong>。</li><li>对于两者之间的区别，三点<strong>放在形参或者等号左边</strong>为<strong>Rest运算符</strong>；<strong>放在实参或者等号右边</strong>为<strong>扩展运算符</strong>，或者说，放在<strong>被赋值一方</strong>为<strong>Rest运算符</strong>，放在<strong>赋值一方</strong>为<strong>扩展运算符</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩展运算符&lt;/strong&gt;用三个点号表示，功能是&lt;strong&gt;把数组或类数组对象展开成&lt;/strong&gt;一系列用逗号隔开的&lt;strong&gt;参数序列&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rest运算符&lt;/strong&gt;也是三个点号，不过其功能与扩展运算符恰好相反，&lt;strong&gt;把逗号隔开的值序列组合成一个数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Object.assign()的使用</title>
    <link href="https://chongtianhong.github.io/2018/06/04/ObjectAssign/"/>
    <id>https://chongtianhong.github.io/2018/06/04/ObjectAssign/</id>
    <published>2018-06-04T12:02:51.000Z</published>
    <updated>2018-09-05T14:31:38.794Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>Object.assign()</code>方法用于将所有<strong>可枚举属性的值</strong>从一个或多个源对象<strong>复制到目标对象</strong>。它将<strong>返回目标对象</strong>。<a id="more"></a></li><li>语法：<code>Object.assign(target, …sources)</code></li><li>该方法有两个参数：<ul><li>第一个<strong>target</strong>为<strong>目标对象</strong>；</li><li>后面的<strong>参数sources</strong>为<strong>源对象</strong>。</li></ul></li><li><p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。<strong>后来的源的属性将类似地覆盖早先的属性</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const object1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const object2 = Object.assign(&#123;c: 4, d: 5&#125;, object1);</span><br><span class="line"></span><br><span class="line">console.log(object2.c, object2.d);</span><br><span class="line">// expected output: 3 5</span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>方法只会<strong>拷贝源对象自身的</strong>并且<strong>可枚举的属性</strong>到目标对象。该方法使用源对象的<code>[[Get]]</code>和目标对象的<code>[[Set]]</code>，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。</p></li><li>注意：<code>Object.assign</code>不会跳过那些值为<code>null</code>或<code>undefined</code>的源对象。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li><p>复制一个对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; a: 1 &#125;;</span><br><span class="line">var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); // &#123; a: 1 &#125;</span><br></pre></td></tr></table></figure></li><li><p>针对<strong>深拷贝</strong>，需要使用其他方法，因为<strong><code>Object.assign()</code>拷贝的是属性值</strong>。假如<strong>源对象的属性值是一个指向对象的引用</strong>，它也<strong>只拷贝那个引用值</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">    <span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class="line">    <span class="built_in">let</span> obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    obj1.a = 1;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    obj2.a = 2;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    obj2.b.c = 3;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    // Deep Clone</span><br><span class="line">    obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class="line">    <span class="built_in">let</span> obj3 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">    obj1.a = 4;</span><br><span class="line">    obj1.b.c = 4;</span><br><span class="line">    console.log(JSON.stringify(obj1)); // &#123; a: 4, b: &#123; c: 4&#125;&#125;</span><br><span class="line">    console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br></pre></td></tr></table></figure></li><li><p>合并对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span><br></pre></td></tr></table></figure></li><li><p>合并具有相同属性的对象，属性被后续参数中具有相同属性的其他对象覆盖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure></li><li><p>拷贝 symbol 类型的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; [Symbol(<span class="string">'foo'</span>)]: 2 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, o1, o2);</span><br><span class="line">console.log(obj); // &#123; a : 1, [Symbol(<span class="string">"foo"</span>)]: 2 &#125;</span><br><span class="line">Object.getOwnPropertySymbols(obj); // [Symbol(foo)]</span><br></pre></td></tr></table></figure></li><li><p><strong>继承属性</strong>和<strong>不可枚举属性</strong>是<strong>不能拷贝</strong>的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。</span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: 2  // bar 是个不可枚举属性。</span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        enumerable: <span class="literal">true</span>  // baz 是个自身可枚举属性。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); // &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure></li><li><p>原始类型会被包装为对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var v1 = <span class="string">"abc"</span>;</span><br><span class="line">var v2 = <span class="literal">true</span>;</span><br><span class="line">var v3 = 10;</span><br><span class="line">var v4 = Symbol(<span class="string">"foo"</span>)</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">// 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">// 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); // &#123; <span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>: <span class="string">"b"</span>, <span class="string">"2"</span>: <span class="string">"c"</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异常会打断后续拷贝任务</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var target = Object.defineProperty(&#123;&#125;, <span class="string">"foo"</span>, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;); // target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is <span class="built_in">read</span>-only</span><br><span class="line">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.assign()&lt;/code&gt;方法用于将所有&lt;strong&gt;可枚举属性的值&lt;/strong&gt;从一个或多个源对象&lt;strong&gt;复制到目标对象&lt;/strong&gt;。它将&lt;strong&gt;返回目标对象&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用ES6新特性优化代码</title>
    <link href="https://chongtianhong.github.io/2018/06/03/codeOptimizationUsingES6/"/>
    <id>https://chongtianhong.github.io/2018/06/03/codeOptimizationUsingES6/</id>
    <published>2018-06-03T09:00:46.000Z</published>
    <updated>2018-09-05T14:37:19.903Z</updated>
    
    <content type="html"><![CDATA[<h4 id="声明变量的新姿势"><a href="#声明变量的新姿势" class="headerlink" title="声明变量的新姿势"></a>声明变量的新姿势</h4><h5 id="用let不用var"><a href="#用let不用var" class="headerlink" title="用let不用var"></a>用let不用var</h5><ul><li>ES6之前我们用<code>var</code>声明一个变量，但是它有很多弊病：<a id="more"></a><ul><li>因为没有块级作用域，很容易声明全局变量</li><li>变量提升</li><li>可以重复声明</li></ul></li><li><p>一道熟悉的面试题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br><span class="line">a[7](); // 10</span><br><span class="line">a[8](); // 10</span><br><span class="line">a[9](); // 10</span><br></pre></td></tr></table></figure></li><li><p>为了使得调用不同的数组元素输出对应的index，既可以使用闭包，也可以对代码做以下修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    // 对于 <span class="built_in">let</span> 来说，它会创建一个块级作用域</span><br><span class="line">    a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br><span class="line">a[7](); // 7</span><br><span class="line">a[8](); // 8</span><br><span class="line">a[9](); // 9</span><br></pre></td></tr></table></figure></li></ul><h5 id="有时候const比let更好"><a href="#有时候const比let更好" class="headerlink" title="有时候const比let更好"></a>有时候const比let更好</h5><ul><li><code>const</code>和<code>let</code>的唯一区别就是，<strong><code>const</code>不可以被更改</strong>，所以当声明变量的时候，尤其是在声明容易被更改的全局变量的时候，尽量使用<code>const</code>。</li><li><code>const</code>的优势在于：<ul><li>更好的代码语义化，一眼看到就是常量。</li><li>另一个原因是<strong>JavaScript编译器对<code>const</code>的优化要比<code>let</code>好</strong>，多使用<code>const</code>，有利于<strong>提高程序的运行效率</strong>。</li></ul></li><li>所有的<strong>函数</strong>都应该<strong>设置为常量</strong>。</li></ul><h4 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h4><ul><li>不要使用“双引号”，一律用单引号或反引号：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const a = <span class="string">"foobar"</span>;</span><br><span class="line">const b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line">// best</span><br><span class="line">const a = <span class="string">'foobar'</span>;</span><br><span class="line">const b = `foo<span class="variable">$&#123;a&#125;</span>bar`;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解构赋值的骚操作"><a href="#解构赋值的骚操作" class="headerlink" title="解构赋值的骚操作"></a>解构赋值的骚操作</h4><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><ul><li>在<strong>用到数组成员对变量赋值</strong>时，尽量使用<strong>解构赋值</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// low</span><br><span class="line">const first = arr[0];</span><br><span class="line">const second = arr[1];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const [first, second] = arr;</span><br></pre></td></tr></table></figure></li></ul><h5 id="函数传对象"><a href="#函数传对象" class="headerlink" title="函数传对象"></a>函数传对象</h5><ul><li><p><strong>函数的参数</strong>如果是<strong>对象的成员</strong>，优先使用<strong>解构赋值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> getFullName(user) &#123;</span><br><span class="line">    const firstName = user.firstName;</span><br><span class="line">    const lastName = user.lastName;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> getFullName(&#123; firstName, lastName &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>函数返回多个值，优先使用对象的解构赋值</strong>，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> processInput(input) &#123;</span><br><span class="line">    <span class="built_in">return</span> [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> processInput(input) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; left, right &#125; = processInput(input);</span><br></pre></td></tr></table></figure></li></ul><h4 id="关于对象的细节"><a href="#关于对象的细节" class="headerlink" title="关于对象的细节"></a>关于对象的细节</h4><h5 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h5><ul><li><p>单行定义的对象结尾不要逗号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const a = &#123; k1: v1, k2: v2, &#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const a = &#123; k1: v1, k2: v2 &#125;;</span><br></pre></td></tr></table></figure></li><li><p>多行定义的对象要保留逗号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const b = &#123;</span><br><span class="line">    k1: v1,</span><br><span class="line">    k2: v2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const b = &#123;</span><br><span class="line">    k1: v1,</span><br><span class="line">    k2: v2,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="一次性初始化完全"><a href="#一次性初始化完全" class="headerlink" title="一次性初始化完全"></a>一次性初始化完全</h5><ul><li><p>不要声明之后又给对象添加新属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const a = &#123;&#125;;</span><br><span class="line">a.x = 3;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const a = &#123; x: null &#125;;</span><br><span class="line">a.x = 3;</span><br></pre></td></tr></table></figure></li><li><p>如果一定非要加请使用<code>Object.assign</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = &#123;&#125;;</span><br><span class="line">Object.assign(a, &#123; x: 3 &#125;);</span><br></pre></td></tr></table></figure></li><li><p>如果对象的属性名是动态的，可以<strong>在创造对象的时候，使用属性表达式定义</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const obj = &#123;</span><br><span class="line">  id: 5,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj[getKey(<span class="string">'enabled'</span>)] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const obj = &#123;</span><br><span class="line">  id: 5,</span><br><span class="line">  name: <span class="string">'San Francisco'</span>,</span><br><span class="line">  [getKey(<span class="string">'enabled'</span>)]: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="尽量简洁表达"><a href="#尽量简洁表达" class="headerlink" title="尽量简洁表达"></a>尽量简洁表达</h5><ul><li>在定义对象时，能简洁表达尽量简洁表达：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var ref = <span class="string">'some value'</span>;</span><br><span class="line"></span><br><span class="line">// low</span><br><span class="line">const atom = &#123;</span><br><span class="line">    ref: ref,</span><br><span class="line"></span><br><span class="line">    value: 1,</span><br><span class="line"></span><br><span class="line">    addValue: <span class="keyword">function</span> (value) &#123;</span><br><span class="line">        <span class="built_in">return</span> atom.value + value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">const atom = &#123;</span><br><span class="line">    ref,</span><br><span class="line"></span><br><span class="line">    value: 1,</span><br><span class="line"></span><br><span class="line">    addValue(value) &#123;</span><br><span class="line">        <span class="built_in">return</span> atom.value + value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="扩展运算符（…）"><a href="#扩展运算符（…）" class="headerlink" title="扩展运算符（…）"></a>扩展运算符（…）</h5><ul><li>使用扩展运算符（…）拷贝数组：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">const len = items.length;</span><br><span class="line">const itemsCopy = [];</span><br><span class="line"><span class="built_in">let</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// cool </span><br><span class="line">const itemsCopy = [...items];</span><br></pre></td></tr></table></figure></li></ul><h5 id="将类数组转化为数组"><a href="#将类数组转化为数组" class="headerlink" title="将类数组转化为数组"></a>将类数组转化为数组</h5><ul><li>用<code>Array.from</code>方法，将类似数组的对象转为数组：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo = document.querySelectorAll(<span class="string">'.foo'</span>);</span><br><span class="line">const nodes = Array.from(foo);</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="箭头函数-gt"><a href="#箭头函数-gt" class="headerlink" title="箭头函数=&gt;"></a>箭头函数=&gt;</h5><ul><li><p><strong>立即执行函数</strong>可以写成箭头函数的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'Welcome to the Internet.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p><strong>尽量写箭头函数</strong>使你的代码看起来简洁优雅：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line">[1, 2, 3].map(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">  <span class="built_in">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// cool !</span><br><span class="line">[1, 2, 3].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure></li></ul><h5 id="rest-运算符（…）"><a href="#rest-运算符（…）" class="headerlink" title="rest 运算符（…）"></a>rest 运算符（…）</h5><ul><li>不需要再用<code>arguments</code>（类数组），使用<strong>rest 运算符（…）</strong>代替，rest 运算符可以提供一个真正的数组。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">concatenateAll</span></span>() &#123;</span><br><span class="line">    const args = Array.prototype.slice.call(arguments);</span><br><span class="line">    <span class="built_in">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> concatenateAll(...args) &#123;</span><br><span class="line">    <span class="built_in">return</span> args.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="传参时可设置默认值"><a href="#传参时可设置默认值" class="headerlink" title="传参时可设置默认值"></a>传参时可设置默认值</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> handleThings(opts) &#123;</span><br><span class="line">    opts = opts || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line"><span class="keyword">function</span> handleThings(opts = &#123;&#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单的键值对优先Map"><a href="#简单的键值对优先Map" class="headerlink" title="简单的键值对优先Map"></a>简单的键值对优先Map</h4><ul><li>如果只是简单的<code>key: value</code>结构，建议<strong>优先使用Map</strong>，因为Map提供方便的遍历机制。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> map = new Map(arr);</span><br><span class="line">// 遍历key值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> key of map.keys()) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历value值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> value of map.values()) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历key和value值</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> item of map.entries()) &#123;</span><br><span class="line">    console.log(item[0], item[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="更加简洁直观class语法"><a href="#更加简洁直观class语法" class="headerlink" title="更加简洁直观class语法"></a>更加简洁直观class语法</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// low</span><br><span class="line"><span class="keyword">function</span> Queue(contents = []) &#123;</span><br><span class="line">    this._queue = [...contents];</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.pop = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    const value = this._queue[0];</span><br><span class="line">    this._queue.splice(0, 1);</span><br><span class="line">    <span class="built_in">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">class Queue &#123;</span><br><span class="line">    constructor(contents = []) &#123;</span><br><span class="line">        this._queue = [...contents];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">pop</span></span>() &#123;</span><br><span class="line">        const value = this._queue[0];</span><br><span class="line">        this._queue.splice(0, 1);</span><br><span class="line">        <span class="built_in">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><h5 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h5><ul><li>使用<code>import</code>取代require，因为<strong>Module是Javascript模块的标准写法</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">const moduleA = require(<span class="string">'moduleA'</span>);</span><br><span class="line">const func1 = moduleA.func1;</span><br><span class="line">const func2 = moduleA.func2;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">import &#123; func1, func2 &#125; from <span class="string">'moduleA'</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="输出模块"><a href="#输出模块" class="headerlink" title="输出模块"></a>输出模块</h5><ul><li><p>使用<code>export</code>输出变量，拒绝<code>module.exports</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">class Breadcrumbs extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;nav /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Breadcrumbs;</span><br></pre></td></tr></table></figure></li><li><p>输出单个值，使用<code>export default</code>。</p></li><li>输出多个值，使用<code>export</code>。</li><li><code>export default</code>与普通的<code>export</code>不要同时使用。</li></ul><h5 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h5><ul><li><p>模块<strong>输出一个函数</strong>，首字母应该小写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getData</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default getData;</span><br></pre></td></tr></table></figure></li><li><p>模块<strong>输出一个对象</strong>，首字母应该大写:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Person = &#123;</span><br><span class="line">    someCode: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default Person;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;声明变量的新姿势&quot;&gt;&lt;a href=&quot;#声明变量的新姿势&quot; class=&quot;headerlink&quot; title=&quot;声明变量的新姿势&quot;&gt;&lt;/a&gt;声明变量的新姿势&lt;/h4&gt;&lt;h5 id=&quot;用let不用var&quot;&gt;&lt;a href=&quot;#用let不用var&quot; class=&quot;headerlink&quot; title=&quot;用let不用var&quot;&gt;&lt;/a&gt;用let不用var&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;ES6之前我们用&lt;code&gt;var&lt;/code&gt;声明一个变量，但是它有很多弊病：
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 错误 - Throw、Try 和 Catch</title>
    <link href="https://chongtianhong.github.io/2018/06/02/tryAndCatch/"/>
    <id>https://chongtianhong.github.io/2018/06/02/tryAndCatch/</id>
    <published>2018-06-02T08:15:39.000Z</published>
    <updated>2018-09-04T14:22:11.436Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>try</code>语句<strong>测试代码块的错误</strong>。</li><li><code>catch</code>语句<strong>处理错误</strong>。</li><li><code>throw</code>语句<strong>创建自定义错误</strong>。</li><li><code>finally</code>语句在code&gt;try和<code>catch</code>之后<strong>无论有无异常都会执行</strong>。<a id="more"></a></li></ul><h4 id="错误一定会发生"><a href="#错误一定会发生" class="headerlink" title="错误一定会发生"></a>错误一定会发生</h4><ul><li>当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误：<ul><li>可能是<strong>语法错误</strong>，通常是程序员造成的编码错误或错别字。</li><li>可能是<strong>拼写错误</strong>或<strong>语言中缺少的功能</strong>（可能由于浏览器差异）。</li><li>可能是<strong>由于来自服务器或用户的错误输出而导致的错误</strong>。</li><li>当然，也可能是由于许多其他<strong>不可预知的因素</strong>。</li></ul></li></ul><h4 id="JavaScript-抛出错误"><a href="#JavaScript-抛出错误" class="headerlink" title="JavaScript 抛出错误"></a>JavaScript 抛出错误</h4><ul><li>当错误发生时，<strong>JavaScript 引擎通常会停止</strong>，并生成一个错误消息。</li><li>描述这种情况的技术术语是：<strong>JavaScript 将抛出一个错误</strong>。</li></ul><h4 id="JavaScript-测试和捕捉"><a href="#JavaScript-测试和捕捉" class="headerlink" title="JavaScript 测试和捕捉"></a>JavaScript 测试和捕捉</h4><ul><li><strong>try</strong>语句允许我们定义在<strong>执行时进行错误测试</strong>的代码块。</li><li><strong>catch</strong>语句允许我们定义当<strong>try</strong>代码块<strong>发生错误时，所执行的代码块</strong>。</li><li>JavaScript 语句<strong>try</strong>和<strong>catch</strong>是<strong>成对出现</strong>的。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">  &#123;</span><br><span class="line">    //在这里运行代码</span><br><span class="line">  &#125;</span><br><span class="line">catch(err)</span><br><span class="line">  &#123;</span><br><span class="line">    //在这里处理错误</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>实例：在下面的例子中，我们故意在<strong>try</strong>块的代码中写了一个错字。该实例本应该提醒”欢迎光临！”，但弹出的是拼写错误信息。<strong>catch</strong>块会捕捉到<strong>try</strong>块中的错误，并执行代码来处理它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;try 语句块中的函数未定义：&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">"demo"</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">try &#123;</span><br><span class="line">    adddlert(<span class="string">"欢迎光临！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch(err) &#123;</span><br><span class="line">    document.getElementById(<span class="string">"demo"</span>).innerHTML = err.message;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Throw-语句"><a href="#Throw-语句" class="headerlink" title="Throw 语句"></a>Throw 语句</h4><ul><li><strong>throw</strong>语句允许我们<strong>创建自定义错误</strong>。正确的<strong>技术术语</strong>是：<strong>创建或抛出异常（exception）</strong>。</li><li>如果把<strong>throw</strong>与<strong>try</strong>和<strong>catch</strong>一起使用，那么我们能够控制程序流，并生成自定义的错误消息。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw exception</span><br></pre></td></tr></table></figure></li><li><p>异常可以是 JavaScript 字符串、数字、逻辑值或对象。</p></li><li><p>检测输入变量的值。如果值是错误的，会抛出一个异常（错误）。catch 会捕捉到这个错误，并显示一段自定义的错误消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>()&#123;</span><br><span class="line">                try&#123; </span><br><span class="line">                    var x=document.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line">                    <span class="keyword">if</span>(x==<span class="string">""</span>)    throw <span class="string">"值为空"</span>;</span><br><span class="line">                    <span class="keyword">if</span>(isNaN(x)) throw <span class="string">"不是数字"</span>;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;10)     throw <span class="string">"太大"</span>;</span><br><span class="line">                    <span class="keyword">if</span>(x&lt;5)      throw <span class="string">"太小"</span>;</span><br><span class="line">                &#125; catch(err)&#123;</span><br><span class="line">                    var y=document.getElementById(<span class="string">"mess"</span>);</span><br><span class="line">                    y.innerHTML=<span class="string">"错误："</span> + err + <span class="string">"。"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h1&gt;我的第一个 JavaScript 程序&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;请输入 5 到 10 之间的数字：&lt;/p&gt;</span><br><span class="line">        &lt;input id=<span class="string">"demo"</span> <span class="built_in">type</span>=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;测试输入值&lt;/button&gt;</span><br><span class="line">        &lt;p id=<span class="string">"mess"</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：如果<code>getElementById</code>函数出错，上面的例子也会抛出一个错误。</p></li></ul><h4 id="Finally-语句"><a href="#Finally-语句" class="headerlink" title="Finally 语句"></a>Finally 语句</h4><ul><li><code>finally</code>语句在code&gt;try和<code>catch</code>之后<strong>无论有无异常都会执行</strong>。</li><li><strong>注意</strong>：<code>catch</code>和<code>finally</code>语句都是可选的，但<strong>在使用<code>try</code>语句时必须至少使用一个</strong>。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    tryCode - 尝试执行代码块</span><br><span class="line">&#125;</span><br><span class="line">catch(err) &#123;</span><br><span class="line">    catchCode - 捕获错误的代码块</span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">    finallyCode - 无论 try / catch 结果如何都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;请输入 5 到 10 之间的数:&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input id=<span class="string">"demo"</span> <span class="built_in">type</span>=<span class="string">"text"</span>&gt;</span><br><span class="line">        &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;检测输入&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p id=<span class="string">"message"</span>&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">myFunction</span></span>() &#123;</span><br><span class="line">            var message, x;</span><br><span class="line">            message = document.getElementById(<span class="string">"message"</span>);</span><br><span class="line">            message.innerHTML = <span class="string">""</span>;</span><br><span class="line">            x = document.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line">            try &#123; </span><br><span class="line">                <span class="keyword">if</span>(x == <span class="string">""</span>)  throw <span class="string">"为空"</span>;</span><br><span class="line">                <span class="keyword">if</span>(isNaN(x)) throw <span class="string">"不是一个数字"</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &gt; 10)   throw <span class="string">"太大"</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; 5)    throw <span class="string">"太小"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            catch(err) &#123;</span><br><span class="line">                message.innerHTML = <span class="string">"输入的值 "</span> + err;</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                document.getElementById(<span class="string">"demo"</span>).value = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;try&lt;/code&gt;语句&lt;strong&gt;测试代码块的错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;catch&lt;/code&gt;语句&lt;strong&gt;处理错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;throw&lt;/code&gt;语句&lt;strong&gt;创建自定义错误&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finally&lt;/code&gt;语句在code&amp;gt;try和&lt;code&gt;catch&lt;/code&gt;之后&lt;strong&gt;无论有无异常都会执行&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout中被遗忘的第三个参数</title>
    <link href="https://chongtianhong.github.io/2018/06/01/theThridParamOfSetTimeOut/"/>
    <id>https://chongtianhong.github.io/2018/06/01/theThridParamOfSetTimeOut/</id>
    <published>2018-06-01T10:11:44.000Z</published>
    <updated>2018-09-03T11:49:38.038Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最熟悉的地方，往往会忽略一些细节。就比如 setTimeout 函数，做前端开发的同学都会很熟悉这个函数，经常使用这个函数，但是知道这个函数还有第三个参数的小伙伴可能就不多了。<a id="more"></a></li><li><p>阮老师的es6的primise章节里有这样一段代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>((value) =&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>仔细查看MDN中的定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var timeoutID = scope.setTimeout(<span class="keyword">function</span>[, delay, param1, param2, ...]);</span><br><span class="line">var timeoutID = scope.setTimeout(<span class="keyword">function</span>[, delay]);</span><br><span class="line">var timeoutID = scope.setTimeout(code[, delay]);</span><br></pre></td></tr></table></figure></li><li><p>定时器启动时候，第三个以后的参数是作为第一个<code>func()</code>的参数传进去。</p></li><li><p>另外一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// HTML content</span><br><span class="line">&lt;p&gt;Live Example&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"delayedAlert();"</span>&gt;Show an alert box after two seconds&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"clearAlert();"</span>&gt;Cancel alert before it happens&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">// JavaScript content</span><br><span class="line">var timeoutID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">delayedAlert</span></span>() &#123;</span><br><span class="line">    timeoutID = window.setTimeout(window.alert, 2000, <span class="string">'That was really slow!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">clearAlert</span></span>() &#123;</span><br><span class="line">    window.clearTimeout(timeoutID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：这种传参方式在<strong>IE9及更低的版本下</strong>是不起作用的，需要使用<code>polyfill</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;最熟悉的地方，往往会忽略一些细节。就比如 setTimeout 函数，做前端开发的同学都会很熟悉这个函数，经常使用这个函数，但是知道这个函数还有第三个参数的小伙伴可能就不多了。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式括号的作用</title>
    <link href="https://chongtianhong.github.io/2018/05/31/regExp2/"/>
    <id>https://chongtianhong.github.io/2018/05/31/regExp2/</id>
    <published>2018-05-31T07:32:32.000Z</published>
    <updated>2018-09-02T10:20:11.124Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>不管哪门语言中都有括号。<strong>正则表达式</strong>也是一门语言，而括号的存在使这门语言更为强大。</li><li>对<strong>括号的使用</strong>是否得心应手，是衡量对正则的掌握水平的一个侧面标准。<a id="more"></a></li><li><strong>正则表达式中的括号</strong>提供了<strong>分组</strong>，便于我们引用它。</li><li>引用某个分组，会有两种情形：在<strong>JavaScript里引用（使用相应API）</strong>，在<strong>正则表达式里引用</strong>。</li></ul><h4 id="分组和分支结构"><a href="#分组和分支结构" class="headerlink" title="分组和分支结构"></a>分组和分支结构</h4><ul><li>这二者是括号最直接的作用，也是最原始的功能。</li></ul><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><ul><li>我们知道<code>/a+/</code>匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用<code>/(ab)+/</code>。其中<strong>括号是提供分组功能</strong>，使量词<code>“+”</code>作用于<code>“ab”</code>这个整体，测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(ab)+/g;</span><br><span class="line">var string = <span class="string">"ababa abbb ababab"</span>;</span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"abab"</span>, <span class="string">"ab"</span>, <span class="string">"ababab"</span>]</span><br></pre></td></tr></table></figure></li></ul><h5 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h5><ul><li><p>在<strong>多选分支结构</strong><code>(p1|p2)</code>中，此处括号的作用也是不言而喻的，提供了<strong>子表达式的所有可能</strong>。比如，要匹配如下的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I love JavaScript</span><br><span class="line"></span><br><span class="line">I love Regular Expression</span><br></pre></td></tr></table></figure></li><li><p>可以使用正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^I love (JavaScript|Regular Expression)$/;</span><br><span class="line">var string1 = <span class="string">"I love JavaScript"</span>;</span><br><span class="line">var string2 = <span class="string">"I love Regular Expression"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">string1.match(regex) // [<span class="string">"I love JavaScript"</span>, <span class="string">"JavaScript"</span>, index: 0, input: <span class="string">"I love JavaScript"</span>]</span><br><span class="line">string2.match(regex) // [<span class="string">"I love Regular Expression"</span>, <span class="string">"Regular Expression"</span>, index: 0, input: <span class="string">"I love Regular Expression"</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果去掉正则中的括号，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^I love JavaScript|Regular Expression$/;</span><br><span class="line">var string1 = <span class="string">"I love JavaScript"</span>;</span><br><span class="line">var string2 = <span class="string">"I love Regular Expression"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">string1.match(regex) // [<span class="string">"I love JavaScript"</span>, index: 0, input: <span class="string">"I love JavaScript"</span>]</span><br><span class="line">string2.match(regex) // [<span class="string">"Regular Expression"</span>, index: 7, input: <span class="string">"I love Regular Expression"</span>]</span><br></pre></td></tr></table></figure></li><li><p>可以看到，匹配字符串是<code>“I love JavaScript”</code>和<code>“Regular Expression”</code>，当然这不是我们想要的。</p></li></ul><h4 id="引用分组"><a href="#引用分组" class="headerlink" title="引用分组"></a>引用分组</h4><ul><li>这是括号一个<strong>重要的作用</strong>，有了它，我们就可以进行<strong>数据提取</strong>，以及更强大的<strong>替换操作</strong>。而要使用它带来的好处，必须配合使用实现环境的API。</li><li><p>以日期为例。假设格式是<code>yyyy-mm-dd</code>的，我们可以先写一个简单的正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/;</span><br></pre></td></tr></table></figure></li><li><p>然后再修改成括号版的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br></pre></td></tr></table></figure></li><li><p>使用括号版的正则，能方便地实现<strong>数据的提取和替换</strong>功能。</p></li></ul><h5 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h5><ul><li><p>比如提取出年、月、日，可以这么做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">console.log( string.match(regex) ); </span><br><span class="line">// =&gt; [<span class="string">"2017-06-12"</span>, <span class="string">"2017"</span>, <span class="string">"06"</span>, <span class="string">"12"</span>, index: 0, input: <span class="string">"2017-06-12"</span>]</span><br></pre></td></tr></table></figure></li><li><p>match返回的一个数组，第一个元素是<strong>整体匹配结果</strong>，然后是<strong>各个分组（括号里）匹配的内容</strong>，然后是<strong>匹配下标(index)</strong>，最后是<strong>输入的文本(input)</strong>。</p></li><li><strong>注意</strong>：如果正则是否有修饰符<code>g</code>，match返回的数组格式是不一样的。</li><li><p>另外也可以使用正则对象的exec方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">console.log( regex.exec(string) ); </span><br><span class="line">// =&gt; [<span class="string">"2017-06-12"</span>, <span class="string">"2017"</span>, <span class="string">"06"</span>, <span class="string">"12"</span>, index: 0, input: <span class="string">"2017-06-12"</span>]</span><br></pre></td></tr></table></figure></li><li><p>同时，也可以使用构造函数的全局属性<code>$1</code>至<code>$9</code>来获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line"></span><br><span class="line">regex.test(string); // 正则操作即可，例如</span><br><span class="line">// regex.exec(string);</span><br><span class="line">// string.match(regex);</span><br><span class="line"></span><br><span class="line">console.log(RegExp.<span class="variable">$1</span>); // <span class="string">"2017"</span></span><br><span class="line">console.log(RegExp.<span class="variable">$2</span>); // <span class="string">"06"</span></span><br><span class="line">console.log(RegExp.<span class="variable">$3</span>); // <span class="string">"12"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul><li><p>比如，想把<code>yyyy-mm-dd</code>格式，替换成<code>mm/dd/yyyy</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="string">"<span class="variable">$2</span>/<span class="variable">$3</span>/<span class="variable">$1</span>"</span>);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li><li><p>其中replace中的<strong>第二个参数</strong>里用<code>$1</code>、<code>$2</code>、<code>$3</code>指代相应的分组。等价于如下的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> RegExp.<span class="variable">$2</span> + <span class="string">"/"</span> + RegExp.<span class="variable">$3</span> + <span class="string">"/"</span> + RegExp.<span class="variable">$1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li><li><p>也等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</span><br><span class="line">var string = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var result = string.replace(regex, <span class="keyword">function</span>(match, year, month, day) &#123;</span><br><span class="line"><span class="built_in">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // <span class="string">"06/12/2017"</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><ul><li>除了使用<strong>相应API</strong>来引用分组，也可以在<strong>正则本身里引用分组</strong>。但<strong>只能引用之前出现的分组</strong>，即<strong>反向引用</strong>。</li><li><p>还是以日期为例。比如要写一个正则支持匹配如下三种格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-06-12</span><br><span class="line"></span><br><span class="line">2016/06/12</span><br><span class="line"></span><br><span class="line">2016.06.12</span><br></pre></td></tr></table></figure></li><li><p>最先可能想到的正则是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/;</span><br><span class="line">var string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line">var string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line">var string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string4) ); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>其中/和.需要转义。虽然匹配了要求的情况，但也匹配<code>“2016-06/12”</code>这样的数据。</p></li><li><p>如果<strong>要求分割符前后一致</strong>则需要<strong>使用反向引用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</span><br><span class="line">var string1 = <span class="string">"2017-06-12"</span>;</span><br><span class="line">var string2 = <span class="string">"2017/06/12"</span>;</span><br><span class="line">var string3 = <span class="string">"2017.06.12"</span>;</span><br><span class="line">var string4 = <span class="string">"2016-06/12"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string4) ); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>注意正则表达式里面的<code>\1</code>，表示的引用之前的那个分组<code>(-|\/|.)</code>。不管它匹配到什么（比如<code>-</code>），<code>\1</code>都<strong>匹配</strong>那个<strong>同样的具体某个字符</strong>。</p></li><li>知道了<code>\1</code>的含义后，那么<code>\2</code>和<code>\3</code>的概念也就理解了，即分别指代<strong>第二个</strong>和<strong>第三个分组</strong>。</li></ul><h5 id="括号嵌套怎么办？"><a href="#括号嵌套怎么办？" class="headerlink" title="括号嵌套怎么办？"></a>括号嵌套怎么办？</h5><ul><li>以<strong>左括号（开括号）</strong>为准。比如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</span><br><span class="line">var string = <span class="string">"1231231233"</span>;</span><br><span class="line">console.log( regex.test(string) ); // <span class="literal">true</span></span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"1231231233"</span>, <span class="string">"123"</span>, <span class="string">"1"</span>, <span class="string">"23"</span>, <span class="string">"3"</span>, index: 0, input: <span class="string">"1231231233"</span>]</span><br><span class="line">console.log( RegExp.<span class="variable">$1</span> ); // 123</span><br><span class="line">console.log( RegExp.<span class="variable">$2</span> ); // 1</span><br><span class="line">console.log( RegExp.<span class="variable">$3</span> ); // 23</span><br><span class="line">console.log( RegExp.<span class="variable">$4</span> ); // 3</span><br></pre></td></tr></table></figure></li></ul><h5 id="10表示什么？"><a href="#10表示什么？" class="headerlink" title="\10表示什么？"></a>\10表示什么？</h5><ul><li>有可能会产生这样的疑问，即<code>\10</code>是表示第10个分组，还是<code>\1</code>和<code>0</code>呢？答案是<strong>前者</strong>，虽然一个正则里出现\10比较罕见。测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(<span class="comment">#) \10+/;</span></span><br><span class="line">var string = <span class="string">"123456789# ######"</span></span><br><span class="line">console.log( regex.test(string) ); // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="引用不存在的分组会怎样？"><a href="#引用不存在的分组会怎样？" class="headerlink" title="引用不存在的分组会怎样？"></a>引用不存在的分组会怎样？</h5><ul><li>因为<strong>反向引用</strong>是<strong>引用前面的分组</strong>，但我们在正则里<strong>引用了不存在的分组时</strong>，此时正则<strong>不会报错</strong>，只是<strong>匹配反向引用的字符本身</strong>。例如<code>\2</code>，就匹配<code>“\2”</code>。注意<code>“\2”</code>表示<strong>对2进行了转义</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /\1\2\3\4\5\6\7\8\9/;</span><br><span class="line">console.log( regex.test(<span class="string">"\1\2\3\4\5\6\7\8\9"</span>) ); </span><br><span class="line">console.log( <span class="string">"\1\2\3\4\5\6\7\8\9"</span>.split(<span class="string">""</span>) ); //  [<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"8"</span>, <span class="string">"9"</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h4><ul><li>之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是<strong>捕获型分组</strong>。</li><li><p>如果<strong>只想要括号最原始的功能</strong>，但<strong>不会引用它</strong>，即，既不在API里引用，也不在正则里反向引用。此时可以<strong>使用非捕获分组<code>(?:p)</code></strong>，例如本文第一个例子可以修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var regex = /(?:ab)+/g;</span><br><span class="line">var string = <span class="string">"ababa abbb ababab"</span>;</span><br><span class="line">console.log( string.match(regex) ); // [<span class="string">"abab"</span>, <span class="string">"ab"</span>, <span class="string">"ababab"</span>]</span><br></pre></td></tr></table></figure></li><li><p>这样使用括号匹配到的数据，将不能在API里或正则里反向引用。</p></li></ul><h4 id="相关案例"><a href="#相关案例" class="headerlink" title="相关案例"></a>相关案例</h4><h5 id="字符串trim方法模拟"><a href="#字符串trim方法模拟" class="headerlink" title="字符串trim方法模拟"></a>字符串trim方法模拟</h5><ul><li><code>trim</code>方法是<strong>去掉字符串的开头和结尾的空白符</strong>。有两种思路去做。</li><li><p><strong>第一种</strong>，匹配到开头和结尾的空白符，然后替换成空字符。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trim(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/^\s+|\s+$/g, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(<span class="string">"  foobar   "</span>) ); // <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>第二种</strong>，匹配整个字符串，然后<strong>用引用来提取出相应的数据</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> trim(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/^\s*(.*?)\s*$/g, <span class="string">"<span class="variable">$1</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log( trim(<span class="string">"  foobar   "</span>) ); // <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></li><li><p>这里使用了惰性匹配<code><em>?</em></code>，不然也会<em>*匹配最后一个空格之前的所有空格</em>。</p></li><li>第一种方法效率高。</li></ul><h5 id="将每个单词的首字母转换为大写"><a href="#将每个单词的首字母转换为大写" class="headerlink" title="将每个单词的首字母转换为大写"></a>将每个单词的首字母转换为大写</h5><ul><li>思路是<strong>找到每个单词的首字母</strong>，当然这里<strong>不使用非捕获匹配也是可以的</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> titleize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.toLowerCase().replace(/(?:^|\s)\w/g, <span class="keyword">function</span>(c) &#123;</span><br><span class="line"><span class="built_in">return</span> c.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( titleize(<span class="string">'my name is epeli'</span>) ); // <span class="string">"My Name Is Epeli"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="驼峰化"><a href="#驼峰化" class="headerlink" title="驼峰化"></a>驼峰化</h5><ul><li><p>比如对<code>‘-moz-transform’</code>进行驼峰化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> camelize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/[-_\s]+(.)?/g, <span class="keyword">function</span>(match, firstLetter) &#123;</span><br><span class="line"><span class="built_in">return</span> firstLetter ? firstLetter.toUpperCase() : <span class="string">''</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log( camelize(<span class="string">'-moz-transform'</span>) ); // MozTransform</span><br></pre></td></tr></table></figure></li><li><p>其中<strong>分组<code>(.)</code>表示首字母</strong>，单词的界定，<strong>前面的字符</strong>可以是多个连字符、下划线以及空白符（中括号规定）。正则后面的<code>?</code>的目的，是为了应对str尾部的字符可能不是单词字符，比如str是<code>‘-moz-transform ‘</code>。</p></li></ul><h5 id="中划线化"><a href="#中划线化" class="headerlink" title="中划线化"></a>中划线化</h5><ul><li>驼峰化的逆过程，比如对<code>‘MozTransform’</code>进行中划线化：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> dasherize(str) &#123;</span><br><span class="line"><span class="built_in">return</span> str.replace(/([A-Z])/g, <span class="string">'-$1'</span>).replace(/[-_\s]+/g, <span class="string">'-'</span>).toLowerCase();</span><br><span class="line">    // 前一个replace结果：-Moz-Transform</span><br><span class="line">    // 后一个replace结果：-Moz-Transform</span><br><span class="line">    // 最后使用toLowerCase：-moz-transform</span><br><span class="line">&#125;</span><br><span class="line">console.log( dasherize(<span class="string">'MozTransform'</span>) ); // -moz-transform</span><br></pre></td></tr></table></figure></li></ul><h5 id="匹配成对标签"><a href="#匹配成对标签" class="headerlink" title="匹配成对标签"></a>匹配成对标签</h5><ul><li><p>要求匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;regular expression&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;laoyao <span class="built_in">bye</span> <span class="built_in">bye</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>不匹配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;wrong!&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>匹配一个开标签，可以使用正则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;[^&gt;]+&gt;</span><br></pre></td></tr></table></figure></li><li><p>匹配一个闭标签，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;\/[^&gt;]+&gt;</span><br></pre></td></tr></table></figure></li><li><p>但是要求<strong>匹配成对标签</strong>，那就需要<strong>使用反向引用</strong>，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var regex = /&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/;</span><br><span class="line">var string1 = <span class="string">"&lt;title&gt;regular expression&lt;/title&gt;"</span>;</span><br><span class="line">var string2 = <span class="string">"&lt;p&gt;laoyao bye bye&lt;/p&gt;"</span>;</span><br><span class="line">var string3 = <span class="string">"&lt;title&gt;wrong!&lt;/p&gt;"</span>;</span><br><span class="line">console.log( regex.test(string1) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string2) ); // <span class="literal">true</span></span><br><span class="line">console.log( regex.test(string3) ); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>其中开标签增加括号版，使用括号的目的是为了后面<strong>使用反向引用</strong>，而提供分组。闭标签使用了反向引用。</p></li><li>另外，<code>[\d\D]</code>的意思是，这个字符是数字或者不是数字，因此，也就是<strong>匹配任意字符</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不管哪门语言中都有括号。&lt;strong&gt;正则表达式&lt;/strong&gt;也是一门语言，而括号的存在使这门语言更为强大。&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;括号的使用&lt;/strong&gt;是否得心应手，是衡量对正则的掌握水平的一个侧面标准。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="正则表达式" scheme="https://chongtianhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Express使用进阶：cookie-parser中间件实现深入剖析</title>
    <link href="https://chongtianhong.github.io/2018/05/30/cookieParse/"/>
    <id>https://chongtianhong.github.io/2018/05/30/cookieParse/</id>
    <published>2018-05-30T08:12:21.000Z</published>
    <updated>2018-09-01T11:56:04.082Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><code>cookie-parser</code>是Express的中间件，用来<strong>实现cookie的解析</strong>，是官方脚手架内置的中间件之一。</li><li>它的使用非常简单，但在使用过程中偶尔也会遇到问题。一般都是因为对<code>Express + cookie-parser</code>的<strong>签名、验证机制</strong>不了解导致的。</li><li>本文深入讲解<code>Express + cookie-parser</code>的<strong>签名和验证</strong>的实现机制，以及cookie签名是如何<strong>增强网站的安全性</strong>的。<a id="more"></a></li></ul><h4 id="cookie特点"><a href="#cookie特点" class="headerlink" title="cookie特点"></a>cookie特点</h4><ul><li>cookie 保存在<strong>浏览器</strong>本地；</li><li>正常设置的 cookie 是不加密的，用户可以自由看到；</li><li>用户可以删除 cookie，或者禁用它；</li><li>cookie 可以<strong>被篡改</strong>；</li><li>cookie 可以用于XSS攻击；</li><li>cookie <strong>存储量很小</strong>。</li></ul><h4 id="cookie的创建"><a href="#cookie的创建" class="headerlink" title="cookie的创建"></a>cookie的创建</h4><ul><li><p>Express直接提供了api，只需要在需要使用的地方调用如下api即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(name, value [, options]);</span><br><span class="line"></span><br><span class="line">// name: 类型为String</span><br><span class="line">// value: 类型为String和Object，如果是Object会在cookie.serialize()之前自动调用JSON.stringify对其进行处理</span><br><span class="line">// Option: 类型为对象，可使用的属性如下:</span><br><span class="line">domain：cookie在什么域名下有效，类型为String,。默认为网站域名</span><br><span class="line">expires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。</span><br><span class="line">httpOnly: 只能被web server访问，类型Boolean，默认<span class="literal">false</span>，设置为<span class="literal">true</span>时不允许客户端脚本访问，能有效的防止XSS攻击。</span><br><span class="line">maxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。</span><br><span class="line">path: cookie在什么路径下有效，默认为<span class="string">'/'</span>，类型为String</span><br><span class="line">secure：只能被HTTPS使用，类型Boolean，默认为<span class="literal">false</span></span><br><span class="line">signed：使用签名，类型Boolean，默认为<span class="literal">false</span>。`express会使用req.secret来完成签名，需要cookie-parser配合使用`</span><br></pre></td></tr></table></figure></li><li><p>Express就会将其填入<code>Response Header</code>中的<code>Set-Cookie</code>，达到<strong>在浏览器中设置cookie</strong>的作用。</p></li><li>用例如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res.cookie(<span class="string">'name'</span>, <span class="string">'koby'</span>, &#123; domain: <span class="string">'.example.com'</span>, path: <span class="string">'/admin'</span>, secure: <span class="literal">true</span> &#125;);</span><br><span class="line">//cookie的有效期为900000ms</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>, <span class="string">'1'</span>, &#123; expires: new Date(Date.now() + 900000), httpOnly: <span class="literal">true</span> &#125;);</span><br><span class="line">//cookie的有效期为900000ms</span><br><span class="line">res.cookie(<span class="string">'rememberme'</span>, <span class="string">'1'</span>, &#123; maxAge: 900000, httpOnly: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">//cookie的value为对象</span><br><span class="line">res.cookie(<span class="string">'cart'</span>, &#123; items: [1,2,3] &#125;);</span><br><span class="line">res.cookie(<span class="string">'cart'</span>, &#123; items: [1,2,3] &#125;, &#123; maxAge: 900000 &#125;);</span><br><span class="line"></span><br><span class="line">res.cookie(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; signed: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="cookie的删除"><a href="#cookie的删除" class="headerlink" title="cookie的删除"></a>cookie的删除</h4><ul><li>Express直接提供了api，只需要在需要使用的地方调用如下api即可：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.clearCookie(name [, options]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="入门例子：cookie设置与解析"><a href="#入门例子：cookie设置与解析" class="headerlink" title="入门例子：cookie设置与解析"></a>入门例子：cookie设置与解析</h4><ul><li>先从最简单的例子来看下<code>cookie-parser</code>的使用，这里采用默认配置：<br>1、<strong>cookie设置</strong>：使用Express的内置方法<code>res.cookie()</code>。<br>2、<strong>cookie解析</strong>：使用<code>cookie-parser</code>中间件。</li><li><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var cookieParser = require(<span class="string">'cookie-parser'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">    console.log(req.cookies.nick); // 第二次访问，输出hongxb</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;  </span><br><span class="line">    res.cookie(<span class="string">'nick'</span>, <span class="string">'hongxb'</span>);</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li><li><p>在当前场景下，<code>cookie-parser</code>中间件大致实现如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">  req.cookies = cookie.parse(req.headers.cookie);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="进阶例子：cookie签名与解析"><a href="#进阶例子：cookie签名与解析" class="headerlink" title="进阶例子：cookie签名与解析"></a>进阶例子：cookie签名与解析</h4><ul><li>出于安全的考虑，我们通常需要<strong>对cookie进行签名</strong>。</li><li>改写例子有几个注意点：<br>1、<code>cookieParser</code>初始化时，传入<code>secret</code>作为签名的<strong>密钥</strong>。<br>2、设置cookie时，将<code>signed</code>设置为<code>true</code>，表示<strong>对即将设置的cookie进行签名</strong>。<br>3、获取cookie时，可以通过<code>req.cookies</code>获取<strong>未签名的cookie</strong>，也可以通过<code>req.signedCookies</code>获取<strong>使用签名的cookie</strong>。<br>4、当然如果想拿到<strong>浏览器传过来的cookie原始数据</strong>，总是可以通过express中的<code>req.headers.cookie</code>获得：</li><li><p>例子改写如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var cookieParser = require(<span class="string">'cookie-parser'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">// 初始化中间件，传入的第一个参数为singed secret</span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>));</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">    console.log(req.cookies.nick); // undefined</span><br><span class="line">    console.log(req.signedCookies.nick); // hongxb</span><br><span class="line">    console.log(req.headers.cookie); // nick=s%3Ahongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">function</span> (req, res, next) &#123;  </span><br><span class="line">    // 传入第三个参数 &#123;signed: <span class="literal">true</span>&#125;，表示要对cookie进行摘要计算</span><br><span class="line">    res.cookie(<span class="string">'nick'</span>, <span class="string">'hongxb'</span>, &#123;signed: <span class="literal">true</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li><li><p>可以看到，签名前的cookie值为<code>chyingp</code>，签名后的cookie值为<code>s%3Ahongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</code>，decode后为<code>s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</code>。</p></li><li>下面就来分析下，cookie的签名、解析是如何实现的。</li></ul><h4 id="cookie签名、验证实现剖析"><a href="#cookie签名、验证实现剖析" class="headerlink" title="cookie签名、验证实现剖析"></a>cookie签名、验证实现剖析</h4><ul><li>Express的内置方法<code>res.cookie()</code>完成cookie值的签名，中间件<code>cookie-parser</code>（<code>req.signedCookies</code>）实现签名cookie的解析。两者<strong>共用同一个密钥</strong>。</li></ul><h5 id="cookie签名"><a href="#cookie签名" class="headerlink" title="cookie签名"></a>cookie签名</h5><ul><li>Express对<strong>cookie的设置（包括签名）</strong>，都是通过<code>res.cookie()</code>这个方法实现的。</li><li><p>精简后的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res.cookie = <span class="keyword">function</span> (name, value, options) &#123;  </span><br><span class="line">    var secret = this.req.secret; // cookie-parser初始化的时候传入的</span><br><span class="line">    var signed = opts.signed;</span><br><span class="line"></span><br><span class="line">    // 如果 options.signed 为<span class="literal">true</span>，则对cookie进行签名</span><br><span class="line">    <span class="keyword">if</span> (signed) &#123;</span><br><span class="line">        val = <span class="string">'s:'</span> + sign(val, secret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.append(<span class="string">'Set-Cookie'</span>, cookie.serialize(name, String(val), opts));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sign</code>为<strong>签名函数</strong>。伪代码如下，其实就是<strong>把cookie的原始值，跟hmac后的值拼接起来</strong>。</p></li><li><p><strong>注意</strong>：签名后的cookie值，包含了原始值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sign (val, secret) &#123;</span><br><span class="line">    <span class="built_in">return</span> val + <span class="string">'.'</span> + hmac(val, secret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码中的<code>req.secret</code>是<code>cookie-parser</code>初始化的时候传入的。如下伪代码所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var cookieParser = <span class="keyword">function</span> (secret) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (req, res, next) &#123;</span><br><span class="line">        req.secret = secret;</span><br><span class="line">        // ...</span><br><span class="line">        next();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(<span class="string">'secret'</span>));</span><br></pre></td></tr></table></figure></li></ul><h5 id="签名cookie解析"><a href="#签名cookie解析" class="headerlink" title="签名cookie解析"></a>签名cookie解析</h5><ul><li>“解析”签名cookie这个阶段，中间件主要做了两件事：<br>1、将签名cookie对应的<strong>原始值提取</strong>出来；<br>2、<strong>验证签名cookie是否合法</strong>。</li><li><p>实现代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// str：签名后的cookie，比如 <span class="string">"s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA"</span></span><br><span class="line">// secret：密钥，比如 <span class="string">"secret"</span></span><br><span class="line"><span class="keyword">function</span> signedCookie(str, secret) &#123;</span><br><span class="line"></span><br><span class="line">    // 检查是否 s: 开头，确保只对签过名的cookie进行解析</span><br><span class="line">    <span class="keyword">if</span> (str.substr(0, 2) !== <span class="string">'s:'</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 校验签名的值是否合法，如合法，返回<span class="literal">true</span>，否则，返回<span class="literal">false</span></span><br><span class="line">    var isValid = unsign(str.slice(2), secret);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断、提取cookie原始值比较简单。只是<code>unsign</code>方法名比较有迷惑性，该方法用于<strong>对签名进行合法校验</strong>。</p></li><li><code>unsign</code>方法主要做了以下三件事：<br>1、从传入的cookie值中，分别提取出原始值A1、签名值B1。<br>2、用同样的密钥对A1进行签名，得到A2。<br>3、根据A2、B1是否相等，判断签名是否合法。</li><li>大致代码如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> unsign(val, secret)&#123;</span><br><span class="line">    var A1 = val.slice(0, val.lastIndexOf(<span class="string">'.'</span>)),  // hongxb</span><br><span class="line">        B1 = val, // hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br><span class="line">        A2 = sign(A1, secret); // hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> B1 == A2 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="cookie签名的作用"><a href="#cookie签名的作用" class="headerlink" title="cookie签名的作用"></a>cookie签名的作用</h4><ul><li>主要是出于安全考虑，<strong>防止cookie被篡改</strong>，增强安全性。</li><li>举个小例子来看下cookie签名是如何实现防篡改的。</li><li><p>基于前面的例子展开。假设网站通过<code>nick</code>这个cookie来<strong>区分当前登录的用户</strong>。在前面例子中，登录用户的cookie中，<code>nick</code>对应的值如下：(decode后的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:hongxb.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br></pre></td></tr></table></figure></li><li><p>此时，有人试图修改这个cookie值，来达到伪造身份的目的。比如修改成<code>xiaoming</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:xiaoming.2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA</span><br></pre></td></tr></table></figure></li><li><p>当网站收到请求，对签名cookie进行解析，发现签名验证不通过。由此可判断，cookie是伪造的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmac(<span class="string">"xiaoming"</span>, <span class="string">"secret"</span>) !== <span class="string">"2cVrRm82HswllwQRkImpw0L2q3uWLoQcmzLnEJxKkFA"</span></span><br></pre></td></tr></table></figure></li><li><p>cookie签名缺点：<br>1、cookie值依然能被看到。<br>2、读取签名过的cookie必须进行解签。<br>3、增加cookie大小，浪费空间。</p></li></ul><h4 id="签名就一定能够确保安全吗"><a href="#签名就一定能够确保安全吗" class="headerlink" title="签名就一定能够确保安全吗"></a>签名就一定能够确保安全吗</h4><ul><li>上个小节的例子，仅通过<code>nick</code>这个cookie的值来判断登录的是哪个用户，这是一个非常糟糕的设计。虽然<strong>在密钥未知的情况下，很难伪造签名cookie</strong>。但<strong>用户名相同的情况下，签名也是相同的</strong>。这种情况下，其实是很容易伪造的。</li><li>另外，开源组件的算法是公开的，因此密钥的安全性就成了关键，要<strong>确保密钥不泄露</strong>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>发送cookie：使用res.cookie直接设置cookie。</li><li>获取cookie时，可以通过<code>req.cookies</code>获取<strong>未签名的cookie</strong>，也可以通过<code>req.signedCookies</code>获取<strong>使用签名的cookie</strong>。</li><li>使用签名cookie可防止cookie被修改，通过在<strong>设置cookie的时候</strong>配置<code>signed</code>属性值为<code>true</code>。</li><li>配置<code>cookie-parser</code>中间件的时候需要传参，作为签名的密钥。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cookie-parser&lt;/code&gt;是Express的中间件，用来&lt;strong&gt;实现cookie的解析&lt;/strong&gt;，是官方脚手架内置的中间件之一。&lt;/li&gt;
&lt;li&gt;它的使用非常简单，但在使用过程中偶尔也会遇到问题。一般都是因为对&lt;code&gt;Express + cookie-parser&lt;/code&gt;的&lt;strong&gt;签名、验证机制&lt;/strong&gt;不了解导致的。&lt;/li&gt;
&lt;li&gt;本文深入讲解&lt;code&gt;Express + cookie-parser&lt;/code&gt;的&lt;strong&gt;签名和验证&lt;/strong&gt;的实现机制，以及cookie签名是如何&lt;strong&gt;增强网站的安全性&lt;/strong&gt;的。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://chongtianhong.github.io/tags/Express/"/>
    
      <category term="cookie-parser" scheme="https://chongtianhong.github.io/tags/cookie-parser/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化（CommonJs、AMD和CMD）</title>
    <link href="https://chongtianhong.github.io/2018/05/29/frontEndModule/"/>
    <id>https://chongtianhong.github.io/2018/05/29/frontEndModule/</id>
    <published>2018-05-29T12:27:50.000Z</published>
    <updated>2018-08-31T15:34:37.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>前端模块规范有三种，分别是<code>CommonJs</code>、<code>AMD</code>和<code>CMD</code>。</li><li><code>CommonJs</code>用在服务器端，<code>AMD</code>和<code>CMD</code>用在浏览器环境。</li><li><code>AMD</code>是<strong>RequireJS</strong>在推广过程中对模块定义的规范化产出。</li><li><code>CMD</code>是<strong>SeaJS</strong>在推广过程中对模块定义的规范化产出。<a id="more"></a></li><li><code>AMD</code>：提前执行（异步加载：依赖先执行）/ 延迟执行（RequireJS 从 2.0 开始，也改成可以延迟执行）。</li><li><code>CMD</code>：延迟执行（运行到需加载，根据顺序执行）。</li></ul><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h5 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h5><ul><li>模块就是实现特定功能的一组方法。</li><li><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m1</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m2</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，组成一个模块。使用的时候，直接调用就行了。</p></li><li>这种做法的<strong>缺点</strong>很明显：<strong>“污染”了全局变量</strong>，<strong>无法保证不与其他模块发生变量名冲突</strong>，而且<strong>模块成员之间看不出直接关系</strong>。</li></ul><h5 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h5><ul><li><p>为了解决上面的缺点，可以<strong>把模块写成一个对象</strong>，所有的<strong>模块成员都放到</strong>这个<strong>对象里面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var module1 = new Object(&#123;</span><br><span class="line"></span><br><span class="line">　　_count : 0,</span><br><span class="line"></span><br><span class="line">　　m1 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;,</span><br><span class="line"></span><br><span class="line">　　m2 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，都封装在module1对象里。使用的时候，就是<strong>调用这个对象的属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure></li><li><p>但是，这样的写法会<strong>暴露所有模块成员</strong>，<strong>内部状态可以被外部改写</strong>。比如，外部代码可以直接改变内部计数器的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1._count = 5;</span><br></pre></td></tr></table></figure></li></ul><h5 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h5><ul><li><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到<strong>不暴露私有成员</strong>的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    var _count = 0;</span><br><span class="line"></span><br><span class="line">    var m1 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var m2 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">    　　m1 : m1,</span><br><span class="line">    　　m2 : m2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>使用上面的写法，<strong>外部代码无法读取内部的</strong><code>_count</code><strong>变量</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.info(module1._count); //undefined</span><br></pre></td></tr></table></figure></li><li><p><code>module1</code>就是Javascript模块的基本写法。</p></li></ul><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ul><li><p><code>CommonJs</code>是<strong>服务器端模块</strong>的规范，由Node推广使用。由于服务端编程的复杂性，如果没有模块很难与操作系统及其他应用程序互动。使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">    <span class="built_in">return</span> add(val, 1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">var increment = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">var a = increment(1); //2</span><br></pre></td></tr></table></figure></li><li><p>根据CommonJS规范：</p><ul><li>一个单独的文件就是一个模块。<strong>每一个模块都是一个单独的作用域</strong>，也就是说，在该<strong>模块内部定义的变量，无法被其他模块读取</strong>，除非定义为<code>global</code>对象的属性。<br>-<strong> 输出模块变量</strong>的最好方法是<strong>使用<code>module.exports</code>对象</strong>。</li><li><strong>加载模块</strong>使用<code>require</code>方法，该方法读取一个文件并执行，返回文件内部的<code>module.exports</code>对象。</li></ul></li><li>仔细看上面的代码，可以发现<strong><code>require</code>是同步的</strong>。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。</li><li>然而，这在浏览器端就会有很大问题。因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，<strong>浏览器处于”假死”状态</strong>。因此，<strong>浏览器端的模块，不能采用”同步加载”（synchronous）</strong>，只能采用”异步加载”（asynchronous）。</li><li><strong>浏览器端</strong>，加载 JavaScript 最佳、最容易的方式是在 document 中插入<code>&lt;script&gt;</code>标签。但<strong>脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载</strong>。</li><li><strong>解决思路之一</strong>是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</li><li><p><strong>另一种解决思路</strong>是，用一套标准模板来封装模块定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  // The module code goes here</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这套模板代码为模块加载器提供了机会，使其能在<strong>模块代码执行之前</strong>，对模块代码进行<strong>静态分析</strong>，并<strong>动态生成依赖列表</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">            sum += args[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">    exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">        <span class="built_in">return</span> add(val, 1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var inc = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">    inc(1); // 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ul><li>AMD是<code>“Asynchronous Module Definition”</code>的缩写，意思就是”异步模块定义”。由于不是JavaScript原生支持，<strong>使用AMD规范进行页面开发需要用到对应的库函数</strong>，也就是<code>RequireJS</code>，实际上AMD 是<code>RequireJS</code>在推广过程中对模块定义的规范化的产出。</li><li>AMD采用<strong>异步方式</strong>加载模块，模块的加载不影响它后面语句的运行。所有<strong>依赖这个模块的语句，都定义在一个回调函数中</strong>，等到加载完成之后，这个回调函数才会运行。</li><li><code>RequireJS</code>主要解决两个问题：<ul><li><strong>多个JS文件可能有依赖关系</strong>，被依赖的文件需要早于依赖它的文件加载到浏览器；</li><li><strong>JS加载的时候浏览器会停止页面渲染</strong>，加载文件越多，页面失去响应时间越长。</li></ul></li><li><code>RequireJS</code>也采用<code>require()</code>语句加载模块，但是<strong>不同于CommonJS，它要求两个参数</strong>，语法：<code>require([module], callback)</code>:<ul><li>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；</li><li>第二个参数callback，则是加载成功之后的回调函数。</li></ul></li><li><p>将使用<strong>不适用于浏览器环境的CommonJS规范</strong>的代码改成<strong>符合AMD规范</strong>的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* CommonJS */</span><br><span class="line">var math = require(<span class="string">'math'</span>);</span><br><span class="line">math.add(2, 3);</span><br><span class="line"></span><br><span class="line">/* AMD */</span><br><span class="line">require([<span class="string">'math'</span>], <span class="keyword">function</span> (math) &#123;</span><br><span class="line">    math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>math.add()</code>与<code>math</code>模块加载不是同步的，浏览器不会发生假死。所以很显然，<strong>AMD比较适合浏览器环境</strong>。</p></li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><ul><li>CMD(Common Module Definition)即<strong>通用模块定义</strong>，CMD规范是国内发展出来的，就像AMD有个<code>RequireJS</code>，CMD有个浏览器的实现<code>SeaJS</code>，<code>SeaJS</code>要解决的问题和<code>RequireJS</code>一样，只不过在<strong>模块定义方式</strong>和<strong>模块加载（可以说运行、解析）时机</strong>上有所不同。</li><li><p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    // require是可以把其他模块导入进来的一个参数;</span><br><span class="line">    // exports是可以把模块内的一些属性和方法导出的;</span><br><span class="line">    // module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</span><br><span class="line"></span><br><span class="line">    // 模块代码</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>AMD是<strong>依赖关系前置</strong>，在定义模块的时候就要声明其依赖的模块；</p></li><li><p>CMD是<strong>按需加载依赖就近</strong>，只有在用到某个模块的时候再去require：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    var b = require(<span class="string">'./b'</span>) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">    // ... </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD 默认推荐的是</span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    b.doSomething()</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>seajs使用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义模块  myModule.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var $ = require(<span class="string">'jquery.js'</span>)</span><br><span class="line">    $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">    exports.data = 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="keyword">function</span>(my)&#123;</span><br><span class="line">    var star = my.data;</span><br><span class="line">    console.log(star);  // 1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/frontEndModule.png" alt="模块方案" style="border:none" width="300"></p><ul><li>AMD和CMD的区别：<ul><li>CMD 推崇<strong>依赖就近</strong>；AMD 推崇<strong>依赖前置</strong>；</li><li>CMD 是<strong>延迟执行</strong>；AMD 是<strong>提前执行</strong>；</li><li>CMD <strong>性能好</strong>，因为只有用户需要的时候才执行；AMD<strong>用户体验好</strong>，因为没有延迟，依赖模块提前执行了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前端模块规范有三种，分别是&lt;code&gt;CommonJs&lt;/code&gt;、&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CommonJs&lt;/code&gt;用在服务器端，&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;用在浏览器环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AMD&lt;/code&gt;是&lt;strong&gt;RequireJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMD&lt;/code&gt;是&lt;strong&gt;SeaJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="CommonJs" scheme="https://chongtianhong.github.io/tags/CommonJs/"/>
    
      <category term="AMD规范" scheme="https://chongtianhong.github.io/tags/AMD%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>SeaJS中use函数用法实例分析</title>
    <link href="https://chongtianhong.github.io/2018/05/28/SeaJS/"/>
    <id>https://chongtianhong.github.io/2018/05/28/SeaJS/</id>
    <published>2018-05-28T09:34:57.000Z</published>
    <updated>2018-08-30T13:31:19.807Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这篇文章主要介绍了<strong>SeaJS</strong>中<strong>use函数</strong>的用法，结合实例形式分析了<strong>use函数</strong>加载模块的使用方法与相关操作技巧。<a id="more"></a></li><li><p>有了<code>define</code>等<strong>模块定义规范</strong>的实现，我们可以开发出很多模块。但光有一堆模块不管用，我们还得让它们能跑起来。在 SeaJS 里，要<strong>启动模块系统</strong>很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>seajs.use</code>用来<strong>在页面中加载模块</strong>。通过<code>use</code>方法，可以在页面中加载任意模块。</p></li><li><p>语法：<code>seajs.use seajs.use(id, callback?)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 加载模块 main，并在加载完成时，执行指定回调</span><br><span class="line">seajs.use(<span class="string">'./main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>use</code>方法还可以<strong>一次加载多个模块</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 并发加载模块 a 和模块 b，并在都加载完成时，执行指定回调</span><br><span class="line">seajs.use([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123;</span><br><span class="line">    a.init();</span><br><span class="line">    b.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>callback</code>参数可选</strong>。当<strong>只加载一个模块，且不需要<code>callback</code>时</strong>，可以用<code>data-main</code>属性来简化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-main=<span class="string">"./main"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>上面的代码等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>SeaJS</strong>还提供<code>data-config</code>来<strong>加载配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-config=<span class="string">"path/to/config"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>data-config</code>等价：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">    preload: [<span class="string">'path/to/config'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>路径解析规则</strong>与<code>seajs.use</code>一致。</p></li><li><p>再看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/js/lib/sea.js"</span> data-config=<span class="string">"/js/config.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">seajs.use(<span class="string">'/js/main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.banner_focus(<span class="string">'#focus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>main</code>为<strong>模块名</strong>，<code>main.method</code>为<strong>模块定义的函数</strong>，<strong>可以传递参数</strong>过去。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;这篇文章主要介绍了&lt;strong&gt;SeaJS&lt;/strong&gt;中&lt;strong&gt;use函数&lt;/strong&gt;的用法，结合实例形式分析了&lt;strong&gt;use函数&lt;/strong&gt;加载模块的使用方法与相关操作技巧。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="SeaJS" scheme="https://chongtianhong.github.io/tags/SeaJS/"/>
    
  </entry>
  
</feed>
