<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-08-27T05:57:23.537Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试题整理</title>
    <link href="https://chongtianhong.github.io/2018/05/25/interviewMap1/"/>
    <id>https://chongtianhong.github.io/2018/05/25/interviewMap1/</id>
    <published>2018-05-25T05:42:04.000Z</published>
    <updated>2018-08-27T05:57:23.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><ul><li>JS 中分为<strong>七种内置类型</strong>，七种内置类型<strong>又分为两大类型</strong>：<strong>基本类型</strong>和<strong>对象（Object）</strong>。</li><li>基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</li><li>其中 <strong>JS 的数字类型是浮点类型的，没有整型</strong>。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。</li><li><code>NaN</code> 也属于 number 类型，并且 <code>NaN</code> 不等于自身。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h4&gt;&lt;h5 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; title=&quot;内置类型&quot;&gt;&lt;/a&gt;内置类型&lt;/h
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的 NaN 与 isNaN</title>
    <link href="https://chongtianhong.github.io/2018/05/24/NaN/"/>
    <id>https://chongtianhong.github.io/2018/05/24/NaN/</id>
    <published>2018-05-24T05:53:29.000Z</published>
    <updated>2018-08-27T06:22:30.911Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><ul><li><code>NaN</code> 即 <strong>Not a Number</strong>，不是一个数字。 在 JavaScript 中，<strong>整数和浮点数都统称为 <code>Number</code> 类型</strong>。</li><li><p>除此之外，<code>Number</code> 类型类型还有一个很特殊的值，即 <strong><code>NaN</code></strong> 。它<strong>是 <code>Number</code> 对象上的一个静态属性，可以通过 Number.NaN 来访问</strong>：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在 ECMAScript v1 和其后的版本中，还可以用<strong>预定义的全局属性 <code>NaN</code> 代替 <code>Number.NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在以下两种场景中，可能会产生 NaN 值：</p></li></ul><blockquote>表达式计算</blockquote><ul><li><p>一个表达式中如果有<strong>减号 (-)</strong>、<strong>乘号 (*)</strong>或 <strong>除号 (/) </strong>等运算符时，JS 引擎在计算之前，会试图<strong>将表达式的每个分项转化为 <code>Number</code> 类型（使用 <code>Number(x)</code> 做转换）</strong>。如果<strong>转换失败，表达式将返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100 - <span class="string">'2a'</span> ;    // NaN</span><br><span class="line"><span class="string">'100'</span> / <span class="string">'20a'</span>;  // NaN</span><br><span class="line"><span class="string">'20a'</span> * 5 ;     // NaN</span><br><span class="line">undefined - 1;  // NaN, Number(undefined) == NaN</span><br><span class="line">[] * 20 ;       // 0, Number([]) == 0</span><br><span class="line">null - 5;       // -5, Number(null) == 0</span><br></pre></td></tr></table></figure></li><li><p>而<strong>加号 (+)</strong>不会将其两边的变量转化为 Number 类型，这是因为JS表达式的执行顺序是按照运算符的优先级从左到右依次进行的：</p><ul><li><strong>如果加号 (+) 两边的变量都是 Number 类型时，才会做数字相加运算</strong>;</li><li>如果<strong>其中有一个变量是字符串</strong>，则会<strong>将两边都作为字符串相加</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 + 4 + <span class="string">'6'</span> = <span class="string">'96'</span>;</span><br><span class="line">1 + <span class="string">'2'</span> + 3 =  <span class="string">'123'</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>类型转换</blockquote><ul><li><p>直接使用<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code><strong>将一个非数字的值转化为数字</strong>时，<strong>表达式返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span> - 3   // NaN</span><br><span class="line">parseInt(<span class="string">'abc'</span>)  // NaN</span><br><span class="line">parseFloat(<span class="string">'abc'</span>) // NaN</span><br><span class="line">Number(<span class="string">'abc'</span>)    // NaN</span><br></pre></td></tr></table></figure></li><li><p>对于<strong>数字+字符</strong>的值，其转化结果会有所不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">'123abc'</span>); // NaN</span><br><span class="line">parseInt(<span class="string">'123abc'</span>); // 123</span><br><span class="line">parseInt(<span class="string">'123abc45'</span>); // 123</span><br><span class="line">parseFloat(<span class="string">'123.45abc'</span>);// 123.45</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Number</code>转换的是整个值</strong>，而不是部分值；<strong><code>parseInt</code>和 <code>parseFloat</code>只转化第一个无效字符之前的字符串</strong>。</p></li><li><p>另外，<strong>一元加操作符</strong>也可以<strong>实现与<code>Number</code>相同的作用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">'12abc'</span>; // NaN</span><br><span class="line">+ <span class="string">'123'</span>; // 123</span><br><span class="line">+ <span class="string">'123.78'</span>; // 123.78</span><br><span class="line">+ <span class="string">'abc'</span>; // NaN</span><br></pre></td></tr></table></figure></li><li><p>因此，<strong>当一个字符串不能被<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code>成功转换时</strong>，就<strong>返回 <code>NaN</code></strong>，表示<strong>该字符串无法被识别为数字类型</strong>，这是一个<strong>异常状态</strong>，并<strong>不是一个确切的值</strong>。</p></li></ul><h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h4><ul><li><code>isNaN()</code>是一个全局方法，它的作用是<strong>检查一个值是否能被<code>Number()</code>成功转换</strong>。</li><li><p>如果<strong>能转换成功</strong>，就<strong>返回<code>false</code></strong>，否则返回<code>true</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)          // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123'</span>)        // <span class="literal">false</span> 能转换</span><br><span class="line">isNaN(<span class="string">'abc'</span>)        // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123ab'</span>)      // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123.45abc'</span>)  // <span class="literal">true</span> 不能转换</span><br></pre></td></tr></table></figure></li><li><p>可以看出，<strong><code>isNaN()</code>没有办法判断某个值本身是否为<code>NaN</code></strong>。</p></li><li><p>如果<strong>想要知道某个值本身是否为<code>NaN</code></strong>，可以利用<strong>NaN 不等于自身</strong>这一特性来判断：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selfIsNaN(value)&#123;</span><br><span class="line">    <span class="built_in">return</span> value !== value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另外，ES6 在<strong><code>Number</code>对象上</strong>也<strong>提供了<code>isNaN()</code>方法</strong>，和全局方法<code>isNaN()</code><strong>不同的是</strong>，它<strong>用于判断某个值本身是否为<code>NaN</code></strong>，而<strong>不需要进行类型转换</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(<span class="string">'123'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(<span class="string">'abc'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(NaN);      // <span class="literal">true</span>　本身是NaN</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NaN&quot;&gt;&lt;a href=&quot;#NaN&quot; class=&quot;headerlink&quot; title=&quot;NaN&quot;&gt;&lt;/a&gt;NaN&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NaN&lt;/code&gt; 即 &lt;strong&gt;Not a Number&lt;/strong&gt;，不是一个数字。 在 JavaScript 中，&lt;strong&gt;整数和浮点数都统称为 &lt;code&gt;Number&lt;/code&gt; 类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除此之外，&lt;code&gt;Number&lt;/code&gt; 类型类型还有一个很特殊的值，即 &lt;strong&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/strong&gt; 。它&lt;strong&gt;是 &lt;code&gt;Number&lt;/code&gt; 对象上的一个静态属性，可以通过 Number.NaN 来访问&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动的四种方式及其原理理解</title>
    <link href="https://chongtianhong.github.io/2018/05/23/clearFloat/"/>
    <id>https://chongtianhong.github.io/2018/05/23/clearFloat/</id>
    <published>2018-05-23T06:25:03.000Z</published>
    <updated>2018-08-27T03:44:16.417Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文介绍了四种清除浮动的方法，并尝试解释其原理。</li><li>在理解了各种清除浮动的原理之后，我们会发现，很多<strong>清除浮动的方法本质上其实是一样的</strong>。<a id="more"></a></li></ul><h4 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h4><ul><li><p>在讲清除浮动的方法之前，我们先来了解一下<strong>为什么要清除浮动</strong>，清除浮动的目的是什么，即，要解决什么样的问题。来看一个浮动的例子(略去了文字内容)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>其样式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在chrome中渲染的效果如下图所示：<br><img src="images/clearFloat1.png" stype="border:none" alt="浮动效果"></p></li><li>这肯定不是我们想要的渲染效果，它可能存在如下问题：<br>① <strong>文字围绕浮动元素排版</strong>，但我们可能希望文字（<code>.textDiv</code>）排列在浮动元素下方，或者，我们并不希望<code>.textDiv</code>两边有浮动元素存在。<br>② 浮动元素排版超出了其父级元素（<code>.topDiv</code>），<strong>父元素的高度出现了塌缩</strong>，若没有文字高度的支撑，不考虑边框，父级元素高度会塌缩成零。<br>③ <strong>浮动元素甚至影响到了其父元素的兄弟元素（<code>.bottomDiv</code>）排版</strong>。因为浮动元素脱离了文档流，<code>.bottomDiv</code>在计算元素位置的时候会忽略其影响，紧接着上一个元素的位置继续排列。</li><li>解决第一个问题，需要<strong>清除<code>.textDiv</code>周围的浮动</strong>。</li><li>解决第二、第三个问题，因为父元素的兄弟元素位置只受父元素位置的影响，就<strong>需要一种方法将父级元素的高度撑起来，将浮动元素包裹在其中</strong>，避免浮动元素影响父元素外部的元素排列。</li><li>接下来就开始介绍清除浮动的方法。</li></ul><h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><h5 id="利用clear样式"><a href="#利用clear样式" class="headerlink" title="利用clear样式"></a>利用clear样式</h5><ul><li><p>还是开篇的例子，我们给<strong>需要清除浮动的元素</strong>添加如下样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line"> </span><br><span class="line">    clear: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清除浮动后的渲染效果如下：<br><img src="images/clearFloat2.png" stype="border:none" alt="清除浮动后的渲染效果"></p></li><li>解析：<ul><li>通过上面的样式，<code>.textDiv</code>告诉浏览器，我的<strong>左边不允许有浮动的元素存在</strong>，请清除掉我左边的浮动元素。</li><li>然而，因为<strong>浮动元素（.floatDiv）位置已经确定</strong>，浏览器在计算<code>.textDiv</code>的位置时，<strong>为满足其需求，将<code>.textDiv</code>渲染在浮动元素下方</strong>，保证了<code>.textDiv</code>左边没有浮动元素。</li><li>同时可以看出，<strong>父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响</strong>，这是因为<strong><code>.textDiv</code>仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的</strong>。</li><li>设置样式为<code>clear: both</code>也有相同的效果，即<strong>两边都不允许有浮动元素</strong>，clear就是对应方向的值，两边都不允许就是both。</li></ul></li><li><strong>注意</strong>：这个规则<strong>只能影响使用清除的元素本身，不能影响其他元素</strong>。</li><li><p>但是，如果我们把HTML中的<code>.floatDiv</code>和<code>.textDiv</code>55：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>无论<code>.textDiv</code>是否应用清除浮动，情况都是下面的样子：<br><img src="images/clearFloat3.png" stype="border:none" alt="交换位置后的结果"></p></li><li><strong><code>.textDiv</code>的位置先确定了</strong>，于是<strong>浮动元素就紧接着<code>.textDiv</code>下方渲染在父元素的左侧</strong>。然而，父元素的高度并没有被撑起来，没有将浮动影响“内化”，导致浮动影响到了接下来的元素排版。</li><li>看来，为达到撑起父元素高度的目的，<strong>使用clear清除浮动的方法</strong>还是<strong>有适用范围</strong>的。我们需要更加通用和可靠的方法。</li></ul><h5 id="父元素结束标签之前插入清除浮动的块级元素"><a href="#父元素结束标签之前插入清除浮动的块级元素" class="headerlink" title="父元素结束标签之前插入清除浮动的块级元素"></a>父元素结束标签之前插入清除浮动的块级元素</h5><ul><li><p>HTML结构如下，在<strong>有浮动的父级元素的末尾</strong>插入了一个<strong>没有内容的块级元素div</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"blankDiv"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>应用样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">// 区别在这里</span><br><span class="line">.blankDiv &#123;</span><br><span class="line">    clear: both; // or left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>渲染效果如下：<br><img src="images/clearFloat4.png" stype="border:none" alt="父元素结束标签之前插入清除浮动的块级元素渲染效果"></p></li><li>和第一个例子里<code>.textDiv</code>应用clear清除浮动，撑起父级元素高度的原理完全一样。这里强调一点，即，<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</li></ul><h5 id="利用伪元素（clearfix）"><a href="#利用伪元素（clearfix）" class="headerlink" title="利用伪元素（clearfix）"></a>利用伪元素（clearfix）</h5><ul><li><p>HTML结构如下，在<code>.topDiv</code>的div上再添加一个<code>clearfix</code>类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv clearfix"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 省略基本的样式</span><br><span class="line">// 区别在这里</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: <span class="string">'.'</span>;       /*生成内容作为最后一个元素，至于content里面是点还是其他都是可以的*/</span><br><span class="line">    height: 0;          /*避免生成内容破坏原有布局的高度*/</span><br><span class="line">    visibility:hidden;  /*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互*/</span><br><span class="line">    display: block;     /*使生成的元素以块级元素显示,占满剩余空间*/</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该样式在<code>.clearfix</code>，即父级元素的最后，添加了一个:after伪元素，<strong>通过清除伪元素的浮动，达到撑起父元素高度的目的</strong>。</p></li><li>注意到该伪元素的<code>display</code>值为<code>block</code>，即，它是一个<strong>不可见的块级元素</strong>。你可能已经意识到，这也只不过是前一种清除浮动方法（添加空白div）的另一种变形，其底层逻辑也是完全一样的。这三种方法，其本质上是一样的。</li></ul><h5 id="利用overflow清除浮动"><a href="#利用overflow清除浮动" class="headerlink" title="利用overflow清除浮动"></a>利用overflow清除浮动</h5><ul><li>首先直观地看看，<code>overflow</code>是如何清除浮动的。</li><li><p>HTML结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用CSS后的渲染效果如下：<br>&lt;img src=”images/clearFloat5.png” stype=”border:none” alt=”利用overflow清除浮动后的渲染效果&gt;</p></li><li>仅仅只<strong>在父级元素上添加了一个值为<code>auto</code>的<code>overflow</code>属性，父元素的高度立即被撑起</strong>，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染。</li><li>其实，<strong>这里的<code>overflow</code>值</strong>，还可以是<strong>除了”visible”之外的任何有效值，它们都能达到撑起父元素高度，清除浮动的目的</strong>。</li><li>不过，<strong>有的值可能会带来副作用</strong>，比如，scroll值会导致滚动条始终可见，hidden会使得超出边框部分不可见等。</li><li><strong>原理</strong>：当<strong>元素设置了<code>overflow</code>样式，且值不为<code>visible</code>时</strong>，该<strong>元素就建构了一个BFC</strong>。</li><li>在上面的例子中，<code>.topDiv</code>因设置了值为<code>auto</code>的<code>overflow</code>样式，所以<strong>该元素建构出一个BFC</strong>，按照第三个特点，<strong>BFC的高度是要包括浮动元素的</strong>，所以<code>.topDiv</code>的高度被撑起来，<strong>达到了清除浮动影响的目的</strong>。</li><li><strong>注意</strong>：这里<strong><code>overflow</code>的作用就是为了构建一个BFC区域，让内部浮动的影响都得以“内化”</strong>。而<strong>构建一个BFC区域的方法有很多种，<code>overflow</code>只是其中的一种</strong>，因此，我们也<strong>可以利用其它的方式构建BFC，且同样能达到清除浮动的目的</strong>。</li><li><p>BFC定义中说，<code>inline-block</code>同样也能构建BFC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">// 其他样式相同，省略</span><br></pre></td></tr></table></figure></li><li><p>渲染效果和使用<code>overflow</code>的效果完全一样。</p></li></ul><h5 id="另外一些方法"><a href="#另外一些方法" class="headerlink" title="另外一些方法"></a>另外一些方法</h5><blockquote>给浮动元素父级设置高度</blockquote><ul><li>使用浮动后，<strong>父元素高度塌陷</strong>是因为<strong>给浮动元素的父级高度是自适应导致的</strong>，因此，可以<strong>给它设置适当的高度</strong>来解决这一问题，然而，缺点是<strong>在浮动元素高度不确定的时候不适用</strong>。</li></ul><blockquote>父级也设置浮动</blockquote><ul><li>缺点：需要给每个浮动元素父级添加浮动，浮动多了容易出现问题。</li></ul><blockquote>使用br清浮动</blockquote><ul><li><p><strong>br标签自带clear属性</strong>，将它的<strong>clear属性设置成both</strong>其实和添加空div原理是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"top"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;br clear=<span class="string">"both"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>缺点：<strong>不符合工作中结构、样式、行为，三者分离的要求</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文介绍了四种清除浮动的方法，并尝试解释其原理。&lt;/li&gt;
&lt;li&gt;在理解了各种清除浮动的原理之后，我们会发现，很多&lt;strong&gt;清除浮动的方法本质上其实是一样的&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="浮动" scheme="https://chongtianhong.github.io/tags/%E6%B5%AE%E5%8A%A8/"/>
    
      <category term="清除浮动" scheme="https://chongtianhong.github.io/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6 类(Class)基本用法与静态属性 + 静态方法</title>
    <link href="https://chongtianhong.github.io/2018/05/22/ES6Class/"/>
    <id>https://chongtianhong.github.io/2018/05/22/ES6Class/</id>
    <published>2018-05-22T06:33:15.000Z</published>
    <updated>2018-08-24T14:41:56.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类-Class-的基本用法"><a href="#类-Class-的基本用法" class="headerlink" title="类(Class)的基本用法"></a>类(Class)的基本用法</h4><ul><li>在 ES6 规范中，引入了<code>Class</code>的概念。使得 JS 开发者终于告别了<strong>直接使用原型对象模仿面向对象中的类</strong>和<strong>类继承</strong>时代。</li><li>但是JS 中并没有一个真正的<code>Class</code>原始类型，<strong><code>Class</code></strong>仅仅只是对原型对象运用语法糖，<strong>作为对象的模板</strong>。所以，只有理解如何<strong>使用原型对象实现类和类继承</strong>，才能真正地用好<code>Class</code>。<a id="more"></a></li><li><p>下面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是<strong>构造方法</strong>，而<code>this</code>关键字则代表实例对象。也就是说，<strong>ES5的构造函数</strong><code>Point</code>，<strong>对应ES6的<code>Point</code>类的构造方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ES6定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    // prototype属性</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">// ES5的构造函数</span><br><span class="line"><span class="keyword">function</span> Point(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype = <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义“类”的方法</strong>的时候，<strong>前面不需要加上<code>function</code>这个关键字</strong>，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔</strong>，加了会报错。</p></li><li><p><strong>构造函数的prototype属性</strong>，在ES6的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的prototype属性上面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>方法可以很方便地<strong>一次向类添加多个方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Point.prototype, &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>类的内部所有定义的方法</strong>，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与ES5的行为不一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES5可枚举，ES6不可枚举</span><br><span class="line">Object.keys(Point.prototype)</span><br></pre></td></tr></table></figure></li><li><p>constructor方法是类的默认方法，<strong>通过new命令生成对象实例时，自动调用该方法</strong>。一个类必须有constructor方法，如果<strong>没有显式定义，一个空的constructor方法会被默认添加</strong>。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p></li><li><strong>类的构造函数，不使用new是没法调用的</strong>，会报错。</li><li><p>可以<strong>通过实例的<code>__proto__</code>属性</strong>为Class添加方法，<strong>可被所有的实例所共享</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3);</span><br><span class="line">var p2 = new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // <span class="string">"Oops"</span></span><br><span class="line">p2.printName() // <span class="string">"Oops"</span></span><br><span class="line"></span><br><span class="line">var p3 = new Point(4,2);</span><br><span class="line">p3.printName() // <span class="string">"Oops"</span></span><br></pre></td></tr></table></figure></li><li><p>可见，<strong>使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎</strong>，不推荐使用，因为这<strong>会改变Class的原始定义，影响到所有实例</strong>。</p></li><li><code>Class</code><strong>不存在变量提升（hoist）</strong>。</li></ul><h4 id="typeof-class-“function”"><a href="#typeof-class-“function”" class="headerlink" title="typeof class == “function”"></a>typeof class == “function”</h4><ul><li>使用<code>Class</code>的语法，让开发者告别了使用 prototype 模仿面向对象的时代。但是，<strong><code>Class</code></strong>并不是 ES6 引入的全新概念，它的<strong>原理依旧是原型继承</strong>。</li><li>通过类型判断，我们可以得知，<strong><code>Class</code></strong>的并不是什么全新的数据类型，它<strong>实际只是 function (或者说 object)</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeof Person // <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><ul><li>在传统面向对象中，<strong>类</strong>是<strong>可以继承类</strong>的。这样子<strong>类</strong>就<strong>可以复制父类的方法，达到代码复用的目的</strong>。</li><li><p>ES6 也提供了类继承的语法<code>extends</code>，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        this.me = who;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">identify</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"I am "</span> + this.me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        // super() 指的是调用父类</span><br><span class="line">        // 调用的同时，会绑定 this 。</span><br><span class="line">        // 如：Foo.call(this, who)</span><br><span class="line">        super(who);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">speak</span></span>()&#123;</span><br><span class="line">        alert( <span class="string">"Hello, "</span> + this.identify() + <span class="string">"."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b1 = new Bar( <span class="string">"b1"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br></pre></td></tr></table></figure></li><li><p>当实例<code>b1</code>调用<code>speak</code>方法时，<code>b1</code>本身没有 <code>speak</code>，所以会到<code>Bar.prototype</code>原型对象上查找，并且调用原型对象上的<code>speak</code>方法。调用<code>identify</code>方式时，由于<code>this</code>指向的是<code>b1</code>对象。所以也会先在<code>b1</code>本身查找，然后沿着原型链，查找<code>Bar.prototype</code>，最后在<code>Foo.prototype</code>原型对象上找到<code>identify</code>方法，然后调用。</p></li><li>实际上，在 JavaScript 中，<strong>类继承的本质依旧是原型对象</strong>。</li></ul><h4 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h4><ul><li><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果<strong>在一个方法前，加上static关键字，就表示该方法不会被实例继承</strong>，而是<strong>直接通过类来调用</strong>，这就称为<strong>“静态方法”</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line">// 定义静态方法</span><br><span class="line">static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 通过类名直接调用</span><br><span class="line">console.log(StaticMethod.getAge());</span><br></pre></td></tr></table></figure></li><li><p><strong>静态方法只能在静态方法中调用，不能在实例方法中调用</strong>。</p></li></ul><h4 id="Class的静态属性和实例属性"><a href="#Class的静态属性和实例属性" class="headerlink" title="Class的静态属性和实例属性"></a>Class的静态属性和实例属性</h4><ul><li><p><strong>静态属性</strong>指的是<strong>Class本身的属性</strong>，即<code>Class.propname</code>，而不是定义在实例对象（this）上的属性。ES6使用静态属性和实例属性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line"></span><br><span class="line">// 定义实例属性</span><br><span class="line">// ES6实例属性只能在constructor构造函数中定义</span><br><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.width = <span class="string">'40cm'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">&#125;</span><br><span class="line">// 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">width;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：目前ES6，只有这种写法可行，<strong>因为ES6明确规定，Class内部只有静态方法，没有静态属性</strong>。</p></li><li><p><strong>ES7</strong>有一个<strong>静态属性的提案</strong>，目前Babel转码器支持。安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，不同的stage封装了不同的插件，官方推荐是使用stage-1安装命令(根据自己的需求调整):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-preset-stage-0</span><br></pre></td></tr></table></figure></li><li><p>ES7使用<strong>静态属性</strong>和<strong>实例属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// ES7提案 定义静态属性</span><br><span class="line">static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"></span><br><span class="line">// ES7定义实例属性</span><br><span class="line">height = <span class="string">'150cm'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：<strong>ES7和ES6的静态属性和实例属性</strong>只是<strong>定义不一样</strong>，<strong>调用的方式是一样的</strong>。</p></li><li>Class的<strong>静态方法/Class静态属性</strong>和<strong>实例属性</strong>的整个案例:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethodParent.js</span><br><span class="line"><span class="built_in">export</span> default class StaticMethodParent&#123;</span><br><span class="line">    static <span class="function"><span class="title">getCommon</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'父类的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// StaticMethod.js</span><br><span class="line">import StaticMethodParent from <span class="string">'./StaticMethodParent'</span></span><br><span class="line"> </span><br><span class="line">// 定义静态属性和静态方法</span><br><span class="line">class StaticMethod extends StaticMethodParent&#123;</span><br><span class="line">    // 因为ES6明确规定，Class内部只有静态方法，没有静态属性,所以ES6在类中定义静态属性都是错误的。</span><br><span class="line">    // static lastName = <span class="string">'pcaca'</span>;ES6错误</span><br><span class="line"> </span><br><span class="line">    // ES7提案 定义静态属性</span><br><span class="line">    // 安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，</span><br><span class="line">    // 不同的stage封装了不同的插件，官方推荐是使用stage-1</span><br><span class="line">    static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"> </span><br><span class="line">    // ES7定义实例属性</span><br><span class="line">    height = <span class="string">'150cm'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getHeight</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.height;//ES7的使用也要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // ES6实例属性只能在constructor构造函数中定义</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.width = <span class="string">'40cm'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">    width;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 定义静态方法</span><br><span class="line">    static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">        // 子类可以调用父类的静态方法</span><br><span class="line">        console.log(super.getCommon());</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">export</span> &#123;StaticMethod&#125;;</span><br><span class="line"> </span><br><span class="line">// index.js</span><br><span class="line">import &#123;StaticMethod&#125; from <span class="string">'./StaticMethod'</span>;</span><br><span class="line">console.log(StaticMethod.getAge());</span><br><span class="line">console.log(StaticMethod.getCommon());</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line">console.log(StaticMethod.lastName);</span><br><span class="line"><span class="built_in">let</span> staticMethod = new StaticMethod();</span><br><span class="line">console.log(staticMethod.height);</span><br><span class="line">console.log(staticMethod.getHeight());</span><br><span class="line">console.log(staticMethod.width);</span><br><span class="line">console.log(staticMethod.getWidth());</span><br><span class="line">//staticMethod.getAge();//bundle.js:7906 Uncaught TypeError: staticMethod.getAge is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类-Class-的基本用法&quot;&gt;&lt;a href=&quot;#类-Class-的基本用法&quot; class=&quot;headerlink&quot; title=&quot;类(Class)的基本用法&quot;&gt;&lt;/a&gt;类(Class)的基本用法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在 ES6 规范中，引入了&lt;code&gt;Class&lt;/code&gt;的概念。使得 JS 开发者终于告别了&lt;strong&gt;直接使用原型对象模仿面向对象中的类&lt;/strong&gt;和&lt;strong&gt;类继承&lt;/strong&gt;时代。&lt;/li&gt;
&lt;li&gt;但是JS 中并没有一个真正的&lt;code&gt;Class&lt;/code&gt;原始类型，&lt;strong&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/strong&gt;仅仅只是对原型对象运用语法糖，&lt;strong&gt;作为对象的模板&lt;/strong&gt;。所以，只有理解如何&lt;strong&gt;使用原型对象实现类和类继承&lt;/strong&gt;，才能真正地用好&lt;code&gt;Class&lt;/code&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Class" scheme="https://chongtianhong.github.io/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>使用Javascript监控前端相关数据</title>
    <link href="https://chongtianhong.github.io/2018/05/21/frontEndMonitor/"/>
    <id>https://chongtianhong.github.io/2018/05/21/frontEndMonitor/</id>
    <published>2018-05-21T12:40:59.000Z</published>
    <updated>2018-08-23T15:06:44.798Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。<strong>项目上线前期的粒度较大的错误</strong>我们都会<strong>在自测和QA测试中发现</strong>，然而<strong>上线之后的错误不是那么好发现</strong>。同时<strong>移动端的开发</strong>也面临着一个问题就是<strong>不好调试</strong>，所以<strong>web开发的错误监控</strong>是一个非常有用的措施。<a id="more"></a></li></ul><h4 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h4><ul><li>常见的web错误主要分为两类：<br>① <strong>运行时错误</strong>：这个错误往往是我们在代码书写时造成的，比如语法错误、逻辑错误，这样的错误通常在测试阶段就会被发现，但是也可能存在“漏网之鱼”。<br>② <strong>资源加载错误</strong>：这个错误通常是找不到文件或者是文件加载超时造成的。</li></ul><h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><ul><li>基于上面两种的错误类型，也有不同的错误捕获方式：</li></ul><blockquote>代码错误捕获：</blockquote><ul><li><p>使用<code>try…catch…</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">    // 运行可能出错的代码</span><br><span class="line"></span><br><span class="line">&#125;catch&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>windown.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>资源加载错误：</blockquote><ul><li><p><code>bject.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var img =document.getElementById(<span class="string">'#img'</span>);</span><br><span class="line"></span><br><span class="line">img.onerror = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用window的Error事件代理，但是需要注意的是<strong>Error事件是不冒泡的</strong>，我们可以<strong>使用事件捕获进行代理</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">"error"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h4><ul><li>常见错误上报有两种： <strong>ajax</strong>、<strong>image对象</strong>推荐）。</li><li><strong>ajax上报</strong>就是在上文注释错误捕获的地方发起ajax请求，来向服务器发送错误信息。</li><li>利用<strong>image对象</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src =<span class="string">"http://post.error.com?"</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="跨域js文件错误获取"><a href="#跨域js文件错误获取" class="headerlink" title="跨域js文件错误获取"></a>跨域js文件错误获取</h4><ul><li><strong>跨域js文件获取是有限制的</strong>，如果想<strong>获取其他域下的js错误</strong>需要<strong>在script标签里添加crossorigin属性</strong>，然后<strong>服务器端要设置</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">'Access-Control-Allow-Origin: *'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="前端监控系统模块实现"><a href="#前端监控系统模块实现" class="headerlink" title="前端监控系统模块实现"></a>前端监控系统模块实现</h4><ul><li>项目开发完成外发后，没有一个监控系统，我们很难了解到发布出去的代码在用户机器上执行是否正确，所以需要建立<strong>前端代码性能相关的监控系统</strong>。</li><li>所以我们需要做以下的一些模块：</li></ul><h5 id="收集脚本执行错误"><a href="#收集脚本执行错误" class="headerlink" title="收集脚本执行错误"></a>收集脚本执行错误</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> error(msg, url, line)&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi"</span>; // 收集上报数据的信息</span><br><span class="line">    var m =[msg, url, line, navigator.userAgent, +new Date];// 收集错误信息，发生错误的脚本文件网络地址，用户代理信息，时间</span><br><span class="line">    var url = REPORT_URL + m.join(<span class="string">'||'</span>);// 组装错误上报信息内容URL</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = url;// 发送数据到后台cgi</span><br><span class="line">&#125;</span><br><span class="line">// 监听错误上报</span><br><span class="line">window.onerror = <span class="keyword">function</span>(msg,url,line)&#123;</span><br><span class="line">    error(msg,url,line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<strong>管理后台系统</strong>，我们可以看到页面上每次错误的信息，通过这些信息我们可以很快定位并且解决问题。</li></ul><h5 id="收集页面执行性能信息"><a href="#收集页面执行性能信息" class="headerlink" title="收集页面执行性能信息"></a>收集页面执行性能信息</h5><ul><li>performance包含<strong>页面加载到执行完成</strong>的整个生命周期中<strong>不同执行步骤的执行时间</strong>。</li><li><p>计算不同步骤时间相对于navigationStart的时间差，可以通过相应后台CGI收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_performance</span></span>()&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi?perf="</span>;</span><br><span class="line">    var perf = (window.webkitPerformance ? window.webkitPerformance : window.msPerformance ),</span><br><span class="line">        points = [<span class="string">'navigationStart'</span>,<span class="string">'unloadEventStart'</span>,<span class="string">'unloadEventEnd'</span>,<span class="string">'redirectStart'</span>,<span class="string">'redirectEnd'</span>,<span class="string">'fetchStart'</span>,<span class="string">'domainLookupStart'</span>,<span class="string">'connectStart'</span>,<span class="string">'requestStart'</span>,<span class="string">'responseStart'</span>,<span class="string">'responseEnd'</span>,<span class="string">'domLoading'</span>,<span class="string">'domInteractive'</span>,<span class="string">'domContentLoadedEventEnd'</span>,<span class="string">'domComplete'</span>,<span class="string">'loadEventStart'</span>,<span class="string">'loadEventEnd'</span>];</span><br><span class="line">    var timing = pref.timing;</span><br><span class="line">    perf = perf  ? perf : window.performance;</span><br><span class="line">    <span class="keyword">if</span>( perf  &amp;&amp; timing ) &#123;</span><br><span class="line">        var arr = [];</span><br><span class="line">        var navigationStart = timing[points[0]];</span><br><span class="line">        <span class="keyword">for</span>(var i=0,l=points.length;i&lt;l;i++)&#123;</span><br><span class="line">            arr[i] = timing[points[i]] - navigationStart;</span><br><span class="line">        &#125;</span><br><span class="line">    var url = REPORT_URL + arr.join(<span class="string">"-"</span>);</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img=null;</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过后台接口收集和统计，我们可以对<strong>页面执行性能</strong>有很详细的了解。</p></li></ul><h5 id="统计每个页面的JS和CSS加载时间"><a href="#统计每个页面的JS和CSS加载时间" class="headerlink" title="统计每个页面的JS和CSS加载时间"></a>统计每个页面的JS和CSS加载时间</h5><ul><li>在<strong>JS或者CSS加载之前打上时间戳，加载之后打上时间戳</strong>，并且将数据（时间差）上报到后台。<strong>加载时间</strong>反映了<strong>页面白屏</strong>，<strong>可操作的等待时间</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;var cssLoadStart = +new Date&lt;/script&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx1.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx2.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;sript&gt;</span><br><span class="line">    var cssLoadTime = (+new Date) - cssLoadStart;</span><br><span class="line">    var jsLoadStart = +new Date;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx1.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx2.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx3.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var jsLoadTime = (+new Date) - jsLoadStart;</span><br><span class="line">    var REPORT_URL = <span class="string">'xxx/cgi?data='</span></span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = REPORT_URL + cssLoadTime + <span class="string">'-'</span> + jsLoadTime;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><h5 id="new-Date"><a href="#new-Date" class="headerlink" title="+new Date"></a>+new Date</h5><ul><li>JavaScript中可以在某个元素前使用 ‘+’ 号，这个操作是<strong>将该元素转换成Number类型</strong>，如果<strong>转换失败</strong>，那么<strong>将得到 NaN</strong>。</li><li>所以，<code>+new Date</code>将会调用<code>Date.prototype</code>上的 <code>valueOf</code>方法，而根据 MDN 文档，<code>Date.prototype.valueOf</code>方法等同于<code>Date.prototype.getTime()</code>，得到毫秒。</li><li>所以下列代码效果相同：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(+new Date);</span><br><span class="line"> </span><br><span class="line">console.log(new Date().getTime());</span><br><span class="line"> </span><br><span class="line">console.log(new Date().valueOf());</span><br><span class="line"> </span><br><span class="line">console.log(new Date() * 1);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。&lt;strong&gt;项目上线前期的粒度较大的错误&lt;/strong&gt;我们都会&lt;strong&gt;在自测和QA测试中发现&lt;/strong&gt;，然而&lt;strong&gt;上线之后的错误不是那么好发现&lt;/strong&gt;。同时&lt;strong&gt;移动端的开发&lt;/strong&gt;也面临着一个问题就是&lt;strong&gt;不好调试&lt;/strong&gt;，所以&lt;strong&gt;web开发的错误监控&lt;/strong&gt;是一个非常有用的措施。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端监控" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Javascript" scheme="https://chongtianhong.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript定义类（class）的三种方法</title>
    <link href="https://chongtianhong.github.io/2018/05/20/ClassDefinition/"/>
    <id>https://chongtianhong.github.io/2018/05/20/ClassDefinition/</id>
    <published>2018-05-20T03:13:53.000Z</published>
    <updated>2018-08-23T15:09:25.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在<strong>面向对象编程</strong>中，<strong>类（class）是对象（object）的模板</strong>，定义了<strong>同一组对象（又称”实例”）共有的属性和方法</strong>。</li><li>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。</li><li>本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。<a id="more"></a><h4 id="构造函数法"><a href="#构造函数法" class="headerlink" title="构造函数法"></a>构造函数法</h4></li><li>这是经典方法，也是教科书必教的方法。</li><li><p>它用<strong>构造函数模拟”类”</strong>，在其内部用<code>this</code>关键字指代实例对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Cat</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"大毛"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成实例的时候，使用<code>new</code>关键字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = new Cat();</span><br><span class="line">alert(cat1.name); // 大毛</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法，还可以<strong>定义在构造函数的prototype对象之上</strong>，<strong>实现不同实例属性和方法的共享</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.makeSound = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(<span class="string">"喵喵喵"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法的主要缺点是，比较复杂，用到了<code>this</code>和<code>prototype</code>，编写和阅读都很费力。</p></li></ul><h4 id="Object-create-法"><a href="#Object-create-法" class="headerlink" title="Object.create()法"></a>Object.create()法</h4><ul><li>为了解决”构造函数法”的缺点，<strong>更方便地生成对象</strong>，Javascript的国际标准ECMAScript第五版，提出了一个新的方法<code>Object.create()</code>。</li><li><p>用这个方法，<strong>“类”</strong>就<strong>是一个对象</strong>，不是函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    name: <span class="string">"大毛"</span>,</span><br><span class="line">    makeSound: <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">        alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，直接用<code>Object.create()</code>生成实例，不需要用到<code>new</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Object.create(Cat);</span><br><span class="line">alert(cat1.name); // 大毛</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Object.create) &#123;</span><br><span class="line">    Object.create = <span class="keyword">function</span> (o) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="built_in">return</span> new F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法<strong>比”构造函数法”简单</strong>，但是<strong>不能实现私有属性和私有方法</strong>，<strong>实例对象之间也不能共享数据</strong>，<strong>对”类”的模拟不够全面</strong>。</p></li></ul><h4 id="极简主义法（推荐）"><a href="#极简主义法（推荐）" class="headerlink" title="极简主义法（推荐）"></a>极简主义法（推荐）</h4><ul><li>荷兰程序员Gabor de Mooij提出了一种比<code>Object.create()</code>更好的新方法，他称这种方法为”极简主义法”（minimalist approach）。这也是<strong>本文推荐的方法</strong>。</li><li>接下来介绍该方法的特点。</li></ul><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul><li>这种方法<strong>不使用<code>this</code>和<code>prototype</code></strong>，<strong>代码部署起来非常简单</strong>，这大概也是它被叫做”极简主义法”的原因。</li><li><p>首先，它也是<strong>用一个对象模拟”类”</strong>。在这个类里面，定义一个构造函数（方法）<code>createNew()</code>，用来生成实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // some code here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，<strong>在<code>createNew()</code>里面，定义一个实例对象</strong>，把这个<strong>实例对象作为返回值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用的时候，<strong>调用<code>createNew()</code>方法，就可以得到实例对象</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这种方法的好处是，<strong>容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</strong>，因此可以方便地部署下面的特性。</p></li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li><strong>让一个类继承另一个类</strong>，实现起来很方便。只要<strong>在前者（继承者）的<code>createNew()</code>方法中，调用后者（被继承者）的<code>createNew()</code>方法</strong>即可。</li><li><p>先定义一个Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Animal = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var animal = &#123;&#125;;</span><br><span class="line">        animal.sleep = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"睡懒觉"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，在Cat的<code>createNew()</code>方法中，调用Animal的<code>createNew()</code>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var cat = Animal.createNew();</span><br><span class="line">    cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">    cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"喵喵喵"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>这样得到的Cat实例，就会同时继承Cat类和Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.sleep(); // 睡懒觉</span><br></pre></td></tr></table></figure></li></ul><h5 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h5><ul><li><p>在<code>createNew()</code>方法中，只要不是定义在cat对象上的方法和属性，都是私有的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        var sound = <span class="string">"喵喵喵"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上例的内部变量<code>sound</code>，外部无法读取，只有通过cat的公有方法<code>makeSound()</code>来读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">alert(cat1.sound); // undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h5><ul><li><p>有时候，我们<strong>需要所有实例对象，能够读写同一项内部数据</strong>。这个时候，只要<strong>把这个内部数据，封装在类对象的里面、createNew()方法的外面</strong>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    sound : <span class="string">"喵喵喵"</span>,</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(Cat.sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        cat.changeSound = <span class="keyword">function</span>(x)&#123; </span><br><span class="line">            Cat.sound = x; </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，生成两个实例对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">var cat2 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这时，如果有一个<strong>实例对象，修改了共享的数据，另一个实例对象也会受到影响</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat2.changeSound(<span class="string">"啦啦啦"</span>);</span><br><span class="line">cat1.makeSound(); // 啦啦啦</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;面向对象编程&lt;/strong&gt;中，&lt;strong&gt;类（class）是对象（object）的模板&lt;/strong&gt;，定义了&lt;strong&gt;同一组对象（又称”实例”）共有的属性和方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。&lt;/li&gt;
&lt;li&gt;本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>defer和async的区别</title>
    <link href="https://chongtianhong.github.io/2018/05/19/asyncAndDefer/"/>
    <id>https://chongtianhong.github.io/2018/05/19/asyncAndDefer/</id>
    <published>2018-05-19T10:35:46.000Z</published>
    <updated>2018-08-22T14:42:14.840Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>script</code>标签用于<strong>加载脚本与执行脚本</strong>，直接使用<code>script</code>标签（不加<code>defer</code>或<code>async</code>属性）的话，<strong>HTML会按照顺序来加载并执行脚本</strong>，在<strong>脚本加载&amp;执行的过程中</strong>，会<strong>阻塞后续的DOM渲染</strong>。<a id="more"></a></li><li><p>使用<code>async</code>属性，<strong>加载和渲染后续文档元素的过程</strong>将和 script.js 的<strong>加载与执行</strong>并行进行（异步）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=<span class="string">"script.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>defer</code>属性，<strong>加载后续文档元素的过程</strong>将和script.js的<strong>加载</strong>并行进行（异步），但是<strong>script.js的执行要在所有元素解析完成之后</strong>、<strong>DOMContentLoaded 事件触发之前</strong>完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"myscript.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>从实用角度来说，<strong>把所有脚本都丢到HTML文档最后、&lt;/body&gt;之前</strong>是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可<strong>保证非脚本的其他一切元素</strong>能够<strong>以最快的速度得到加载和解析</strong>。</p></li><li>下图中，蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。<br><img src="/images/asyncAndDefer1.png" alt="脚本加载和执行过程" width="600" style="border:none"></li><li>此图告诉我们以下几个要点：<br>1.<code>defer</code> 和 async 在<strong>网络读取（下载）时都是异步的</strong>（相较于 HTML 解析）。<br>2.它们差别在于脚本下载完之后何时执行，显然<strong><code>defer</code>是最接近我们对于应用脚本加载和执行的要求的</strong>。<br>3.关于<code>defer</code>，HTML5规范要求脚本执行应该按照脚本出现的先后顺序执行，但<strong>实际情况下，延迟脚本不一定按照先后顺序执行</strong>。<br>4.<strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>，与声明顺序无关。<br>5.<code>async</code>对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它<strong>对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适</strong>的，最典型的例子：谷歌/百度统计。</li></ul><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li>如果<code>script</code>标签设置了<code>defer</code>属性，则浏览器会<strong>异步的下载该文件</strong>并且<strong>不会影响到后续DOM的渲染</strong>；</li><li>如果有<strong>多个设置了<code>defer</code>的<code>script</code>标签</strong>存在，则会<strong>按照顺序执行所有的<code>script</code></strong>；</li><li><code>defer</code>脚本会<strong>在文档渲染完毕后，DOMContentLoaded事件调用前执行</strong>。</li></ul><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul><li><code>async</code>的设置，会使得<strong><code>script</code>脚本异步的加载</strong>并在允许的情况下执行。</li><li><strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>。</li><li><strong>DOMContentLoaded事件的触发并不受设置了<code>async</code>属性的脚本加载的影响</strong>，也就是说，<strong><code>async</code>属性脚本的加载不计入DOMContentLoaded事件统计</strong>。在脚本加载完之前，有可能已经触发了DOMContentLoaded。如果给设置了<code>async</code>属性的脚本一定的时间，是<strong>有可能在DOMContentLoaded事件之前就执行</strong>的。</li><li>设置了<code>async</code>属性的脚本的执行是<strong>加载完成就会去执行</strong>，而不像defer那样要等待所有的脚本加载完后按照顺序执行。</li></ul><h4 id="图例分析"><a href="#图例分析" class="headerlink" title="图例分析"></a>图例分析</h4><ul><li>拿四个不同的颜色来标明各自代表的含义，蓝色为文档解析，紫色为脚本渲染，黄色为脚本执行，绿色为DOMContentLoaded。</li></ul><h5 id="普通script"><a href="#普通script" class="headerlink" title="普通script"></a>普通script</h5><ul><li>文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载（但是Chrome会做一个优化，如果遇到script脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载script所对应的资源，这样能够节省一部分下载的时间）。</li><li><strong>资源的下载是在解析过程中进行</strong>的，虽说script1脚本会很快的加载完毕，但是如果它前边的script2并没有加载&amp;执行，所以它只能处于一个挂起的状态，等待script2执行完毕后再执行。</li><li>当这两个脚本都执行完毕后，才会继续解析页面。<br><img src="/images/asyncAndDefer2.png" alt="普通script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="defer-1"><a href="#defer-1" class="headerlink" title="defer"></a>defer</h5><ul><li>文档解析时，遇到设置了<code>defer</code>的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。</li><li>会<strong>等到所有的<code>defer</code>脚本加载完毕并按照顺序执行，执行完毕后</strong>会<strong>触发DOMContentLoaded事件</strong>。<br><img src="/images/asyncAndDefer3.png" alt="设置defer属性script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="async-1"><a href="#async-1" class="headerlink" title="async"></a>async</h5><ul><li><code>async</code>脚本会在<strong>加载完毕后立即执行</strong>。</li><li><code>async</code>脚本的加载<strong>不计入DOMContentLoaded事件统计</strong>，也就是说下图两种情况都是有可能发生的。</li><li>情况一：<br><img src="/images/asyncAndDefer4.png" alt="设置async属性script的加载和执行过程情况1" width="600" style="border:none"></li><li>情况二：<br><img src="/images/asyncAndDefer5.png" alt="设置async属性script的加载和执行过程情况2" width="600" style="border:none"></li></ul><h4 id="推荐的应用场景"><a href="#推荐的应用场景" class="headerlink" title="推荐的应用场景"></a>推荐的应用场景</h4><h5 id="defer-2"><a href="#defer-2" class="headerlink" title="defer"></a>defer</h5><ul><li>如果<strong>脚本代码依赖于页面中的DOM元素</strong>（文档是否解析完毕），或者<strong>被其他脚本文件依赖</strong>。例：<ul><li>评论框</li><li>代码语法高亮</li><li>polyfill.js</li></ul></li></ul><h5 id="async-2"><a href="#async-2" class="headerlink" title="async"></a>async</h5><ul><li>如果<strong>脚本并不关心页面中的DOM元素</strong>（文档是否解析完毕），并且<strong>也不会产生其他脚本需要的数据</strong>。例：<ul><li>谷歌/百度统计</li></ul></li><li>如果不太能确定的话，用defer总是会比async稳定（保证脚本执行顺序性、文档渲染完成后才执行）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;script&lt;/code&gt;标签用于&lt;strong&gt;加载脚本与执行脚本&lt;/strong&gt;，直接使用&lt;code&gt;script&lt;/code&gt;标签（不加&lt;code&gt;defer&lt;/code&gt;或&lt;code&gt;async&lt;/code&gt;属性）的话，&lt;strong&gt;HTML会按照顺序来加载并执行脚本&lt;/strong&gt;，在&lt;strong&gt;脚本加载&amp;amp;执行的过程中&lt;/strong&gt;，会&lt;strong&gt;阻塞后续的DOM渲染&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Object.getOwnPropertyNames的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/"/>
    <id>https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/</id>
    <published>2018-05-18T02:11:02.000Z</published>
    <updated>2018-08-22T14:30:04.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.getOwnPropertyNames()</code>方法返回一个由<strong>指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><code>Object.getOwnPropertyNames()</code>返回的数组中，<strong>枚举属性</strong>的顺序与通过<code>for…in</code>循环（或 Object.keys）迭代该对象属性时一致。数组中<strong>不可枚举属性的顺序未定义</strong>。</li><li><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">console.log(Object.getOwnPropertyNames(arr).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"length"</span>]</span><br><span class="line"></span><br><span class="line">// 类数组对象</span><br><span class="line">var obj = &#123; 0: <span class="string">"a"</span>, 1: <span class="string">"b"</span>, 2: <span class="string">"c"</span>&#125;;</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line"></span><br><span class="line">// 使用Array.forEach输出属性名和属性值</span><br><span class="line">Object.getOwnPropertyNames(obj).forEach(<span class="keyword">function</span>(val, idx, array) &#123;</span><br><span class="line">    console.log(val + <span class="string">" -&gt; "</span> + obj[val]);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出</span><br><span class="line">// 0 -&gt; a</span><br><span class="line">// 1 -&gt; b</span><br><span class="line">// 2 -&gt; c</span><br><span class="line"></span><br><span class="line">//不可枚举属性</span><br><span class="line">var my_obj = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    getFoo: &#123;</span><br><span class="line">        value: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.foo; &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">my_obj.foo = 1;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(my_obj).sort()); // [<span class="string">"foo"</span>, <span class="string">"getFoo"</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>只要获取到可枚举属性</strong>，可使用<code>Object.keys</code>或用<code>for…in</code>循环（<code>for…in</code>还会获取到原型链上的可枚举属性，不过<strong>可以使用<code>hasOwnProperty()</code>方法过滤掉</strong>）。</p></li><li>下面的例子演示了<code>Object.getOwnPropertyNames()</code>方法<strong>不会获取到原型链上的属性</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ParentClass</span></span>() &#123;&#125;</span><br><span class="line">ParentClass.prototype.inheritedMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ChildClass</span></span>() &#123;</span><br><span class="line">  this.prop = 5;</span><br><span class="line">  this.method = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildClass.prototype = new ParentClass;</span><br><span class="line">ChildClass.prototype.prototypeMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Object.getOwnPropertyNames(</span><br><span class="line">    new ChildClass()  // [<span class="string">"prop"</span>, <span class="string">"method"</span>]</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><blockquote>只获取不可枚举的属性</blockquote><ul><li><p>下面的例子使用了<code>Array.prototype.filter()</code>方法，从所有的属性名数组（使用<code>Object.getOwnPropertyNames()</code>方法获得）中去除可枚举的属性（使用<code>Object.keys()</code>方法获得），剩余的属性便是不可枚举的属性了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var target = myObject;</span><br><span class="line">var enum_and_nonenum = Object.getOwnPropertyNames(target);</span><br><span class="line">var enum_only = Object.keys(target);</span><br><span class="line">var nonenum_only = enum_and_nonenum.filter(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">    var indexInEnum = enum_only.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (indexInEnum == -1) &#123;</span><br><span class="line">        // 没有发现在enum_only键集中意味着这个键是不可枚举的,</span><br><span class="line">        // 因此返回<span class="literal">true</span> 以便让它保持在过滤结果中</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(nonenum_only);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>Array.filter(filt_func)</code>方法<strong>创建一个新数组</strong>, 其包含<strong>通过</strong>所提供函数实现的<strong>测试的所有元素</strong>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在 ES5 中，如果参数不是一个原始对象类型，将抛出一个 TypeError  异常。</li><li>在 ES2015 中，非对象参数被强制转换为对象 。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// [<span class="string">'length'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]  (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;方法返回一个由&lt;strong&gt;指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Object.keys的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/17/ObejectKeys/"/>
    <id>https://chongtianhong.github.io/2018/05/17/ObejectKeys/</id>
    <published>2018-05-17T01:44:26.000Z</published>
    <updated>2018-08-22T14:30:10.432Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.keys()</code>方法会返回一个由一个<strong>给定对象的自身可枚举属性（不包括可枚举属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><p>看下面的题目，输出对象中值大于2的key的数组，即期待输出的结果为：<code>[“c”,”d”]</code>请问xxx处填什么？：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> xxx ;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>正确答案：xxx处应该填入<code>data[x] &lt; 2</code>，即代码修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> data[x] &gt; 2;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>Object.keys()</code>是ES5中新增的方法，用来<strong>获取对象自身所有的可枚举的属性名</strong>，但<strong>不包括原型中的属性</strong>，然后返回一个<strong>由属性名组成的数组</strong>。</p></li><li>注意它同<code>for..in</code>一样<strong>不能保证属性按对象原来的顺序输出</strong>。数组中<strong>属性名的排列顺序和使用<code>for..in</code>循环遍历该对象时返回的顺序一致</strong>。</li><li><code>Array.filter(function)</code>对数组进行过滤返回符合条件的数组。</li><li><p>更多例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// simple array</span><br><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">console.log(Object.keys(arr)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object</span><br><span class="line">var obj = &#123; 0: <span class="string">'a'</span>, 1: <span class="string">'b'</span>, 2: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(obj)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object with random key ordering</span><br><span class="line">var anObj = &#123; 100: <span class="string">'a'</span>, 2: <span class="string">'b'</span>, 7: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(anObj)); // console: [<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'100'</span>]</span><br><span class="line"></span><br><span class="line">// getFoo is a property <span class="built_in">which</span> isn<span class="string">'t enumerable</span></span><br><span class="line"><span class="string">var myObj = Object.create(&#123;&#125;, &#123;</span></span><br><span class="line"><span class="string">    getFoo: &#123;</span></span><br><span class="line"><span class="string">        value: function () &#123; return this.foo; &#125;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">myObj.foo = 1;</span></span><br><span class="line"><span class="string">console.log(Object.keys(myObj)); // console: ['</span>foo<span class="string">']</span></span><br></pre></td></tr></table></figure></li><li><p>如果想获取一个对象的所有属性，甚至包括不可枚举的，应使用<code>Object.getOwnPropertyNames</code>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在ES5里，如果<strong>此方法的参数不是对象（而是一个原始值）</strong>，那么它<strong>会抛出 TypeError</strong>。</li><li>在ES2015中，非对象的参数将被强制转换为一个对象。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]                   (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.keys()&lt;/code&gt;方法会返回一个由一个&lt;strong&gt;给定对象的自身可枚举属性（不包括可枚举属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Object.create()的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/16/ObjectCreate/"/>
    <id>https://chongtianhong.github.io/2018/05/16/ObjectCreate/</id>
    <published>2018-05-16T02:49:41.000Z</published>
    <updated>2018-08-22T14:27:55.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>Object.create()</code>是Object的内置方法，可以创建一个新对象，<strong>使用现有的对象</strong>来<strong>提供新创建的对象的<code>__proto__</code></strong>。 <a id="more"></a></li><li>语法：<code>Object.create ( proto, [ propertiesObject ] ) </code></li><li>该方法有两个参数：<ul><li>第一个<strong>参数proto</strong>是一个对象，作为新建对象的原型对象；</li><li>第二个<strong>参数propertiesObject</strong>是可选的，如果<strong>没有则指定为 undefined</strong>。该<strong>参数对象</strong>是一组属性与值，该对象的<strong>属性名称</strong>将是<strong>新创建的对象的属性名称</strong>，<strong>值</strong>是<strong>属性描述符</strong>（这些属性描述符的结构与Object.defineProperties()的第三个参数一样）。如果<strong>propertiesObject参数不是 null 或一个对象，则抛出一个 TypeError 异常</strong>。</li></ul></li><li>使用该方法，创建对象会执行以下步骤：<br>①方法内部定义一个新的空对象obj<br>②将obj.__proto__的对象指向传入的参数proto<br>③返回一个新的对象</li><li><p>例子1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    isHuman: <span class="literal">false</span>,</span><br><span class="line">    printIntroduction: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(`My name is <span class="variable">$&#123;this.name&#125;</span>. Am I human? <span class="variable">$&#123;this.isHuman&#125;</span>`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me = Object.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">"Matthew"</span>; // <span class="string">"name"</span> is a property <span class="built_in">set</span> on <span class="string">"me"</span>, but not on <span class="string">"person"</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; // inherited properties can be overwritten</span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line">// expected output: <span class="string">"My name is Matthew. Am I human? true"</span></span><br></pre></td></tr></table></figure></li><li><p>例子2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var o;</span><br><span class="line"></span><br><span class="line">// 创建一个原型为null的空对象</span><br><span class="line">o = Object.create(null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line">// 以字面量方式创建的空对象就相当于:</span><br><span class="line">o = Object.create(Object.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = Object.create(Object.prototype, &#123;</span><br><span class="line">  // foo会成为所创建对象的数据属性</span><br><span class="line">    foo: &#123; </span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        value: <span class="string">"hello"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    // bar会成为所创建对象的访问器属性</span><br><span class="line">    bar: &#123;</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        get: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> 10 &#125;,</span><br><span class="line">        <span class="built_in">set</span>: <span class="keyword">function</span>(value) &#123;</span><br><span class="line">        console.log(<span class="string">"Setting `o.bar` to"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Constructor</span></span>()&#123;&#125;</span><br><span class="line">o = new Constructor();</span><br><span class="line">// 上面的一句就相当于:</span><br><span class="line">o = Object.create(Constructor.prototype);</span><br><span class="line">// 当然，如果在Constructor函数中有一些初始化代码，Object.create不能执行那些代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个以另一个空对象为原型，且拥有一个属性p的对象</span><br><span class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">// 省略了的属性特性默认为<span class="literal">false</span>，所以属性p是不可写，不可枚举，不可配置的:</span><br><span class="line">o.p = 24</span><br><span class="line">o.p</span><br><span class="line">//42</span><br><span class="line"></span><br><span class="line">o.q = 12</span><br><span class="line"><span class="keyword">for</span> (var prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">    console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">//<span class="string">"q"</span></span><br><span class="line"></span><br><span class="line">delete o.p</span><br><span class="line">//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//创建一个可写的，可枚举的，可配置的属性p</span><br><span class="line">o2 = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    p: &#123;</span><br><span class="line">        value: 42, </span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="与使用关键字new对象的区别"><a href="#与使用关键字new对象的区别" class="headerlink" title="与使用关键字new对象的区别"></a>与使用关键字new对象的区别</h4><ul><li>使用<code>Object.create()</code>是将对象继承到<code>__proto__</code>属性上：</li><li><code>new Object()</code>方法的实质是，<strong>使用引用类型Object的构造函数创建了一个新的实例</strong>，<strong>这个实例拥有Object默认的方法</strong>如<code>toString</code>、<code>toLocaleString</code>等：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">test</span> = Object.create(&#123;x:123,y:345&#125;);</span><br><span class="line">console.log(<span class="built_in">test</span>);// &#123;&#125;</span><br><span class="line">console.log(test.x);// 123</span><br><span class="line">console.log(test.__proto__.x);// 3</span><br><span class="line">console.log(test.__proto__.x === test.x);// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var test1 = new Object(&#123;x:123,y:345&#125;);</span><br><span class="line">console.log(test1);// &#123;x:123,y:345&#125;</span><br><span class="line">console.log(test1.x);// 123</span><br><span class="line">console.log(test1.__proto__.x);// undefined</span><br><span class="line">console.log(test1.__proto__.x === test1.x);// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">var test2 = &#123;x:123,y:345&#125;;</span><br><span class="line">console.log(test2);// &#123;x:123,y:345&#125;;</span><br><span class="line">console.log(test2.x);// 123</span><br><span class="line">console.log(test2.__proto__.x);// undefined</span><br><span class="line">console.log(test2.__proto__.x === test2.x);// <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.create()&lt;/code&gt;是Object的内置方法，可以创建一个新对象，&lt;strong&gt;使用现有的对象&lt;/strong&gt;来&lt;strong&gt;提供新创建的对象的&lt;code&gt;__proto__&lt;/code&gt;&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>前端路由的两种实现原理</title>
    <link href="https://chongtianhong.github.io/2018/05/15/frontEndRouting/"/>
    <id>https://chongtianhong.github.io/2018/05/15/frontEndRouting/</id>
    <published>2018-05-15T07:14:00.000Z</published>
    <updated>2018-08-20T14:38:25.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在<strong>单页应用</strong>上，前端路由并不陌生。单页应用是指<strong>在浏览器中运行的应用，在使用期间页面不会重新加载</strong>。</li><li>早期的路由都是后端实现的，直接<strong>根据url来重载页面</strong>，当页面变得越来越复杂时，服务器端压力变大。</li><li>随着<strong>ajax</strong>的出现，页面实现<strong>非重载</strong>就能刷新数据，也给前端路由的出现奠定了基础。我们可以<strong>通过修改 url 来记录 ajax 的变化</strong>，从而实现<strong>前端路由</strong>。<a id="more"></a></li><li>从<strong>性能</strong>和<strong>用户体验</strong>的层面来比较的话，<strong>后端路由每次访问一个新页面的时候都要向服务器发送请求</strong>，然后<strong>服务器</strong>再<strong>响应请求</strong>，这个过程肯定会有延迟。而<strong>前端路由在访问一个新页面的时候仅仅是变换了一下路径</strong>而已，<strong>没有了网络延迟</strong>，对于<strong>用户体验</strong>来说会有<strong>相当大的提升</strong>。 </li><li>从<strong>用户的角度</strong>看，前端路由主要实现了两个功能（使用ajax更新页面状态的情况下）：<ul><li><strong>记录当前页面的状态</strong>（保存或分享当前页的url，再次打开该url时，网页还是保存（分享）时的状态）；</li><li><strong>可以使用浏览器的前进后退功能</strong>（如点击后退按钮，可以使页面回到使用ajax更新页面之前的状态，url也回到之前的状态）；</li></ul></li><li>作为<strong>开发者</strong>，要实现这两个功能，我们需要做到：<ul><li>改变url且不让浏览器向服务器发出请求；</li><li>监测 url 的变化；</li><li>截获 url 地址，并解析出需要的信息来匹配路由规则。</li></ul></li><li>路由常用的hash模式和history模式实际上就是实现了上面的功能。</li></ul><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><ul><li>history 是 HTML5 才有的新 API，可以用来<strong>操作浏览器的 session history (会话历史)</strong>。</li><li>History API 能让开发人员在<strong>不刷新整个页面的情况下修改站点的URL</strong>。这个功能很有用，例如通过一段JavaScript代码局部加载页面的内容，你希望<strong>通过改变当前页面的URL来反应出页面内容的变化</strong>，这时该功能可以派上用场。</li><li>举个例子，当用户从首页进入帮助页面时，我们<strong>通过Ajax来加载帮助页面的内容</strong>。然后这个用户又转到产品页面，我们需要再一次通<strong>过Ajax请求来替换页面的内容</strong>。当用户想分享页面的URL时，通过History API，我们可以改变页面的URL来反应内容的修改，这样不管是用户分享还是保存的URL都能和页面的内容对应起来。</li><li>要查看这个API提供了哪些功能非常简单，打开浏览器的开发者工具面板（F12），然后在控制台（console）中输入<code>history</code>。如果浏览器支持History API，将会看到这个对象下面附带了很多方法。关于每个API的用法，可以查看MDN的文档。<br><img src="/images/history.png" width="600" alt="History API提供的功能" style="border:none"></li><li>重点说其中的两个新增的API：<code>history.pushState</code>和<code>history.replaceState</code>。</li><li>这两个 API 都接收三个参数，分别是：<ul><li><strong>状态对象（state object）</strong>：一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。</li><li><strong>标题（title）</strong>：截止到目前，几乎所有的浏览器都忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。</li><li><strong>地址（URL）</strong>：<strong>新的历史记录条目的地址</strong>。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；<strong>不指定的话则为文档当前URL</strong>。</li></ul></li><li><strong>相同之处</strong>是两个 API 都会<strong>操作浏览器的历史记录</strong>，而<strong>不会引起页面的刷新</strong>。</li><li><strong>不同之处</strong>在于，<code>history.pushState</code>会<strong>增加一条新的历史记录</strong>，而<code>history.replaceState</code>则会<strong>替换当前的历史记录</strong>。</li><li><code>history.pushState</code>将我们传给它的URL添加到浏览器的历史记录中，从而改变了浏览器的history。</li><li><strong><code>history.replaceState</code>只是简单地替换了地址栏中的URL（当前的历史记录），不会产生新的记录</strong>。也就是说，<code>history.replaceState</code>改变了当前页面的URL，并没有发出任何request请求，当前窗口仍然停留在之前的页面。当我们点击浏览器的后退按钮时，页面并不会回退到我们通过<code>history.replaceState</code>修改之前的那个URL，而是直接回退到了上一个页面（即我们进入到这个页面之前的那个页面）。</li></ul><blockquote>举例说明</blockquote><ul><li><p>在<strong>百度首页</strong>打开控制台，在控制台输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, <span class="string">"https://www.baidu.com/?name=xbhong"</span>);</span><br></pre></td></tr></table></figure></li><li><p>观察此时的 url 变成了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/?name=xbhong</span><br></pre></td></tr></table></figure></li><li><p>其他用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, <span class="string">"https://www.baidu.com/name/xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name/xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"?name=xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com?name=xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"name=xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name=xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"/name/xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name/xbhong</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：这里的<strong>url不支持跨域</strong>，当我们把<code>www.baidu.com</code>换成<code>baidu.com</code>时就会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught DOMException: Failed to execute <span class="string">'pushState'</span> on <span class="string">'History'</span>: A <span class="built_in">history</span> state object with URL <span class="string">'https://baidu.com/?name=xbhong'</span> cannot be created <span class="keyword">in</span> a document with origin <span class="string">'https://www.baidu.com'</span> and URL <span class="string">'https://www.baidu.com/?name=xbhong'</span>.</span><br></pre></td></tr></table></figure></li><li><p>从上面的例子可以看到，每次<strong>改变url页面并没有刷新</strong>，而浏览器会产生历史记录（可查询到历史记录），这就是<strong>实现页面无刷新情况下改变url</strong>的前提。</p></li></ul><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><ul><li>这里的 hash 就是指<strong>url尾巴后的 # 号以及后面的字符</strong>。这里的 # 和 css 里的 # 是一个意思。hash 也称作<strong>锚点</strong>，本身是用来做<strong>页面定位</strong>的，它可以<strong>使对应 id 的元素显示在可视区域内</strong>。</li><li><strong>基于hash的前端路由</strong>优点是：能<strong>兼容低版本的浏览器</strong>。大型框架的路由系统大多都是hash（哈希）实现的。</li><li><strong>基本原理</strong>：当 url 的 hash 发生改变时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。</li><li>使用到的api：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash = <span class="string">'qq'</span> // 设置 url 的 <span class="built_in">hash</span>，会在当前url后加上 <span class="string">'#qq'</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">hash</span> = window.location.hash // <span class="string">'#qq'</span>  </span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    // 监听<span class="built_in">hash</span>变化，点击浏览器的前进后退会触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote>hash 模式能兼容低版本的浏览器，为什么需要History API</blockquote><ul><li>hash 能兼容到IE8， History API只能兼容到 IE10，使用History API的原因是：<ul><li><strong>hash 本来是拿来做页面定位的</strong>，如果拿来做路由的话，原来的锚点功能就不能用了。</li><li>hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 <strong>history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中</strong>。</li><li>路由的 history 模式比较美观（没有#）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;单页应用&lt;/strong&gt;上，前端路由并不陌生。单页应用是指&lt;strong&gt;在浏览器中运行的应用，在使用期间页面不会重新加载&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;早期的路由都是后端实现的，直接&lt;strong&gt;根据url来重载页面&lt;/strong&gt;，当页面变得越来越复杂时，服务器端压力变大。&lt;/li&gt;
&lt;li&gt;随着&lt;strong&gt;ajax&lt;/strong&gt;的出现，页面实现&lt;strong&gt;非重载&lt;/strong&gt;就能刷新数据，也给前端路由的出现奠定了基础。我们可以&lt;strong&gt;通过修改 url 来记录 ajax 的变化&lt;/strong&gt;，从而实现&lt;strong&gt;前端路由&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="Router" scheme="https://chongtianhong.github.io/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>Promise 的链式调用与中止</title>
    <link href="https://chongtianhong.github.io/2018/05/14/promiseChain/"/>
    <id>https://chongtianhong.github.io/2018/05/14/promiseChain/</id>
    <published>2018-05-14T07:04:43.000Z</published>
    <updated>2018-08-19T08:45:53.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文主要讲的是如何<strong>实现 Promise 的链式调用</strong>，也就是<code>promise().then().then().catch()</code>的形式，然后讨论如何<strong>在某一个 then() 里面中止 Promise</strong>。<a id="more"></a></li><li>在程序中，只要<strong>返回了一个 promise 对象</strong>，只要<strong>该 promise 对象不是 Rejected 或 Fulfilled 状态，then 方法就会继续调用</strong>。利用这个特性，可以<strong>处理多个异步逻辑</strong>。</li><li>但有时候某个 then 方法的执行结果可能会决定是否需要执行下一个 then，这个时候就需中止 promise，主要思想就是<strong>使用 reject 来中止 promise 的 then 继续执行</strong>。</li></ul><h4 id="回顾Promise知识点"><a href="#回顾Promise知识点" class="headerlink" title="回顾Promise知识点"></a>回顾Promise知识点</h4><ul><li><p><strong>Promise</strong>其实很简单，就<strong>是一个处理异步的方法</strong>。一般可以通过 new 方法来调用 Promise 的构造器实例化一个 promise 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步处理</span><br><span class="line">    // 处理结束后，调用 resolve 或 reject</span><br><span class="line">    //      成功时就调用 resolve</span><br><span class="line">    //      失败时就调用 reject</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>用<code>new Promise</code>实例化的 promise 对象有以下三个状态：</p><ul><li>“has-resolution” - <strong>Fulfilled</strong>。resolve(成功)时，此时会调用 onFulfilled;</li><li>“has-rejection” - <strong>Rejected</strong>。reject(失败)时，此时会调用 onRejected;</li><li>“unresolved” - <strong>Pending</strong>。既不是resolve也不是reject的状态，也就是promise对象刚被创建后的初始化状态等。</li></ul></li><li>Promise对象的状态改变，只有两种可能：<strong>从Pending变为Fulfilled</strong>和<strong>从Pending变为Rejected</strong>。只要这两种情况发生，<strong>状态</strong>就<strong>凝固</strong>了，<strong>不会再变</strong>了，会一直保持这个结果。<br><img src="/images/promiseProcess.png" alt="promise的状态变化示意图" width="600" style="border:none"></li></ul><h4 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h4><ul><li><code>then()</code>方法的作用是<strong>为Promise实例添加解决（fulfillment）和拒绝（rejection）状态的回调函数</strong>。</li><li><code>then()</code>方法会<strong>返回一个新的Promise实例</strong>，所以<strong><code>then()</code>方法后面可以继续跟另一个<code>then()</code>方法进行链式调用</strong>。</li><li><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// promise start</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">        resolve(<span class="string">'start'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p1</span><br><span class="line"><span class="keyword">function</span> p1(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p2</span><br><span class="line"><span class="keyword">function</span> p2(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((reject)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        reject(2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p3</span><br><span class="line"><span class="keyword">function</span> p3(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        resolve(3);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p4</span><br><span class="line"><span class="keyword">function</span> p4(ex)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        resolve(4);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(p1)</span><br><span class="line">    .<span class="keyword">then</span>(p2)</span><br><span class="line">    .<span class="keyword">then</span>(p3)</span><br><span class="line">    .catch(p4)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // end</span><br><span class="line">        console.log(<span class="string">'result of p4: '</span>, data);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的代码最终会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result of start:  start</span><br><span class="line">result of p1:  1</span><br><span class="line">ex:  2</span><br><span class="line">result of p4:  4</span><br></pre></td></tr></table></figure></li><li><p>可以看到，代码的执行逻辑是<code>promise start –&gt; promise p1 –&gt; promise p3 –&gt; promise p4 –&gt; end</code>。所以可总结出以下几点：</p><ul><li>promise 的 <strong>then 方法里面</strong>可以<strong>继续返回一个新的 promise 对象</strong>;</li><li>下一个 <strong>then 方法的参数</strong>是<strong>上一个 promise 对象的 resolve 参数</strong>;</li><li><strong>catch 方法的参数</strong>是其<strong>之前某个 promise 对象的 rejecte 参数</strong>;</li><li>一旦某个 then 方法里面的 <strong>promise 状态改变为了 rejected</strong>，则promise 方法连会<strong>跳过后面的 then 直接执行 catch</strong>;</li><li><strong>catch 方法</strong>里面依旧<strong>可以返回一个新的 promise 对象</strong>。</li></ul></li></ul><h4 id="如何中指promise的链式调用"><a href="#如何中指promise的链式调用" class="headerlink" title="如何中指promise的链式调用"></a>如何中指promise的链式调用</h4><ul><li>通过上面的例子，我们可以知道<strong> promise 的状态改变为 rejected 后，promise 就会跳过后面的 then 方法</strong>。</li><li>也就是说，当<strong>某个 then 里面发生异常后</strong>，就会<strong>跳过 then 方法</strong>，<strong>直接执行 catch</strong>。</li><li><p>所以，当在构造的 promise 方法链中，如果<strong>在某个 then 后面，不需要再执行 then 方法了，就可以把它当作一个异常来处理</strong>，返回一个异常信息给 catch，其参数可自定义，比如该异常的参数信息为 { notRealPromiseException: true}，然后在 catch 里面判断一下 notRealPromiseException 是否为 true，如果为 true，就说明不是程序出现异常，而是在正常逻辑里面中止 then 方法的执行。代码示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise start</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(1); // p1</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p1</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.reject(&#123;</span><br><span class="line">            notRealPromiseException: <span class="literal">true</span>,</span><br><span class="line">        &#125;); // p2</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p2</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(3); // p3</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(ex =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        <span class="keyword">if</span> (ex.notRealPromiseException) &#123;</span><br><span class="line">            // 一切正常，只是通过 catch 方法来中止 promise chain</span><br><span class="line">            // 也就是中止 promise p2 的执行</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // 真正发生异常</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样的做法可能不符合<code>catch</code>的语义。不过从某种意义上来说，promise 方法链没有继续执行，也可以算是一种“异常”。</p></li></ul><h4 id="Promise-all-与-Promise-race"><a href="#Promise-all-与-Promise-race" class="headerlink" title="Promise.all 与 Promise.race"></a>Promise.all 与 Promise.race</h4><ul><li>其实 promise 方法链更好用的一点是，当<strong>下一个操作依赖于上一个操作的结果</strong>的时候，可以很方便地<strong>通过 then 方法的参数来传递数据</strong>。</li><li>前面也提到过，<strong>下一个 then 方法的参数就是上一个 then 方法里面 resolve 的参数</strong>，所以当然就可以<strong>把上一个 then 方法的执行结果作为参数传递给下一个 then 方法</strong>。</li><li><p>还有些时候，可能 then 方法的执行顺序也没有太多要求，只需要 promise 方法链中的两个或多个 promise 全部都执行正确。这时，如果依旧一个一个去写 then 可能就比较麻烦，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p2</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p3</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在<strong>只需要<code>p1</code>、<code>p2</code>、<code>p3</code>这三个 promise 都执行</strong>，并且 <strong>promise 最终状态都是 Fulfilled</strong>，那么如果还是使用链式调用，这时这样调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p1()</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p2();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p3();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>代码貌似就不那么精炼了。这个时候就有了 <code>Promise.all</code> 这个方法。</p></li><li><code>Promise.all</code> 接收一个<strong>promise对象的数组</strong>作为参数，当这个数组里的所有 promise 对象<strong>全部变为 resolve</strong> 或 <strong>reject 状态</strong>的时候，它才会去调用 then 方法。</li><li><p>于是，调用这几个 promise 的代码就可以这样写了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([p1, p2, p3]).<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;).catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>对于 <code>Promise.race</code>，其<strong>参数</strong>也跟 <code>Promise.all</code> 一样<strong>*是一个数组</strong>。只是<strong>数组中的任何一个 promise 对象如果变为 resolve 或者reject 的话，该函数就会返回</strong>，并<strong>使用这个 promise 对象的值进行 resolve 或者 reject</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本文主要讲的是如何&lt;strong&gt;实现 Promise 的链式调用&lt;/strong&gt;，也就是&lt;code&gt;promise().then().then().catch()&lt;/code&gt;的形式，然后讨论如何&lt;strong&gt;在某一个 then() 里面中止 Promise&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Promise" scheme="https://chongtianhong.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Ajax中返回数据的格式和处理方法分析</title>
    <link href="https://chongtianhong.github.io/2018/05/13/ajaxDataType/"/>
    <id>https://chongtianhong.github.io/2018/05/13/ajaxDataType/</id>
    <published>2018-05-13T05:51:23.000Z</published>
    <updated>2018-08-18T12:35:57.196Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Ajax中常见的<strong>返回数据的格式</strong>有三种：分别为<strong>文本</strong>，<strong>XML</strong>和<strong>JSON</strong>。<a id="more"></a></li></ul><h4 id="Text-HTML格式"><a href="#Text-HTML格式" class="headerlink" title="Text/HTML格式"></a>Text/HTML格式</h4><ul><li>通过Ajax对象的<code>responseText</code>属性就可以获取到返回的文本信息。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxText(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(oAjax.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="XML格式"><a href="#XML格式" class="headerlink" title="XML格式"></a>XML格式</h4><ul><li>通过Ajax对象的<code>responseXML</code>属性就可以获取到返回的<strong>XML DOM</strong>对象。</li><li><p>解析<strong>XML DOM</strong>的数据就类似于HTML DOM 编程. 比如<strong>通过TagName获取标签对象</strong>(数组形式)，再从该数组中获取需要的标签对象，再从标签对象中获取文本值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(XML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param tagName  要获取值的标签名</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxXML(url, jsonData, tagName, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   //拼 装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var oXml =  oAjax.responseXML; //返 回的是一个XML DOM对象</span><br><span class="line">            var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">            var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(tagValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>XML文件具有的几大特点：</p><ul><li>标签没有预定义，开发者根据自己的需求发明标签</li><li>结构清晰，具有自我描述性。从XML文档就可以看出数据的内容</li><li>都是双标签</li><li>和HTML相似，同样也具有树结构</li></ul></li></ul><h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><ul><li>由于JSON格式相比XML更小，传输更快，所以现在Ajax返回json数据格式的情况更多。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)，但是返回的是Json类型的文本数据</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据,利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxJson(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>); // 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var json = JSON.parse(oAjax.responseText);// 把传回来的字符串解析成json对象</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三种格式的函数封装"><a href="#三种格式的函数封装" class="headerlink" title="三种格式的函数封装"></a>三种格式的函数封装</h4><ul><li>为了方便使用，可以把三个函数合并，合并后的函数如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @<span class="keyword">function</span> 利用ajax动态交换数据</span><br><span class="line"> * @param url   要提交请求的页面</span><br><span class="line"> * @param jsonData  要提交的数据,利用Json传递</span><br><span class="line"> * @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line"> * @param <span class="built_in">type</span>    接受的数据类型,text/xml/json</span><br><span class="line"> * @param tagName <span class="built_in">type</span> = xml 的时候这个参数设置为要获取的文本的标签名</span><br><span class="line"> * @<span class="built_in">return</span> 无</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> ajax(url,jsonData,getMsg,<span class="built_in">type</span>,tagName)&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'text'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(oAjax.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'json'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var json = JSON.parse(oAjax.responseText); // 把传回来的字符串解析成json对象</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'xml'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var oXml =  oAjax.responseXML; // 返回的是一个XML DOM对象</span><br><span class="line">                var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">                var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(tagValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Ajax中常见的&lt;strong&gt;返回数据的格式&lt;/strong&gt;有三种：分别为&lt;strong&gt;文本&lt;/strong&gt;，&lt;strong&gt;XML&lt;/strong&gt;和&lt;strong&gt;JSON&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Ajax" scheme="https://chongtianhong.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>浅谈arguments与arguments的妙用</title>
    <link href="https://chongtianhong.github.io/2018/05/12/arguments/"/>
    <id>https://chongtianhong.github.io/2018/05/12/arguments/</id>
    <published>2018-05-12T12:41:53.000Z</published>
    <updated>2018-08-18T12:38:49.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>每个函数都有一个<strong>arguments属性</strong>，表示函数的<strong>实参集合</strong>，这里的实参是重点，就是<strong>执行函数时实际传入的参数的集合</strong>。<a id="more"></a></li><li><strong>arguments</strong>不是数组而是一个<strong>对象</strong>，但它和数组很相似，所以通常称为<strong>类数组对象</strong>，以后看到类数组其实就表示<strong>arguments</strong>。</li><li><p><strong>arguments有length属性</strong>，表示函数实参个数，可以用<code>arguments[index]</code>显式调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(var i=0; i&lt; arguments.length; i++)&#123;</span><br><span class="line">        console.log(arguments[i]);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">"a"</span>, 17, [1, 2, 3], &#123;name:<span class="string">"javascript"</span>, <span class="built_in">type</span>:<span class="string">"language"</span>&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">a</span><br><span class="line">17</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&#123;name: <span class="string">"javascript"</span>, <span class="built_in">type</span>: <span class="string">"language"</span>&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><strong>arguments</strong>还有一个叫做<code>callee</code>的属性，这个属性是表示的是<strong>当前函数的一个引用</strong>，简单点说，这个属性里面存储的我们调用的这个函数的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showcallee</span></span>() &#123;</span><br><span class="line">    var a = <span class="string">'这里是代码'</span>;</span><br><span class="line">    var b = <span class="string">'这是另一段代码'</span>;</span><br><span class="line">    var c = a + b;</span><br><span class="line"></span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">showcallee();</span><br><span class="line">// arguments.callee将完整地把这个函数的所有代码返回。</span><br></pre></td></tr></table></figure></li></ul><h4 id="arguments的妙用"><a href="#arguments的妙用" class="headerlink" title="arguments的妙用"></a>arguments的妙用</h4><h5 id="利用arguments实现方法的重载"><a href="#利用arguments实现方法的重载" class="headerlink" title="利用arguments实现方法的重载"></a>利用arguments实现方法的重载</h5><ul><li><p>由于<strong>Javascript</strong>是一种<strong>弱类型</strong>的语言，<strong>没有重载机制</strong>，当我们重写函数时，会将原来的函数直接覆盖，这里我们能<strong>利用arguments</strong>，来<strong>判断传入的实参类型与数量进行不同的操作</strong>，然后<strong>返回不同的数值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">doAdd</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(arguments.length == 1) &#123;</span><br><span class="line">        alert(arguments[0] + 5);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arguments.length == 2) &#123;</span><br><span class="line">        alert(arguments[0] + arguments[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(10);//输出 <span class="string">"15"</span></span><br><span class="line">doAdd(40, 20);//输出 <span class="string">"60"</span></span><br></pre></td></tr></table></figure></li><li><p>当只有一个参数时，<code>doAdd()</code>函数给参数加 5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，<code>doAdd(10)</code>输出的是 “15”，而<code>doAdd(40, 20)</code>输出的是 “60”。</p></li></ul><h5 id="利用arguments-callee实现递归"><a href="#利用arguments-callee实现递归" class="headerlink" title="利用arguments.callee实现递归"></a>利用arguments.callee实现递归</h5><ul><li><p>用之前的方法来实现一个<strong>计算阶乘</strong>的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * factorial(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是当这个函数变成了一个匿名函数时，我们就可以利用<code>callee</code>来递归这个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * arguments.callee(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：在<strong>严格模式</strong>中<code>arguments.callee</code>这个属性被<strong>禁止使用</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个函数都有一个&lt;strong&gt;arguments属性&lt;/strong&gt;，表示函数的&lt;strong&gt;实参集合&lt;/strong&gt;，这里的实参是重点，就是&lt;strong&gt;执行函数时实际传入的参数的集合&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="arguments" scheme="https://chongtianhong.github.io/tags/arguments/"/>
    
  </entry>
  
  <entry>
    <title>for循环、forEach、map、filter区别及效率分析</title>
    <link href="https://chongtianhong.github.io/2018/05/11/arrayMethodsComparation/"/>
    <id>https://chongtianhong.github.io/2018/05/11/arrayMethodsComparation/</id>
    <published>2018-05-11T11:55:57.000Z</published>
    <updated>2018-08-18T14:22:25.708Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>遍历数组</strong>最常用到的for循环，是最为熟知的一种方法，在ES5中定义了一些新的遍历方法，更加适用于函数式编程。</li><li>本文对各种数组遍历方法的区别和效率进行分析记录。<a id="more"></a></li><li><p>首先，写入以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var testData = []; // 数组初始化</span><br><span class="line">var x = 9999;</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; x; i++)&#123;</span><br><span class="line">    testData[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在每个遍历开始前和结束后取时间戳的差值，每个测试10次取平均值查看结果。<strong>以下测试结果基于Google浏览器</strong>。</p></li></ul><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><ul><li><p>对于普通的for循环来说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; testData.length; i++)&#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是7.3ms。</p></li><li><p>重新对for循环进行优化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0, len = testData.length; i &lt; len; i++)&#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是2.7ms。</p></li><li>但是当x = 99999，到达10^5级时，遍历时间分别是7ms和7.1ms，二者几乎没有差别；当 x = 999999时，遍历时间分别是，14.1ms和14.6ms，前者循环耗时比后者要少，即<strong>遍历数据从10^5级别开始，普通for循环相比优化的for循环效率更高</strong>。</li></ul><h5 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h5><ul><li><p>当使用forEach方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testData.forEach(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是2.1ms，x = 99999时，取值8.9ms，x = 999999时，取值39ms，由此可见，<strong>在10^4级别及以下forEach的效率占有绝对优势</strong>，但从10^5级别开始就走下坡了了。然而用<strong>火狐</strong>测过以后，结果却<strong>截然不同</strong>（见页底）。</p></li></ul><h5 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h5><ul><li><p>当使用map方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.map(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>传递给map()函数的调用方式和传递给forEach()函数的调用方式一样，但传递给map()函数应该有返回值。在<strong>Google浏览器</strong>环境下，<strong>耗时是forEach方法的基础上相应增加的</strong>。</p></li></ul><h5 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h5><ul><li><p>当使用filter方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.filter(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>filter()方法返回的数组元素是调用的数组的一个子集，传递的函数用来进行逻辑判定的，该函数返回true或false，同样的的式子，在<strong>Google浏览器</strong>环境下，<strong>耗时相比较是map方法的40%左右</strong>。</p></li></ul><h5 id="不同浏览器的结果对比"><a href="#不同浏览器的结果对比" class="headerlink" title="不同浏览器的结果对比"></a>不同浏览器的结果对比</h5><ul><li>Google环境下的测试结果：<br><img src="/images/Google.jpg" alt="Google环境下的测试结果" width="600" style="border:none"></li><li>Firefox环境下的测试结果：<br><img src="/images/Firefox.jpg" alt="Firefox环境下的测试结果" width="600" style="border:none"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;最常用到的for循环，是最为熟知的一种方法，在ES5中定义了一些新的遍历方法，更加适用于函数式编程。&lt;/li&gt;
&lt;li&gt;本文对各种数组遍历方法的区别和效率进行分析记录。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Array" scheme="https://chongtianhong.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>30个你“不可能全部会做”的JavaScript题目及解析</title>
    <link href="https://chongtianhong.github.io/2018/05/10/30JSproblems/"/>
    <id>https://chongtianhong.github.io/2018/05/10/30JSproblems/</id>
    <published>2018-05-10T06:32:18.000Z</published>
    <updated>2018-08-21T14:23:32.436Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文记录了30个<code>你“不可能全部会做”的JavaScript题目</code>，并对各个答案进行分析。<a id="more"></a></li></ul><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line"></span><br><span class="line">　　B.[1,2,3]</span><br><span class="line"></span><br><span class="line">　　C.[0,1,2]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[typeof null, null instanceof Object]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"object"</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　B.[null,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="string">"object"</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[3,2,1].reduce(Math.pow),[].reduce(Math.pow)]</span><br><span class="line"></span><br><span class="line">　　A.报错</span><br><span class="line"></span><br><span class="line">　　B.[9,0]</span><br><span class="line"></span><br><span class="line">　　C.[9,NaN]</span><br><span class="line"></span><br><span class="line">　　D.[9,undefined]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var val = <span class="string">'value'</span>;</span><br><span class="line">console.info(<span class="string">'Value id '</span> + (val === <span class="string">'value'</span>)?<span class="string">'Something'</span>:<span class="string">'Nothing'</span>);</span><br><span class="line"></span><br><span class="line">　　A.Something</span><br><span class="line"></span><br><span class="line">　　B.Nothing</span><br><span class="line"></span><br><span class="line">　　C.NaN</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">'World'</span>;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　<span class="keyword">if</span>(typeof name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">　　　　var name = <span class="string">"Jack"</span>;</span><br><span class="line">　　　　console.info(<span class="string">'Goodbye '</span>+ name);</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Hello '</span> + name);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">　　A.Goodbye Jack</span><br><span class="line"></span><br><span class="line">　　B.Hello Jack</span><br><span class="line"></span><br><span class="line">　　C.Goodbye undefined</span><br><span class="line"></span><br><span class="line">　　D.Hello undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var END = 9007199254740992;</span><br><span class="line">var START = END -100;</span><br><span class="line">var count = 0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var i = START ; i &lt;= END ; i++)&#123;</span><br><span class="line">　　count ++;</span><br><span class="line">&#125;</span><br><span class="line">console.info(count);</span><br><span class="line"></span><br><span class="line">　　A.0</span><br><span class="line"></span><br><span class="line">　　B.100</span><br><span class="line"></span><br><span class="line">　　C.101</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0, 1, 2];</span><br><span class="line">arr[10] = 10;</span><br><span class="line">arr.filter(<span class="keyword">function</span>(x)&#123;<span class="built_in">return</span> x === undefined&#125;);</span><br><span class="line"></span><br><span class="line">　　A.[undefined x 7]</span><br><span class="line"></span><br><span class="line">　　B.[0, 1, 2, 10]</span><br><span class="line"></span><br><span class="line">　　C.[]</span><br><span class="line"></span><br><span class="line">　　D.[undefined]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var two = 0.2;</span><br><span class="line">var one = 0.1;</span><br><span class="line">var eight = 0.8;</span><br><span class="line">var six = 0.6;</span><br><span class="line">[two - one == one, eight - six == two];</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showCase(value)&#123;</span><br><span class="line"></span><br><span class="line">　　switch(value)&#123;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case A'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case B'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> undefined :</span><br><span class="line">　　　　　　console.info(<span class="string">'undefined'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　default:</span><br><span class="line">　　　　　　console.info(<span class="string">'Do not know!'</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(new String(<span class="string">'A'</span>));</span><br><span class="line"></span><br><span class="line">　　A.Case A</span><br><span class="line"></span><br><span class="line">　　B.Case B</span><br><span class="line"></span><br><span class="line">　　C.Do not know</span><br><span class="line"></span><br><span class="line">　　D.undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showCase(value)&#123;</span><br><span class="line"></span><br><span class="line">　　switch(value)&#123;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case A'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case B'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> undefined :</span><br><span class="line">　　　　　　console.info(<span class="string">'undefined'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　default:</span><br><span class="line">　　　　　　console.info(<span class="string">'Do not know!'</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(String(<span class="string">'A'</span>));</span><br><span class="line"></span><br><span class="line">　　A.Case A</span><br><span class="line"></span><br><span class="line">　　B.Case B</span><br><span class="line"></span><br><span class="line">　　C.Do not know</span><br><span class="line"></span><br><span class="line">　　D.undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目11"><a href="#题目11" class="headerlink" title="题目11"></a>题目11</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isOdd(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> num % 2 == 1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> isEven(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> num % 2 == 0; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> isSane(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> isEven(num)||isOdd(num);</span><br><span class="line">&#125;</span><br><span class="line">var values = [7, 4, <span class="string">'13'</span>, -9, Infinity];</span><br><span class="line">values.map(isSane);</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　D.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目12"><a href="#题目12" class="headerlink" title="题目12"></a>题目12</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[parseInt(3,8),parseInt(3,2),parseInt(3,0)]</span><br><span class="line"></span><br><span class="line">　　A.[3,3,3]</span><br><span class="line"></span><br><span class="line">　　B.[3,3,NaN]</span><br><span class="line"></span><br><span class="line">　　C.[3,NaN,NaN]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目13"><a href="#题目13" class="headerlink" title="题目13"></a>题目13</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(Array.prototype)</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目14"><a href="#题目14" class="headerlink" title="题目14"></a>题目14</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [0];</span><br><span class="line"><span class="keyword">if</span>([0])&#123;</span><br><span class="line">　　console.info(a == <span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　console.info(<span class="string">"else"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.<span class="string">"else"</span></span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目15"><a href="#题目15" class="headerlink" title="题目15"></a>题目15</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[]==[]</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目16"><a href="#题目16" class="headerlink" title="题目16"></a>题目16</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'5'</span> + 3), (<span class="string">'5'</span>- 3)]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"53"</span>, 2]</span><br><span class="line"></span><br><span class="line">　　B.[8, 2]</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目17"><a href="#题目17" class="headerlink" title="题目17"></a>题目17</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1+-+++-+1</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目18"><a href="#题目18" class="headerlink" title="题目18"></a>题目18</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array(3);</span><br><span class="line">arr[0] = 2</span><br><span class="line">arr.map(<span class="keyword">function</span>(elem)&#123;<span class="built_in">return</span> <span class="string">'1'</span>;&#125;);</span><br><span class="line"></span><br><span class="line">　　A.[2,1,1]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line"></span><br><span class="line">　　C.[2,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目19"><a href="#题目19" class="headerlink" title="题目19"></a>题目19</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sidEffecting(arr)&#123;</span><br><span class="line">　　arr[0] = arr[2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> bar(a, b, c)&#123;</span><br><span class="line">　　c = 10;</span><br><span class="line">    // arguments = [1, 1, 10]</span><br><span class="line">　　sidEffecting(arguments);</span><br><span class="line">　　<span class="built_in">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">bar(1,1,1);</span><br><span class="line"></span><br><span class="line">　　A.3</span><br><span class="line"></span><br><span class="line">　　B.12</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目20"><a href="#题目20" class="headerlink" title="题目20"></a>题目20</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 111111111111111110000,</span><br><span class="line">b = 1111;</span><br><span class="line">console.info(a+b);</span><br><span class="line"></span><br><span class="line">　　A.111111111111111111111</span><br><span class="line"></span><br><span class="line">　　B.111111111111111110000</span><br><span class="line"></span><br><span class="line">　　C.NaN</span><br><span class="line"></span><br><span class="line">　　D.Infinity</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目21"><a href="#题目21" class="headerlink" title="题目21"></a>题目21</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var x = [].reverse;</span><br><span class="line">x();</span><br><span class="line"></span><br><span class="line">　　A.[]</span><br><span class="line"></span><br><span class="line">　　B.undefined</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.window</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目22"><a href="#题目22" class="headerlink" title="题目22"></a>题目22</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.MIN_VALUE &gt; 0</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目23"><a href="#题目23" class="headerlink" title="题目23"></a>题目23</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1&lt;2&lt;3,3&lt;2&lt;1]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目24"><a href="#题目24" class="headerlink" title="题目24"></a>题目24</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 == [[[2]]]</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.undefined</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目25"><a href="#题目25" class="headerlink" title="题目25"></a>题目25</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[3.toString(),3..toString(),3...toString()]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"3"</span>,error,error]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="string">"3"</span>,<span class="string">"3.0"</span>,error]</span><br><span class="line"></span><br><span class="line">　　C.[error,<span class="string">"3"</span>,error]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目26"><a href="#题目26" class="headerlink" title="题目26"></a>题目26</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　var x1 = y1 = 1;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.info(y1);</span><br><span class="line">console.info(x1);</span><br><span class="line"></span><br><span class="line">　　A.1，1</span><br><span class="line"></span><br><span class="line">　　B.error，error</span><br><span class="line"></span><br><span class="line">　　C.1，error</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目27"><a href="#题目27" class="headerlink" title="题目27"></a>题目27</h5><ul><li>列举IE和FF脚本兼容性的问题。</li></ul><h5 id="题目28"><a href="#题目28" class="headerlink" title="题目28"></a>题目28</h5><ul><li>以下函数有什么问题？如何改进？<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">initButtons</span></span>()&#123;</span><br><span class="line">    var body = document.body, button;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0;i &lt; 5; i++)&#123;</span><br><span class="line">        button = document.createElement(<span class="string">"button"</span>);</span><br><span class="line">        button.innerHTML = <span class="string">"Button"</span> + i;</span><br><span class="line">        button.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        body.appendChild(button);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">initButtons();</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目29"><a href="#题目29" class="headerlink" title="题目29"></a>题目29</h5><ul><li>写一段代码，判断一个字符串中出现次数最多的字符，并统计出现的次数。</li></ul><h5 id="题目30"><a href="#题目30" class="headerlink" title="题目30"></a>题目30</h5><ul><li>请问一下两段代码有什么不同？<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代码一</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>()&#123;        </span><br><span class="line">    /*代码块*/        </span><br><span class="line">    setTimeout(arguments.callee, 10);    </span><br><span class="line">&#125;, 10);   </span><br><span class="line"></span><br><span class="line">// 代码二</span><br><span class="line">setInterval(<span class="function"><span class="title">function</span></span>()&#123;        </span><br><span class="line">　　/*代码块*/    </span><br><span class="line">&#125;, 10);</span><br></pre></td></tr></table></figure></li></ul><h4 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h4><h5 id="题目1-1"><a href="#题目1-1" class="headerlink" title="题目1"></a>题目1</h5><ul><li>解析:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">map对数组的每个元素调用定义的回调函数并返回包含结果的数组。</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)对于数组中每个元素调用paresInt。</span><br><span class="line">map中回调函数的语法：<span class="keyword">function</span> callbackfn(value, index, array1)，可使用最多三个参数来声明回调函数。第一参数value，数组元素的值；第二个参数index，数组元素的数组所以；array1，包含该元素的数组对象。</span><br><span class="line">map在作用parseInt函数时，其实传入了元素的值(作为需要转化为十进制的字符串)，以及所对应的索引(作为转化的基数)。</span><br><span class="line">因此，题目等同于[parseInt(1,0), parseInt(2,1), parseInt(3,2)]</span><br><span class="line">最终返回[1, NaN, NaN]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目2-1"><a href="#题目2-1" class="headerlink" title="题目2"></a>题目2</h5><ul><li>解析:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">typeof用以获取一个变量或者表达式的类型。null是个特殊的Object类型的值，表示空引用的意思。</span><br><span class="line">instanceof 表示某个变量是否是某个对象的实例。</span><br><span class="line">typeof null ==== <span class="string">'object'</span></span><br><span class="line">null instanceof Object === <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="题目3-1"><a href="#题目3-1" class="headerlink" title="题目3"></a>题目3</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。其效果就是：</span><br><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br><span class="line">pow() 方法可返回 x 的 y 次幂的值。[3,2,1].reduce(Math.pow);等同于：</span><br><span class="line"><span class="keyword">function</span> testFuc(x,y)&#123;</span><br><span class="line">    console.info(x +<span class="string">" : "</span>+y);</span><br><span class="line">    <span class="built_in">return</span> Math.pow(x,y);</span><br><span class="line">&#125;</span><br><span class="line">console.info([3,2,1].reduce(testFuc));</span><br><span class="line">3 : 2  =&gt; Math.pow(3,2) == 9</span><br><span class="line">9 : 1  =&gt; Math.pow(9,1) == 9</span><br><span class="line">9 ==&gt; 最终结果</span><br><span class="line"></span><br><span class="line">但是要注意：Array的reduce()不能作用在空数组上，会报 Uncaught TypeError: Reduce of empty array with no initial value 错误。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目4-1"><a href="#题目4-1" class="headerlink" title="题目4"></a>题目4</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">先执行字符串拼接，再执行三元表达式判断</span><br><span class="line"><span class="string">'Value id '</span> + <span class="literal">true</span> 结果为 <span class="string">'Value id true'</span></span><br><span class="line">字符串不为空，因此为<span class="literal">true</span>，所以返回<span class="string">'Something'</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="题目5-1"><a href="#题目5-1" class="headerlink" title="题目5"></a>题目5</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">判断语句被包裹在立即调用函数里，函数中声明了一个局部变量name，</span><br><span class="line">变量在函数内部进行变量提升，在进行判断时，</span><br><span class="line">name已经声明但尚未初始化，因此，进入了<span class="keyword">if</span>(<span class="literal">true</span>)的语句块中，</span><br><span class="line">name被初始化为<span class="string">"Jack"</span>，最终输出Goodbye Jack。</span><br><span class="line">与C系语言不同的是，JavaScript是函数级作用域(<span class="keyword">function</span>-level scope)，只有函数才会创建新的作用域。 </span><br><span class="line">。在<span class="keyword">if</span>语句块中，声明新的变量，这些变量会影响到外部作用域。</span><br><span class="line">如：</span><br><span class="line">var x = 1; </span><br><span class="line">console.log(x); // 1 </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">var x = 2; </span><br><span class="line">console.log(x); //2 </span><br><span class="line">&#125; </span><br><span class="line">console.log(x);// 2 </span><br><span class="line">若将题目改成：</span><br><span class="line">var name = <span class="string">'World'</span>;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　<span class="keyword">if</span>(typeof name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Goodbye '</span>+ name);</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Hello '</span> + name);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">将得到Hello World的结果</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目6-1"><a href="#题目6-1" class="headerlink" title="题目6"></a>题目6</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">10进制的整数的精确表达范围是-9007199254740992(-2^53)到9007199254740992(2^53)</span><br><span class="line">END = 9007199254740992 ,START = 9007199254740892目的是计算的END和START之间的差。</span><br><span class="line">但是2的53次方计算出的结果由于精度问题使得i++失效。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目7-1"><a href="#题目7-1" class="headerlink" title="题目7"></a>题目7</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">filter不会接触到没有被赋值的元素，</span><br><span class="line">即在arr中，长度为11但实际数值元素列表为[0, 1, 2, 10]，</span><br><span class="line">因此，最终返回一个空的数组[]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目8-1"><a href="#题目8-1" class="headerlink" title="题目8"></a>题目8</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">两个浮点数相加或者相减，将会导致一定的正常的数据转换造成的精度丢失问题</span><br><span class="line">eight - six = 0.20000000000000007。</span><br><span class="line">更严谨的做法是(eight - six ).totoFiexd(1)或者用Math.round()方法回归整数运算。</span><br><span class="line">判断两个浮点数是否相等，还是建议用逼近的比较，比如<span class="keyword">if</span>((a-b) &lt; 1E-10)</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目9-1"><a href="#题目9-1" class="headerlink" title="题目9"></a>题目9</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">使用new String()使用构造函数调用将一个全新的对象作为this变量的值，并且隐式返回这个新对象作为调用的结果，</span><br><span class="line">因此showCase()接收的参数为String &#123;0: “A”&#125;而不是我们所认为的“A”，为一个对象。</span><br><span class="line">switch是进行绝对等于判断，new String(<span class="string">'A'</span>) !== <span class="string">'A'</span> 而 new String(<span class="string">'A'</span>) == <span class="string">'A'</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="题目10-1"><a href="#题目10-1" class="headerlink" title="题目10"></a>题目10</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">直接调用String(“A”)创建的变量和”A”无异。</span><br><span class="line">例子：</span><br><span class="line">var a = <span class="string">"123"</span>; // 只是设置变量</span><br><span class="line">b = new String(<span class="string">'123'</span>); // 设置一个成员</span><br><span class="line"></span><br><span class="line">var a = <span class="string">"123"</span>;</span><br><span class="line">a.sex = 1;</span><br><span class="line">alert(a.sex); // 输出未定义，因为不是成员，没有这属性</span><br><span class="line"></span><br><span class="line">b = new String(<span class="string">'123'</span>);</span><br><span class="line">b.sex = 1;</span><br><span class="line">alert(b.sex); // 输出1，成员的属性</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目11-1"><a href="#题目11-1" class="headerlink" title="题目11"></a>题目11</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">该函数判断num是否为正整数，</span><br><span class="line"><span class="string">'13'</span>被强制转换为数值13，-9%2结果为-1，Infinity%2为NaN。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目12-1"><a href="#题目12-1" class="headerlink" title="题目12"></a>题目12</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">最终结果为[3, NaN, 3]； </span><br><span class="line">parseInt() 函数可解析一个字符串，并返回一个整数。</span><br><span class="line">当参数 radix 的值为 0，或没有设置该参数时，则数字将以 10 为基础来解析。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目13-1"><a href="#题目13-1" class="headerlink" title="题目13"></a>题目13</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Array.prototype为[]，因此Array.isArray(Array.prototype)为<span class="literal">true</span></span><br><span class="line">Array.isArray(a)是一个判断a是否为数组的方法。</span><br><span class="line">判断对象是否为数组的方法： </span><br><span class="line">1）ES5函数isArray()，该函数测试对象的内部[[Class]]属性是否为Array:</span><br><span class="line">Arrray.isArray(a);</span><br><span class="line">2）判断对象的构造函数是否为Array:</span><br><span class="line">a.constructor === Array</span><br><span class="line">3）使用对象内部[[Class]]属性创建结果字符串：</span><br><span class="line">Object.prototype.toString.call(a)</span><br><span class="line">4）使用instanceof操作符测试对象是否继承自Array： </span><br><span class="line">（但由于，一个页面的iframe不会继承自另外一个页面的iframe，该方法不可靠）</span><br><span class="line">a instanceof Array</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目14-1"><a href="#题目14-1" class="headerlink" title="题目14"></a>题目14</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">由于Boolean([0]) === <span class="literal">true</span></span><br><span class="line">因此进入<span class="keyword">if</span>为<span class="literal">true</span>的语句块中，</span><br><span class="line">由于a为数组(对象)，与布尔值进行相对等于比较，需要两边都转化为数值后在进行判断。</span><br><span class="line">左边[0]先转化为字符串<span class="string">"0"</span>，接着转化为数值0，而右边<span class="literal">true</span>转化为数值1。</span><br><span class="line">因此a == <span class="literal">true</span>最终返回为<span class="literal">false</span>。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目15-1"><a href="#题目15-1" class="headerlink" title="题目15"></a>题目15</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">数组在Javascript中是对象，对象使用 == 比较都是对引用（存放在栈内存的指针）的比较。</span><br><span class="line">简单的说，就是，如果是同一个对象，就相等，如果不是同一个对象，就不等。</span><br><span class="line">每次使用 [] 都是新建一个数组对象，所以 [] == [] 这个语句里建了两个数据对象，所以它们不等。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目16-1"><a href="#题目16-1" class="headerlink" title="题目16"></a>题目16</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">执行<span class="string">'5'</span> + 3，加号具备拼接字符串功能，会将3强制转换为字符串<span class="string">'3'</span>和<span class="string">'5'</span>拼接。 </span><br><span class="line">执行<span class="string">'5'</span> - 3，减号只具备数值运算的功能，因此会将<span class="string">'5'</span>转化为数值，进行5-3的数值运算</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目17-1"><a href="#题目17-1" class="headerlink" title="题目17"></a>题目17</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目18-1"><a href="#题目18-1" class="headerlink" title="题目18"></a>题目18</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">区分赋值和声明。</span><br><span class="line">虽然var arr = Array(3);创建一个长度为3的数组，</span><br><span class="line">但是实际只有一个元素被赋值，因此arr的实际长度为1，即最终参与map的只有一个元素，返回[<span class="string">"1"</span>]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目19-1"><a href="#题目19-1" class="headerlink" title="题目19"></a>题目19</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">按照执行步骤，无需多疑，最终结果为10+1+10=21</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目20-1"><a href="#题目20-1" class="headerlink" title="题目20"></a>题目20</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">js的精确整数最大为：Math.pow(2,53) - 1 = 9007199254740991. </span><br><span class="line">var a = 111111111111111110000, </span><br><span class="line">max = 9007199254740992; </span><br><span class="line">a的值大于JavaScript所能表示的最大整数精度，因此和任何数值相加将会导致失真。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目21-1"><a href="#题目21-1" class="headerlink" title="题目21"></a>题目21</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">正确调用方式为x.call(arr) =&gt; x.call([])</span><br><span class="line">Array.prototype为[]，[].reverse相当于Array.prototype.reverse，</span><br><span class="line">将它call(arr)之后，Array.prototype.reverse中的this就指向了arr对象了。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目22-1"><a href="#题目22-1" class="headerlink" title="题目22"></a>题目22</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Number.MIN_VALUE表示的最小值为5e-324，</span><br><span class="line">Number.MIN_VALUE代表的并不是负最小，而是最接近0的一个数，因此Number.MIN_VALUE&gt;0。 </span><br><span class="line">负最小值可以使用-Number.MAX_VALUE表示，为1.7976931348623157e+308。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目23-1"><a href="#题目23-1" class="headerlink" title="题目23"></a>题目23</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">1&lt;2，返回<span class="literal">true</span>，执行<span class="literal">true</span>&lt;3，会强制将<span class="literal">true</span>转换为1，1&lt;3，最终返回<span class="literal">true</span>。 </span><br><span class="line">3&lt;2，返回<span class="literal">false</span>，执行<span class="literal">false</span>&lt;1,会强制将<span class="literal">false</span>转换为0，0&lt;1，最终返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目24-1"><a href="#题目24-1" class="headerlink" title="题目24"></a>题目24</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">使用a==b判断a和b对象是否相等，可以会将b对象强制转换为a对象的类型，即执行2 == [[[2]]]，会隐式调用parseInt([[[2]]])将[[[2]]]强制转化为数字基本量，即2，2==2，最终返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目25-1"><a href="#题目25-1" class="headerlink" title="题目25"></a>题目25</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">Number中的toString(a)，能够将数值转化成为a进制的值。但a缺省时，默认转化为十进制。 </span><br><span class="line">一般使用方法为：var n = 3; (3).toString(); </span><br><span class="line">执行3.toString()，因为3只是为数值型变量，为非Number实例，因此对于3不能直接调用toString方法。</span><br><span class="line">而执行3..toString()，会强制将3转化为数字实例，因此能够被解释，输出3，同样可以使用(3).toString()达到一样的效果。</span><br><span class="line">3...toString()会报<span class="string">"Unexpected token ."</span>的错。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目26-1"><a href="#题目26-1" class="headerlink" title="题目26"></a>题目26</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">在立即调用函数内执行，var x1 = y1 =1; 创建局部变量x1和全局变量y1。</span><br><span class="line">函数外部试图访问函数内部的变量x1，将会导致错误。可以访问全局变量y1。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目27-1"><a href="#题目27-1" class="headerlink" title="题目27"></a>题目27</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">列举IE和FF脚本兼容性的问题 </span><br><span class="line">（1）window.event </span><br><span class="line">表示当前的事件对象，IE有这个对象，FF没有 </span><br><span class="line">（2）获取事件源 </span><br><span class="line">IE用srcElement获取事件源，而FF用target获取事件源 </span><br><span class="line">（3）添加、移除事件</span><br><span class="line">IE：</span><br><span class="line">element.attachEvent(<span class="string">"onclick"</span>,<span class="keyword">function</span>)</span><br><span class="line">element.detachEvent(<span class="string">"onclick"</span>,<span class="keyword">function</span>)</span><br><span class="line">FF:</span><br><span class="line">element.addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>,<span class="literal">true</span>)</span><br><span class="line">element.removeEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>,<span class="literal">true</span>)</span><br><span class="line">``` </span><br><span class="line"><span class="comment">##### 题目28</span></span><br><span class="line">+ 解析：</span><br><span class="line">``` bash</span><br><span class="line">解析：</span><br><span class="line">题目所给出的代码，除了有addEventListener不兼容IE浏览器的问题之外，最突出的一个问题是： </span><br><span class="line">虽然在页面上会显示五个按钮，但是点击任意一个按钮，最终都会显示5。</span><br><span class="line">要想点击相关按钮，弹出相应的1，2，3，4，5的值，需要理解闭包原理实现和使用立即回调函数。修改后的代码如下：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">initButtons</span></span>()&#123; </span><br><span class="line">    var body = document.body, button; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; 5; i++)&#123; </span><br><span class="line">        (<span class="keyword">function</span>(j)&#123; </span><br><span class="line">            button = document.createElement(<span class="string">"button"</span>); </span><br><span class="line">            button.innerHTML = <span class="string">"Button"</span> + j; </span><br><span class="line">            button.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(e)&#123; </span><br><span class="line">                alert(j); </span><br><span class="line">            &#125;, <span class="literal">false</span>); </span><br><span class="line">            body.appendChild(button); </span><br><span class="line">        &#125;)(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">initButtons();</span><br><span class="line">闭包存储的是外部变量的引用而非值。 </span><br><span class="line">立即调用的函数表达式，是一种不可或缺的解决javascript缺少块级作用域的方法。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目29-1"><a href="#题目29-1" class="headerlink" title="题目29"></a>题目29</h5><ul><li>解析：可使用常规方法和正则表达式匹配两种算法来求解。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toGetTheMostCharsByArray(s)&#123; </span><br><span class="line">    var r = &#123;&#125;; </span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; s.length; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!r[s[i]])&#123; </span><br><span class="line">            r[s[i]] = 1; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            r[s[i]]++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    var max = &#123; </span><br><span class="line">        <span class="string">"value"</span> : s[0], </span><br><span class="line">        <span class="string">"num"</span> : r[s[0]] </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var n <span class="keyword">in</span> r)&#123;//对象使用<span class="keyword">in</span>关键字，因为没有length </span><br><span class="line">        <span class="keyword">if</span>(r[n]&gt;max.num)&#123; </span><br><span class="line">            max.num = r[n]; </span><br><span class="line">            max.value = n;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">return</span> max; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> toGetTheMostCharsByRegex(s)&#123; </span><br><span class="line">    var a = s.split(<span class="string">''</span>); </span><br><span class="line">    a.sort(); </span><br><span class="line">    s = a.join(<span class="string">''</span>); </span><br><span class="line"></span><br><span class="line">    var regex = /(\w)\1+/g ;//\1代表重复的 </span><br><span class="line"></span><br><span class="line">    var max = &#123; </span><br><span class="line">        <span class="string">"value "</span>　:s[0], </span><br><span class="line">        <span class="string">"num"</span> :  0 </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    s.replace(regex, <span class="keyword">function</span>(a, b)&#123; </span><br><span class="line">        // a为重复的字符串</span><br><span class="line">        // b为重复字符</span><br><span class="line">        <span class="keyword">if</span>(max.num &lt; a.length)&#123; </span><br><span class="line">            max.num = a.length; </span><br><span class="line">            max.value= b; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="built_in">return</span> max; </span><br><span class="line">&#125; </span><br><span class="line">var <span class="built_in">test</span> = <span class="string">"efdfssssfrhth"</span>; </span><br><span class="line">console.info(<span class="string">"使用常规方法　，出现最多的字符串为："</span>+toGetTheMostCharsByArray(<span class="built_in">test</span>).value+<span class="string">" ，出现次数："</span>+toGetTheMostCharsByArray(<span class="built_in">test</span>).num); </span><br><span class="line">console.info(<span class="string">"使用字符串匹配，出现最多的字符串为："</span>+toGetTheMostCharsByRegex(<span class="built_in">test</span>).value+<span class="string">" ，出现次数："</span>+toGetTheMostCharsByRegex(<span class="built_in">test</span>).num);</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目30-1"><a href="#题目30-1" class="headerlink" title="题目30"></a>题目30</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript的引擎是单线程的，且是基于事件驱动的。</span><br><span class="line">setTimeout和setInterval都是往事件队列中增加一个待处理时间而已，setTimeout只触发一次，而setInterval是循环触发。</span><br><span class="line">代码一可使得setTimeout循环触发。但是，执行完这段代码块才挂起时间，所以两次执行时间会大于10毫秒。</span><br><span class="line">代码二是自动在10的时候挂上这个事件，所以两次事件的相隔会小于等于10毫秒。 </span><br><span class="line">当线程阻塞在一个事件的时候，不管是使用setInterval还是setTimeout都需要等待当前事件处理完才能执行。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文记录了30个&lt;code&gt;你“不可能全部会做”的JavaScript题目&lt;/code&gt;，并对各个答案进行分析。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="习题" scheme="https://chongtianhong.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的三种类型检测的比较</title>
    <link href="https://chongtianhong.github.io/2018/05/09/typeChecking/"/>
    <id>https://chongtianhong.github.io/2018/05/09/typeChecking/</id>
    <published>2018-05-09T09:37:13.000Z</published>
    <updated>2018-08-27T05:29:52.334Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在JavaScript中，可使用<code>typeof</code>、<code>instanceof</code>、<code>Object.prototype.toString</code>对变量类型进行检测，接下来将对它们进行比较。<a id="more"></a></li></ul><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><ul><li><code>typeof</code>是JavaScript的一个<strong>一元运算符</strong>，放在一个运算数之前，运算数可以是任意类型。</li><li><code>typeof</code>返回一个<strong>用来表示表达式的数据类型的字符串</strong>，返回结果为JavaScript中的<strong>基本数据类型</strong>，包括：<code>number</code>、<code>boolean</code>、<code>string</code>、<code>object</code>、<code>undefined</code>、<code>function</code>等6种数据类型。</li><li>也就是说，<code>typeof</code>只能返回这几种类型，而<strong>对于</strong>我们的<strong>自定义对象</strong>，它<strong>只会返回object</strong>，在实际应用中作用约等于零。</li><li>此外，<code>typeof</code>在不同浏览器中<strong>可能存在一些兼容性的问题</strong>，如将function类型认作是object等。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof <span class="string">''</span>);//string</span><br><span class="line">console.log(typeof []);//object</span><br><span class="line">console.log(typeof &#123;&#125;);//object</span><br><span class="line">console.log(typeof 1);//number</span><br><span class="line">console.log(typeof null);//object</span><br><span class="line">console.log(typeof undefined);//undefined</span><br><span class="line">console.log(typeof <span class="literal">true</span>);//boolean</span><br><span class="line">console.log(typeof <span class="function"><span class="title">function</span></span>()&#123;&#125;);//<span class="keyword">function</span></span><br><span class="line">console.log(typeof /\d/);//object</span><br></pre></td></tr></table></figure></li></ul><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul><li>在使用<code>typeof</code>运算符对<strong>引用类型变量</strong>进行类型判断时，会出现一个问题，无论引用的是什么类型的对象，它<strong>都返回 “object”</strong>。这就需要用到<code>instanceof</code>来<strong>检测某个对象是不是另一个对象的实例</strong>。</li><li><code>instanceof</code>主要的目的是用来检测<strong>引用类型</strong>，如判断Array、RegExp、日期对象等。</li><li><code>instanceof</code>操作符采用了<strong>原型链方式</strong>来判断对象类型。</li><li><p>如 a instanceof b只要能在a对象的原型链上找到b，则认为a是b类型的一个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=new Array();</span><br><span class="line">alert(a instanceof Array); // <span class="literal">true</span>，</span><br><span class="line">// 同时 </span><br><span class="line">alert(a instanceof Object) // 也会返回 <span class="literal">true</span>;</span><br><span class="line">// 因为 Array 是 object 的子类。</span><br></pre></td></tr></table></figure></li><li><p>再如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;&#125;;</span><br><span class="line">var a = new <span class="built_in">test</span>();</span><br><span class="line">alert(a instanceof <span class="built_in">test</span>) // 会返回<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>关于null的类型判断</blockquote><ul><li><strong>null是个特殊的Object类型的值</strong>，表示空引用的意思 。但<code>typeof null</code>返回<strong>“object”</strong>这个其实是最初JavaScript的实现的一个错误，然后被ECMAScript沿用了，成为了现在的标准，不过我们可以<strong>把null理解为尚未存在的对象的占位符</strong>。</li><li>注意：<code>null instanceof Object</code>会返回<strong>false</strong>。</li></ul><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h4><ul><li><code>Object.prototype.toString</code>是对象的一个原生原型扩展函数，用来<strong>精确的区分数据类型</strong>。</li><li>使用<code>Object.prototype.toString.call(value)</code>方法去调用对象，可得到对象的构造函数名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">type</span> = Object.prototype.toString;</span><br><span class="line">console.log(type.call(<span class="string">''</span>));//object String</span><br><span class="line">console.log(type.call([]));//object Array</span><br><span class="line">console.log(type.call(&#123;&#125;));//object Object</span><br><span class="line">console.log(type.call(<span class="literal">false</span>));//object Boolean</span><br><span class="line">console.log(type.call(null));//object Null</span><br><span class="line">console.log(type.call(undefined));//object Undefined</span><br><span class="line">console.log(type.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;));//object Function</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在JavaScript中，可使用&lt;code&gt;typeof&lt;/code&gt;、&lt;code&gt;instanceof&lt;/code&gt;、&lt;code&gt;Object.prototype.toString&lt;/code&gt;对变量类型进行检测，接下来将对它们进行比较。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="类型检测" scheme="https://chongtianhong.github.io/tags/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议入门</title>
    <link href="https://chongtianhong.github.io/2018/05/08/httpProtocol/"/>
    <id>https://chongtianhong.github.io/2018/05/08/httpProtocol/</id>
    <published>2018-05-08T05:42:51.000Z</published>
    <updated>2018-08-17T15:02:23.890Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>HTTP 协议是互联网的基础协议</strong>，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。 </li><li>本文介绍 HTTP 协议的历史演变和设计思路。<a id="more"></a><img src="/images/httpProtocol.jpg" alt="http图示" width="600" style="border:none"></li></ul><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h4><ul><li>HTTP 是<strong>基于 TCP/IP 协议</strong>的<strong>应用层协议</strong>。它<strong>不涉及数据包（packet）传输</strong>，主要规定了客户端和服务器之间的通信格式，<strong>默认使用80端口</strong>。 </li><li><p>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure></li><li><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p></li><li><p>协议规定，服务器<strong>只能回应HTML格式的字符串</strong>，不能回应别的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务器发送完毕，就关闭TCP连接。</p></li></ul><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul><li>1996年5月，HTTP/1.0 版本发布，内容大大增加。</li><li>首先，<strong>任何格式的内容都可以发送</strong>。这使得互联网不仅可以<strong>传输文字</strong>，还能<strong>传输图像、视频、二进制文件</strong>。这为互联网的大发展奠定了基础。</li><li>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</li><li>再次，<strong>HTTP请求和回应的格式</strong>也变了。除了数据部分，<strong>每次通信都必须包括头信息（HTTP header）</strong>，用来描述一些元数据。</li><li>其他的新增功能还包括<strong>状态码（status code）</strong>、<strong>多字符集支持</strong>、<strong>多部分发送（multi-part type）</strong>、<strong>权限（authorization）</strong>、<strong>缓存（cache）</strong>、<strong>内容编码（content encoding）</strong>等。</li></ul><h5 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h5><ul><li><p>下面是一个1.0版的HTTP请求的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></li><li><p>可以看到，这个格式与0.9版有很大变化。</p></li><li>第一行是请求命令，<strong>必须在尾部添加协议版本（HTTP/1.0）</strong>。后面就是多行<strong>头信息</strong>，<strong>描述客户端的情况</strong>。</li></ul><h5 id="回应格式"><a href="#回应格式" class="headerlink" title="回应格式"></a>回应格式</h5><ul><li><p>服务器的回应如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>回应的格式是<strong>“头信息 + 一个空行（<code>\r\n</code>） + 数据”</strong>。</p></li><li>其中，第一行是<strong>状态行</strong>，包含<strong>“协议版本 + 状态码（status code） + 状态描述”</strong>。</li></ul><h5 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h5><ul><li>关于字符的编码，1.0版规定，<strong>头信息必须是 ASCII 码</strong>，后面的<strong>数据可以是任何格式</strong>。</li><li>因此，<strong>服务器回应的时候，必须告诉客户端，数据是什么格式</strong>，这就是<strong>Content-Type字段的作用</strong>。</li><li><p>下面是一些常见的<code>Content-Type</code>字段的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">text/plain</span><br><span class="line">text/html</span><br><span class="line">text/css</span><br><span class="line">image/jpeg</span><br><span class="line">image/png</span><br><span class="line">image/svg+xml</span><br><span class="line">audio/mp4</span><br><span class="line">video/mp4</span><br><span class="line">application/javascript</span><br><span class="line">application/pdf</span><br><span class="line">application/zip</span><br><span class="line">application/atom+xml</span><br></pre></td></tr></table></figure></li><li><p>这些数据类型总称为<code>MIME type</code>，每个值包括<strong>一级类型</strong>和<strong>二级类型</strong>，<strong>之间用斜杠分隔</strong>。</p></li><li><p>除了预定义的类型，厂商也可以自定义类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure></li><li><p>上面的类型表明，发送的是Debian系统的二进制数据包。</p></li><li><p><code>MIME type</code>还可以在尾部使用分号，添加参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></li><li><p>上面的类型表明，<strong>发送的是网页</strong>，而且<strong>编码方式是UTF-8</strong>。</p></li><li><p><strong>客户端请求</strong>的时候，可以使用<code>Accept</code>字段<strong>声明自己可以接受哪些数据格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p></li><li><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h5><ul><li><p>由于<strong>服务端发送的数据可以是任何格式</strong>，因此<strong>可以把数据压缩后再发送</strong>。<code>Content-Encoding</code>字段<strong>说明数据的压缩方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端在请求时</strong>，用<code>Accept-Encoding</code>字段<strong>说明自己可以接受哪些压缩方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>HTTP/1.0 版的<strong>主要缺</strong>点是，<strong>每个TCP连接只能发送一个请求</strong>。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</li><li><strong>TCP连接的新建成本很高</strong>，因为需要客户端和服务器<strong>三次握手</strong>，并且<strong>开始时发送速率较慢（slow start）</strong>。所以，<strong>HTTP 1.0版本的性能比较差</strong>。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</li><li><p>为了解决这个问题，有些<strong>浏览器在请求时</strong>，用了一个非标准的<code>Connection</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></li><li><p>这个字段<strong>要求服务器不要关闭TCP连接</strong>，以便其他请求复用。<strong>服务器同样回应这个字段</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></li><li><p>一个<strong>可以复用的TCP连接</strong>就建立了，<strong>直到客户端或服务器主动关闭连接</strong>。但是，这<strong>不是标准字段，不同实现的行为可能不一致</strong>，因此<strong>不是根本的解决办法</strong>。</p></li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><ul><li>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</li></ul><h5 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h5><ul><li>1.1 版的<strong>最大变化</strong>，就是<strong>引入了持久连接（persistent connection）</strong>，即<strong>TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code></strong>。</li><li><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，<strong>规范的做法</strong>是，<strong>客户端</strong>在<strong>最后一个请求</strong>时，<strong>发送<code>Connection: close</code></strong>，明确要求服务器关闭TCP连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure></li><li><p>目前，对于<strong>同一个域名</strong>，大多数浏览器<strong>允许同时建立6个持久连接</strong>。</p></li></ul><h5 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h5><ul><li>1.1 版还引入了<strong>管道机制（pipelining）</strong>，即<strong>在同一个TCP连接里面，客户端可以同时发送多个请求</strong>。这样就进一步<strong>改进了HTTP协议的效率</strong>。</li><li>举例来说，客户端需要请求两个资源：<ul><li>以前的做法是，在<strong>同一个TCP连接里面</strong>，<strong>先发送A请求，然后等待服务器做出回应，收到后再发出B请求</strong>。</li><li><strong>管道机制</strong>则是<strong>允许浏览器同时发出A请求和B请求</strong>，但是<strong>服务器还是按照顺序，先回应A请求，完成后再回应B请求</strong>。</li></ul></li></ul><h5 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h5><ul><li><p><strong>一个TCP连接现在可以传送多个回应</strong>，势必就要有一种<strong>机制</strong>，<strong>区分数据包是属于哪一个回应的</strong>。这就是<code>Content-length</code>字段的作用，<strong>声明本次回应的数据长度</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 3495</span><br></pre></td></tr></table></figure></li><li><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p></li><li><strong>在1.0版中</strong>，<code>Content-length</code>字段<strong>不是必需</strong>的，因为<strong>浏览器发现服务器关闭了TCP连接</strong>，就<strong>表明收到的数据包已经全了</strong>。</li></ul><h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><ul><li>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</li><li><p>另外，<strong>客户端请求的头信息新增了Host字段</strong>，用来<strong>指定服务器的域名</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure></li><li><p>有了<code>Host字段</code>，就可以<strong>将请求发往同一台服务器上的不同网站</strong>，为虚拟主机的兴起打下了基础。</p></li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>虽然<strong>1.1版允许复用TCP连接</strong>，但是<strong>同一个TCP连接里面，所有的数据通信是按次序进行的</strong>。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<strong>“队头堵塞”（Head-of-line blocking）</strong>。</li><li>为了避免这个问题，只有两种方法：<ul><li>一是减少请求数</li><li>二是同时多开持久连接</li></ul></li><li>这导致了很多的<strong>网页优化技巧</strong>，比如<strong>合并脚本和样式表</strong>、<strong>将图片嵌入CSS代码</strong>、<strong>域名分片（domain sharding）</strong>等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</li></ul><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><ul><li>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</li></ul><h5 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h5><ul><li>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。</li><li><strong>HTTP/2</strong>则是一个彻底的<strong>二进制协议</strong>，<strong>头信息和数据体都是二进制</strong>，并且统称为”帧”（frame）：<strong>头信息帧</strong>和<strong>数据帧</strong>。</li><li><strong>二进制协议</strong>的一个<strong>好处</strong>是，<strong>可以定义额外的帧</strong>。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</li></ul><h5 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h5><ul><li>HTTP/2 复用TCP连接，在一个连接里，<strong>客户端和浏览器</strong>都可以<strong>同时发送多个请求或回应</strong>，而且<strong>不用按照顺序一一对应</strong>，这样就<strong>避免了”队头堵塞”</strong>。</li><li>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</li><li>这样<strong>双向的、实时</strong>的通信，就叫做<strong>多工（Multiplexing）</strong>。</li></ul><h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><ul><li>因为 <strong>HTTP/2 的数据包是不按顺序发送的</strong>，<strong>同一个连接</strong>里面<strong>连续的数据包，可能属于不同的回应</strong>。因此，必<strong>须要对数据包做标记</strong>，指出它属于哪个回应。</li><li>HTTP/2 将<strong>每个</strong>请求或回应的<strong>所有数据包</strong>，称为一个<strong>数据流（stream）</strong>。<ul><li><strong>每个数据流(同个请求或回应的数据包)都有一个独一无二的编号</strong>。</li><li><strong>数据包发送的时候，都必须标记数据流ID</strong>，用来区分它属于哪个数据流。</li><li>另外还规定，<strong>客户端发出的数据流</strong>，<strong>ID</strong>一律为<strong>奇数</strong>，<strong>服务器发出的ID</strong>为<strong>偶数</strong>。</li></ul></li><li><strong>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流</strong>。<ul><li><strong>1.1版取消数据流</strong>的<strong>唯一方法</strong>，就是<strong>关闭TCP连接</strong>。</li><li>这就是说，<strong>HTTP/2 可以取消某一次请求</strong>，同时<strong>保证TCP连接还打开着</strong>，<strong>可以被其他请求使用</strong>。</li></ul></li><li><strong>客户端</strong>还可以<strong>指定数据流的优先级</strong>。<strong>优先级越高</strong>，<strong>服务器</strong>就会<strong>越早回应</strong>。</li></ul><h5 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h5><ul><li>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</li><li>HTTP/2 对这一点做了优化，引入了<strong>头信息压缩机制（header compression）</strong>。<ul><li>一方面，<strong>头信息</strong>使用<code>gzip</code>或<code>compress</code><strong>压缩后再发送</strong>；</li><li>另一方面，<strong>客户端和服务器同时维护一张头信息表</strong>，<strong>所有字段都会存入这个表，生成一个索引号</strong>，以后就不发送同样字段了，<strong>只发送索引号</strong>，这样就<strong>提高速度</strong>了。</li></ul></li></ul><h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><ul><li>HTTP/2 <strong>允许服务器未经请求，主动向客户端发送资源</strong>，这叫做<strong>服务器推送（server push）</strong>。</li><li>常见场景是<strong>客户端请求一个网页，这个网页里面包含很多静态资源</strong>。<ul><li>正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。</li><li>其实，<strong>服务器</strong>可以预期到客户端请求网页后，很可能会再请求静态资源，所以就<strong>主动把这些静态资源随着网页一起发给客户端</strong>了。</li></ul></li></ul><div class="note info">声明：本文转载自 <a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></div>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP 协议是互联网的基础协议&lt;/strong&gt;，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。 &lt;/li&gt;
&lt;li&gt;本文介绍 HTTP 协议的历史演变和设计思路。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="HTTP" scheme="https://chongtianhong.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JS中parseInt()和map()用法分析</title>
    <link href="https://chongtianhong.github.io/2018/05/07/paseIntAndMap/"/>
    <id>https://chongtianhong.github.io/2018/05/07/paseIntAndMap/</id>
    <published>2018-05-07T08:10:35.000Z</published>
    <updated>2018-08-14T13:20:31.772Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文对<code>[“1”, “2”, “3”].map(parseInt)</code>得到的结果答案是<code>[1, NaN, NaN]</code>的原因进行具体分析。<a id="more"></a></li></ul><blockquote>parseInt(string, radix)</blockquote><ul><li><code>parseInt(string, radix)<code>用来<strong>解析字符串</strong>，返回<strong>整数</strong>。<ul><li><strong>参数<code>string</code></strong><code>必需。要被解析的字符串。</code></li><li><strong>参数<code>radix</code></strong><code>可选，<strong>其值必须介于2~36之间</strong>；如果<strong>省略该参数</strong>或<strong>其值为 0</strong>，则<strong>数字将以 10 为基础来解析</strong>。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。<strong>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN</strong>。</code></li></ul></code></code></li></ul><blockquote>parseInt(string, radix)</blockquote><ul><li><code>map()<code>是<strong>对数组的每一个元素调用回调函数</strong>并<strong>返回一个包含结果的数组</strong>。</code></code></li><li><code>map()<code>的callback回调<strong>最多可传递3个参数</strong>，分别为<strong>数组中当前被传递的元素</strong>item、<strong>数组中当前被传递的元素的索引</strong>index、<strong>调用 map 方法的数组</strong>array。</code></code></li></ul><blockquote>例子分析</blockquote><ul><li>前面提到，<code>parseInt(string, radix)<code>接收的是两个参数，<code>map()<code>回调传递的是3个参数。</code></code></code></code></li><li><p>因此，<code>[“1”, “2”, “3”].map(parseInt)</code>等于<code>[parseInt(1,0),parseInt(2,1),parseInt(3,2)]</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)</span><br><span class="line">// 等同于</span><br><span class="line"><span class="keyword">function</span> testFuc(item, index)&#123;</span><br><span class="line">    <span class="built_in">return</span> parseInt(item, index);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(testFuc)</span><br><span class="line"></span><br><span class="line">parseInt(1,0) // radix为0，数字将以 10 为基础来解，1转化为十进制后结果为1</span><br><span class="line">parseInt(2,1) // radix小于2，返回NaN</span><br><span class="line">parseInt(3,2) // radix为2, 无法将3用二进制解析，结果为NaN</span><br></pre></td></tr></table></figure></li><li><p>再看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>,<span class="string">"5"</span>,6,7,8,9,10,11,12,13,14,15];</span><br><span class="line">a.map(parseInt);</span><br><span class="line">// 返回结果为：[1,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,9,11,13,15,17,19]</span><br></pre></td></tr></table></figure></li><li><p>由于<code>map()<code>的回调函数的参数index索引值作了<code>parseInt(string, radix)<code>的基数radix，导致出现<strong>超范围的radix赋值</strong>和<strong>不合法的进制解析</strong>，才会返回NaN。</code></code></code></code></p></li><li><p>重新定义parseInt函数，再来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> parseInt(str, radix) &#123; </span><br><span class="line">    <span class="built_in">return</span> str+<span class="string">'-'</span>+radix; </span><br><span class="line">&#125;;</span><br><span class="line">var a=[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>,<span class="string">"5"</span>,6,7,8,9,10,11,12,13,14,15];</span><br><span class="line">a.map(parseInt);</span><br><span class="line">// 输出结果为：[<span class="string">"1-0"</span>,<span class="string">"2-1"</span>,<span class="string">"3-2"</span>,<span class="string">"4-3"</span>,<span class="string">"5-4"</span>,<span class="string">"6-5"</span>,<span class="string">"7-6"</span>,<span class="string">"8-7"</span>,<span class="string">"9-8"</span>,<span class="string">"10-9"</span>,<span class="string">"11-10"</span>,<span class="string">"12-11"</span>,<span class="string">"13-12"</span>,<span class="string">"14-13"</span>,<span class="string">"15-14"</span>]</span><br></pre></td></tr></table></figure></li><li><p>因此，如果要得到正确的整数数组，正确的代码应该为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>];</span><br><span class="line">arr.map((item)=&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> parseInt(item);</span><br><span class="line">&#125;)</span><br><span class="line">// 结果为[1, 2, 3]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文对&lt;code&gt;[“1”, “2”, “3”].map(parseInt)&lt;/code&gt;得到的结果答案是&lt;code&gt;[1, NaN, NaN]&lt;/code&gt;的原因进行具体分析。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="高阶函数" scheme="https://chongtianhong.github.io/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
      <category term="parseInt" scheme="https://chongtianhong.github.io/tags/parseInt/"/>
    
      <category term="map" scheme="https://chongtianhong.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>高阶函数：map/reduce/filter/sort</title>
    <link href="https://chongtianhong.github.io/2018/05/06/highOrderFunction/"/>
    <id>https://chongtianhong.github.io/2018/05/06/highOrderFunction/</id>
    <published>2018-05-06T15:18:40.000Z</published>
    <updated>2018-08-15T13:36:28.850Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>JavaScript的<strong>函数</strong>其实都<strong>指向某个变量</strong>。既然<strong>变量可以指向函数</strong>，<strong>函数的参数能接收变量</strong>，那么<strong>一个函数就可以接收另一个函数作为参数</strong>，这种函数就称之为<strong>高阶函数(Higher-order function)</strong>。<a id="more"></a></li><li><p>一个最简单的<strong>高阶函数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(x, y, f) &#123;</span><br><span class="line">    <span class="built_in">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(-5, 6, Math.abs); // 11</span><br></pre></td></tr></table></figure></li><li><p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数x，y和f分别接收-5，6和函数Math.abs，根据函数定义，我们可以推导计算过程为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = -5;</span><br><span class="line">y = 6;</span><br><span class="line">f = Math.abs;</span><br><span class="line">f(x) + f(y) ==&gt; Math.abs(-5) + Math.abs(6) ==&gt; 11;</span><br><span class="line"><span class="built_in">return</span> 11;</span><br></pre></td></tr></table></figure></li><li><p>编写高阶函数，就是<strong>让函数的参数能够接收别的函数</strong>。</p></li></ul><h4 id="高阶函数介绍"><a href="#高阶函数介绍" class="headerlink" title="高阶函数介绍"></a>高阶函数介绍</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><ul><li><p>由于<code>map()</code>方法定义在JavaScript的Array中，我们<strong>调用Array的map()方法</strong>，<strong>参数传入自定义函数</strong>，就<strong>得到了一个新的Array</strong>作为结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> pow(x) &#123;</span><br><span class="line">    <span class="built_in">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure></li><li><p><code>map()</code>传入的参数是<code>pow</code>，即函数对象本身。</p></li><li><p><code>map()</code>作为高阶函数，事实上它<strong>把运算规则抽象</strong>了，因此，我们还可以计算任意复杂的函数，比如，<strong>把Array的所有数字转为字符串</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">arr.map(String); // [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br></pre></td></tr></table></figure></li><li><p>把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。</p><ul><li>输入：[‘adam’, ‘LISA’, ‘barT’]</li><li>输出：[‘Adam’, ‘Lisa’, ‘Bart’]</li></ul></li><li><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> normalize(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.map(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">        //x[0]等效于x.substring(0,1)</span><br><span class="line">        <span class="built_in">return</span> x[0].toUpperCase() + x.substring(1).toLowerCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line"><span class="keyword">if</span> (normalize([<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]).toString() === [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>].toString()) &#123;</span><br><span class="line">    alert(<span class="string">'测试通过!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'测试失败!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>小明希望利用<code>map()</code>把字符串变成整数，他写的代码很简洁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">var arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">var r;</span><br><span class="line">r = arr.map(parseInt);</span><br><span class="line">alert(<span class="string">'['</span> + r[0] + <span class="string">', '</span> + r[1] + <span class="string">', '</span> + r[2] + <span class="string">']'</span>);</span><br></pre></td></tr></table></figure></li><li><p>结果竟然是<code>[1, NaN, NaN]</code>，小明百思不得其解，请帮他找到原因并修正代码。</p></li><li>我们先看下<code>map()</code>的语法：<code>array1.map(callbackfn[, thisArg])</code></li><li>callbackfn参数是一个回调函数，最多接受三个值：<strong>value</strong>(数组元素的值)，<strong>index</strong>(数组元素的数字索引)，<strong>array1</strong>(数组对象本身)。</li><li>所以<strong>map在作用parseInt函数时</strong>，其实<strong>传入了元素的值</strong>，<strong>以及所对应的索引</strong>。这样就得到了这样的结果。</li><li>因此，我们只需要元素的值，不需要索引，修改代码为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">var arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>];</span><br><span class="line">var r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> returnInt(element)&#123; </span><br><span class="line">    <span class="built_in">return</span> parseInt(element);</span><br><span class="line">&#125;</span><br><span class="line">r = arr.map(returnInt);</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'['</span> + r[0] + <span class="string">', '</span> + r[1] + <span class="string">', '</span> + r[2] + <span class="string">']'</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><ul><li><p>Array的<code>reduce()</code>把一个函数作用在这个Array的[x1, x2, x3…]上，这个<strong>函数必须接收两个参数</strong>，<code>reduce()</code><strong>把结果</strong>继续<strong>和序列的下一个元素做累积计算</strong>，其效果就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure></li><li><p>比方说对一个Array求和，就可以用reduce实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x + y;</span><br><span class="line">&#125;); // 25</span><br></pre></td></tr></table></figure></li><li><p>已知<code>pow()</code>方法可返回x的y次幂的值。看下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[3, 2, 1].reduce(Math.pow)</span><br><span class="line">// 可以看成</span><br><span class="line"><span class="keyword">function</span> testFunc(x, y)&#123;</span><br><span class="line">    console.info(x + <span class="string">"："</span> + y);</span><br><span class="line">    <span class="built_in">return</span> Math.pow(x, y);</span><br><span class="line">&#125;</span><br><span class="line">// 执行Math.pow(3, 2)和Math.pow(9, 1)，最终返回9和9</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：空数组不能使用<code>reduce()</code>方法，否则会报错。</p></li><li><p>利用<code>reduce()</code>求积：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> product(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.reduce(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">        <span class="built_in">return</span> x * y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line"><span class="keyword">if</span> (product([1, 2, 3, 4]) === 24 &amp;&amp; product([0, 1, 2]) === 0 &amp;&amp; product([99, 88, 77, 66]) === 44274384) &#123;</span><br><span class="line">    alert(<span class="string">'测试通过!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">'测试失败!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要把[1, 3, 5, 7, 9]变换成整数13579，<code>reduce()</code>也能派上用场：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x * 10 + y;</span><br><span class="line">&#125;); // 13579</span><br></pre></td></tr></table></figure></li><li><p>如果我们继续改进这个例子，想办法把一个字符串13579先变成Array——[1, 3, 5, 7, 9]，再利用<code>reduce()</code>就可以写出一个<strong>把字符串转换为Number</strong>的函数。</p></li><li>不要使用JavaScript内置的<code>parseInt()</code>函数，<strong>利用map和reduce操作实现</strong>一个string2int()函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> string2int(s) &#123;</span><br><span class="line">    <span class="built_in">return</span> s.split(<span class="string">''</span>).map(<span class="keyword">function</span>(x)&#123;</span><br><span class="line">        <span class="built_in">return</span> x - 0;</span><br><span class="line">    &#125;).reduce(<span class="keyword">function</span> (x,y)&#123;</span><br><span class="line">        <span class="built_in">return</span> x * 10 + y;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><ul><li><code>filter()</code>也是一个常用的操作，它用于<strong>把Array的某些元素过滤掉</strong>，然后<strong>返回剩下的元素</strong>。</li><li>和<code>map()</code>类似，Array的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后<strong>根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素</strong>。</li><li><p>例如，在一个Array中，<strong>删掉偶数，只保留奇数</strong>，可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 4, 5, 6, 9, 10, 15];</span><br><span class="line">var r = arr.filter(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">    <span class="built_in">return</span> x % 2 !== 0;</span><br><span class="line">&#125;);</span><br><span class="line">r; // [1, 5, 9, 15]</span><br></pre></td></tr></table></figure></li><li><p>把一个Array中的<strong>空(无效)字符串删掉</strong>，可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, null, undefined, <span class="string">'C'</span>, <span class="string">'  '</span>];</span><br><span class="line">var r = arr.filter(<span class="keyword">function</span> (s) &#123;</span><br><span class="line">    <span class="built_in">return</span> s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法</span><br><span class="line">&#125;);</span><br><span class="line">r; // [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>filter()</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p></li></ul><blockquote>回调函数</blockquote><ul><li><p><code>filter()</code>接收的回调函数，其实<strong>可以有多个参数</strong>。通常我们仅使用第一个参数，表示<strong>Array的某个元素</strong>。回调函数还可以接收另外两个参数，表示<strong>元素的位置</strong>和<strong>数组本身</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">var r = arr.filter(<span class="keyword">function</span> (element, index, self) &#123;</span><br><span class="line">    console.log(element); // 依次打印<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span></span><br><span class="line">    console.log(index); // 依次打印0, 1, 2</span><br><span class="line">    console.log(self); // self就是变量arr</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>利用filter，可以巧妙地<strong>去除Array的重复元素</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">var r;</span><br><span class="line">var arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line"></span><br><span class="line">r = arr.filter(<span class="keyword">function</span> (element, index, self) &#123;</span><br><span class="line">    <span class="built_in">return</span> self.indexOf(element) === index;//判断元素是不是第一次出现</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(r.toString());</span><br></pre></td></tr></table></figure></li><li><p><strong>去除重复元素</strong>依靠的是<strong>indexOf总是返回第一个元素的位置</strong>，<strong>后续的重复元素位置与indexOf返回的位置不相等</strong>，因此被filter滤掉了。</p></li></ul><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><ul><li>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是<strong>比较两个元素的大小</strong>。</li><li>如果是数字，我们可以直接比较。但如果是<strong>字符串</strong>或者两个<strong>对象</strong>，<strong>直接比较数学上的大小是没有意义的</strong>，因此，<strong>比较的过程必须通过函数抽象出来</strong>。</li><li>通常规定，对于两个元素x和y，如果认为<code>x &lt; y</code>，则返回<code>-1</code>，如果认为<code>x == y</code>，则返回<code>0</code>，如果认为<code>x &gt; y</code>，则返回<code>1</code>，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</li><li><p>JavaScript的Array的<code>sort()</code>方法就是用于排序的，先看下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 看上去正常的结果:</span><br><span class="line">[<span class="string">'Google'</span>, <span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>].sort(); // [<span class="string">'Apple'</span>, <span class="string">'Google'</span>, <span class="string">'Microsoft'</span>];</span><br><span class="line"></span><br><span class="line">// apple排在了最后:</span><br><span class="line">[<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>].sort(); // [<span class="string">'Google'</span>, <span class="string">'Microsoft", '</span>apple<span class="string">']</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 出乎意料的结果:</span></span><br><span class="line"><span class="string">[10, 20, 1, 2].sort(); // [1, 10, 2, 20]</span></span><br></pre></td></tr></table></figure></li><li><p>第二个排序把apple排在了最后，是因为<strong>字符串根据ASCII码进行排序</strong>，而<strong>小写字母a的ASCII码在大写字母之后</strong>。</p></li><li>第三个排序结果是因为<strong>Array的<code>sort()</code>方法默认把所有元素先转换为String再排序</strong>，结果’10’排在了’2’的前面，因为<strong>字符’1’比字符’2’的ASCII码小</strong>。</li><li><code>sort()</code>方法也是一个高阶函数，它还<strong>可以接收一个比较函数</strong>来<strong>实现自定义的排序</strong>。</li><li><p>要按数字<strong>从小到大排序</strong>，我们可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x - y; </span><br><span class="line">&#125;);</span><br><span class="line">// 等价于</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123; // 不交换</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123; // 交换</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; // 不交换</span><br><span class="line">&#125;); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure></li><li><p>如果要<strong>倒序排序</strong>，我们可以把大的数放前面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="built_in">return</span> y - x; </span><br><span class="line">&#125;);</span><br><span class="line">// 等价于</span><br><span class="line">arr.sort(<span class="keyword">function</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="built_in">return</span> 1; // 交换</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="built_in">return</span> -1; // 不交换</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0; // 不交换</span><br><span class="line">&#125;); // [20, 10, 2, 1]</span><br></pre></td></tr></table></figure></li><li><p><strong>默认情况下，对字符串排序，是按照ASCII的大小比较的</strong>，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>];</span><br><span class="line">arr.sort(<span class="keyword">function</span> (s1, s2) &#123;</span><br><span class="line">    x1 = s1.toUpperCase(); //转大写 toLowerCase() 转小写</span><br><span class="line">    x2 = s2.toUpperCase();</span><br><span class="line">    <span class="keyword">if</span> (x1 &lt; x2) &#123;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2) &#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;); // [<span class="string">'apple'</span>, <span class="string">'Google'</span>, <span class="string">'Microsoft'</span>]</span><br></pre></td></tr></table></figure></li><li><p>忽略大小写来比较两个字符串，实际上就是<strong>先把字符串都变成大写（或者都变成小写），再比较</strong>。</p></li><li>从上述例子可以看出，<strong>高阶函数的抽象能力</strong>是<strong>非常强大</strong>的，而且，<strong>核心代码可以保持得非常简洁</strong>。</li><li><strong>特别的是</strong>：与前面提到的高阶函数不同，<strong><code>sort()</code>方法会直接对Array进行修改</strong>，它返回的结果仍是当前Array：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a1 = [<span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>];</span><br><span class="line">var a2 = a1.sort();//直接对a1进行修改了</span><br><span class="line">a1; // [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">a2; // [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">a1 === a2; // <span class="literal">true</span>, a1和a2是同一对象</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JavaScript的&lt;strong&gt;函数&lt;/strong&gt;其实都&lt;strong&gt;指向某个变量&lt;/strong&gt;。既然&lt;strong&gt;变量可以指向函数&lt;/strong&gt;，&lt;strong&gt;函数的参数能接收变量&lt;/strong&gt;，那么&lt;strong&gt;一个函数就可以接收另一个函数作为参数&lt;/strong&gt;，这种函数就称之为&lt;strong&gt;高阶函数(Higher-order function)&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="高阶函数" scheme="https://chongtianhong.github.io/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
