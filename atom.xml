<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-09-28T13:49:40.082Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DOM插入操作优化：DocumentFragment</title>
    <link href="https://chongtianhong.github.io/2018/09/28/documentFragment/"/>
    <id>https://chongtianhong.github.io/2018/09/28/documentFragment/</id>
    <published>2018-09-28T02:58:35.000Z</published>
    <updated>2018-09-28T13:49:40.082Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>在进行<strong>DOM操作</strong>中，我们经常使用<strong>新建元素</strong>然后<strong>将其插入到文档中</strong>的操作。</li><li><p>若是非常小（对页面的改动很小）的插入操作或许在性能上没有什么，但是<strong>若需要很多的插入操作和改动</strong>，继续使用类似于下面的代码则会很有问题。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(<span class="string">"ul"</span>);</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    var li = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于<strong>每一次对文档的插入都会引起重新渲染</strong>（计算元素的尺寸，显示背景，内容等），所以<strong>进行多次插入操作使得浏览器发生了很多次渲染，效率是比较低的</strong>。这是我们提倡<strong>通过减少页面的渲染来提高DOM操作的效率</strong>的原因。</p></li><li>一个优化的方法是<strong>将要创建的元素写到一个字符串上</strong>，然后<strong>一次性写到innerHTML上</strong>，这种利用浏览器对innerHTML的解析确实是相比上面的多次插入快了很多。但是<strong>构造字符串灵活性上面比较差，很难符合创建各种各样的DOM元素的需求</strong>。</li><li>利用<code>DocumentFragment</code>，可以弥补这两个方法的不足。</li><li><code>DocumentFragment</code>是<strong>没有父节点</strong>的<strong>最小的文档对象</strong>，用于存储HTML和XML片段。<code>DocumentFragment</code>对象继承Node，所以它<strong>有Node的所有属性方法</strong>，完全可以操作Node(NodeList)那样操作<code>DocumentFragment</code>。此外<strong>W3C对<code>DocumentFragment</code>也定义了一些另外的属性和方法</strong>，但是由于多数浏览器都没有实现，<strong>从兼容性上来说不推荐使用这些属性</strong>。具体有哪些属性方法可以参考MDN说明。</li><li>创建<code>DocumentFragment</code>的方法有两种，<code>document.createDocumentFragment()</code>和<code>new Fragment()</code>。对于<code>document.createDocumentFragment()</code>，所有浏览器都支持（包括IE6），而构造函数方法就不是所有浏览器都有效了（IE没有实现该方法）。所以<strong>从兼容性上来说推荐使用<code>document.createDocumentFragment()</code></strong>。</li><li>上面也提到，使用<code>DocumentFragment</code>与一般的Node无异，可以当作是DOM对象一样操作。在使用<code>appendChild</code>，<code>insertBefore</code>等方法时，<strong>被添加（插入）的是片段的所有子节点</strong>，而非本身。</li><li><p>因为<strong>文档片段存在于内存中</strong>，并不在DOM中，所以<strong>将子元素插入到文档片段中时不会引起页面回流</strong>（对元素位置和几何上的计算），因此使用<code>DocumentFragment</code>可以起到<strong>性能优化</strong>的作用。例如上面的代码就可以改成下面的片段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    var li = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>由于<code>DocumentFragment</code>的优势，很多JavaScript库都是用它来创建HTML的，包括jQuery。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>DocumentFragment</code>节点不属于文档树，继承的<code>parentNode</code>属性总是 <code>null</code>。</li><li><code>DocumentFragment</code>节点有一种特殊的行为，该行为使得它非常有用，即<strong>当请求把一个<code>DocumentFragment</code>节点插入文档树时，插入的不是<code>DocumentFragment</code>自身，而是它的所有子孙节点</strong>。这使得<code>DocumentFragment</code>成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。</li><li>重点就在于<strong><code>DocumentFragment</code>节点不属于文档树</strong>。因此<strong>当把创建的节点添加到该对象时，并不会导致页面的回流</strong>，因此性能就自然上去了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在进行&lt;strong&gt;DOM操作&lt;/strong&gt;中，我们经常使用&lt;strong&gt;新建元素&lt;/strong&gt;然后&lt;strong&gt;将其插入到文档中&lt;/strong&gt;的操作。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若是非常小（对页面的改动很小）的插入操作或许在性能上没有什么，但是&lt;strong&gt;若需要很多的插入操作和改动&lt;/strong&gt;，继续使用类似于下面的代码则会很有问题。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="DOM" scheme="https://chongtianhong.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>jQuery ajax()使用serialize()提交form数据</title>
    <link href="https://chongtianhong.github.io/2018/09/28/serializeOfJQuery/"/>
    <id>https://chongtianhong.github.io/2018/09/28/serializeOfJQuery/</id>
    <published>2018-09-28T02:06:17.000Z</published>
    <updated>2018-09-28T13:49:40.019Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>jQuery的<code>serialize()</code>方法通过<strong>序列化表单值</strong>，<strong>创建URL编码文本字符串</strong>，我们就可以选择一个或多个表单元素，也可以直接选择form将其序列化，如：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">""</span>&gt;</span><br><span class="line">First name: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"FirstName"</span> value=<span class="string">"Bill"</span> /&gt;&lt;br /&gt;</span><br><span class="line">Last name: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"LastName"</span> value=<span class="string">"Gates"</span> /&gt;&lt;br /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log($(<span class="string">"form"</span>).serialize()); // FirstName=Bill&amp;LastName=Gates</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样，我们就可以把序列化的值传给<code>ajax()</code>作为url的参数，轻松使用<code>ajax()</code>提交form表单了，而不需要一个一个获取表单中的值然后传给<code>ajax()</code>，举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'your url'</span>,</span><br><span class="line">    data: $(<span class="string">"form"</span>).serialize(),</span><br><span class="line">    success: <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>$.post()</code>、<code>$.get()</code>和<code>$.getJSON()</code>也是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.getJSON(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;jQuery的&lt;code&gt;serialize()&lt;/code&gt;方法通过&lt;strong&gt;序列化表单值&lt;/strong&gt;，&lt;strong&gt;创建URL编码文本字符串&lt;/strong&gt;，我们就可以选择一个或多个表单元素，也可以直接选择form将其序列化，如：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="jQuery" scheme="https://chongtianhong.github.io/tags/jQuery/"/>
    
      <category term="ajax" scheme="https://chongtianhong.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>页面添加锚点的三种方式</title>
    <link href="https://chongtianhong.github.io/2018/06/25/methodOfAddingAnchorPoints/"/>
    <id>https://chongtianhong.github.io/2018/06/25/methodOfAddingAnchorPoints/</id>
    <published>2018-06-25T02:15:36.000Z</published>
    <updated>2018-09-27T15:01:56.883Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>HTML中的链接</strong>，正确的说法应该称作”<strong>锚点</strong>“。</li><li>锚点链接（也叫书签链接）常常用于那些内容庞大繁琐的网页，通过<strong>点击命名锚点</strong>，不仅让我们能<strong>指向文档</strong>，还能<strong>指向页面里的特定段落</strong>，更能当作<strong>“精准链接”的便利工</strong>具，让链接对象接近焦点。便于浏览者查看网页内容。类似于我们阅读书籍时的目录页码或章回提示。</li><li>在需要<strong>指定到页面的特定部分</strong>时，<strong>标记锚点</strong>是最佳的方法。　<a id="more"></a></li></ul><h4 id="锚点链接对SEO的作用"><a href="#锚点链接对SEO的作用" class="headerlink" title="锚点链接对SEO的作用"></a>锚点链接对SEO的作用</h4><ul><li>锚链接是一个非常重要的概念，在网页中增加恰当的锚链接，会让所在网页和所指向网页的重要程度有所提升，从而影响到关键词排名。<strong>锚链接对SEO的作用</strong>主要体现在以下几个方面：</li></ul><p><blockquote>对锚链接所在的页面的作用</blockquote>　　</p><ul><li>正常来讲，<strong>页面中增加的锚链接都和页面本身有一定的关系</strong>，因此，<strong>锚文本可以作为锚链接所在的页面的内容的评估</strong>。例如：本篇文章中含有“SEO”的链接，那么，说明本篇文章和SEO有一定关系。</li></ul><p><blockquote>对锚链接所指向页面的作用</blockquote>　　</p><ul><li>锚链接能精确的描述所指向页面的内容，因此，<strong>锚链接能可以对所指向页面的评估</strong>。</li></ul><p><blockquote>锚链接对关键词排名的影响</blockquote>　　</p><ul><li><strong>锚链接对于关键字排名的意义</strong>在于它可以<strong>让内容页随机链接在一起</strong>，<strong>让蜘蛛可以很好的抓取更多页面</strong>，<strong>权重</strong>也能<strong>均匀的传递</strong>，同时<strong>增强页面的相关性</strong>，<strong>最终提升网站的关键词排名</strong>。</li></ul><h4 id="锚点的添加方式"><a href="#锚点的添加方式" class="headerlink" title="锚点的添加方式"></a>锚点的添加方式</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><ul><li><p>给锚点文本标签添加id，使用&lt;a href=”#”&gt;&lt;/a&gt;来定位，当单击a链接时，就会跳到id为a01的p标签处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#a01"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">"a01"</span>&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>这样的定位<strong>可以针对任何标签来定位</strong>。</p></li></ul><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><ul><li><p>给a标签的文本添加锚点，单击链接可跳到name为a01的a标签处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#a01"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;a name=<span class="string">"a01"</span> href=“<span class="comment">#”&gt;练习&lt;/a&gt;</span></span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用name属性<strong>只能针对a标签来定位</strong>，而对div等其他标签就不能起到定位作用。</p></li></ul><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><ul><li>使用JS中<strong>与页面（容器）滚动相关的API</strong> <code>scrollIntoView</code>，可让当前的元素滚动到浏览器窗口的可视区域内。</li><li>调用方法为<code>element.scrollIntoView()</code>，参数默认为true。<ul><li>参数为true时调用该函数，页面（或容器）发生滚动，使element的顶部与视图（容器）顶部对齐；</li><li>参数为false时，使element的底部与视图（容器）底部对齐。</li></ul></li><li><strong>注意</strong>：只有当页面（容器）可滚动时此API才能起作用。</li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li onclick=<span class="string">"javascript:document.getElementById('here').scrollIntoView()"</span>&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTML中的链接&lt;/strong&gt;，正确的说法应该称作”&lt;strong&gt;锚点&lt;/strong&gt;“。&lt;/li&gt;
&lt;li&gt;锚点链接（也叫书签链接）常常用于那些内容庞大繁琐的网页，通过&lt;strong&gt;点击命名锚点&lt;/strong&gt;，不仅让我们能&lt;strong&gt;指向文档&lt;/strong&gt;，还能&lt;strong&gt;指向页面里的特定段落&lt;/strong&gt;，更能当作&lt;strong&gt;“精准链接”的便利工&lt;/strong&gt;具，让链接对象接近焦点。便于浏览者查看网页内容。类似于我们阅读书籍时的目录页码或章回提示。&lt;/li&gt;
&lt;li&gt;在需要&lt;strong&gt;指定到页面的特定部分&lt;/strong&gt;时，&lt;strong&gt;标记锚点&lt;/strong&gt;是最佳的方法。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
      <category term="锚点" scheme="https://chongtianhong.github.io/tags/%E9%94%9A%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用CDN可以加快网络速度</title>
    <link href="https://chongtianhong.github.io/2018/06/24/CDN/"/>
    <id>https://chongtianhong.github.io/2018/06/24/CDN/</id>
    <published>2018-06-24T10:26:12.000Z</published>
    <updated>2018-09-20T16:08:17.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>大多数人都知道，一个用户在打开一个新网站的时候，如果网站打开的速度过慢，用户是很难继续浏览的。</li><li>因此，很多网站的运营人员想方设法的<strong>提高网站的加载速度</strong>。网站的加载速度是一个成功网站的必备要素之一，速度不够快，会<strong>降低转化率</strong>。<a id="more"></a></li><li>本文将简单地介绍下CDN，<strong>CDN是帮助一个网站能够快速打开的有效和实用方法</strong>。</li></ul><h4 id="网站打开速度慢的原因"><a href="#网站打开速度慢的原因" class="headerlink" title="网站打开速度慢的原因"></a>网站打开速度慢的原因</h4><ul><li><strong>网站打开速度慢</strong>受很多因素的影响，简单归纳下常见的几个原因：<ul><li><strong>共享主机服务器</strong>不堪重负，<strong>响应速度慢</strong>；</li><li><strong>网站的图片和内容太大</strong>，需要花费很多时间下载；</li><li>网站使用了太多不同的脚本和图片，这些<strong>脚本和图片没有针对快速加载网站进行优化，加载时间长</strong>；</li><li>网站的服务器位置与网站的访问者<strong>位于不同的地理位置</strong>。</li></ul></li><li>其实还有许多其他的原因，但这些以上列举的几点是最主要的。</li></ul><h4 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h4><ul><li>CDN指的是<strong>内容分发网络</strong>。其基本思路是<strong>尽可能的避开互联网上</strong>有可能影响<strong>数据传输速度</strong>和<strong>稳定性</strong>的瓶颈和环节，使内容传输的更快、更稳定。</li><li>CDN是通过<strong>在网络各处放置节点服务器</strong>所构成的在现有的互联网基础之上的一层<strong>智能虚拟网络</strong>，它能够实<strong>时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间</strong>等综合信息<strong>将用户的请求重新导向离用户最近的服务节点上</strong>。</li><li>CDN系统的目的是使用户可就<strong>近取得所需内容</strong>，<strong>解决Internet网络拥挤</strong>的状况，<strong>提高用户访问网站的响应速度</strong>。</li><li>CDN起到<strong>内容分发</strong>的作用，就是<strong>网站的内容是被复制到各个地区的不同服务器上面</strong>，这个距离离访问者所在地越近越好。</li><li>下图就展示了未使用CDN和使用CDN的区别图，显而易见，<strong>使用CDN可以提高访问速度</strong>：<br><img src="/images/CDN.png" alt="未使用CDN和使用CDN的区别图" width="600" style="border:none"></li></ul><h4 id="网站使用CDN加速的好处"><a href="#网站使用CDN加速的好处" class="headerlink" title="网站使用CDN加速的好处"></a>网站使用CDN加速的好处</h4><ul><li><strong>网站加速，利于Google的排名</strong>：Google 把网站的打开速度当做一个比较重要的指标，所以网站打开的速度会影响Google排名。使用CDN之后，网站打开速度变快，就可以减少跳出率，也可以增加用户对网站的友好体验。</li><li><strong>有利于提高网站的转化率</strong>：毫无疑问，用户的访问网站的时间提高了，跳出率减少了，当然会利于网站的转化率和销售量。现在大环境下的人们都比较浮躁，我想谁都没有耐心去等一个需要10秒才能打开的网站，这样的网站一开始就不友好，更别想提高网站的转化率了。</li><li><strong>提升网站的稳定性和安全性</strong>：CDN因为节点分散，攻击者比较难下手，攻击一个节点仅仅是影响一个节点的缓存访问而已，并且CDN的“内容路由”会自动的启用另一个节点，如果CDN服务节点数量够多，那么攻击者需要的流量包就会呈几何级的增加，这样攻击成本自然就高了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;大多数人都知道，一个用户在打开一个新网站的时候，如果网站打开的速度过慢，用户是很难继续浏览的。&lt;/li&gt;
&lt;li&gt;因此，很多网站的运营人员想方设法的&lt;strong&gt;提高网站的加载速度&lt;/strong&gt;。网站的加载速度是一个成功网站的必备要素之一，速度不够快，会&lt;strong&gt;降低转化率&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CDN加速" scheme="https://chongtianhong.github.io/tags/CDN%E5%8A%A0%E9%80%9F/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>大流量的下兜底容灾方案（转）</title>
    <link href="https://chongtianhong.github.io/2018/06/23/frontEndDisasterRecoveryPlan/"/>
    <id>https://chongtianhong.github.io/2018/06/23/frontEndDisasterRecoveryPlan/</id>
    <published>2018-06-23T08:55:16.000Z</published>
    <updated>2018-09-20T14:40:25.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>随着网络的普及，上网的成本和门槛越来越低，很多网站的流量也是蹭蹭蹭的往上涨，而<strong>页面上的数据来源也不确定</strong>，可能<strong>来自多个平台</strong>，也可能是有<strong>专门的人员在手动维护</strong>。由于<strong>数据来源众多，出错的概率</strong>也会<strong>增加</strong>，为了<strong>降低页面在大流量下的维护成本</strong>，本文做了一些阐述。<a id="more"></a></li></ul><h4 id="兜底容灾的必要性"><a href="#兜底容灾的必要性" class="headerlink" title="兜底容灾的必要性"></a>兜底容灾的必要性</h4><ul><li>一个日均承载几千万上亿流量的网页，会经常出现以下问题：<br>① 某个<strong>接口挂了</strong>，前端拿不到数据或者拿到的数据不够，<strong>页面展示就会出问题</strong>，出现空白或者某个模块直接出错。<br>② <strong>用户因为网络问题</strong>或者<strong>安装了某些插件</strong>，导致页面广告、接口请求挂掉，从而页面出现问题。</li><li><strong>前者的概率不是很大</strong>，因为<strong>网页上的请求 QPS 都是预先评估过的</strong>，只要前端请求没有成倍激增，并且后端压力都在系统监控范围内，不会出太大的岔子。但是一旦出问题，页面上就有可能空白一大块，<strong>如果后端排查和处理问题不及时</strong>，很可能从<strong>小问题演变成故障</strong>。</li><li>而<strong>第二个问题比较严峻</strong>，据统计，不管网站做的多简洁，总是会有千分之一的<strong>用户因为网络或者浏览器插件问题导致页面访问失败</strong>或者<strong>部分接口请求失败</strong>，比如一个 pv 一亿的网站，按照千分之一计算，一个接口每天会有 10w 左右的 pv 请求失败，而请求接口一多，页面上整体的请求失败量就很高了，这个数据会达到几百万。</li></ul><h4 id="如何兜底，如何容灾"><a href="#如何兜底，如何容灾" class="headerlink" title="如何兜底，如何容灾"></a>如何兜底，如何容灾</h4><ul><li><strong>兜底容灾的方案</strong>有很多，<strong>目的</strong>就是让<strong>请求失败而页面展示依然正常</strong>。下面说一说常用的几个方案：</li></ul><h5 id="再请求一次"><a href="#再请求一次" class="headerlink" title="再请求一次"></a>再请求一次</h5><ul><li><p>照顾到用户体验，同时也<strong>考虑到一个请求的正常发送、接受时间</strong>，我们<strong>把超时时间设置为 5s</strong>，<strong>超过 5s 或者请求的结果状态为 failed ，则重新请求一次</strong>。所以我们可以重新封装下 Ajax 模块，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 设置请求次数</span><br><span class="line">var tryTimes = 2;</span><br><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    timeout: 5000,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    // try</span><br><span class="line">    tryTimes: tryTimes</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这种处理方案<strong>对于提交订单、选中商品到购物车的页面比较合适</strong>，因为操作流是确定的，提交一次不成功，很自然的想到再提交一次，只是<strong>用户等待的不同阶段应该用不同的文案来提醒</strong>。</p></li><li>而<strong>对于展示类的数据请求，不太适合多次失败尝试</strong>。所以首页未采用这种方案。</li></ul><h5 id="缓存每一次请求到本地"><a href="#缓存每一次请求到本地" class="headerlink" title="缓存每一次请求到本地"></a>缓存每一次请求到本地</h5><ul><li><p>现在的<strong>浏览器都支持本地储存</strong>（无论使用 userData 还是 localStorage），<strong>当每次请求到达用户浏览器的时候，把请求的数据缓存一份到本地储存</strong>，那么下次请求失败就可以使用上次缓存的数据了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    success: <span class="keyword">function</span>(data)&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">        cache(DATAKEY, data);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 请求失败，获取本地缓存数据</span><br><span class="line">        var data = cache(DATAKEY);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这种方式是比较常用的，<strong>每次请求成功都会缓存最新的数据</strong>。不过这里存在两个问题：<br>① 如果<strong>用户第一次访问就失败了</strong>，假设新用户是比较多的。<br>② <strong>缓存的数据是否具有时效性</strong>，如果缓存的数据过期了：比如是一个推荐接口，推荐的商品用户已经购买过了，但是访问的时候接口挂掉，依然显示用户购买过的商品，这个逻辑是不太能接受的。</p></li><li>对<strong>于第一次访问</strong>的情况，这个概率是相当低的，但是要提出另外的解决方案来避免新用户访问页面显示空白的情况发生。</li><li>而对于第二个问题，<strong>有缓存总比没有数据的好</strong>，就算数据过期，但是依然是正确的链接，所以<strong>基本可以接受</strong>。</li></ul><h5 id="备用接口（硬兜底）"><a href="#备用接口（硬兜底）" class="headerlink" title="备用接口（硬兜底）"></a>备用接口（硬兜底）</h5><ul><li>当<strong>后端接口返回失败，用户本地也没有数据缓存</strong>的时候，则可以<strong>采用备用接口</strong>的方式（通过<strong>访问CDN对应地址</strong>拉取数据渲染）。</li><li><p>当<strong>后端为网页接口准备一个备用接口</strong>后，前端请求时可以做个包装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    // 备份接口</span><br><span class="line">    backUrl: backUrl</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>一旦请求失败，<strong>进入备用数据接口请求备份数据</strong>。</p></li><li>同样的，这里也存在一个问题：如果接口是个性化的，则每个用户访问这个接口拿到的数据都不一样，那么这个备份接口该如何推数据？如果备用接口的数据跟正常接口一样，那还不如直接去请求两次。所以这里提到的备用接口，主要是<strong>数据的硬兜底</strong>，硬兜底的来源有两个：<br>① <strong>运营</strong>维护一份数据，推送到 CDN，每一份数据都有一个固定的地址；<br>② <strong>后端</strong>向 CDN push 一份通用数据。我们知道<strong>个性化都是使用 cookie 去识别用户的</strong>，对于没有浏览器记录的新用户就没有 cookie，此时会推一份通用的数据，这个<strong>通用的数据可以作为接口的备份源</strong>。</li></ul><h4 id="兜底容错实践"><a href="#兜底容错实践" class="headerlink" title="兜底容错实践"></a>兜底容错实践</h4><ul><li>我们很容易得到如下的操作流程：<br><img src="/images/frontEndDisasterRecoveryPlan1.png" alt="兜底容错实践操作流程1" width="600" style="border:none"></li><li>而这里存在的问题是：<br>① 获取缓存数据后，不好对数据格式进行判断，一般来说，<strong>只有有效的数据才能存到本地储存中</strong>，而判断是否有效往往存在误差；<br>② <strong>兜底数据没有及时更新</strong>；<br>③ <strong>程序只会报警</strong>，但是<strong>不会自动修复</strong>。</li><li>存在的隐患是：<br>① <strong>前端每次改版</strong>，如更换接口、更换人员，<strong>兜底数据没有及时更新</strong>；<br>② 如果<strong>兜底数据也存在错误</strong>，则页面一定出现空白天窗。</li><li>所以对整个流程做了一些改进：<br><img src="/images/frontEndDisasterRecoveryPlan2.png" alt="兜底容错实践操作流程2" width="600" style="border:none"></li><li>数据经过统一平台输出，在输出之前，我们将数据推一份到 CDN 作为备份，产生另一个接口，一旦原始接口请求失败，则直接请求备份的接口，这个在<strong>规则对应</strong>和<strong>即时更新</strong>上可以做到很好！那么基本的流程就是这样：<br><img src="/images/frontEndDisasterRecoveryPlan3.png" alt="兜底容错实践操作流程2的基本流程" width="200" style="border:none"></li><li>不过为了确保无误，我的建议是，<strong>页面上每个接口必须对应一个运营手填的数据</strong>，这个<strong>作为最后的硬兜底</strong>，而<strong>这个硬兜底也会被缓存到本地</strong>，整个流程就形成一个闭环。那么，剩下的工作就只有监控和警报了。</li><li><p>下面是一串伪代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var url = interfaceURL;</span><br><span class="line">var backUrl = interfaceBackURL;</span><br><span class="line">var hardBackUrl = hardDataURL;</span><br><span class="line">var cacheTime = 10day;</span><br><span class="line"></span><br><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    backurl: backUrl,</span><br><span class="line">    success: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">        cache(DATAKEY, data, cacheTime);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 请求失败，获取本地缓存数据</span><br><span class="line">        var data = cache(DATAKEY);</span><br><span class="line">        <span class="keyword">if</span>(data) &#123;</span><br><span class="line">            Reporter.send(/*WARN*/);</span><br><span class="line">            show(data); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Reporter.send(/*ERROR*/);</span><br><span class="line">            _failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 请求硬兜底</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_failed</span></span>() &#123;</span><br><span class="line">    Ajax(&#123;</span><br><span class="line">        url: hadrBackUrl,</span><br><span class="line">        success: <span class="keyword">function</span>(data)&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">            cache(DATAKEY, data, cacheTime);</span><br><span class="line">            show(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            Reporter.send(/*SUPER_ERROR*/);</span><br><span class="line">            show(data); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意到，我们在上面使用了缓存失效时间，考虑到数据的及时性，设置为 10 天。backUrl 是 url 的备份地址，hardBackUrl 是运营填写的备份数据，整个流程都在闭环之中，所以出问题的概率就大大降低了，即便是后端接口出错，我们也可以看着监控信息，放心的给后端开发打个电话，告知下等待修复，而不是急急忙忙，担惊受怕。</p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>本文提供的都是伪代码，而这些伪代码的实现并不复杂，也没必要写成组件，主要是提供思路，如何<strong>处理大流量高并发下的异步数据接口的兜底容灾</strong>。</li></ul><div class="note info">原文出处：<a href="https://www.barretlee.com/blog/2015/09/16/backup-solution-at-big-traffic/" target="_blank" rel="noopener">大流量的下兜底容灾方案</a></div>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;随着网络的普及，上网的成本和门槛越来越低，很多网站的流量也是蹭蹭蹭的往上涨，而&lt;strong&gt;页面上的数据来源也不确定&lt;/strong&gt;，可能&lt;strong&gt;来自多个平台&lt;/strong&gt;，也可能是有&lt;strong&gt;专门的人员在手动维护&lt;/strong&gt;。由于&lt;strong&gt;数据来源众多，出错的概率&lt;/strong&gt;也会&lt;strong&gt;增加&lt;/strong&gt;，为了&lt;strong&gt;降低页面在大流量下的维护成本&lt;/strong&gt;，本文做了一些阐述。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="兜底" scheme="https://chongtianhong.github.io/tags/%E5%85%9C%E5%BA%95/"/>
    
      <category term="容灾" scheme="https://chongtianhong.github.io/tags/%E5%AE%B9%E7%81%BE/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之WXS模块</title>
    <link href="https://chongtianhong.github.io/2018/06/22/wxsOfMiniProgram/"/>
    <id>https://chongtianhong.github.io/2018/06/22/wxsOfMiniProgram/</id>
    <published>2018-06-22T02:37:08.000Z</published>
    <updated>2018-09-19T14:17:03.756Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>WXS（WeiXin Script）是<strong>小程序</strong>的一套<strong>脚本语言</strong>，<strong>与 wxml 结合</strong>，可以构建出页面的结构。</li><li>WXS 代码可以编写在wxml文件中的 &lt;wxs&gt; 标签内，或以 <code>.wxs</code> 为后缀名的文件内。<a id="more"></a></li></ul><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><ul><li>每一个 <code>.wxs</code> 文件和 &lt;wxs&gt; 标签都是一个<strong>单独的模块</strong>。</li><li><strong>每个模块</strong>都有自己<strong>独立的作用域</strong>。即在一个模块里面定义的变量与函数，<strong>默认为私有的</strong>，<strong>对其他模块不可见</strong>。</li><li>一个模块要想<strong>对外暴露其内部的私有变量与函数</strong>，只能<strong>通过 <code>module.exports</code> 实现</strong>。</li></ul><h5 id="wxs-文件"><a href="#wxs-文件" class="headerlink" title=".wxs 文件"></a>.wxs 文件</h5><ul><li><p>在微信开发者工具里面，右键可以直接创建 <code>.wxs</code> 文件，在其中直接编写 WXS 脚本。示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/comm.wxs</span><br><span class="line">*/ </span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from comm.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span>(d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    foo: foo,</span><br><span class="line">    bar: bar</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上述例子在 <code>/pages/comm.wxs</code> 的文件里面编写了 WXS 代码。该 <code>.wxs</code> 文件<strong>可以被其他的 <code>.wxs</code> 文件 或 WXML 中的 <wxs> 标签引用</wxs></strong>。</p></li></ul><h5 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h5><ul><li>每个 wxs 模块均有一个<strong>内置的 module 对象</strong>。</li><li>module 对象有一个<code>exports</code>属性。 通过该属性，可以<strong>对外共享</strong>本模块的<strong>私有变量与函数</strong>。</li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/tools.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from tools.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span> (d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    FOO: foo,</span><br><span class="line">    bar: bar,</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.msg = <span class="string">"some msg"</span>;</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- page/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../tools.wxs"</span> module=<span class="string">"tools"</span> /&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.msg&#125;&#125; &lt;/view&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.bar(tools.FOO)&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some msg</span><br><span class="line"><span class="string">'hello world'</span> from tools.wxs</span><br></pre></td></tr></table></figure></li></ul><h5 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h5><ul><li>在<code>.wxs</code>模块中<strong>引用其他 wxs 文件模块</strong>，可以<strong>使用 <code>require</code>函数</strong>。</li><li>引用的时候，要注意如下几点：<ul><li>只能引用<code>.wxs</code>文件模块，且<strong>必须使用相对路径</strong>。</li><li>wxs 模块均为<strong>单例</strong>，wxs 模块在第一次被引用时，会自动初始化为单例对象。<strong>多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象</strong>。</li><li>如果一个 <strong>wxs 模块在定义之后，一直没有被引用</strong>，则该模块<strong>不会被解析与运行</strong>。</li></ul></li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/tools.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from tools.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span> (d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    FOO: foo,</span><br><span class="line">    bar: bar,</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.msg = <span class="string">"some msg"</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>logic.wxs</code>模块中引用<code>tools.wxs</code>文件模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/logic.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var tools = require(<span class="string">"./tools.wxs"</span>);</span><br><span class="line"></span><br><span class="line">console.log(tools.FOO);</span><br><span class="line">console.log(tools.bar(<span class="string">"logic.wxs"</span>));</span><br><span class="line">console.log(tools.msg);</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- /page/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../logic.wxs"</span> module=<span class="string">"logic"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>控制台输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span> from tools.wxs</span><br><span class="line">logic.wxs</span><br><span class="line">some msg</span><br></pre></td></tr></table></figure></li></ul><h5 id="wxs标签"><a href="#wxs标签" class="headerlink" title="wxs标签"></a>wxs标签</h5><ul><li>&lt;wxs&gt;标签有两个属性，如下表所示：</li></ul><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">module</td><td style="text-align:center">String</td><td style="text-align:center">当前 &lt;wxs&gt; 标签的模块名。必填字段</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">String</td><td style="text-align:center">引用 .wxs 文件的相对路径。仅当本标签为<strong>单闭合标签</strong>或<strong>标签的内容为空</strong>时有效</td></tr></tbody></table><blockquote>module 属性</blockquote><ul><li>module 属性是<strong>当前 &lt;wxs&gt; 标签的模块名</strong>。在单个 wxml 文件内，<strong>建议其值唯一</strong>。有重复模块名则<strong>按照先后顺序覆盖</strong>（后者覆盖前者）。<strong>不同文件之间的 wxs 模块名不会相互覆盖</strong>。</li><li>module 属性值的命名必须符合下面两个规则：<ul><li>首字符必须是：字母（a-zA-Z），下划线（_）</li><li>剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）</li></ul></li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--wxml--&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs module=<span class="string">"foo"</span>&gt;</span><br><span class="line">    var some_msg = <span class="string">"hello world"</span>;</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        msg : some_msg,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;foo.msg&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></li><li><p>上面例子声明了一个名字为<code>foo</code>的模块，将<code>some_msg</code>变量暴露出来，供当前页面使用。</p></li></ul><blockquote>src 属性</blockquote><ul><li>src 属性可以用来<strong>引用其他的 wxs 文件模块</strong>。</li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/index/index.js</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">"'hello wrold' from js"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- /pages/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../comm.wxs"</span> module=<span class="string">"some_comms"</span>&gt;&lt;/wxs&gt;</span><br><span class="line">&lt;!-- 也可以直接使用单标签闭合的写法</span><br><span class="line">    &lt;wxs src=<span class="string">"./../comm.wxs"</span> module=<span class="string">"some_comms"</span> /&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 some_comms 模块里面的 foo --&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;some_comms.bar(some_comms.foo)&#125;&#125; &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 page/index/index.js 里面的 msg --&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;some_comms.bar(msg)&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span> from comm.wxs</span><br><span class="line"><span class="string">'hello wrold'</span> from js</span><br></pre></td></tr></table></figure></li><li><p>上述例子在文件<code>/page/index/index.wxml</code>中通过 &lt;wxs&gt; 标签引用了<code>/page/comm.wxs</code>模块。</p></li><li>注意：<ul><li>&lt;wxs&gt; 模块只能在<strong>定义模块的 WXML 文件</strong>中被访问到。使用 &lt;include&gt; 或 &lt;import&gt; 时，&lt;wxs&gt; 模块不会被引入到对应的 WXML 文件中。</li><li>&lt;template&gt; 标签中，只能使用定义该 &lt;template&gt; 的 WXML 文件中定义的 &lt;wxs&gt; 模块。</li></ul></li></ul><h4 id="微信小程序，用js还是wxs？"><a href="#微信小程序，用js还是wxs？" class="headerlink" title="微信小程序，用js还是wxs？"></a>微信小程序，用js还是wxs？</h4><ul><li>在开发微信小程序的时候，应该<strong>根据情况</strong>，选择使用js或wxs。</li><li>wxs是专门用于wxml页面的，如果我们有<strong>在页面中使用js脚本</strong>的需求可以使用wxs来实现。</li><li>wxs和js<strong>不能互相直接调用</strong>。</li><li>wxs其实就是封装后的js，用法跟js一模一样。有些功能，用wxs和js都能实现，但是有时会发现用wxs<strong>更方便、直接</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;WXS（WeiXin Script）是&lt;strong&gt;小程序&lt;/strong&gt;的一套&lt;strong&gt;脚本语言&lt;/strong&gt;，&lt;strong&gt;与 wxml 结合&lt;/strong&gt;，可以构建出页面的结构。&lt;/li&gt;
&lt;li&gt;WXS 代码可以编写在wxml文件中的 &amp;lt;wxs&amp;gt; 标签内，或以 &lt;code&gt;.wxs&lt;/code&gt; 为后缀名的文件内。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="https://chongtianhong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="WXS" scheme="https://chongtianhong.github.io/tags/WXS/"/>
    
  </entry>
  
  <entry>
    <title>使用moment.js轻松管理日期和时间</title>
    <link href="https://chongtianhong.github.io/2018/06/21/momentJS/"/>
    <id>https://chongtianhong.github.io/2018/06/21/momentJS/</id>
    <published>2018-06-21T02:33:16.000Z</published>
    <updated>2018-09-19T14:09:06.287Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>moment.js</strong>是一个非常好用的时间处理插件，对js中的date对象进行了一层封装，使之具有更加强大日期处理能力。</li><li><strong>moment.js</strong>里面包含了非常多而且有用的<strong>对时间进行操作</strong>的方法，例如：时间加减法、比较大小/差值计算、isBefore/isAfter，还支持非常多的时间格式及语言。<a id="more"></a></li></ul><h4 id="moment-js"><a href="#moment-js" class="headerlink" title="moment.js"></a>moment.js</h4><ul><li>Momentjs<strong>支持多个环境</strong>，既可以<strong>在浏览器中使用</strong>，也可以<strong>脱离浏览器的环境在nodejs中使用</strong>。</li></ul><h5 id="node"><a href="#node" class="headerlink" title="node"></a>node</h5><ul><li>在Node.js中使用momentjs的话需要<strong>安装moment模块</strong>，然后<strong>加载模块</strong>就行了。命令如下: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install moment </span><br><span class="line">var moment = require(<span class="string">'moment'</span>);</span><br><span class="line">moment().format();</span><br></pre></td></tr></table></figure></li></ul><h5 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h5><ul><li>在浏览器中使用，则用下面方法引入momentjs文件即可，使用的时候在Node.js和浏览器中并没有什么区别。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"moment.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    moment().format();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>下面将对一些常用方法进行介绍，更多内容可到<a href="http://momentjs.cn/" target="_blank" rel="noopener">Moment.js 中文网</a>获取。</li></ul><blockquote>日期格式化</blockquote><ul><li><p>当前时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>); // 2018-06-14 23:36:09</span><br></pre></td></tr></table></figure></li><li><p>今天是星期几：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'d'</span>); // 4</span><br></pre></td></tr></table></figure></li><li><p>转换当前时间的Unix时间戳：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'X'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote>字符串转日期</blockquote><ul><li>代码示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'2018-06-14'</span>).toDate();</span><br><span class="line">moment(<span class="string">'2018-06-14 10:20:15'</span>).toDate();</span><br></pre></td></tr></table></figure></li></ul><blockquote>时间戳转日期</blockquote><ul><li>代码示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(1448896064621).toDate();</span><br></pre></td></tr></table></figure></li></ul><blockquote>相对时间</blockquote><ul><li><p>时间加减：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'years'</span>);       // 加7年</span><br><span class="line">moment().add(7, <span class="string">'month'</span>);       // 加7个月</span><br><span class="line">moment().add(7, <span class="string">'days'</span>);        // 加7天</span><br><span class="line">moment().add(7, <span class="string">'hours'</span>);       // 加7小时</span><br><span class="line">moment().add(7, <span class="string">'minutes'</span>);     // 加7分钟</span><br><span class="line">moment().add(7, <span class="string">'seconds'</span>);     // 加7秒钟</span><br><span class="line"> </span><br><span class="line">moment().subtract(7, <span class="string">'years'</span>);  // 减7年</span><br><span class="line">moment().subtract(7, <span class="string">'month'</span>);  // 减7个月</span><br><span class="line">moment().subtract(7, <span class="string">'days'</span>);   // 减7天</span><br><span class="line">moment().subtract(7, <span class="string">'hours'</span>);  // 减7小时</span><br><span class="line">moment().subtract(7, <span class="string">'minutes'</span>);// 减7分钟</span><br><span class="line">moment().subtract(7, <span class="string">'seconds'</span>);// 减7秒钟</span><br><span class="line"></span><br><span class="line">moment().subtract(7, <span class="string">'days'</span>).format(<span class="string">'YYYY年MM月DD日'</span>); // 7天前的日期</span><br><span class="line">moment().add(7, <span class="string">'days'</span>).format(<span class="string">'YYYY年MM月DD日'</span>); // 7天后的日期</span><br><span class="line">moment().subtract(7, <span class="string">'hours'</span>).format(<span class="string">'HH:mm:ss'</span>); // 7小时前的时间</span><br><span class="line">moment().add(7, <span class="string">'hours'</span>).format(<span class="string">'HH:mm:ss'</span>); // 7小时后的时间</span><br></pre></td></tr></table></figure></li><li><p>moment.js的函数<strong>支持链式写法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'days'</span>).add(1, <span class="string">'months'</span>);</span><br></pre></td></tr></table></figure></li><li><p>20160601相对当前日期是2年前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">"20160601"</span>, <span class="string">"YYYYMMDD"</span>).fromNow(); // 2 years ago</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h4><ul><li>moment.js提供了丰富的说明文档，使用它还可以<strong>创建日历项目</strong>等复杂的日期时间应用。</li><li>在日常开发中最常用的是<strong>格式化时间</strong>，下面将常用的格式制作成表格说明：</li></ul><table><thead><tr><th style="text-align:center">格式代码</th><th style="text-align:center">说明</th><th style="text-align:center">返回值例子</th></tr></thead><tbody><tr><td style="text-align:center">M</td><td style="text-align:center">数字表示的月份，没有前导零</td><td style="text-align:center">1到12</td></tr><tr><td style="text-align:center">MM</td><td style="text-align:center">数字表示的月份，有前导零</td><td style="text-align:center">01到12</td></tr><tr><td style="text-align:center">MMM</td><td style="text-align:center">三个字母缩写表示的月份</td><td style="text-align:center">Jan到Dec</td></tr><tr><td style="text-align:center">MMMM</td><td style="text-align:center">月份，完整的文本格式</td><td style="text-align:center">January到December</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">季度</td><td style="text-align:center">1到4</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">月份中的第几天，没有前导零</td><td style="text-align:center">1到31</td></tr><tr><td style="text-align:center">DD</td><td style="text-align:center">月份中的第几天，有前导零</td><td style="text-align:center">01到31</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">星期中的第几天，数字表示</td><td style="text-align:center">0到6，0表示周日，6表示周六</td></tr><tr><td style="text-align:center">ddd</td><td style="text-align:center">三个字母缩写表示星期中的第几天</td><td style="text-align:center">Sun到Sat</td></tr><tr><td style="text-align:center">dddd</td><td style="text-align:center">星期几，完整的星期文本</td><td style="text-align:center">从Sunday到Saturday</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">年份中的第几周</td><td style="text-align:center">如42：表示第42周</td></tr><tr><td style="text-align:center">YYYY</td><td style="text-align:center">四位数字完整表示的年份</td><td style="text-align:center">如：2014 或 2000</td></tr><tr><td style="text-align:center">YY</td><td style="text-align:center">两位数字表示的年份</td><td style="text-align:center">如：14 或 98</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">大写的AM PM</td><td style="text-align:center">AM PM</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">小写的am pm</td><td style="text-align:center">am pm</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">小时，24小时制，无前导零</td><td style="text-align:center">0到23</td></tr><tr><td style="text-align:center">HH</td><td style="text-align:center">小时，24小时制，有前导零</td><td style="text-align:center">00到23</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">小时，12小时制，无前导零</td><td style="text-align:center">0到12</td></tr><tr><td style="text-align:center">hh</td><td style="text-align:center">小时，12小时制，有前导零</td><td style="text-align:center">00到12</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">没有前导零的分钟数</td><td style="text-align:center">0到59</td></tr><tr><td style="text-align:center">mm</td><td style="text-align:center">有前导零的分钟数</td><td style="text-align:center">00到59</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">没有前导零的秒数</td><td style="text-align:center">0到59</td></tr><tr><td style="text-align:center">ss</td><td style="text-align:center">有前导零的描述</td><td style="text-align:center">00到59</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">Unix时间戳</td><td style="text-align:center">1411572969</td></tr></tbody></table><h4 id="写法示例"><a href="#写法示例" class="headerlink" title="写法示例"></a>写法示例</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment() // 当前时间</span><br><span class="line">moment(<span class="string">"1995-12-25"</span>) // 1995-12-25</span><br><span class="line">moment(<span class="string">"12-25-1995"</span>, <span class="string">"MM-DD-YYYY"</span>) // 1995-12-25</span><br><span class="line">moment(&#123; year :2010, month :3, day :5, hour :15, minute :10, second :3, millisecond :123&#125;)</span><br><span class="line">moment(Date.now() - 24 * 60 * 60 * 1000) // 昨天</span><br><span class="line">moment(new Date(2011, 9, 16)) // 2011-10-16</span><br></pre></td></tr></table></figure><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'YYYY年MM月DD日 HH:mm:ss'</span>) // 2016年11月11日 22:05:19</span><br><span class="line">moment().format(<span class="string">'hh:m:ss'</span>) // 10:5:19</span><br><span class="line">moment().format(<span class="string">'[YYYY]'</span>) // <span class="string">"YYYY"</span>。[] 里的会原样输出。</span><br></pre></td></tr></table></figure><h5 id="转化成-Date-对象"><a href="#转化成-Date-对象" class="headerlink" title="转化成 Date 对象"></a>转化成 Date 对象</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().toDate()</span><br></pre></td></tr></table></figure><h5 id="获取-设置时间信息"><a href="#获取-设置时间信息" class="headerlink" title="获取/设置时间信息"></a>获取/设置时间信息</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">moment().second() //获得 秒</span><br><span class="line">moment().second(Number) //设置 秒。0 到 59</span><br><span class="line">moment().minute() //获得 分</span><br><span class="line">moment().minute(Number) //设置 分。0 到 59</span><br><span class="line">// 类似的用法</span><br><span class="line">moment().hour() // 小时</span><br><span class="line">moment().date() // 一个月里的第几天</span><br><span class="line">moment().day() // 星期几</span><br><span class="line">moment().dayOfYear() // 一年里的第几天</span><br><span class="line">moment().week() // 一年里的第几周</span><br><span class="line">moment().month() // 第几个月</span><br><span class="line">moment().quarter() // 一年里的第几个季度</span><br><span class="line">moment().year() // 年</span><br><span class="line">moment().daysInMonth() // 当前月有多少天</span><br></pre></td></tr></table></figure><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'days'</span>) // 之后的第7天。第2个参数还可以是 <span class="string">'months'</span>, <span class="string">'years'</span> 等。注意是复数。</span><br><span class="line">moment().add(7, <span class="string">'d'</span>）// 与上面一行代码的运行结果一样。</span><br><span class="line">moment().subtract(1, <span class="string">'months'</span>) // 上个月</span><br><span class="line"></span><br><span class="line">moment().startOf(<span class="string">'week'</span>) // 这周的第一天</span><br><span class="line">moment().startOf(<span class="string">'hour'</span>) // 与 moment().minutes(0).seconds(0).milliseconds(0)等效。</span><br><span class="line">// 还支持 <span class="string">'year'</span>，<span class="string">'month'</span> 等</span><br><span class="line"></span><br><span class="line">moment().endOf(<span class="string">'week'</span>) // 这周的最后一天</span><br></pre></td></tr></table></figure><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 早于</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2010-10-21'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2010-12-31'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 是否相等</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2010-10-20'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2009-12-31'</span>, <span class="string">'year'</span>)  // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2010-01-01'</span>, <span class="string">'year'</span>)  // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 晚于</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2010-10-19'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2010-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2009-12-31'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 是否在时间范围内</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-10-19'</span>, <span class="string">'2010-10-25'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-01-01'</span>, <span class="string">'2012-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2009-12-31'</span>, <span class="string">'2012-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">moment().isLeapYear() // 是否是闰年</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;moment.js&lt;/strong&gt;是一个非常好用的时间处理插件，对js中的date对象进行了一层封装，使之具有更加强大日期处理能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;moment.js&lt;/strong&gt;里面包含了非常多而且有用的&lt;strong&gt;对时间进行操作&lt;/strong&gt;的方法，例如：时间加减法、比较大小/差值计算、isBefore/isAfter，还支持非常多的时间格式及语言。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="moment.js" scheme="https://chongtianhong.github.io/tags/moment-js/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序动态修改页面标题</title>
    <link href="https://chongtianhong.github.io/2018/06/20/setNavigationBarTitle/"/>
    <id>https://chongtianhong.github.io/2018/06/20/setNavigationBarTitle/</id>
    <published>2018-06-20T02:55:36.000Z</published>
    <updated>2018-09-19T14:16:25.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在微信小程序的开发中，如果页面的状态改变，需要<strong>动态的修改微信小程序的页面的标题</strong>，可以通过<strong>微信小程序提供的API</strong>，<code>wx.setNavigationBarTitle</code>来实现动态的修改微信小程序的页面标题。<a id="more"></a></li></ul><h4 id="静态设置页面标题"><a href="#静态设置页面标题" class="headerlink" title="静态设置页面标题"></a>静态设置页面标题</h4><ul><li>在<strong>对应页面的json文件</strong>里面加入下面代码就可以<strong>实现页面标题的设置</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"当前页标题"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="动态设置页面标题"><a href="#动态设置页面标题" class="headerlink" title="动态设置页面标题"></a>动态设置页面标题</h4><ul><li><p>下面是动态修改微信小程序的页面标题的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var sign = 1;</span><br><span class="line">    var <span class="built_in">times</span> = setInterval(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(sign &gt; 10 )</span><br><span class="line">        &#123;</span><br><span class="line">            clearInterval(<span class="built_in">times</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            var tmpTitle = <span class="string">'微信小程序的页面标题'</span> + sign++;</span><br><span class="line">            wx.setNavigationBarTitle(&#123;</span><br><span class="line">            title: tmpTitle,</span><br><span class="line">            success: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"当前微信小程序的页面标题为\""</span> + tmpTitle + <span class="string">"\""</span> );</span><br><span class="line">            &#125;,</span><br><span class="line">            complete: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"动态修改微信小程序的页面标题-complete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>关键的操作是<code>wx.setNavigationBarTitle({ title: tmpTitle })</code>。</p></li><li><code>wx.setNavigationBarTitle</code>的API也<strong>支持</strong>在执行修改小程序页面标题的成功、失败和完成的状态的<strong>回调事件</strong>。</li><li>注意<code>wx.setNavigationBarTitle</code>要在onready之后设置<br>（onload也是在onready）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在微信小程序的开发中，如果页面的状态改变，需要&lt;strong&gt;动态的修改微信小程序的页面的标题&lt;/strong&gt;，可以通过&lt;strong&gt;微信小程序提供的API&lt;/strong&gt;，&lt;code&gt;wx.setNavigationBarTitle&lt;/code&gt;来实现动态的修改微信小程序的页面标题。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="https://chongtianhong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="setNavigationBarTitle" scheme="https://chongtianhong.github.io/tags/setNavigationBarTitle/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（五）事件类型之鼠标事件</title>
    <link href="https://chongtianhong.github.io/2018/06/19/mouseEventOfEventType/"/>
    <id>https://chongtianhong.github.io/2018/06/19/mouseEventOfEventType/</id>
    <published>2018-06-19T11:46:45.000Z</published>
    <updated>2018-09-19T14:09:10.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><ul><li>DOM3级事件中定义了9个鼠标事件：<ul><li><code>mousedown</code>：<strong>鼠标按钮被按下（左键或者右键）</strong>时触发。不能通过键盘触发。</li><li><code>mouseup</code>：<strong>鼠标按钮被释放弹起</strong>时触发。不能通过键盘触发。</li><li><code>click</code>：<strong>单击鼠标左键</strong>或者<strong>按下回车键</strong>时触发。这点对确保易访问性很重要，意味着<code>onclick</code>事件处理程序<strong>既可以通过键盘也可以通过鼠标执行</strong>。</li><li><code>dblclick</code>：<strong>双击鼠标左键</strong>时触发。</li><li><code>mouseover</code>：鼠标移入目标元素上方。鼠标移到其后代元素上时会触发。</li><li><code>mouseout</code>：鼠标移出目标元素上方。</li><li><code>mouseenter</code>：鼠标移入元素范围内触发，该事件<strong>不冒泡</strong>，即<strong>鼠标移到其后代元素上时不会触发</strong>。</li><li><code>mouseleave</code>：鼠标移出元素范围时触发，该事件<strong>不冒泡</strong>，即<strong>鼠标移到其后代元素时不会触发</strong>。</li><li><code>mousemove</code>：<strong>鼠标在元素内部移动</strong>时不断触发。不能通过键盘触发。</li></ul></li></ul><h5 id="事件触发的顺序"><a href="#事件触发的顺序" class="headerlink" title="事件触发的顺序"></a>事件触发的顺序</h5><ul><li><p>举例：通过双击按钮，看一下所触发的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"mousedown"</span>, <span class="keyword">function</span>(event) &#123;</span><br><span class="line">            console.log(<span class="string">"mousedown"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"mouseup"</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">"mouseup"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            console.log(<span class="string">"click"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"dblclick"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            console.log(<span class="string">"dblclick"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>事件触发的顺序如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mousedown</span><br><span class="line">mouseup</span><br><span class="line">click</span><br><span class="line">mousedown</span><br><span class="line">mouseup</span><br><span class="line">click</span><br><span class="line">dbclick</span><br></pre></td></tr></table></figure></li></ul><h5 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h5><ul><li><code>mouseover</code>事件<strong>会冒泡</strong>，这意味着，鼠标移到其后代元素上时会触发。</li><li><code>mouseenter</code>事件<strong>不冒泡</strong>，这意味着，鼠标移到其后代元素上时不会触发。</li><li><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="comment">#outer&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                top:0;</span><br><span class="line">                left: 0;</span><br><span class="line">                bottom:0;</span><br><span class="line">                right: 0;</span><br><span class="line">                margin: auto;</span><br><span class="line">                background-color: pink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#inner&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height:100px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left:50%;</span><br><span class="line">                margin-left: -50px;</span><br><span class="line">                margin-top: -50px;;</span><br><span class="line">                background-color: orange;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#outer,#inner&#123;</span></span><br><span class="line">                border-radius:50%;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">"inner"</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var parentDiv = document.getElementById(<span class="string">"outer"</span>);</span><br><span class="line">            parentDiv.addEventListener(<span class="string">"mouseover"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                console.log(<span class="string">"父div的mouseover事件被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseenter"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseenter事件被触发"</span>);</span><br><span class="line">            //&#125;,<span class="literal">false</span>);</span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseout"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseout事件被触发"</span>);</span><br><span class="line">            //&#125;, <span class="literal">false</span>);</span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseleave"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseleave事件被触发"</span>);</span><br><span class="line">            //&#125;, <span class="literal">false</span>);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>当<strong>鼠标从外面移入圆心</strong>，外面圆的<code>mouseover</code>事件被触发2次，第二次是<strong>里面圆的<code>mouseover</code>事件冒泡到外面圆</strong>而触发的。</p></li><li>当鼠标从外面移入圆心，外面圆的<code>mouseenter</code>事件被触发一次，因为<strong><code>mouseenter</code>事件不冒泡</strong>，鼠标移到后代元素不会触发。</li><li>另外，<code>mouseover</code>对应<code>mouseout</code>，<code>mouseenter</code>对应<code>mouseleave</code>。效果可以取消上面代码的注释来看。</li></ul><h5 id="鼠标左键和右键"><a href="#鼠标左键和右键" class="headerlink" title="鼠标左键和右键"></a>鼠标左键和右键</h5><ul><li>IE下鼠标的左键是1，右键是2。</li><li>ff和chrome下，鼠标左键是0，右键是2。</li><li>示例代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">document.onmousedown = <span class="keyword">function</span> (ev) &#123;</span><br><span class="line">    var oEvent = ev || event; //IE浏览器直接使用event或者window.event得到事件本身。</span><br><span class="line">    alert(oEvent.button); // IE下鼠标的 左键是1 ，  右键是2   ff和chrome下 鼠标左键是0  右键是2</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="mouseover和mousemove的区别"><a href="#mouseover和mousemove的区别" class="headerlink" title="mouseover和mousemove的区别"></a>mouseover和mousemove的区别</h5><ul><li><code>mousemove</code>事件通过鼠标在元素上移动来触发。事件处理函数会被传递一个事件对象event，<code>event.clientX</code>和 <code>event.clientY</code>属性代表鼠标的坐标。</li><li><code>mouseover</code>事件会在<strong>鼠标移入对象</strong>时触发。</li><li>一般情况下<code>mouseover</code>即可，特殊情况才用<code>mousemove</code>，因为<strong><code>mousemove</code>更耗资源</strong>，比如要<strong>监控鼠标坐标的变化</strong>等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;鼠标事件&quot;&gt;&lt;a href=&quot;#鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;鼠标事件&quot;&gt;&lt;/a&gt;鼠标事件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;DOM3级事件中定义了9个鼠标事件：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mousedown&lt;/code&gt;：&lt;stron
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（四）event的公共成员（属性和方法）</title>
    <link href="https://chongtianhong.github.io/2018/06/18/publicMembersOfEvent/"/>
    <id>https://chongtianhong.github.io/2018/06/18/publicMembersOfEvent/</id>
    <published>2018-06-18T12:34:43.000Z</published>
    <updated>2018-09-18T14:49:55.187Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件对象的公共成员"><a href="#事件对象的公共成员" class="headerlink" title="事件对象的公共成员"></a>事件对象的公共成员</h4><h5 id="DOM中的event的公共成员"><a href="#DOM中的event的公共成员" class="headerlink" title="DOM中的event的公共成员"></a>DOM中的event的公共成员</h5><ul><li><code>event</code>对象包含与<strong>创建它的特定事件有关</strong>的属性和方法。触发的事件类型不一样，可用的属性和方法不一样。但是，DOM中所有事件都有以下<strong>公共成员</strong>。【注意<code>bubbles</code>属性和<code>cancelable</code>属性】<a id="more"></a></li></ul><table><thead><tr><th style="text-align:center">属性/方法</th><th style="text-align:center">类型</th><th style="text-align:center">读/写</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">bubbles</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">表明事件是否冒泡</td></tr><tr><td style="text-align:center">stopPropagation()</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法</td></tr><tr><td style="text-align:center">stopImmediatePropagation()</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增）</td></tr><tr><td style="text-align:center">cancelable</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">表明是否可以取消事件的默认行为</td></tr><tr><td style="text-align:center">preventDefault()</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的默认行为。如果cancelable是true，则可以使用这个方法</td></tr><tr><td style="text-align:center">defaultPrevented</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">为true表示已经调用了preventDefault()(DOM3级事件中新增)</td></tr><tr><td style="text-align:center">currentTarget</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">其事件处理程序当前正在处理事件的那个元素（currentTarget始终===this，即处理事件的元素）</td></tr><tr><td style="text-align:center">target</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">直接事件目标，真正触发事件的目标</td></tr><tr><td style="text-align:center">detail</td><td style="text-align:center">Integer</td><td style="text-align:center">只读</td><td style="text-align:center">与事件相关的细节信息</td></tr><tr><td style="text-align:center">eventPhase</td><td style="text-align:center">Integer</td><td style="text-align:center">只读</td><td style="text-align:center">调用事件处理程序的阶段：1表示捕获阶段，2表示处于目标阶段，3表示冒泡阶段</td></tr><tr><td style="text-align:center">trusted</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">为true表示事件是由浏览器生成的。为false表示事件是由开发人员通过JavaScript创建的（DOM3级事件中新增）</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">String</td><td style="text-align:center">只读</td><td style="text-align:center">被触发的事件的类型</td></tr><tr><td style="text-align:center">view</td><td style="text-align:center">AbstractView</td><td style="text-align:center">只读</td><td style="text-align:center">关联</td></tr></tbody></table><blockquote>对比currentTarget和target</blockquote><ul><li>在事件处理程序内部，<strong>对象this始终等于currentTarget的值</strong>，而<strong>target则只是包含事件的实际目标</strong>。</li><li><p>举例：页面有个按钮，在body（按钮的父节点）中注册click事件，点按钮时click事件会<strong>冒泡到body进行处理</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        document.body.onclick = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"body中注册的click事件"</span>);</span><br><span class="line">            console.log(<span class="string">"this === event.currentTarget? "</span> + (this === event.currentTarget)); // <span class="literal">true</span></span><br><span class="line">            console.log(<span class="string">"currentTarget === document.body? "</span> + (event.currentTarget === document.body)); // <span class="literal">true</span></span><br><span class="line">            console.log(<span class="string">'event.target === document.getElementById("btn")? '</span> + (event.target === document.getElementById(<span class="string">"btn"</span>))); // <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body中注册的click事件</span><br><span class="line">this === event.currentTarget? <span class="literal">true</span> // this始终等于currentTarget</span><br><span class="line">currentTarget === document.body? <span class="literal">true</span> // 属于body上注册的事件，所以currentTarget为body</span><br><span class="line">event.target === document.getElementById(<span class="string">"btn"</span>)? <span class="literal">true</span> // 按钮触发的事件，所以target为button</span><br></pre></td></tr></table></figure></li></ul><blockquote>通过type属性，可以在一个函数中处理多个事件</blockquote><ul><li><strong>原理</strong>：通过检测<code>event.type</code>属性，对不同事件进行不同处理。</li><li><p><strong>举例</strong>：定义一个<code>handler</code>函数用来处理3种事件：click，mouseover，mouseout：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var handler = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            switch (event.type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">                    alert(<span class="string">"clicked"</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">                    event.target.style.backgroundColor = <span class="string">"pink"</span>;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">                    event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.onclick = handler;</span><br><span class="line">        btn.onmouseover = handler;</span><br><span class="line">        btn.onmouseout = handler;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行效果：</p><ul><li><strong>点击</strong>按钮，弹出框；</li><li>鼠标<strong>经过</strong>按钮，按钮背景色变为粉色；</li><li>鼠标<strong>离开</strong>按钮，按钮背景色恢复默认颜色。</li></ul></li></ul><blockquote>stopPropagation()和stopImmediatePropagation()对比</blockquote><ul><li><strong>同</strong>：<code>stopPropagation()</code>和<code>stopImmediatePropagation()</code>都可以用来<strong>取消事件的进一步捕获或冒泡</strong>。</li><li><strong>异</strong>：二者的区别在于<strong>当一个事件有多个事件处理程序时</strong>，<code>stopImmediatePropagation()</code>可以<strong>阻止之后事件处理程序被调用</strong>。</li><li><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"buttn click listened once"</span>);</span><br><span class="line">            // event.stopPropagation(); // 取消注释查看效果</span><br><span class="line">            // event.stopImmediatePropagation(); // 取消注释查看效果</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(<span class="string">"button click listened twice"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        document.body.onclick = <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"body clicked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>若不使用<code>stopPropagation()</code>和<code>stopImmediatePropagation()</code>，运行效果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buttn click listened once</span><br><span class="line">button click listened twice</span><br><span class="line">body clicked</span><br></pre></td></tr></table></figure></li><li><p>若给<strong>按钮的第一个事件处理程序</strong>添加<code>stopPropagation()</code>，将<strong>阻止事件进一步冒泡</strong>，所以body上的事件处理程序不被触发，运行效果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buttn click listened once</span><br><span class="line">button click listened twice</span><br></pre></td></tr></table></figure></li><li><p>若给<strong>按钮的第一个事件处理程序</strong>添加<code>stopImmediatePropagation()</code>，将<strong>阻止之后事件处理程序被调用</strong>，所以第二个事件处理程序不被触发，同时事件冒泡也被阻止，运行效果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buttn click listened once</span><br></pre></td></tr></table></figure></li></ul><blockquote>eventPhase</blockquote><ul><li><code>eventPhase</code>值在<strong>捕获阶段</strong>为1，处于<strong>目标阶段</strong>为2，<strong>冒泡阶段</strong>为3。</li></ul><table><thead><tr><th style="text-align:center">常量</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">Event.CAPTURING_PHASE</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Event.AT_TARGET</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Event.BUBBLING_PHASE</td><td style="text-align:center">3</td></tr></tbody></table><ul><li><p>可以通过下面代码查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">btn.onclick = <span class="keyword">function</span> (event) &#123;</span><br><span class="line">console.log(event.CAPTURING_PHASE); // 1</span><br><span class="line">console.log(event.AT_TARGET); // 2</span><br><span class="line">console.log(event.BUBBLING_PHASE); // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.onclick = <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"按钮DOM0级方法添加事件处理程序eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为true时eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为false时eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">            document.body.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">                console.log(<span class="string">"body上添加事件处理程序，且在捕获阶段eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        document.body.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"body上添加事件处理程序，且在冒泡阶段eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">body上添加事件处理程序，且在捕获阶段eventPhase值为？1</span><br><span class="line">按钮DOM0级方法添加事件处理程序eventPhase值为？2</span><br><span class="line">按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为<span class="literal">true</span>时eventPhase值为？2</span><br><span class="line">按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为<span class="literal">false</span>时eventPhase值为？2</span><br><span class="line">body上添加事件处理程序，且在冒泡阶段eventPhase值为？3</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">捕获阶段调用事件处理程序，eventPhase值为1</span><br><span class="line">处于目标阶段，eventPhase值为2</span><br><span class="line">冒泡阶段调用事件处理程序，eventPhase值为3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><h5 id="IE中event的公共成员"><a href="#IE中event的公共成员" class="headerlink" title="IE中event的公共成员"></a>IE中event的公共成员</h5><ul><li>IE中的event的属性和方法和DOM一样会随着事件类型的不同而不同，但是也有一些是所有对象都有的公共成员，且这些成员大部分有对应的DOM属性或方法。</li></ul><table><thead><tr><th style="text-align:center">属性/方法</th><th style="text-align:center">类型</th><th style="text-align:center">读/写</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">cancelBubble</td><td style="text-align:center">Boolean</td><td style="text-align:center">读/写</td><td style="text-align:center">默认为false，但将其设置为true就可以取消事件冒泡（与DOM中stopPropagation()方法的作用相同）</td></tr><tr><td style="text-align:center">returnValue()</td><td style="text-align:center">Boolean</td><td style="text-align:center">读/写</td><td style="text-align:center">默认为true，但将其设置为false就可以取消事件的默认行为（与DOM中的preventDefault()方法的作用相同）</td></tr><tr><td style="text-align:center">srcElement()</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">事件的目标（与DOM中的target属性相同）</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">String</td><td style="text-align:center">只读</td><td style="text-align:center">被触发的事件的类型</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件对象的公共成员&quot;&gt;&lt;a href=&quot;#事件对象的公共成员&quot; class=&quot;headerlink&quot; title=&quot;事件对象的公共成员&quot;&gt;&lt;/a&gt;事件对象的公共成员&lt;/h4&gt;&lt;h5 id=&quot;DOM中的event的公共成员&quot;&gt;&lt;a href=&quot;#DOM中的event的公共成员&quot; class=&quot;headerlink&quot; title=&quot;DOM中的event的公共成员&quot;&gt;&lt;/a&gt;DOM中的event的公共成员&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;event&lt;/code&gt;对象包含与&lt;strong&gt;创建它的特定事件有关&lt;/strong&gt;的属性和方法。触发的事件类型不一样，可用的属性和方法不一样。但是，DOM中所有事件都有以下&lt;strong&gt;公共成员&lt;/strong&gt;。【注意&lt;code&gt;bubbles&lt;/code&gt;属性和&lt;code&gt;cancelable&lt;/code&gt;属性】
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（三）事件对象</title>
    <link href="https://chongtianhong.github.io/2018/06/17/eventObject/"/>
    <id>https://chongtianhong.github.io/2018/06/17/eventObject/</id>
    <published>2018-06-17T05:15:29.000Z</published>
    <updated>2018-09-17T15:13:21.008Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><ul><li>在<strong>触发DOM上的事件时</strong>都会<strong>产生一个对象</strong>，这个对象则称为<strong>事件对象</strong>。<a id="more"></a></li></ul><h5 id="认识事件对象"><a href="#认识事件对象" class="headerlink" title="认识事件对象"></a>认识事件对象</h5><ul><li>事件<strong>在浏览器中</strong>是<strong>以对象的形式存在</strong>的，即<strong>event</strong>。触发一个事件，就会产生一个事件对象event，<strong>该对象包含着所有与事件有关的信息</strong>。包括<strong>导致事件的元素</strong>、<strong>事件的类型</strong>以及其他<strong>与特定事件相关的信息</strong>。</li><li>例如：<strong>鼠标操作</strong>产生的event中会<strong>包含鼠标位置的信息</strong>；<strong>键盘操作</strong>产生的event中会<strong>包含与按下的键有关的信息</strong>。</li><li>所有浏览器都支持event对象，但支持方式不同，在DOM中<strong>event对象必须作为唯一的参数传给事件处理函数</strong>，在IE中<strong>event是window对象的一个属性</strong>。</li></ul><h5 id="html事件处理程序中event"><a href="#html事件处理程序中event" class="headerlink" title="html事件处理程序中event"></a>html事件处理程序中event</h5><ul><li><p>下面的例子会创建一个包含局部变量event的函数。可通过event直接访问事件对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span> onclick=<span class="string">"console.log('html事件处理程序'+event.type)"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li><p>当点击input按钮时，控制台将输出<code>html事件处理程序click</code>。</p></li></ul><h5 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h5><ul><li><strong>DOM0级</strong>和<strong>DOM2级</strong>事件处理程序都会<strong>把event作为参数传入</strong>。</li><li><p><strong>根据习惯来：可以用e，或者ev或者event</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.onclick = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"DOM0 &amp; click"</span>);</span><br><span class="line">            console.log(event.type);    // click</span><br><span class="line">        &#125;</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"DOM2 &amp; click"</span>);</span><br><span class="line">            console.log(event.type);    // click</span><br><span class="line">        &#125;,<span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>DOM中事件对象重要<strong>属性和方法</strong>总结如下：</p><ul><li><strong>属性</strong>：<br>①<code>type</code>属性，用于<strong>获取事件类型</strong>。<br>②<code>target</code>属性，用于<strong>获取事件目标事件加在哪个元素上</strong>。（更具体target.nodeName）</li><li><strong>方法</strong>：<br>①<code>stopPropagation()</code>方法用于<strong>阻止事件冒泡</strong>。<br>②<code>preventDefault()</code>方法<strong>阻止事件的默认行为</strong>(移动端用的多)。</li></ul></li></ul><h5 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h5><ul><li><p>第一种情况：通过<strong>DOM0级</strong>方法添加事件处理程序时，<strong>event对象作为window对象的一个属性</strong>存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">    btn.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var event = window.event;</span><br><span class="line">       console.log(event.type); // click</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二种情况：通过<code>attachEvent()</code>添加的事件处理程序，<strong>event对象作为参数传入</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">    btn.attachEvent(<span class="string">"onclick"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">        console.log(event.type); // click</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>IE中事件对象<strong>重要属性</strong>总结如下：</p><ul><li><p><strong>属性</strong>：<br>①<code>type</code>属性，用于<strong>获取事件类型</strong>。<br>②<code>srcElement</code>属性，用于<strong>获取事件目标事件加在哪个元素上</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//兼容性处理</span><br><span class="line"><span class="keyword">function</span> showMsg(event)&#123;</span><br><span class="line">    event = event || window.event; // IE8以前必须是通过window获取event，DOM中就是个简单的传参</span><br><span class="line">    var ele = event.target || event.srcElement; // 获取目标元素，DOM中用target，IE中用srcElement</span><br><span class="line">    alert(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③<code>cancelBubble</code>属性用于<strong>阻止事件冒泡</strong>。IE中<code>cancelBubble</code>为属性而不是方法，<strong>true表示阻止冒泡</strong>。<br>④<code>returnValue</code>属性<strong>阻止事件的默认行为</strong>，<code>false</code>表示<strong>阻止事件的默认行为</strong>。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件对象&quot;&gt;&lt;a href=&quot;#事件对象&quot; class=&quot;headerlink&quot; title=&quot;事件对象&quot;&gt;&lt;/a&gt;事件对象&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;触发DOM上的事件时&lt;/strong&gt;都会&lt;strong&gt;产生一个对象&lt;/strong&gt;，这个对象则称为&lt;strong&gt;事件对象&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（二）事件处理程序</title>
    <link href="https://chongtianhong.github.io/2018/06/16/eventHandler/"/>
    <id>https://chongtianhong.github.io/2018/06/16/eventHandler/</id>
    <published>2018-06-16T03:44:32.000Z</published>
    <updated>2018-09-15T14:09:01.151Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><ul><li><a href="http://xbhong.top/2018/06/15/eventFlow/#more" target="_blank" rel="noopener">JavaScript事件（一）事件流</a>中提到，事件是<strong>用户</strong>或<strong>浏览器自身</strong>执行的某种动作，如<code>click</code>，<code>load</code>和<code>mouseover</code>都是事件的名字。</li><li><strong>响应某个事件的函数</strong>就叫<strong>事件处理程序</strong>（也叫事件处理函数、事件句柄）。<a id="more"></a></li><li>事件处理程序的名字以”on”开头，因此<code>click</code>事件的事件处理程序就是<strong>onclick</strong>，<code>load</code>事件的事件处理程序就是<strong>onload</strong>。</li><li><strong>为事件指定事件处理程序的方法</strong>主要有3种，分别是<strong>HTML事件处理程序</strong>、<strong>DOM0级事件处理程序</strong>和<strong>DOM2级事件处理程序</strong>。</li></ul><h5 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h5><ul><li>事件直接加在HTML元素上。这种方式也有两种方法，都很简单：</li><li><p>第一种：直接<strong>在HTML元素中定义事件处理程序及包含的动作</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span> onclick=<span class="string">"alert('clicked!')"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二种：HTML元素中定义事件处理程序，<strong>执行的动作</strong>则<strong>调用其他地方定义的脚本</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span> onclick=<span class="string">"showMessage()"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">showMessage</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>知识点：<br>1）通过<strong>event变量</strong>可以<strong>直接访问事件本身</strong>，比如<code>onclick=”alert(event.type)”</code>会弹出<code>click</code>事件。<br>2）<strong>this值等于事件的目标元素</strong>，这里目标元素是input。比如<code>onclick=”alert(this.value)”</code>可以得到input元素的value值。</p></li></ul><h5 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h5><ul><li>把一个<strong>函数赋值</strong>给一个<strong>事件处理程序属性</strong>。**</li><li>这种方法简单而且跨浏览器，但是<strong>只能为一个元素添加一个事件处理函数</strong>，即这种方法<strong>无法为元素添加多个相同事件的事件处理函数</strong>，则<strong>后面的会覆盖前面的</strong>。</li><li><p><strong>添加</strong>事件处理程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">/*</span><br><span class="line">    第一步：myBtn = document.getElementById(<span class="string">"myBtn"</span>);取得btn对象</span><br><span class="line">    第二步：myBtn.onclick其实相当于给myBtn添加了一个onclick的属性。</span><br><span class="line">    第三步：myBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    把函数赋值给onclick事件处理程序属性。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong>事件处理程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myBtn.onclick = null;</span><br></pre></td></tr></table></figure></li></ul><h5 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h5><ul><li>DOM2级事件处理程序可以<strong>为一个元素添加多个事件处理程序</strong>。其定义了两个方法用于添加和删除事件处理程序：<code>addEventListener()</code>和<code>removeEventListener()</code>。</li><li><strong>所有的DOM节点都包含这2个方法</strong>。</li><li>这两个方法都需要3个参数：<strong>事件名</strong>，<strong>事件处理函数</strong>，<strong>布尔值</strong>。布尔值为<code>true</code>时，在捕获阶段处理事件；为<code>false</code>时，在冒泡阶段处理事件。布尔值默认为<code>false</code>。</li><li><p><strong>添加事件处理程序</strong>：现在为按钮添加两个事件处理函数，一个弹出“hello”，一个弹出“world”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"world"</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除事件处理程序</strong>：通过<code>addEventListener()</code>添加的事件处理程序必须通过<code>removeEventListener()</code>删除，且<strong>参数一致</strong>。</p></li><li><p><strong>注意</strong>：通过<code>addEventListener()</code>添加的<strong>匿名函数将无法删除</strong>。下面这段代码将不起作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myBtn.removeEventListener(<span class="string">"click"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(<span class="string">"world"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>看似该<code>removeEventListener()</code>与上面的<code>addEventListener()</code>参数一致，实则<strong>第二个参数中匿名函数是完全不同的</strong>。所以<strong>为了能删除事件处理程序</strong>，代码可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handler = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">    myBtn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4><h5 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h5><ul><li><strong>IE8及以下浏览器不支持<code>addEventListener()</code></strong>，在实际开发中如果要兼容到IE8及以下浏览器。</li><li><p>如果用原生的绑定事件，需要做兼容处理，可利用jquery的bind代替。语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).<span class="built_in">bind</span>(event, data, <span class="keyword">function</span>)</span><br></pre></td></tr></table></figure></li><li><p>其中：</p><ul><li><code>event</code>是必需的。规定添加到元素的一个或多个事件。可由空格分隔多个事件。必须是有效的事件。</li><li><code>data</code>是可选的。规定传递到函数的额外数据。</li><li><code>function</code>是必需的。规定当事件发生时运行的函数。</li></ul></li><li>例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).<span class="built_in">bind</span>(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    $(<span class="string">"p"</span>).slideToggle();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h5 id="IE8事件绑定"><a href="#IE8事件绑定" class="headerlink" title="IE8事件绑定"></a>IE8事件绑定</h5><ul><li>IE8及以下版本浏览器实现了与DOM中类似的两个方法：<code>attachEvent()</code>和<code>detachEvent()</code>。</li><li>这两个方法都需要两个参数：<strong>事件处理程序名称</strong>和<strong>事件处理程序函数</strong>。由于<strong>IE8及更早版本只支持事件冒泡</strong>，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。</li><li><strong>注意</strong>是<strong>事件处理程序名称</strong>而不是事件名称，所以要加上on，是<strong>onclick</strong>而不是click。</li><li>知识点：<ul><li>IE11只支持<code>addEventListener</code>。</li><li>IE9，IE10对<code>attachEvent</code>和<code>addEventListener</code>都支持。</li><li>IE8及以下版本只支持<code>attachEvent</code>。</li></ul></li><li><p>可以拿下面代码在IE各个版本浏览器中进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handlerIE = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"helloIE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    var handlerDOM = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(<span class="string">"helloDOM"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, handlerDOM, <span class="literal">false</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, handlerIE);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加事件处理程序</strong>：现在为按钮添加两个事件处理函数，一个弹出<code>“hello”</code>，一个弹出<code>“world”</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"world"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>这里运行效果值得注意一下：</p><ul><li><strong>IE8以下浏览器</strong>中先弹出“world”，再弹出“hello”。<strong>和DOM中事件触发顺序相反</strong>。</li><li><strong>IE9及以上浏览器</strong>先弹出“hello”，再弹出“world”。<strong>和DOM中事件触发顺序相同</strong>。</li></ul></li><li><strong>删除事件处理程序</strong>：通过<code>attachEvent</code>添加的事件处理程序必须通过<code>detachEvent</code>方法删除，且参数一致。</li><li><p>和DOM事件一样，<strong>添加的匿名函数将无法删除</strong>。所以为了能删除事件处理程序，代码可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handler = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">    myBtn.detachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>IE事件处理程序</strong>中还有一个地方需要注意：<strong>作用域</strong>。</p></li><li>使用<code>attachEvent</code>方法，事件处理程序会在全局作用域中运行，因此<strong>this等于window</strong>。在编写跨浏览器的代码时，需牢记这点。</li><li>而<strong>DOM2</strong>或<strong>DOM0</strong>级的方法<strong>作用域都是在元素内部，this值为目标元素</strong>。</li><li>下面例子会弹出true：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(this === window);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件处理程序&quot;&gt;&lt;a href=&quot;#事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;事件处理程序&quot;&gt;&lt;/a&gt;事件处理程序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://xbhong.top/2018/06/15/eventFlow/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript事件（一）事件流&lt;/a&gt;中提到，事件是&lt;strong&gt;用户&lt;/strong&gt;或&lt;strong&gt;浏览器自身&lt;/strong&gt;执行的某种动作，如&lt;code&gt;click&lt;/code&gt;，&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;mouseover&lt;/code&gt;都是事件的名字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应某个事件的函数&lt;/strong&gt;就叫&lt;strong&gt;事件处理程序&lt;/strong&gt;（也叫事件处理函数、事件句柄）。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>通过cookie在HTML页面间跳转传值</title>
    <link href="https://chongtianhong.github.io/2018/06/15/passValuesByCookieBThtmlPages/"/>
    <id>https://chongtianhong.github.io/2018/06/15/passValuesByCookieBThtmlPages/</id>
    <published>2018-06-15T05:50:22.000Z</published>
    <updated>2018-09-25T13:35:18.331Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>静态页面间如何跳转传值？我在网上搜索后发现方法有几种：<br>① 通过 url 携带数据<br>② 通过 cookie<br>③ 通过 html5 的 sessionStorage 或 localStorage</li><li>本文总结了<strong>通过 cookie</strong>的方法。<a id="more"></a></li><li>Cookie是<strong>浏览器存储</strong>少量命名数据，它<strong>与某个特定的网页或网站关联</strong>在一起.</li><li>Cookie用来<strong>给浏览器提供内存</strong>，以便<strong>脚本和服务器程序</strong>可以<strong>在一个页面中使用另一个页面的输入数据</strong>。</li></ul><h4 id="场景及实现"><a href="#场景及实现" class="headerlink" title="场景及实现"></a>场景及实现</h4><ul><li>假设有 Post.htm、Read.htm 两个页面，Read.htm 将通过 cookie 使用 Post.htm 页面的数据。</li><li><p>先看 Post.htm 页面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"txt1"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"Post"</span>&gt;</span><br><span class="line">&lt;script language=<span class="string">"javascript"</span> &gt;</span><br><span class="line">    <span class="keyword">function</span> setCookie(name, value) &#123;</span><br><span class="line">        /*</span><br><span class="line">        *--------------- setCookie(name, value) -----------------</span><br><span class="line">        * setCookie(name, value)</span><br><span class="line">        * 功能：设置变量name的值</span><br><span class="line">        * 参数：name,字符串; value,字符串.</span><br><span class="line">        * 实例：setCookie(<span class="string">'username'</span>, <span class="string">'baobao'</span>)</span><br><span class="line">        *--------------- setCookie(name, value) -----------------</span><br><span class="line">        */</span><br><span class="line">        var Days = 30; // 此 cookie 将被保存 30 天</span><br><span class="line">        var exp　= new Date();</span><br><span class="line">        exp.setTime(exp.getTime() + Days*24*60*60*1000);</span><br><span class="line">        document.cookie = name + <span class="string">"="</span>+ escape (value) + <span class="string">";expires="</span> + exp.toGMTString();</span><br><span class="line">        location.href = <span class="string">"Read.htm"</span>; //接收页面.</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>接着看 Read.htm 页面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span> &gt;</span><br><span class="line">    <span class="keyword">function</span> getCookie(name) &#123;</span><br><span class="line">        /*</span><br><span class="line">        *--------------- getCookie(name) -----------------</span><br><span class="line">        * getCookie(name)</span><br><span class="line">        * 功能：取得变量name的值</span><br><span class="line">        * 参数：name, 字符串</span><br><span class="line">        * 实例：alert(getCookie(<span class="string">"baobao"</span>));</span><br><span class="line">        *--------------- getCookie(name) -----------------</span><br><span class="line">        */</span><br><span class="line">        var arr = document.cookie.match(new RegExp(<span class="string">"(^| )"</span>+name+<span class="string">"=([^;]*)(;|$)"</span>));</span><br><span class="line">        <span class="keyword">if</span>(arr != null)&#123;</span><br><span class="line">            <span class="built_in">return</span> unescape(arr[2]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(getCookie(<span class="string">"baobao"</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>通过 cookie</strong>的方法优点是<strong>可以在同源内的任意网页内访问</strong>，生命期可以设置。</li><li>缺点是<strong>值长度有限制</strong>（cookie大小限制导致）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;静态页面间如何跳转传值？我在网上搜索后发现方法有几种：&lt;br&gt;① 通过 url 携带数据&lt;br&gt;② 通过 cookie&lt;br&gt;③ 通过 html5 的 sessionStorage 或 localStorage&lt;/li&gt;
&lt;li&gt;本文总结了&lt;strong&gt;通过 cookie&lt;/strong&gt;的方法。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Cookie" scheme="https://chongtianhong.github.io/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（一）事件流</title>
    <link href="https://chongtianhong.github.io/2018/06/15/eventFlow/"/>
    <id>https://chongtianhong.github.io/2018/06/15/eventFlow/</id>
    <published>2018-06-15T02:09:33.000Z</published>
    <updated>2018-09-14T14:37:09.371Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul><li>事件是在<strong>文档</strong>或者<strong>浏览器窗口</strong>中发生的，特定的交互瞬间。</li><li>事件是<strong>用户</strong>或<strong>浏览器自身</strong>执行的某种动作，如<code>click</code>，<code>load</code>和<code>mouseover</code>都是事件的名字。<a id="more"></a></li><li>事件是<strong>JavaScript</strong>和<strong>DOM</strong>之间<strong>交互的桥梁</strong>。</li><li>事件发生，调用它的处理函数执行相应的JavaScript代码给出响应（你若触发，我便执行）。</li><li>典型的例子有：<strong>页面加载完毕</strong>触发<code>load</code>事件；<strong>用户单击元素</strong>触发<code>click</code>事件。</li></ul><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><ul><li>事件流描述的是<strong>从页面中接收事件的顺序</strong>。</li></ul><h5 id="事件流感性认识"><a href="#事件流感性认识" class="headerlink" title="事件流感性认识"></a>事件流感性认识</h5><ul><li><strong>问题</strong>：单击页面元素，什么样的元素能感应到这样一个事件？</li><li><strong>答案</strong>：单击元素的同时，也单击了元素的容器元素，甚至整个页面。</li><li><strong>例子</strong>：有三个同心圆， 给每个圆添加对应的事件处理函数，弹出对应的文字。单击最里面的圆，同时也单击了外面的圆，所以外面圆的<code>click</code>事件也会被触发。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="comment">#outer&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 400px;</span><br><span class="line">                height: 400px;</span><br><span class="line">                top:0;</span><br><span class="line">                left: 0;</span><br><span class="line">                bottom:0;</span><br><span class="line">                right: 0;</span><br><span class="line">                margin: auto;</span><br><span class="line">                background-color: deeppink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#middle&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height:300px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left: 50%;</span><br><span class="line">                margin-left: -150px;</span><br><span class="line">                margin-top: -150px;</span><br><span class="line">                background-color: deepskyblue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#inner&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height:100px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left:50%;</span><br><span class="line">                margin-left: -50px;</span><br><span class="line">                margin-top: -50px;;</span><br><span class="line">                background-color: darkgreen;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">                color:white;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#outer,#middle,#inner&#123;</span></span><br><span class="line">                border-radius:100%;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">            &lt;div id=<span class="string">"middle"</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">"inner"</span>&gt;</span><br><span class="line">                    click me!</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var innerCircle = document.getElementById(<span class="string">"inner"</span>);</span><br><span class="line">            innerCircle.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"innerCircle"</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            var middleCircle = document.getElementById(<span class="string">"middle"</span>);</span><br><span class="line">            middleCircle.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                alert(<span class="string">"middleCircle"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            var outerCircle = document.getElementById(<span class="string">"outer"</span>);</span><br><span class="line">            outerCircle.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"outerCircle"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="事件流-1"><a href="#事件流-1" class="headerlink" title="事件流"></a>事件流</h5><ul><li>事件发生时会在<strong>元素节点</strong>与<strong>根节点</strong>之间<strong>按照特定的顺序传播</strong>，<strong>路径所经过的所有节点</strong>都会<strong>收到该事件</strong>，这个传播过程即<strong>DOM事件流</strong>。</li></ul><h6 id="两种事件流模型"><a href="#两种事件流模型" class="headerlink" title="两种事件流模型"></a>两种事件流模型</h6><ul><li><strong>事件传播的顺序</strong>对应<strong>浏览器的两种事件流模型</strong>：<strong>捕获型</strong>事件流和<strong>冒泡型</strong>事件流。</li><li><strong>冒泡型</strong>事件流：事件的传播是从<strong>最特定的事件目标</strong>到最不特定的事件目标。即从DOM树的叶子到根。【推荐】</li><li><strong>捕获型</strong>事件流：事件的传播是从<strong>最不特定的事件目标</strong>到最特定的事件目标。即从DOM树的根到叶子。</li><li><p><strong>事件捕获</strong>的思想就是<strong>不太具体的节点应该更早接收到事件</strong>，而<strong>最具体的节点最后接收到事件</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"myDiv"</span>&gt;Click me!&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>上面这段html代码中，单击了页面中的&lt;div&gt;元素，</p></li><li>在<strong>冒泡型事件流</strong>中<code>click</code>事件传播顺序为：&lt;div&gt;—》&lt;body&gt;—》&lt;html&gt;—》document</li><li>在<strong>捕获型事件流</strong>中<code>click</code>事件传播顺序为：document—》&lt;html&gt;—》&lt;body&gt;—》&lt;div&gt;<br><img src="/images/eventflow1.png" alt="两种事件流模型" width="600" style="border:none"></li><li>总结：<br>1）<strong>所有现代浏览器都支持事件冒泡</strong>，但在<strong>具体实现中略有差别</strong>：<br>IE5.5及更早版本中事件冒泡会跳过<html>元素(从body直接跳到document)。<br>IE9、Firefox、Chrome、和Safari则将事件一直冒泡到window对象。<br>2）IE9、Firefox、Chrome、Opera、和Safari都支持事件捕获。尽管DOM标准要求事件应该从document对象开始传播，但这些浏览器<strong>都是从window对象开始捕获事件的</strong>。<br>3）由于老版本浏览器不支持，很少有人使用事件捕获。<strong>建议使用事件冒泡</strong>。</html></li></ul><h6 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h6><ul><li>DOM标准采用<strong>捕获+冒泡</strong>。两种事件流都会触发DOM的所有对象，<strong>从document对象开始</strong>，也<strong>在document对象结束</strong>。<br><img src="/images/eventflow2.png" alt="DOM事件流" width="400" style="border:none"></li><li>DOM标准规定<strong>事件流包括三个阶段</strong>：事件捕获阶段、处于目标阶段和事件冒泡阶段。<ul><li><strong>事件捕获阶段</strong>：实际目标（&lt;div&gt;）在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。上图中为1~3。</li><li><strong>处于目标阶段</strong>：事件在&lt;div&gt;上发生并处理。<strong>绑定在目标元素上的事件按绑定顺序依次触发</strong>。</li><li><strong>冒泡阶段</strong>：事件又传播回文档。</li></ul></li><li><strong>注意</strong>：并非所有的事件都会经过冒泡阶段。<strong>所有的事件</strong>都要经过<strong>捕获阶段</strong>和<strong>处于目标阶段</strong>，但是<strong>有些事件会跳过冒泡阶段</strong>：如，获得输入焦点的<code>focus</code>事件和失去输入焦点的<code>blur</code>事件。</li><li><p>DOM事件流例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="comment">#outer&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 400px;</span><br><span class="line">                height: 400px;</span><br><span class="line">                top:0;</span><br><span class="line">                left: 0;</span><br><span class="line">                bottom:0;</span><br><span class="line">                right: 0;</span><br><span class="line">                margin: auto;</span><br><span class="line">                background-color: deeppink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#middle&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 300px;</span><br><span class="line">                height:300px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left: 50%;</span><br><span class="line">                margin-left: -150px;</span><br><span class="line">                margin-top: -150px;</span><br><span class="line">                background-color: deepskyblue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#inner&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height:100px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left:50%;</span><br><span class="line">                margin-left: -50px;</span><br><span class="line">                margin-top: -50px;;</span><br><span class="line">                background-color: darkgreen;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">                color:white;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#outer,#middle,#inner&#123;</span></span><br><span class="line">                border-radius:100%;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">            &lt;div id=<span class="string">"middle"</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">"inner"</span>&gt;click me!&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var innerCircle = document.getElementById(<span class="string">"inner"</span>);</span><br><span class="line">            innerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"innerCircle的click事件在捕获阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            innerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"innerCircle的click事件在冒泡阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line">            var middleCircle = document.getElementById(<span class="string">"middle"</span>);</span><br><span class="line">            middleCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"middleCircle的click事件在捕获阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            middleCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"middleCircle的click事件在冒泡阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line">            var outerCircle = document.getElementById(<span class="string">"outer"</span>);</span><br><span class="line">            outerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"outerCircle的click事件在捕获阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            outerCircle.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                alert(<span class="string">"outerCircle的click事件在冒泡阶段被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>当点击id为inner的圆时，运行效果就是会陆续弹出6个框，结果如下图所示：<br><img src="/images/eventflow3.png" alt="运行结果" width="600" style="border:none"></p><h6 id="事件流的典型应用：事件代理"><a href="#事件流的典型应用：事件代理" class="headerlink" title="事件流的典型应用：事件代理"></a>事件流的典型应用：事件代理</h6></li><li><strong>传统的事件处理</strong>中，需要为<strong>每个元素</strong>添加事件处理器。</li><li>JS<strong>事件代理</strong>则是一种简单有效的技巧，通过它可以<strong>把事件处理器添加到一个父级元素上</strong>，从而<strong>避免把事件处理器添加到多个子级元素上</strong>。</li></ul><blockquote>事件代理</blockquote><ul><li><strong>事件代理的原理</strong>用到的就是事件冒泡和目标元素，<strong>把事件处理器添加到父元素，等待子元素事件冒泡</strong>，并<strong>且父元素能够通过target（IE为srcElement）判断是哪个子元素</strong>，从而<strong>做相应处理</strong>。</li><li><p><strong>传统事件处理</strong>，为每个元素添加事件处理器，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul id=<span class="string">"color-list"</span>&gt;</span><br><span class="line">        &lt;li&gt;red&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;orange&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;yellow&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;green&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;blue&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;indigo&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;purple&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            var colorList = document.getElementById(<span class="string">"color-list"</span>);</span><br><span class="line">            var colors = colorList.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line">            <span class="keyword">for</span>(var i  = 0; i &lt; colors.length; i++) &#123;</span><br><span class="line">                colors[i].addEventListener(<span class="string">'click'</span>, showColor, <span class="literal">false</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">function</span> showColor(e) &#123;</span><br><span class="line">                e = e || window.event;</span><br><span class="line">                var targetElement = e.target || e.srcElement;</span><br><span class="line">                alert(targetElement.innerHTML);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>事件代理</strong>的处理方式，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul id=<span class="string">"color-list"</span>&gt;</span><br><span class="line">        &lt;li&gt;red&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;orange&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;yellow&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;green&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;blue&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;indigo&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;purple&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            var colorList = document.getElementById(<span class="string">"color-list"</span>);</span><br><span class="line">            colorList.addEventListener(<span class="string">'click'</span>, showColor, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">function</span> showColor(e) &#123;</span><br><span class="line">                e = e || window.event;</span><br><span class="line">                var targetElement = e.target || e.srcElement;</span><br><span class="line">                <span class="keyword">if</span>(targetElement.nodeName.toLowerCase() === <span class="string">"li"</span>)&#123;</span><br><span class="line">                    alert(targetElement.innerHTML);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>事件代理的好处</blockquote><ul><li>在<strong>传统的事件处理</strong>中，需要<strong>为每一个元素添加</strong>或者是<strong>删除事件处理器</strong>。然而，事件处理器<strong>将有可能导致内存泄露或者是性能下降</strong>（用得越多这种风险就越大）。</li><li><strong>事件代理的好处</strong>总结如下：<ul><li><strong>将多个事件处理器减少到一个</strong>，因为事件处理器要驻留内存，这样就<strong>提高了性能</strong>。想象如果有一个100行的表格，对比传统的为每个单元格绑定事件处理器的方式和事件代理（即table上添加一个事件处理器），不难得出结论，事件代理确实避免了一些潜在的风险，提高了性能。</li><li><strong>DOM更新无需重新绑定事件处理器</strong>，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a, span, div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历。</li></ul></li></ul><blockquote>事件代理的问题</blockquote><ul><li><p>代码如下：事件代理同时绑定了li和span，当点击span的时候，li和span都会冒泡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;</span><br><span class="line">    &lt;span&gt;li中的span的内容&lt;/span&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(document).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">        alert(<span class="string">'li li'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(document).on(<span class="string">'click'</span>, <span class="string">'span'</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">        alert(<span class="string">'li span'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>解决方法一：span的事件处理程序中阻止冒泡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(<span class="string">'click'</span>, <span class="string">'span'</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">    alert(<span class="string">'li span'</span>);</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>解决方法二：li的事件处理程序中检测target元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.target.nodeName == <span class="string">'SPAN'</span>) &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">'li li'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote>事件代理的一个有趣应用</blockquote><ul><li>点击一个列表时，输出对应的索引：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var ul = document.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">    var lis = ul.querySelectorAll(<span class="string">'ul li'</span>);</span><br><span class="line">    ul.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">        var target = e.target;</span><br><span class="line">        <span class="keyword">if</span>(target.nodeName.toUpperCase() === <span class="string">'LI'</span>)&#123;</span><br><span class="line">            alert([].indexOf.call(lis, target));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><div class="note info">参考链接：<a href="http://www.cnblogs.com/starof/p/4066381.html" target="_blank" rel="noopener">http://www.cnblogs.com/starof/p/4066381.html</a></div>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;事件是在&lt;strong&gt;文档&lt;/strong&gt;或者&lt;strong&gt;浏览器窗口&lt;/strong&gt;中发生的，特定的交互瞬间。&lt;/li&gt;
&lt;li&gt;事件是&lt;strong&gt;用户&lt;/strong&gt;或&lt;strong&gt;浏览器自身&lt;/strong&gt;执行的某种动作，如&lt;code&gt;click&lt;/code&gt;，&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;mouseover&lt;/code&gt;都是事件的名字。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Cookie知识点整理</title>
    <link href="https://chongtianhong.github.io/2018/06/14/cookie/"/>
    <id>https://chongtianhong.github.io/2018/06/14/cookie/</id>
    <published>2018-06-14T11:40:07.000Z</published>
    <updated>2018-09-13T15:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Cookie 是<strong>服务器保存在浏览器</strong>的一小段文本信息。<strong>浏览器每次向服务器发出请求</strong>，就会<strong>自动附上这段信息</strong>。<a id="more"></a></li></ul><h5 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h5><ul><li>Cookie 主要用来<strong>分辨两个请求是否来自同一个浏览器</strong>。</li><li>Cookie 可用来<strong>保存一些状态信息</strong>，例如：<ul><li>对话（session）管理：保存<strong>登录</strong>、<strong>购物车</strong>等需要记录的信息。</li><li>个性化：<strong>保存用户的偏好</strong>，比如网页的字体大小、背景色等等。</li><li>追踪：<strong>记录和分析用户行为</strong>。</li></ul></li><li><strong>不推荐</strong>使用Cookie作为<strong>客户端存储</strong>，原因：<ul><li>它的容量很小（4KB）</li><li>缺乏数据操作接口</li><li>影响性能</li></ul></li><li>客户端储存应该使用<strong>Web storage API</strong>和<strong>IndexedDB</strong>。</li></ul><h5 id="Cookie的组成"><a href="#Cookie的组成" class="headerlink" title="Cookie的组成"></a>Cookie的组成</h5><ul><li>Cookie 包含以下几方面的信息：<ul><li>Cookie 的<strong>名字Name</strong></li><li>Cookie 的<strong>值Value</strong>（真正的数据写在这里面）(1、2两点就是键值对)</li><li><strong>到期时间Expire</strong>[属性]</li><li><strong>所属域名Domain</strong>（默认是当前域名）[属性]</li><li><strong>生效的路径Path</strong>（默认是当前网址）[属性]</li><li>Cookie 的<strong>容量</strong>[属性]</li></ul></li></ul><h5 id="Cookie的作用过程"><a href="#Cookie的作用过程" class="headerlink" title="Cookie的作用过程"></a>Cookie的作用过程</h5><ul><li>举例来说：<ul><li>当用户访问网址<code>www.example.com</code>，<strong>服务器</strong>就会<strong>在浏览器写入一个 Cookie</strong>。这个<strong>Cookie</strong>就会<strong>包含</strong><code>www.example.com</code>这个<strong>域名</strong>，以及<strong>根路径</strong>。(这意味着，这个 Cookie 对该域名的根路径和它的所有子路径都有效。如果路径设为/forums，那么这个 Cookie 只有在访问www.example.com/forums及其子路径时才有效。)</li><li>浏览器存储了Cookie以后，一旦<strong>再次访问</strong>这个<strong>路径</strong>，<strong>浏览器就会附上这段 Cookie 发送给服务器</strong>。</li></ul></li></ul><h5 id="Cookies作用范围"><a href="#Cookies作用范围" class="headerlink" title="Cookies作用范围"></a>Cookies作用范围</h5><ul><li><strong>浏览器的同源政策</strong>规定，两个网址只要<strong>域名相同</strong>和<strong>端口相同</strong>，就可以<strong>共享 Cookie</strong>。</li><li><strong>注意</strong>：这里<strong>不要求协议相同</strong>。也就是说，通过<code><a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></code>设置的 Cookie，可以被<code><a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></code>读取。</li></ul><h4 id="HTTP-协议中的Cookie"><a href="#HTTP-协议中的Cookie" class="headerlink" title="HTTP 协议中的Cookie"></a>HTTP 协议中的Cookie</h4><h5 id="HTTP-响应：Cookie-的生成-服务器端生成cookies"><a href="#HTTP-响应：Cookie-的生成-服务器端生成cookies" class="headerlink" title="HTTP 响应：Cookie 的生成(服务器端生成cookies)"></a>HTTP 响应：Cookie 的生成(服务器端生成cookies)</h5><ul><li><p>服务器如果希望在浏览器保存 Cookie，就要在<strong>HTTP 响应</strong>的<strong>头信息</strong>里面，放置一个<code>Set-Cookie</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:foo=bar</span><br></pre></td></tr></table></figure></li><li><p>上面代码会在浏览器保存一个名为<code>foo</code>的 Cookie，它的值为<code>bar</code>。(设置的格式为:<code>&lt;键(名)&gt;=&lt;值&gt;</code>)</p></li><li><p>HTTP 响应<strong>可以包含多个<code>Set-Cookie</code>字段</strong>，即在浏览器生成多个 Cookie。下面是一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure></li><li><p>除了 Cookie 的值，<code>Set-Cookie</code>字段还可以<strong>附加 Cookie 的属性</strong>。</p></li><li>一个<code>Set-Cookie</code>字段里面，可以同时包括多个属性，<strong>没有次序的要求</strong>。</li><li><p>下面是设置一个Cookie的例子：除了名与它的值，还包含<code>Domain</code>属性<code>Secure</code>属性和<code>HttpPnly</code>属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;; Secure; HttpOnly</span><br></pre></td></tr></table></figure></li><li><p>除了<code>键=值</code>来设置cookie的名字和值之外，还可以设置属性：</p><ul><li><code>Expires</code>，<code>Max-Age</code>用来<strong>设置cookie持续时间</strong>。</li><li><code>Domain</code>，<code>Path</code>设置<strong>发送http请求时</strong>哪些<strong>域名</strong>和<strong>路径</strong>需要附带这个Cookie。</li><li><code>Secure</code>属性指定浏览器只有在<strong>加密协议 HTTPS</strong>下才能发送。</li><li><code>HttpOnly</code>属性指定该 Cookie 无法通过<strong>JavaScript 脚本</strong>拿到。</li></ul></li></ul><h5 id="HTTP-请求：Cookie-的发送-浏览器发送Cookie"><a href="#HTTP-请求：Cookie-的发送-浏览器发送Cookie" class="headerlink" title="HTTP 请求：Cookie 的发送(浏览器发送Cookie)"></a>HTTP 请求：Cookie 的发送(浏览器发送Cookie)</h5><ul><li><p>浏览器向服务器<strong>发送 HTTP 请求</strong>时，每个请求都会<strong>带上相应的 Cookie</strong>。也就是说，把<strong>服务器早前保存在浏览器</strong>的这段信息，再发回服务器。这时要使用<strong>HTTP 头信息的Cookie字段</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: foo=bar</span><br></pre></td></tr></table></figure></li><li><p>上面代码会向服务器发送名为<code>foo</code>的 Cookie，值为<code>bar</code>。</p></li><li><p><strong>Cookie字段</strong>可以<strong>包含多个 Cookie</strong>，使用分号（;）分隔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: name=value; name2=value2; name3=value3</span><br></pre></td></tr></table></figure></li><li><p>下面是一个Http请求的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure></li><li><p>服务器收到浏览器发来的 Cookie 时，有两点是无法知道的(因为这些<strong>Cookie的属性只保存在浏览器上</strong>)：</p><ul><li>Cookie 的<strong>各种属性</strong>，比如何时过期。</li><li><strong>哪个域名设置的 Cookie</strong>，到底是一级域名设的，还是某一个二级域名设的。</li></ul></li></ul><h4 id="document-cookie读写当前网页的Cookie"><a href="#document-cookie读写当前网页的Cookie" class="headerlink" title="document.cookie读写当前网页的Cookie"></a>document.cookie读写当前网页的Cookie</h4><h5 id="读Cookie"><a href="#读Cookie" class="headerlink" title="读Cookie"></a>读Cookie</h5><ul><li><strong>读取的时候</strong>，它会返回当前网页的所有 Cookie，前提是<strong>该 Cookie 不能有<code>HTTPOnly</code>属性</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie // <span class="string">"foo=bar;baz=bar"</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="写Coookie"><a href="#写Coookie" class="headerlink" title="写Coookie"></a>写Coookie</h5><ul><li><code>document.cookie</code>属性是可写的，可以通过它<strong>为当前网站添加 Cookie</strong>。</li><li><p>但是，<code>document.cookie</code><strong>一次只能写入一个 Cookie</strong>，而且<strong>写入</strong>并不是覆盖，而<strong>是添加</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">'test1=hello'</span>;</span><br><span class="line">document.cookie = <span class="string">'test2=world'</span>;</span><br><span class="line">document.cookie</span><br><span class="line">// test1=hello;test2=world</span><br></pre></td></tr></table></figure></li><li><p>写入 Cookie 的时候，可以一起写入 Cookie 的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">"foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT"</span>;</span><br></pre></td></tr></table></figure></li><li><p>各个属性的写入注意点如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path属性必须为绝对路径，默认为当前路径。</span><br><span class="line">domain属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是example.com，就不能将其设为foo.com。该属性默认为当前的一级域名（不含二级域名）。</span><br><span class="line">max-age属性的值为秒数。</span><br><span class="line">expires属性的值为 UTC 格式，可以使用Date.prototype.toUTCString()进行日期格式转换。</span><br></pre></td></tr></table></figure></li><li><p><code>document.cookie</code>写入 Cookie 的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">'fontSize=14; '</span></span><br><span class="line">  + <span class="string">'expires='</span> + someDate.toGMTString() + <span class="string">'; '</span></span><br><span class="line">  + <span class="string">'path=/subdirectory; '</span></span><br><span class="line">  + <span class="string">'domain=*.example.com'</span>;</span><br></pre></td></tr></table></figure></li><li><p>Cookie 的属性一旦设置完成，就<strong>没有办法读取这些属性的值</strong>。</p></li></ul><h5 id="Cookie-的删除"><a href="#Cookie-的删除" class="headerlink" title="Cookie 的删除"></a>Cookie 的删除</h5><ul><li><p>使用<code>document.cookie</code>实现<strong>删除一个现存 Cookie</strong>的唯一方法，是<strong>设置</strong>它的<strong><code>expires</code>属性</strong>为一个<strong>过去的日期</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">'fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT'</span>;</span><br></pre></td></tr></table></figure></li><li><p>上面代码中，名为<code>fontSize</code>的 Cookie 的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Cookie 是&lt;strong&gt;服务器保存在浏览器&lt;/strong&gt;的一小段文本信息。&lt;strong&gt;浏览器每次向服务器发出请求&lt;/strong&gt;，就会&lt;strong&gt;自动附上这段信息&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="cookie" scheme="https://chongtianhong.github.io/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>通过url携带数据在HTML页面间跳转传值</title>
    <link href="https://chongtianhong.github.io/2018/06/14/passUrlValuesBThtmlPages/"/>
    <id>https://chongtianhong.github.io/2018/06/14/passUrlValuesBThtmlPages/</id>
    <published>2018-06-14T03:28:34.000Z</published>
    <updated>2018-09-25T13:11:43.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li>静态页面间如何跳转传值？我在网上搜索后发现方法有几种：<br>① 通过 url 携带数据<br>② 通过 cookie<br>③ 通过 html5 的 sessionStorage 或 localStorage</li><li>本文总结了<strong>通过 url 携带数据传值</strong>的方法。<a id="more"></a></li></ul><h4 id="场景及实现"><a href="#场景及实现" class="headerlink" title="场景及实现"></a>场景及实现</h4><ul><li>假设有 A、B 两个页面，A 页面有一超链接跳转到 B 页面，并将携带的数据填充到 B 页面的 input 框里面。</li><li><p>先看 A 页面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;A page&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(document).ready(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            // 拼接跳转url中要传输的数据</span><br><span class="line">            var dataList = [];</span><br><span class="line">            var dataStr;</span><br><span class="line">            dataList.push(<span class="string">'apple'</span>);</span><br><span class="line">            dataList.push(<span class="string">'bear'</span>);</span><br><span class="line">            dataStr = JSON.toStringify(dataList);</span><br><span class="line"></span><br><span class="line">            $(<span class="string">'#aPage'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                $(<span class="string">'#aPage'</span>).attr(<span class="string">"href"</span>, <span class="string">"b.html?data="</span> + dataStr);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=<span class="string">"b.html"</span> id=<span class="string">"aPage"</span>&gt;在url里带数据跳转到b页面&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>首先我定义一个字符串数组 dataList 来存放传递的数据；</li><li>这里假设我要传递的数据为 <strong>apple,bear</strong>；</li><li>通过 jQuery 的点击事件，将 a 标签的 href 属性修改成加上数据的 url。</li></ul></li><li><p>接着看 B 页面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;B page&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.2.1/jquery.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"getUrlData"</span>&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(document).ready(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            //使用正则表达式获取url中的参数</span><br><span class="line">            <span class="keyword">function</span> getUrlParam(name) &#123;</span><br><span class="line">                //构造一个含有目标参数的正则表达式对象</span><br><span class="line">                var reg = new RegExp(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>);</span><br><span class="line">                //匹配目标参数 </span><br><span class="line">                var r = window.location.search.substr(1).match(reg);  </span><br><span class="line">                //返回参数值</span><br><span class="line">                <span class="keyword">if</span> (r != null) <span class="built_in">return</span> unescape(r[2]); <span class="built_in">return</span> null;</span><br><span class="line">            &#125;</span><br><span class="line">            var urlData = getUrlParam(<span class="string">'data'</span>);</span><br><span class="line">            // 将数据填充到input框里面</span><br><span class="line">            $(<span class="string">'#getUrlData'</span>).val(urlData);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>说明：</p><ul><li>创建一个 JavaScript 函数，使用正则表达式获取 url 里面的数据值；</li><li>将数据填充到 input 框里面。</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>利用 url 在静态页面间传值，无非是<strong>利用 url 里 <code>?</code> 后面携带的数据</strong>，然后<strong>在目标页面通过方法获取传过来的数据</strong>，在本文中<strong>通过正则表达式检索数据并获取</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;静态页面间如何跳转传值？我在网上搜索后发现方法有几种：&lt;br&gt;① 通过 url 携带数据&lt;br&gt;② 通过 cookie&lt;br&gt;③ 通过 html5 的 sessionStorage 或 localStorage&lt;/li&gt;
&lt;li&gt;本文总结了&lt;strong&gt;通过 url 携带数据传值&lt;/strong&gt;的方法。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="正则表达式" scheme="https://chongtianhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>循环下的正则匹配？说说正则中的lastIndex</title>
    <link href="https://chongtianhong.github.io/2018/06/13/regExpMatchingUnderCycles/"/>
    <id>https://chongtianhong.github.io/2018/06/13/regExpMatchingUnderCycles/</id>
    <published>2018-06-13T01:40:12.000Z</published>
    <updated>2018-09-12T02:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><ul><li><p>最近在使用正则匹配的时候，我遇到一个非常有意思的现象，代码如下所示：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/g;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'test2.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'test4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item)));</span><br></pre></td></tr></table></figure></li><li><p>这段代码很好理解：它的规则就是判断字符串中是否含有<code>.jpg</code>，然后再循环地和数组中的字符串进行匹配，打印出结果。</p></li><li><p>一开始认为输出的结果应该全为<code>true</code>，然而，它的结果是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>代码的执行结果非常神奇：它并没有全部打印<code>true</code>，而是<strong>交替打印</strong><code>true</code>和<code>false</code>值，这到底是为什么？</p></li><li>为了查清楚到底是怎么回事，我开始上网搜索相关资料，经过一番搜索后，发现正则并没有我们想象的那么简单…</li></ul><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><ul><li>首先正则有一个<code>lastIndex</code>属性，它表示<strong>正则下一次匹配时的起始位置</strong>。一般情况下我们是使用不到它的，但<strong>在正则中包含全局标志g时，正则的test和exec方法就会使用到它</strong>，具体规则如下：<ul><li>初始状态下<code>lastIndex</code>的值为0；</li><li>若成功匹配，<code>lastIndex</code>的值就被更新成<strong>被匹配字符串后面的第一个字符的<code>index</code></strong>，或者可理解为被匹配字符串的最后一个字符<code>index + 1</code>；</li><li>若匹配失败，<code>lastIndex</code>则被重置为0；</li><li>如果我们<strong>继续使用原先的正则进行下一轮匹配</strong>，它则会<strong>从字符串<code>lastIndex</code>的位置开始进行</strong>。</li></ul></li><li>为验证这个结论，我特意做了三个实验：</li></ul><blockquote>实验一</blockquote><ul><li><p>直接将正则的<code>lastIndex</code>打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/g;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'test2.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'test4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item), reg.lastIndex));</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> 9</span><br><span class="line"><span class="literal">false</span> 0</span><br><span class="line"><span class="literal">true</span> 9</span><br><span class="line"><span class="literal">false</span> 0</span><br><span class="line"><span class="literal">true</span> 9</span><br></pre></td></tr></table></figure></li><li><p>从实验结果可以看到，由于数组中字符串的长度都是一致的，成功匹配后<code>lastIndex</code>的值直接更新为9，下次匹配的时候直接从第10个字符开始，因此<strong>匹配失败，<code>lastIndex</code>重置为0</strong>。以此类推，最终以9、0、9的形式<strong>交替打印</strong>。</p></li></ul><blockquote>实验二</blockquote><ul><li><p>对数组中的字符串稍作修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/g;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item), reg.lastIndex));</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> 9</span><br><span class="line"><span class="literal">true</span> 13</span><br><span class="line"><span class="literal">false</span> 0</span><br><span class="line"><span class="literal">true</span> 13</span><br><span class="line"><span class="literal">false</span> 0</span><br></pre></td></tr></table></figure></li><li><p>从实验结果可以看到，由于我们增加了部分字符串的长度，因此对于第2、4个字符串而言，即使从第9个字符开始匹配，依然能匹配到后边的<code>.jpg</code>，故<code>lastIndex</code>继续更新到13。</p></li></ul><blockquote>实验三</blockquote><ul><li><p>对正则表达式进行修改，去掉全局匹配模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\.jpg/;</span><br><span class="line">const arr = [</span><br><span class="line">    <span class="string">'test1.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test3.jpg'</span>,</span><br><span class="line">    <span class="string">'longTest4.jpg'</span>,</span><br><span class="line">    <span class="string">'test5.jpg'</span>,</span><br><span class="line">];</span><br><span class="line">arr.map(item =&gt; console.log(reg.test(item), reg.lastIndex));</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br><span class="line"><span class="literal">true</span> 0</span><br></pre></td></tr></table></figure></li><li><p>可以看到，<strong>当正则中不包含全局标志g时</strong>，正则的<code>test</code>方法的<code>lastIndex</code>每一次判断时都为0，即不起作用，因此都能匹配到结果。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>使用正则的时候还是要多加小心，对于<code>test</code>和<code>exec</code>方法，最好还是<strong>不要随意加上全局标志g</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最近在使用正则匹配的时候，我遇到一个非常有意思的现象，代码如下所示：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="正则表达式" scheme="https://chongtianhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离内容介绍</title>
    <link href="https://chongtianhong.github.io/2018/06/12/frontEndSeparation/"/>
    <id>https://chongtianhong.github.io/2018/06/12/frontEndSeparation/</id>
    <published>2018-06-12T06:20:54.000Z</published>
    <updated>2018-09-11T07:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>由于Node.js的逐渐成熟和日趋稳定，越来越多的公司中的前端团队开始尝试使用Node.js来练一下手，尝一尝鲜。</li><li>一般的做法都是将<strong>原本属于后端的一部分相对于业务不是很重要的功能</strong>迁移到Node.js上面来，也有一些公司<strong>将Node.js作为前后端分离的一个解决方案</strong>去施行。而像淘宝网这类的大型网站也很早的完成了前后端的分离，给我们这样的后来者提供了宝贵的经验。<a id="more"></a></li><li>接下来将对前后端分离的内容进行介绍。</li></ul><h4 id="认识前后端分离"><a href="#认识前后端分离" class="headerlink" title="认识前后端分离"></a>认识前后端分离</h4><ul><li>在<strong>传统的web应用开发</strong>中，大多数的程序员会<strong>将浏览器作为前后端的分界线</strong>。将<strong>浏览器中为用户进行页面展示的部分</strong>称之为<strong>前端</strong>，而将<strong>运行在服务器，为前端提供业务逻辑和数据准备的所有代码</strong>统称为<strong>后端</strong>。</li><li>由于前后端分离这个概念相对来说刚出现不久，很多人都是只闻其声，不见其形，所以可能会对它产生一些误解，误以为前后端分离只是一种web应用开发模式，只要在web应用的开发期进行了前后端开发工作的分工就是前后端分离。</li><li>其实<strong>前后端分离并不只是开发模式，还是web应用的一种架构模式</strong>。在开发阶段，前后端工程师约定好数据交互接口，实现<strong>并行开发和测试</strong>；在运行阶段前后端分离模式需要对web应用进行<strong>分离部署</strong>，前后端之间使用HTTP或者其他协议进行交互请求。然而作为一种<strong>架构模式</strong>，我们在实施的过程中主要对以下四个方面来进行比较和重新认识。</li><li>前后端分离大概可以从四个方面来理解：<br>1、交互形式<br>2、代码组织方式<br>3、开发模式<br>4、数据接口规范流程</li></ul><h5 id="交互形式"><a href="#交互形式" class="headerlink" title="交互形式"></a>交互形式</h5><ul><li>在前后端分离架构中，<strong>后端</strong>只需要负责<strong>按照约定的数据格式向前端提供可调用的API服务</strong>即可。<strong>前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的组装和渲染，最终返回给浏览器</strong>。<br><img src="/images/frontEndSeparation1.jpg" width="600" alt="交互形式" style="border:none"></li></ul><h5 id="代码组织方式"><a href="#代码组织方式" class="headerlink" title="代码组织方式"></a>代码组织方式</h5><ul><li>在<strong>传统架构模式</strong>中，前后端代码存放于<strong>同一个代码库</strong>中，甚至是<strong>同一工程目录</strong>下。页面中还夹杂着后端代码。前后端工程师进行开发时，都必须把整个项目导入到开发工具中。<br><img src="/images/frontEndSeparation2.jpg" width="600" alt="代码组织方式" style="border:none"></li><li>而前后端分离模式在代码组织形式上有以下两种：<ul><li><strong>半分离</strong><br><strong>前后端共用一个代码库，但是代码分别存放在两个工程中</strong>。后端不关心或很少关心前端元素的输出情况，前端不能独立进行开发和测试，项目中缺乏前后端交互的测试用例。</li><li><strong>分离</strong><br><strong>前后端代码库分离</strong>，前端代码中有可以进行Mock测试(通过构造虚拟测试对象以简化测试环境的方法)的伪后端，能支持前端的独立开发和测试。而后端代码中除了功能实现外，还有着详细的测试用例，以保证API的可用性，降低集成风险。</li></ul></li></ul><h5 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h5><ul><li><strong>传统的MVC架构，整体没有进行前后端分离</strong>。在项目的开发阶段，前端工程师负责编写HTML，完成前端的页面设计并套页面，然后再使用模板技术将写好的前端代码转换为Smarty脚本，同时内嵌一些后端提供的模板变量和一些逻辑操作。应用运行期，将全部代码进行打包，和后端代码部署到同一服务器上，同时会进行简单的动静态分离部署。</li><li>此时，应用的开发流程如下图所示：<br><img src="/images/frontEndSeparation3.jpg" width="600" alt="开发模式1" style="border:none"></li><li>而在<strong>实现前后端分离架构之后</strong>，前端工程师只需要编写HTML、js、CSS等前端资源，然后通过HTTP请求调用后端提供的服务即可。除了<strong>开发期的分离</strong>，在<strong>运行期前后端资源</strong>也会<strong>进行分离部署</strong>。</li><li>前后端分离之后，开发流程将如下图所示。<br><img src="/images/frontEndSeparation4.jpg" width="600" alt="开发模式2" style="border:none"></li><li>通过上面的两幅流程图，不难发现，在开发模式上，前后端分离不仅仅只是工程师的分工开发，更重要的意义在于<strong>实现了前后端的并行开发，简化了开发流程</strong>。</li></ul><h5 id="数据接口规范流程"><a href="#数据接口规范流程" class="headerlink" title="数据接口规范流程"></a>数据接口规范流程</h5><ul><li>在<strong>开发期间</strong>前后端共同商定好数据接口的交互形式和数据格式。然后实现<strong>前后端的并行开发</strong>，其中前端工程师再开发完成之后可以独自进行mock测试，而后端也可以使用接口测试平台进行接口自测，然后<strong>前后端一起进行功能联调并校验格式</strong>，最终进行<strong>自动化测试</strong>。<br><img src="/images/frontEndSeparation5.jpg" width="600" alt="数据接口规范流程" style="border:none"></li></ul><h4 id="分离的四个好处"><a href="#分离的四个好处" class="headerlink" title="分离的四个好处"></a>分离的四个好处</h4><ul><li>前后端分离模式和传统的web应用架构相比有很大的不同，从目前应用软件开发的发展趋势来看，主要有两方面需要注意：<br>1、越来越<strong>注重用户体验</strong>，随着互联网的发展，开始<strong>多终端化</strong>。<br>2、大型应用架构模式正在向<strong>云化、微服务化</strong>发展。</li><li>通过前后端分离架构，可以为我们带来以下四个方面的提升：<ul><li><strong>为优质产品打造精益团队</strong><br>通过将开发团队前后端分离化，让前后端工程师只需要专注于前端或后端的开发工作，是的前后端工程师实现自治，培养其独特的技术特性，然后构建出一个全栈式的精益开发团队。</li><li><strong>提升开发效率</strong><br>前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。与此同时，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。如此一来整个应用的开发效率必然会有质的提升。</li><li><strong>完美应对复杂多变的前端需求</strong><br>如果开发团队能完成前后端分离的转型，打造优秀的前后端团队，开发独立化，让开发人员做到专注专精，开发能力必然会有所提升，能够完美应对各种复杂多变的前端需求。</li><li><strong>增强代码可维护性</strong><br>前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系。</li></ul></li><li>应用代码将会变得整洁清晰，不论是代码阅读还是代码维护都会比以前轻松。</li></ul><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><ul><li>前后端分离并非仅仅只是前后端开发的分工，而是<ul><li>在<strong>开发期</strong>进行<strong>代码存放分离</strong>、<strong>前后端开发职责分离</strong>，<strong>前后端能够独立进行开发测试</strong>；</li><li>在<strong>运行期</strong>进行<strong>应用部署分离</strong>，<strong>前后端之间通过HTTP请求进行通讯</strong>。</li></ul></li><li>前后端分离的开发模式与传统模式相比，能为我们<strong>提升开发效率、增强代码可维护性</strong>，让我们有规划地打造一个前后端并重的精益开发团队，更好地应对越来越复杂多变的Web应用开发需求。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;由于Node.js的逐渐成熟和日趋稳定，越来越多的公司中的前端团队开始尝试使用Node.js来练一下手，尝一尝鲜。&lt;/li&gt;
&lt;li&gt;一般的做法都是将&lt;strong&gt;原本属于后端的一部分相对于业务不是很重要的功能&lt;/strong&gt;迁移到Node.js上面来，也有一些公司&lt;strong&gt;将Node.js作为前后端分离的一个解决方案&lt;/strong&gt;去施行。而像淘宝网这类的大型网站也很早的完成了前后端的分离，给我们这样的后来者提供了宝贵的经验。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="前后端分离" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端有用网址收藏</title>
    <link href="https://chongtianhong.github.io/2018/06/11/webStudyLink/"/>
    <id>https://chongtianhong.github.io/2018/06/11/webStudyLink/</id>
    <published>2018-06-11T13:00:10.000Z</published>
    <updated>2018-09-12T02:22:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Web方面"><a href="#Web方面" class="headerlink" title="Web方面"></a>Web方面</h4><ul><li>JS注释规范：<a href="http://usejsdoc.org/" target="_blank" rel="noopener">http://usejsdoc.org/</a></li><li>查看HTML5是否符合大纲：<a href="https://gsnedders.html5.org/outliner/" target="_blank" rel="noopener">https://gsnedders.html5.org/outliner/</a></li><li>浏览器CSS支持情况查询：<a href="http://www.caniuse.com" target="_blank" rel="noopener">http://www.caniuse.com</a><a id="more"></a></li><li>TGideas整体WEB解决方案：<a href="http://tguide.qq.com/main/index.htm" target="_blank" rel="noopener">http://tguide.qq.com/main/index.htm</a></li><li>在线API文档：<a href="http://tool.oschina.net/apidocs/api" target="_blank" rel="noopener">http://tool.oschina.net/apidocs/api</a></li><li>剖析Vue原理：<a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006599500</a></li></ul><h4 id="学习教程或文档"><a href="#学习教程或文档" class="headerlink" title="学习教程或文档"></a>学习教程或文档</h4><ul><li>Vue.js：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></li><li>React.js：<a href="https://react.bootcss.com/" target="_blank" rel="noopener">https://react.bootcss.com/</a></li><li>MDN：<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a></li><li>w3school：<a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a></li><li>菜鸟教程：<a href="http://www.runoob.com/" target="_blank" rel="noopener">http://www.runoob.com/</a></li><li>易百教程：<a href="http://www.yiibai.com" target="_blank" rel="noopener">http://www.yiibai.com</a></li><li>瓢城WEB俱乐部：<a href="http://www.ycku.com/" target="_blank" rel="noopener">http://www.ycku.com/</a></li><li>coursera在线学习：<a href="https://www.coursera.org" target="_blank" rel="noopener">https://www.coursera.org</a></li><li>慕课网：<a href="https://www.imooc.com" target="_blank" rel="noopener">https://www.imooc.com</a></li><li>互联网工程任务组：<a href="https://tools.ietf.org" target="_blank" rel="noopener">https://tools.ietf.org</a></li></ul><h4 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h4><ul><li>牛客网：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></li><li>知乎：<a href="https://www.zhihu.com" target="_blank" rel="noopener">https://www.zhihu.com</a></li><li>掘金：<a href="https://juejin.im" target="_blank" rel="noopener">https://juejin.im</a></li><li>推酷网：<a href="http://www.tuicool.com/" target="_blank" rel="noopener">http://www.tuicool.com/</a></li><li>Vue.js中文论坛：<a href="https://forum.vuejs.org/c/chinese" target="_blank" rel="noopener">https://forum.vuejs.org/c/chinese</a></li><li>IM开发社区：<a href="http://www.52im.net/" target="_blank" rel="noopener">http://www.52im.net/</a></li><li>SegmentFault：<a href="https://segmentfault.com" target="_blank" rel="noopener">https://segmentfault.com</a></li><li>StackOverFlow：<a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li></ul><h4 id="关于图标"><a href="#关于图标" class="headerlink" title="关于图标"></a>关于图标</h4><ul><li>阿里图标：<a href="http://www.iconfont.cn" target="_blank" rel="noopener">http://www.iconfont.cn</a></li><li>IconFinder：<a href="https://www.iconfinder.com" target="_blank" rel="noopener">https://www.iconfinder.com</a></li><li>FontAwesome：<a href="https://fontawesome.com/" target="_blank" rel="noopener">https://fontawesome.com/</a></li></ul><h4 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h4><ul><li>S6教程：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li><li>Understanding ECMAScript 6：<a href="https://sagittarius-rev.gitbooks.io/understanding-ecmascript-6-zh-ver/content/" target="_blank" rel="noopener">https://sagittarius-rev.gitbooks.io/understanding-ecmascript-6-zh-ver/content/</a></li><li>Node入门：<a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">https://www.nodebeginner.org/index-zh-cn.html</a></li><li>Webpack入门：<a href="https://love2.io/@hfpp2012/doc/webpack-tutorial/README.md" target="_blank" rel="noopener">https://love2.io/@hfpp2012/doc/webpack-tutorial/README.md</a></li><li>Express框架：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></li><li>Koa框架：<a href="https://koa.bootcss.com/" target="_blank" rel="noopener">https://koa.bootcss.com/</a></li></ul><h4 id="色彩查询"><a href="#色彩查询" class="headerlink" title="色彩查询"></a>色彩查询</h4><ul><li>网页色彩常用搭配表：<a href="http://tool.c7sky.com/webcolor/" target="_blank" rel="noopener">http://tool.c7sky.com/webcolor/</a> </li><li>颜色表及html代码：<a href="http://xh.5156edu.com/page/z1015m9220j18754.html" target="_blank" rel="noopener">http://xh.5156edu.com/page/z1015m9220j18754.html</a> </li><li>rgb颜色查询对照表：<a href="http://www.999.com/tool/rgb.html" target="_blank" rel="noopener">http://www.999.com/tool/rgb.html</a></li></ul><h4 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h4><ul><li>阮一峰：<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/</a></li><li>刘哇勇：<a href="http://www.cnblogs.com/Wayou/" target="_blank" rel="noopener">http://www.cnblogs.com/Wayou/</a></li><li>胡孙杨：<a href="http://hcysun.me/" target="_blank" rel="noopener">http://hcysun.me/</a></li><li>郭锦荣：<a href="http://www.cnblogs.com/jr1993/" target="_blank" rel="noopener">http://www.cnblogs.com/jr1993/</a></li><li>张鑫旭：<a href="https://www.zhangxinxu.com/" target="_blank" rel="noopener">https://www.zhangxinxu.com/</a></li></ul><h4 id="测试调试"><a href="#测试调试" class="headerlink" title="测试调试"></a>测试调试</h4><ul><li>JSFiddle：<a href="https://jsfiddle.net/" target="_blank" rel="noopener">https://jsfiddle.net/</a></li><li>codeOpen：<a href="https://codepen.io/" target="_blank" rel="noopener">https://codepen.io/</a></li><li>在线正则表达式：<a href="http://tool.oschina.net/regex/" target="_blank" rel="noopener">http://tool.oschina.net/regex/</a></li><li>移动前端开发调试：<a href="http://yujiangshui.com/multidevice-frontend-debug/" target="_blank" rel="noopener">http://yujiangshui.com/multidevice-frontend-debug/</a></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>hexo博客搭建：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a></li><li>webstorm 2017 激活破解：<a href="http://blog.csdn.net/it_talk/article/details/52448597" target="_blank" rel="noopener">http://blog.csdn.net/it_talk/article/details/52448597</a></li><li>webstorm 2018 激活破解方法大全：<a href="https://blog.csdn.net/voke_/article/details/76418116" target="_blank" rel="noopener">https://blog.csdn.net/voke_/article/details/76418116</a></li><li>81道经典Vue面试题总结（长期更新）：<a href="https://segmentfault.com/a/1190000016351284" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016351284</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Web方面&quot;&gt;&lt;a href=&quot;#Web方面&quot; class=&quot;headerlink&quot; title=&quot;Web方面&quot;&gt;&lt;/a&gt;Web方面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;JS注释规范：&lt;a href=&quot;http://usejsdoc.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://usejsdoc.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;查看HTML5是否符合大纲：&lt;a href=&quot;https://gsnedders.html5.org/outliner/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gsnedders.html5.org/outliner/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;浏览器CSS支持情况查询：&lt;a href=&quot;http://www.caniuse.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.caniuse.com&lt;/a&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="网址" scheme="https://chongtianhong.github.io/tags/%E7%BD%91%E5%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>前端渲染与后端渲染的区别</title>
    <link href="https://chongtianhong.github.io/2018/06/10/diffBetweenFEandSE/"/>
    <id>https://chongtianhong.github.io/2018/06/10/diffBetweenFEandSE/</id>
    <published>2018-06-10T11:03:46.000Z</published>
    <updated>2018-09-10T12:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>渲染</strong>的本质：字符串的拼接，将<strong>数据</strong>渲染进<strong>固定格式的html代码</strong>中，形成最终的html显示在用户页面上。<a id="more"></a></li></ul><h4 id="前端渲染"><a href="#前端渲染" class="headerlink" title="前端渲染"></a>前端渲染</h4><ul><li>指的是前端向后端发起请求，<strong>后端返回JSON数据</strong>，前端利用预先写的html模板，循环读取JSON数据，拼接字符串（es6的模板字符串特性大大减少了拼接字符串的的成本），并插入页面。</li><li>也就是说，<strong>前端渲染</strong>就是后端返回的html是静态文件，作为纯文件形式的存在，<strong>后端直接吐给前端，不做任何涂抹</strong>，前端拿到后执行决定做什么。</li><li><strong>好处</strong>：<ul><li>网络传输数据量小。</li><li>不占用服务端运算资源（解析模板），模板在前端（很有可能仅部分在前端），改结构变交互都由前端自己完成。</li></ul></li><li><strong>坏处</strong>：<ul><li>前端耗时较多，对前端工作人员水平要求相对较高。</li><li>前端代码较多，因为部分以前在后台处理的交互逻辑交给了前端处理。</li><li>占用少部分客户端运算资源用于解析模板。</li></ul></li></ul><h4 id="后端渲染"><a href="#后端渲染" class="headerlink" title="后端渲染"></a>后端渲染</h4><ul><li>指的是前端发起请求，<strong>后端用后台模板引擎（例如ejs等）直接生成html</strong>，前端接受到html数据之后，直接插入页面。</li><li>也就是说，<strong>后端渲染</strong>就是<strong>html先被后端涂抹过一遍</strong>再给前端（前端拿到后是否要再涂抹则随意）。</li><li>好处：<ul><li>前端耗时少，即<strong>减少了首屏时间</strong>，模板统一在后端。</li><li>前端（相对）省事，不占用客户端运算资源（解析模板）。</li></ul></li><li>坏处：<ul><li>占用服务器资源，请求的数据量偏大，前端的交互样式更改需要联动修改。</li></ul></li></ul><h4 id="前端渲染与后端渲染对比"><a href="#前端渲染与后端渲染对比" class="headerlink" title="前端渲染与后端渲染对比"></a>前端渲染与后端渲染对比</h4><h5 id="后端渲染-1"><a href="#后端渲染-1" class="headerlink" title="后端渲染"></a>后端渲染</h5><ul><li><strong>页面呈现速度快</strong>，受限于用户的带宽。</li><li><strong>流量消耗少一点点</strong>（可以省去前端框架部分的代码）。</li><li><strong>可维护性差</strong>，不利于前后端分离。</li><li><strong>seo友好度好</strong>，因为后端已经渲染好了，所以加载体验相对较好，网速差时表现较差。</li><li><strong>编码效率低</strong>。</li><li>相对模块化，适用于片展示型的页面。</li></ul><h5 id="前端渲染-1"><a href="#前端渲染-1" class="headerlink" title="前端渲染"></a>前端渲染</h5><ul><li>页面呈现速度主要<strong>受限于带宽和客户端机器的好坏</strong>，优化得好可以逐步动态展开内容，感觉上会更快一点。</li><li><strong>流量消耗多一点点</strong>（一个前端框架大概50KB），当然，有的用后端渲染的项目前端部分也有在用框架。</li><li><strong>可维护性好</strong>，不必反复请求，理论上更加符合前后端分离。</li><li><strong>SEO友好度差</strong>，大量使用ajax，多数浏览器不能抓取ajax数据。</li><li><strong>编码效率高</strong>，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低。</li><li>比较灵活，适用于<strong>DOM操作比较频繁</strong>或<strong>交互复杂</strong>的业务场景。</li></ul><h5 id="从后端渲染到前端渲染的改变"><a href="#从后端渲染到前端渲染的改变" class="headerlink" title="从后端渲染到前端渲染的改变"></a>从后端渲染到前端渲染的改变</h5><blockquote>计算机任务的转移</blockquote><ul><li>原本由服务器渲染的任务交给客户端，当有大量用户访问时，大大减轻了后端的压力。性能大大提高，因为服务器做的事情确实减少了。而且随着客户端硬件的发展，也能处理好多数的渲染任务。</li></ul><blockquote>放弃前端权限</blockquote><ul><li>将页面整个UI逻辑交给客户端的话，一些有经验的用户可能会看到一些本不该看到的页面，违反了安全原则。所以<strong>后端不能轻信从前端传来的数据</strong>，一定要<strong>做好过滤与验证</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;渲染&lt;/strong&gt;的本质：字符串的拼接，将&lt;strong&gt;数据&lt;/strong&gt;渲染进&lt;strong&gt;固定格式的html代码&lt;/strong&gt;中，形成最终的html显示在用户页面上。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="渲染" scheme="https://chongtianhong.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
</feed>
