<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-08-30T13:53:47.684Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端模块化（CommonJs、AMD和CMD）</title>
    <link href="https://chongtianhong.github.io/2018/08/29/frontEndModule/"/>
    <id>https://chongtianhong.github.io/2018/08/29/frontEndModule/</id>
    <published>2018-08-29T12:27:50.000Z</published>
    <updated>2018-08-30T13:53:47.684Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>前端模块规范有三种，分别是<code>CommonJs</code>、<code>AMD</code>和<code>CMD</code>。</li><li><code>CommonJs</code>用在服务器端，<code>AMD</code>和<code>CMD</code>用在浏览器环境。</li><li><code>AMD</code>是<strong>RequireJS</strong>在推广过程中对模块定义的规范化产出。</li><li><code>CMD</code>是<strong>SeaJS</strong>在推广过程中对模块定义的规范化产出。<a id="more"></a></li><li><code>AMD</code>：提前执行（异步加载：依赖先执行）/ 延迟执行（RequireJS 从 2.0 开始，也改成可以延迟执行）。</li><li><code>CMD</code>：延迟执行（运行到需加载，根据顺序执行）。</li></ul><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h5 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h5><ul><li>模块就是实现特定功能的一组方法。</li><li><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m1</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">m2</span></span>()&#123;</span><br><span class="line">　　//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，组成一个模块。使用的时候，直接调用就行了。</p></li><li>这种做法的<strong>缺点</strong>很明显：<strong>“污染”了全局变量</strong>，<strong>无法保证不与其他模块发生变量名冲突</strong>，而且<strong>模块成员之间看不出直接关系</strong>。</li></ul><h5 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h5><ul><li><p>为了解决上面的缺点，可以<strong>把模块写成一个对象</strong>，所有的<strong>模块成员都放到</strong>这个<strong>对象里面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var module1 = new Object(&#123;</span><br><span class="line"></span><br><span class="line">　　_count : 0,</span><br><span class="line"></span><br><span class="line">　　m1 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;,</span><br><span class="line"></span><br><span class="line">　　m2 : <span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">　　　　//...</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的函数<code>m1()</code>和<code>m2()</code>，都封装在module1对象里。使用的时候，就是<strong>调用这个对象的属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure></li><li><p>但是，这样的写法会<strong>暴露所有模块成员</strong>，<strong>内部状态可以被外部改写</strong>。比如，外部代码可以直接改变内部计数器的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1._count = 5;</span><br></pre></td></tr></table></figure></li></ul><h5 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h5><ul><li><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到<strong>不暴露私有成员</strong>的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    var _count = 0;</span><br><span class="line"></span><br><span class="line">    var m1 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var m2 = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    　　//...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">    　　m1 : m1,</span><br><span class="line">    　　m2 : m2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>使用上面的写法，<strong>外部代码无法读取内部的</strong><code>_count</code><strong>变量</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.info(module1._count); //undefined</span><br></pre></td></tr></table></figure></li><li><p><code>module1</code>就是Javascript模块的基本写法。</p></li></ul><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h4><ul><li><p><code>CommonJs</code>是<strong>服务器端模块</strong>的规范，由Node推广使用。由于服务端编程的复杂性，如果没有模块很难与操作系统及其他应用程序互动。使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">    <span class="built_in">return</span> add(val, 1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">var increment = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">var a = increment(1); //2</span><br></pre></td></tr></table></figure></li><li><p>根据CommonJS规范：</p><ul><li>一个单独的文件就是一个模块。<strong>每一个模块都是一个单独的作用域</strong>，也就是说，在该<strong>模块内部定义的变量，无法被其他模块读取</strong>，除非定义为<code>global</code>对象的属性。<br>-<strong> 输出模块变量</strong>的最好方法是<strong>使用<code>module.exports</code>对象</strong>。</li><li><strong>加载模块</strong>使用<code>require</code>方法，该方法读取一个文件并执行，返回文件内部的<code>module.exports</code>对象。</li></ul></li><li>仔细看上面的代码，可以发现<strong><code>require</code>是同步的</strong>。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。</li><li>然而，这在浏览器端就会有很大问题。因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，<strong>浏览器处于”假死”状态</strong>。因此，<strong>浏览器端的模块，不能采用”同步加载”（synchronous）</strong>，只能采用”异步加载”（asynchronous）。</li><li><strong>浏览器端</strong>，加载 JavaScript 最佳、最容易的方式是在 document 中插入<code>&lt;script&gt;</code>标签。但<strong>脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载</strong>。</li><li><strong>解决思路之一</strong>是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</li><li><p><strong>另一种解决思路</strong>是，用一套标准模板来封装模块定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  // The module code goes here</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这套模板代码为模块加载器提供了机会，使其能在<strong>模块代码执行之前</strong>，对模块代码进行<strong>静态分析</strong>，并<strong>动态生成依赖列表</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* math.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    exports.add = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">            sum += args[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* increment.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var add = require(<span class="string">'math'</span>).add;</span><br><span class="line">    exports.increment = <span class="keyword">function</span>(val) &#123;</span><br><span class="line">        <span class="built_in">return</span> add(val, 1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/* index.js */</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var inc = require(<span class="string">'increment'</span>).increment;</span><br><span class="line">    inc(1); // 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ul><li>AMD是<code>“Asynchronous Module Definition”</code>的缩写，意思就是”异步模块定义”。由于不是JavaScript原生支持，<strong>使用AMD规范进行页面开发需要用到对应的库函数</strong>，也就是<code>RequireJS</code>，实际上AMD 是<code>RequireJS</code>在推广过程中对模块定义的规范化的产出。</li><li>AMD采用<strong>异步方式</strong>加载模块，模块的加载不影响它后面语句的运行。所有<strong>依赖这个模块的语句，都定义在一个回调函数中</strong>，等到加载完成之后，这个回调函数才会运行。</li><li><code>RequireJS</code>主要解决两个问题：<ul><li><strong>多个JS文件可能有依赖关系</strong>，被依赖的文件需要早于依赖它的文件加载到浏览器；</li><li><strong>JS加载的时候浏览器会停止页面渲染</strong>，加载文件越多，页面失去响应时间越长。</li></ul></li><li><code>RequireJS</code>也采用<code>require()</code>语句加载模块，但是<strong>不同于CommonJS，它要求两个参数</strong>，语法：<code>require([module], callback)</code>:<ul><li>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；</li><li>第二个参数callback，则是加载成功之后的回调函数。</li></ul></li><li><p>将使用<strong>不适用于浏览器环境的CommonJS规范</strong>的代码改成<strong>符合AMD规范</strong>的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* CommonJS */</span><br><span class="line">var math = require(<span class="string">'math'</span>);</span><br><span class="line">math.add(2, 3);</span><br><span class="line"></span><br><span class="line">/* AMD */</span><br><span class="line">require([<span class="string">'math'</span>], <span class="keyword">function</span> (math) &#123;</span><br><span class="line">    math.add(2, 3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>math.add()</code>与<code>math</code>模块加载不是同步的，浏览器不会发生假死。所以很显然，<strong>AMD比较适合浏览器环境</strong>。</p></li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><ul><li>CMD(Common Module Definition)即<strong>通用模块定义</strong>，CMD规范是国内发展出来的，就像AMD有个<code>RequireJS</code>，CMD有个浏览器的实现<code>SeaJS</code>，<code>SeaJS</code>要解决的问题和<code>RequireJS</code>一样，只不过在<strong>模块定义方式</strong>和<strong>模块加载（可以说运行、解析）时机</strong>上有所不同。</li><li><p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    // require是可以把其他模块导入进来的一个参数;</span><br><span class="line">    // exports是可以把模块内的一些属性和方法导出的;</span><br><span class="line">    // module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</span><br><span class="line"></span><br><span class="line">    // 模块代码</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>AMD是<strong>依赖关系前置</strong>，在定义模块的时候就要声明其依赖的模块；</p></li><li><p>CMD是<strong>按需加载依赖就近</strong>，只有在用到某个模块的时候再去require：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var a = require(<span class="string">'./a'</span>)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    var b = require(<span class="string">'./b'</span>) // 依赖可以就近书写</span><br><span class="line">    b.doSomething()</span><br><span class="line">    // ... </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD 默认推荐的是</span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123; // 依赖必须一开始就写好</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处略去 100 行</span><br><span class="line">    b.doSomething()</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>seajs使用例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义模块  myModule.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">    var $ = require(<span class="string">'jquery.js'</span>)</span><br><span class="line">    $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">    exports.data = 1;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="keyword">function</span>(my)&#123;</span><br><span class="line">    var star = my.data;</span><br><span class="line">    console.log(star);  // 1</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="images/frontEndModule.png" stype="border:none" alt="模块方案" style="border:none"></p><ul><li>AMD和CMD的区别：<ul><li>CMD 推崇<strong>依赖就近</strong>；AMD 推崇<strong>依赖前置</strong>；</li><li>CMD 是<strong>延迟执行</strong>；AMD 是<strong>提前执行</strong>；</li><li>CMD <strong>性能好</strong>，因为只有用户需要的时候才执行；AMD<strong>用户体验好</strong>，因为没有延迟，依赖模块提前执行了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前端模块规范有三种，分别是&lt;code&gt;CommonJs&lt;/code&gt;、&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CommonJs&lt;/code&gt;用在服务器端，&lt;code&gt;AMD&lt;/code&gt;和&lt;code&gt;CMD&lt;/code&gt;用在浏览器环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AMD&lt;/code&gt;是&lt;strong&gt;RequireJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CMD&lt;/code&gt;是&lt;strong&gt;SeaJS&lt;/strong&gt;在推广过程中对模块定义的规范化产出。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="CommonJs" scheme="https://chongtianhong.github.io/tags/CommonJs/"/>
    
      <category term="AMD规范" scheme="https://chongtianhong.github.io/tags/AMD%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>SeaJS中use函数用法实例分析</title>
    <link href="https://chongtianhong.github.io/2018/05/28/SeaJS/"/>
    <id>https://chongtianhong.github.io/2018/05/28/SeaJS/</id>
    <published>2018-05-28T09:34:57.000Z</published>
    <updated>2018-08-30T13:31:19.807Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这篇文章主要介绍了<strong>SeaJS</strong>中<strong>use函数</strong>的用法，结合实例形式分析了<strong>use函数</strong>加载模块的使用方法与相关操作技巧。<a id="more"></a></li><li><p>有了<code>define</code>等<strong>模块定义规范</strong>的实现，我们可以开发出很多模块。但光有一堆模块不管用，我们还得让它们能跑起来。在 SeaJS 里，要<strong>启动模块系统</strong>很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>seajs.use</code>用来<strong>在页面中加载模块</strong>。通过<code>use</code>方法，可以在页面中加载任意模块。</p></li><li><p>语法：<code>seajs.use seajs.use(id, callback?)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 加载模块 main，并在加载完成时，执行指定回调</span><br><span class="line">seajs.use(<span class="string">'./main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>use</code>方法还可以<strong>一次加载多个模块</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 并发加载模块 a 和模块 b，并在都加载完成时，执行指定回调</span><br><span class="line">seajs.use([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="keyword">function</span>(a, b) &#123;</span><br><span class="line">    a.init();</span><br><span class="line">    b.init();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>callback</code>参数可选</strong>。当<strong>只加载一个模块，且不需要<code>callback</code>时</strong>，可以用<code>data-main</code>属性来简化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-main=<span class="string">"./main"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>上面的代码等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    seajs.use(<span class="string">'./main'</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>SeaJS</strong>还提供<code>data-config</code>来<strong>加载配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/sea.js"</span> data-config=<span class="string">"path/to/config"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>data-config</code>等价：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seajs.config(&#123;</span><br><span class="line">    preload: [<span class="string">'path/to/config'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>路径解析规则</strong>与<code>seajs.use</code>一致。</p></li><li><p>再看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/js/lib/sea.js"</span> data-config=<span class="string">"/js/config.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">seajs.use(<span class="string">'/js/main'</span>, <span class="keyword">function</span>(main) &#123;</span><br><span class="line">    main.banner_focus(<span class="string">'#focus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>main</code>为<strong>模块名</strong>，<code>main.method</code>为<strong>模块定义的函数</strong>，<strong>可以传递参数</strong>过去。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;这篇文章主要介绍了&lt;strong&gt;SeaJS&lt;/strong&gt;中&lt;strong&gt;use函数&lt;/strong&gt;的用法，结合实例形式分析了&lt;strong&gt;use函数&lt;/strong&gt;加载模块的使用方法与相关操作技巧。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CMD规范" scheme="https://chongtianhong.github.io/tags/CMD%E8%A7%84%E8%8C%83/"/>
    
      <category term="模块化编程" scheme="https://chongtianhong.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/"/>
    
      <category term="SeaJS" scheme="https://chongtianhong.github.io/tags/SeaJS/"/>
    
  </entry>
  
  <entry>
    <title>Node.js使用MySQL数据库时对RowDataPacket对象的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/27/RowDataPacket/"/>
    <id>https://chongtianhong.github.io/2018/05/27/RowDataPacket/</id>
    <published>2018-05-27T03:30:12.000Z</published>
    <updated>2018-08-29T13:57:00.970Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>使用Node.js连接数据库查询表后</strong>，拿到的<strong>数据是一个数组</strong>，数组里面是<strong>JSON格式的数据</strong>，但是每个JSON前面都有一个<strong>RowDataPacket</strong>，这就导致<strong>前端获取到这些数据</strong>后不得不<strong>进行一些格式处理</strong>。<a id="more"></a></li><li><p>未处理前是这个样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">  RowDataPacket &#123;</span><br><span class="line">    contractname: <span class="string">'datatime'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdfsd'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: null,</span><br><span class="line">    uploaddate: <span class="string">'2018-07-16 16:36:08'</span>,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  RowDataPacket &#123;</span><br><span class="line">    contractname: <span class="string">'sd'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdf'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: <span class="string">''</span>,</span><br><span class="line">    uploaddate: null,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>我们可以在拿到数据后，进行一个<strong>JSON的格式化处理</strong>，即利用<code>JSON.stringify()</code>把对象转为对象字符串，可<strong>去掉RowDataPacket</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataString = JSON.stringify(results);</span><br><span class="line">var data = JSON.parse(dataString);</span><br></pre></td></tr></table></figure></li><li><p>其中<code>results</code>就是<strong>从数据库拿到的数据</strong>，通过这样的格式化后，我们得到最终的数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">  &#123; </span><br><span class="line">    contractname: <span class="string">'datatime'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdfsd'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: null,</span><br><span class="line">    uploaddate: <span class="string">'2018-07-16 16:36:08'</span>,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; </span><br><span class="line">    contractname: <span class="string">'sd'</span>,</span><br><span class="line">    contractdesc: <span class="string">'sdf'</span>,</span><br><span class="line">    deploystatus: <span class="string">'0'</span>,</span><br><span class="line">    deployuser: <span class="string">''</span>,</span><br><span class="line">    uploaddate: null,</span><br><span class="line">    deploydate: null,</span><br><span class="line">    isvalid: <span class="string">'1'</span> </span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用Node.js连接数据库查询表后&lt;/strong&gt;，拿到的&lt;strong&gt;数据是一个数组&lt;/strong&gt;，数组里面是&lt;strong&gt;JSON格式的数据&lt;/strong&gt;，但是每个JSON前面都有一个&lt;strong&gt;RowDataPacket&lt;/strong&gt;，这就导致&lt;strong&gt;前端获取到这些数据&lt;/strong&gt;后不得不&lt;strong&gt;进行一些格式处理&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="MySQL" scheme="https://chongtianhong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题整理二（JS部分）</title>
    <link href="https://chongtianhong.github.io/2018/05/26/interviewMap2/"/>
    <id>https://chongtianhong.github.io/2018/05/26/interviewMap2/</id>
    <published>2018-05-26T11:35:34.000Z</published>
    <updated>2018-08-30T13:56:18.228Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS-Part"><a href="#JS-Part" class="headerlink" title="JS Part"></a>JS Part</h4><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><ul><li>每个对象都有<code>__proto__</code>属性，指向了<strong>创建该对象的构造函数的原型</strong>。其实这个属性指向了<code>[[prototype]]</code>，但是<strong><code>[[prototype]]</code>是内部属性</strong>，我们并<strong>不能访问到</strong>，所以使用<code>__proto__</code>来访问。<a id="more"></a></li><li><strong>对象</strong>可以<strong>通过<code>__proto__</code>来寻找不属于该对象的属性</strong>，<code>__proto__</code><strong>将对象连接起来</strong>组成了<strong>原型链</strong>。</li></ul><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><ul><li><strong>new操作符创建对象</strong>可以分为四个步骤：<br>1、创建一个空对象，这个对象的类型是<code>object</code>；<br>2、将<strong>所创建的实例对象</strong>的<code>__proto__</code>属性值设成<strong>构造函数</strong>的<code>prototype</code>属性值（关系：<code>instance.constructor.prototype = instance.__proto__</code>）；<br>3、执行<strong>构造函数</strong>中的代码，构造函数中的this指向新创建的对象；<br>4、返回该对象（如果构造器函数有返回值，则以该对象作为返回值。若没有return或return了基本类型，则将上述的新对象作为返回值）。</li><li>对于实例对象来说，都是通过<code>new</code>产生的，无论是<strong>使用构造函数创建对象</strong><code>function Foo()</code>还是<strong>使用字面量的方式创建对象</strong><code>let a = { b : 1 }</code>。</li><li><p>对于<strong>创建一个对象</strong>来说，<strong>更推荐使用字面量的方式创建对象</strong>（无论性能上还是可读性）。因为<strong>使用<code>new Object()</code>的方式创建对象</strong>需要<strong>通过作用域链一层层找到 Object</strong>，但是如果使用字面量的方式就没这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;&#125;</span><br><span class="line">// <span class="keyword">function</span> 就是个语法糖</span><br><span class="line">// 内部等同于 new Function()</span><br><span class="line"><span class="built_in">let</span> a = &#123; b: 1 &#125;</span><br><span class="line">// 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure></li><li><p>对于<code>new</code>来说，还需要<strong>注意运算符优先级</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Foo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Foo.getName();   // -&gt; 1</span><br><span class="line">new Foo().getName(); // -&gt; 2</span><br></pre></td></tr></table></figure></li><li><p><code>new Func()</code>的优先级大于<code>new Func</code>，所以对于上述代码来说可以这样划分执行顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new (Foo.getName());   </span><br><span class="line">(new Foo()).getName();</span><br></pre></td></tr></table></figure></li><li><p>对于第一个函数来说，先执行了<code>Foo.getName()</code>，所以结果为<code>1</code>；</p></li><li>对于第二个函数来说，先执行<code>new Foo()</code>产生了一个实例，然后通过原型链找到了<code>Foo</code>上的<code>getName</code>函数，所以结果为<code>2</code>。</li></ul><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><ul><li><code>instanceof</code>可以正确的判断对象的类型，因为内部机制是通过<strong>判断对象的原型链中是否能找到构造函数的<code>prototype</code></strong>。</li><li>试着实现一下<code>instanceof</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> instanceOf(left, right) &#123;</span><br><span class="line">    // 获得构造函数的原型</span><br><span class="line">    <span class="built_in">let</span> prototype = right.prototype</span><br><span class="line">    // 判断对象的类型是否等于构造函数的原型</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === null)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        // 获得实例对象的原型</span><br><span class="line">        left = left.__proto__</span><br><span class="line">    <span class="keyword">if</span> (prototype === left)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h5><ul><li>当执行 JS 代码时，会产生三种执行上下文：<ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JS-Part&quot;&gt;&lt;a href=&quot;#JS-Part&quot; class=&quot;headerlink&quot; title=&quot;JS Part&quot;&gt;&lt;/a&gt;JS Part&lt;/h4&gt;&lt;h5 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;每个对象都有&lt;code&gt;__proto__&lt;/code&gt;属性，指向了&lt;strong&gt;创建该对象的构造函数的原型&lt;/strong&gt;。其实这个属性指向了&lt;code&gt;[[prototype]]&lt;/code&gt;，但是&lt;strong&gt;&lt;code&gt;[[prototype]]&lt;/code&gt;是内部属性&lt;/strong&gt;，我们并&lt;strong&gt;不能访问到&lt;/strong&gt;，所以使用&lt;code&gt;__proto__&lt;/code&gt;来访问。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题整理一（JS部分）</title>
    <link href="https://chongtianhong.github.io/2018/05/25/interviewMap1/"/>
    <id>https://chongtianhong.github.io/2018/05/25/interviewMap1/</id>
    <published>2018-05-25T05:42:04.000Z</published>
    <updated>2018-08-30T13:31:02.087Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JS-Part"><a href="#JS-Part" class="headerlink" title="JS Part"></a>JS Part</h4><h5 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h5><ul><li>JS 中分为<strong>七种内置类型</strong>，七种内置类型<strong>又分为两大类型</strong>：<strong>基本类型</strong>和<strong>对象（Object）</strong>。</li><li>基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</li><li>其中 <strong>JS 的数字类型是浮点类型的，没有整型</strong>。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。</li><li><code>NaN</code> 也属于 number 类型，并且<strong><code>NaN</code> 不等于自身</strong>。</li><li><p>对于<strong>基本类型</strong>来说，如果<strong>使用字面量的方式</strong>，那么<strong>这个变量只是个字面量</strong>，只有<strong>在必要的时候才会转换为对应的类型</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 111 // 这只是字面量，不是 number 类型</span><br><span class="line">a.toString() // 使用时候才会转换为对象类型</span><br></pre></td></tr></table></figure></li><li><p>对<strong>象（Object）</strong>是<strong>引用类型</strong>，在使用过程中会遇到<strong>浅拷贝</strong>和<strong>深拷贝</strong>的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123; name: <span class="string">'FE'</span> &#125;</span><br><span class="line"><span class="built_in">let</span> b = a</span><br><span class="line">b.name = <span class="string">'EF'</span></span><br><span class="line">console.log(a.name) // EF</span><br></pre></td></tr></table></figure></li></ul><h5 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h5><ul><li><p><code>typeof</code>对于<strong>基本类型</strong>，<strong>除了<code>null</code></strong>都可以显示正确的类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // <span class="string">'number'</span></span><br><span class="line">typeof <span class="string">'1'</span> // <span class="string">'string'</span></span><br><span class="line">typeof undefined // <span class="string">'undefined'</span></span><br><span class="line">typeof <span class="literal">true</span> // <span class="string">'boolean'</span></span><br><span class="line">typeof Symbol() // <span class="string">'symbol'</span></span><br><span class="line">typeof b // b 没有声明，但是还会显示 undefined</span><br></pre></td></tr></table></figure></li><li><p><code>typeof</code>对于<strong>对象</strong>，<strong>除了函数</strong>都会显示<code>object</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] // <span class="string">'object'</span></span><br><span class="line">typeof &#123;&#125; // <span class="string">'object'</span></span><br><span class="line">typeof console.log // <span class="string">'function'</span></span><br></pre></td></tr></table></figure></li><li><p>对于<code>null</code>来说，虽然它是<strong>基本类型</strong>，但是会<strong>显示 <code>object</code></strong>，这是一个存在很久了的 Bug：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof null // <span class="string">'object'</span></span><br><span class="line">/* 原因：</span><br><span class="line">因为在 JS 的最初版本中，使用的是 32 位系统，</span><br><span class="line">为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，</span><br><span class="line">然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class="line">虽然现在的内部类型判断代码已经改变了，</span><br><span class="line">但是对于这个 Bug 却是一直流传下来。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>如果我们想获得一个变量的正确类型，可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似<code>[object Type]</code>的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">type</span> = Object.prototype.toString;</span><br><span class="line">console.log(type.call(<span class="string">''</span>));//object String</span><br><span class="line">console.log(type.call([]));//object Array</span><br><span class="line">console.log(type.call(&#123;&#125;));//object Object</span><br><span class="line">console.log(type.call(<span class="literal">false</span>));//object Boolean</span><br><span class="line">console.log(type.call(null));//object Null</span><br><span class="line">console.log(type.call(undefined));//object Undefined</span><br><span class="line">console.log(type.call(<span class="function"><span class="title">function</span></span>()&#123;&#125;));//object Function</span><br></pre></td></tr></table></figure></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><h5 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h5><ul><li>在条件判断时，除了<code>undefined</code>，<code>null</code>，<code>false</code>，<code>NaN</code>，<code>‘’</code>，<code>0</code>，<code>-0</code>，<strong>其他所有值都转为<code>true</code>，包括所有对象</strong>。</li></ul><h5 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h5><ul><li><p><strong>对象在转换基本类型</strong>时，首先会<strong>调用<code>valueOf</code></strong>，然后<strong>调用<code>toString</code></strong>。并且这两个方法是<strong>可以重写</strong>的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">    <span class="function"><span class="title">valueOf</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当然也<strong>可以重写<code>Symbol.toPrimitive</code></strong>，该方法<strong>在转基本类型时调用优先级最高</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'1'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    <span class="built_in">return</span> 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 + a // =&gt; 3</span><br><span class="line"><span class="string">'1'</span> + a // =&gt; <span class="string">'12'</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h5><ul><li>只有当<strong>加法运算</strong>时，其中<strong>一方是字符串类型</strong>，就会<strong>把另一个也转为字符串类型</strong>。</li><li>并且<strong>加法运算会触发三种类型转换</strong>：将值转换为原始值，转换为数字，转换为字符串。</li><li><p><strong>其他运算</strong>只要其中一方是数字，那么另一方就转为数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 + <span class="string">'1'</span> // <span class="string">'11'</span></span><br><span class="line">2 * <span class="string">'2'</span> // 4</span><br><span class="line">[1, 2] + [2, 1] // <span class="string">'1,22,1'</span></span><br><span class="line">// [1, 2].toString() -&gt; <span class="string">'1,2'</span></span><br><span class="line">// [2, 1].toString() -&gt; <span class="string">'2,1'</span></span><br><span class="line">// <span class="string">'1,2'</span> + <span class="string">'2,1'</span> = <span class="string">'1,22,1'</span></span><br></pre></td></tr></table></figure></li><li><p>对于加号需要注意这个表达式 ‘a’ + + ‘b’，<strong>一元加操作符</strong>可以<strong>实现与<code>Number</code>相同的作用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> // -&gt; <span class="string">"aNaN"</span></span><br><span class="line">// 因为 + <span class="string">'b'</span> -&gt; NaN</span><br></pre></td></tr></table></figure></li></ul><h5 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a>== 操作符</h5><ul><li><p>比较运算<code>x==y</code>，其中<code>x</code>和<code>y</code>是值，比较运算产生<code>true</code>或<code>false</code>。这样的比较按如下方式进行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 若Type(x)与Type(y)相同，则</span><br><span class="line">    a. 若Type(x)为Undefined，返回<span class="literal">true</span>。</span><br><span class="line">    b. 若Type(x)为Null，返回<span class="literal">true</span>。</span><br><span class="line">    c. 若Type(x)为Number，则</span><br><span class="line">        i. 若x为NaN，返回<span class="literal">false</span>。</span><br><span class="line">       ii. 若y为NaN，返回<span class="literal">false</span>。</span><br><span class="line">      iii. 若x与为为相同数值，返回<span class="literal">true</span>。</span><br><span class="line">       iv. 若x为+0且y为-0，返回<span class="literal">true</span>。</span><br><span class="line">        v. 若x为-0且y为+0，返回<span class="literal">true</span>。</span><br><span class="line">       vi. 返回<span class="literal">false</span>。</span><br><span class="line">    d. 若Type(x)为String，则当x和y为完全相同的字符串序列（长度相等且相同字符在相同位置）时返回ture，否则返回<span class="literal">false</span>。</span><br><span class="line">    e. 若Type(x)为Boolean，当x和y同为<span class="literal">true</span>或者同为<span class="literal">false</span>时返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">    f. 当x和y引用同一对象时返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">2. 若x为null且y为undefined，返回<span class="literal">true</span>。</span><br><span class="line">3. 若x为undefined且y为null，返回ture。</span><br><span class="line">4. 若Type(x)为Number且Type(y)为String，返回x==Number(y)的结果。</span><br><span class="line">5. 若Type(x)为String且Type(y)为Number，返回Number(x)==y的结果。</span><br><span class="line">6. 若Type(x)为Boolean，返回比较Number(x)==y的结果。</span><br><span class="line">7. 若Type(y)为Boolean，返回比较X==Number(y)的结果。</span><br><span class="line">8. 若Type(x)为String或Number，且Type(y)为Object，返回比较x==ToPrimitive(y)的结果。</span><br><span class="line">9. 若Type(x)为Object，且Type(y)为String或Number，返回比较ToPrimitive(x)==y的结果。</span><br><span class="line">10.其余情况返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure></li><li><p>上面提到的<code>toPrimitive</code>就是<strong>对象转基本类型</strong>。</p></li><li>解析一道题目<code>[] == ![] // -&gt; true</code>，下面是这个表达式为何为 true 的步骤：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// [] 转成 <span class="literal">true</span>，然后取反变成 <span class="literal">false</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line">// 根据第 8 条得出</span><br><span class="line">[] == ToNumber(<span class="literal">false</span>)</span><br><span class="line">[] == 0</span><br><span class="line">// 根据第 10 条得出</span><br><span class="line">ToPrimitive([]) == 0</span><br><span class="line">// [].toString() -&gt; <span class="string">''</span></span><br><span class="line"><span class="string">''</span> == 0</span><br><span class="line">// 根据第 6 条得出</span><br><span class="line">0 == 0 // -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><ul><li>如果是<strong>对象</strong>，就<strong>通过<code>toPrimitive<code>将对象转换为基本类型</code></code></strong>。</li><li>如果是<strong>字符串</strong>，就<strong>通过<code>unicode<code>字符索引</code></code></strong>来比较。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JS-Part&quot;&gt;&lt;a href=&quot;#JS-Part&quot; class=&quot;headerlink&quot; title=&quot;JS Part&quot;&gt;&lt;/a&gt;JS Part&lt;/h4&gt;&lt;h5 id=&quot;内置类型&quot;&gt;&lt;a href=&quot;#内置类型&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="面试题" scheme="https://chongtianhong.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的 NaN 与 isNaN</title>
    <link href="https://chongtianhong.github.io/2018/05/24/NaN/"/>
    <id>https://chongtianhong.github.io/2018/05/24/NaN/</id>
    <published>2018-05-24T05:53:29.000Z</published>
    <updated>2018-08-27T06:22:30.911Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><ul><li><code>NaN</code> 即 <strong>Not a Number</strong>，不是一个数字。 在 JavaScript 中，<strong>整数和浮点数都统称为 <code>Number</code> 类型</strong>。</li><li><p>除此之外，<code>Number</code> 类型类型还有一个很特殊的值，即 <strong><code>NaN</code></strong> 。它<strong>是 <code>Number</code> 对象上的一个静态属性，可以通过 Number.NaN 来访问</strong>：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在 ECMAScript v1 和其后的版本中，还可以用<strong>预定义的全局属性 <code>NaN</code> 代替 <code>Number.NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN); // NaN</span><br></pre></td></tr></table></figure></li><li><p>在以下两种场景中，可能会产生 NaN 值：</p></li></ul><blockquote>表达式计算</blockquote><ul><li><p>一个表达式中如果有<strong>减号 (-)</strong>、<strong>乘号 (*)</strong>或 <strong>除号 (/) </strong>等运算符时，JS 引擎在计算之前，会试图<strong>将表达式的每个分项转化为 <code>Number</code> 类型（使用 <code>Number(x)</code> 做转换）</strong>。如果<strong>转换失败，表达式将返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100 - <span class="string">'2a'</span> ;    // NaN</span><br><span class="line"><span class="string">'100'</span> / <span class="string">'20a'</span>;  // NaN</span><br><span class="line"><span class="string">'20a'</span> * 5 ;     // NaN</span><br><span class="line">undefined - 1;  // NaN, Number(undefined) == NaN</span><br><span class="line">[] * 20 ;       // 0, Number([]) == 0</span><br><span class="line">null - 5;       // -5, Number(null) == 0</span><br></pre></td></tr></table></figure></li><li><p>而<strong>加号 (+)</strong>不会将其两边的变量转化为 Number 类型，这是因为JS表达式的执行顺序是按照运算符的优先级从左到右依次进行的：</p><ul><li><strong>如果加号 (+) 两边的变量都是 Number 类型时，才会做数字相加运算</strong>;</li><li>如果<strong>其中有一个变量是字符串</strong>，则会<strong>将两边都作为字符串相加</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 + 4 + <span class="string">'6'</span> = <span class="string">'96'</span>;</span><br><span class="line">1 + <span class="string">'2'</span> + 3 =  <span class="string">'123'</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>类型转换</blockquote><ul><li><p>直接使用<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code><strong>将一个非数字的值转化为数字</strong>时，<strong>表达式返回 <code>NaN</code></strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span> - 3   // NaN</span><br><span class="line">parseInt(<span class="string">'abc'</span>)  // NaN</span><br><span class="line">parseFloat(<span class="string">'abc'</span>) // NaN</span><br><span class="line">Number(<span class="string">'abc'</span>)    // NaN</span><br></pre></td></tr></table></figure></li><li><p>对于<strong>数字+字符</strong>的值，其转化结果会有所不同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">'123abc'</span>); // NaN</span><br><span class="line">parseInt(<span class="string">'123abc'</span>); // 123</span><br><span class="line">parseInt(<span class="string">'123abc45'</span>); // 123</span><br><span class="line">parseFloat(<span class="string">'123.45abc'</span>);// 123.45</span><br></pre></td></tr></table></figure></li><li><p><strong><code>Number</code>转换的是整个值</strong>，而不是部分值；<strong><code>parseInt</code>和 <code>parseFloat</code>只转化第一个无效字符之前的字符串</strong>。</p></li><li><p>另外，<strong>一元加操作符</strong>也可以<strong>实现与<code>Number</code>相同的作用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="string">'12abc'</span>; // NaN</span><br><span class="line">+ <span class="string">'123'</span>; // 123</span><br><span class="line">+ <span class="string">'123.78'</span>; // 123.78</span><br><span class="line">+ <span class="string">'abc'</span>; // NaN</span><br></pre></td></tr></table></figure></li><li><p>因此，<strong>当一个字符串不能被<code>parseInt</code>，<code>parseFloat</code>或<code>Number</code>成功转换时</strong>，就<strong>返回 <code>NaN</code></strong>，表示<strong>该字符串无法被识别为数字类型</strong>，这是一个<strong>异常状态</strong>，并<strong>不是一个确切的值</strong>。</p></li></ul><h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h4><ul><li><code>isNaN()</code>是一个全局方法，它的作用是<strong>检查一个值是否能被<code>Number()</code>成功转换</strong>。</li><li><p>如果<strong>能转换成功</strong>，就<strong>返回<code>false</code></strong>，否则返回<code>true</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN)          // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123'</span>)        // <span class="literal">false</span> 能转换</span><br><span class="line">isNaN(<span class="string">'abc'</span>)        // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123ab'</span>)      // <span class="literal">true</span> 不能转换</span><br><span class="line">isNaN(<span class="string">'123.45abc'</span>)  // <span class="literal">true</span> 不能转换</span><br></pre></td></tr></table></figure></li><li><p>可以看出，<strong><code>isNaN()</code>没有办法判断某个值本身是否为<code>NaN</code></strong>。</p></li><li><p>如果<strong>想要知道某个值本身是否为<code>NaN</code></strong>，可以利用<strong>NaN 不等于自身</strong>这一特性来判断：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> selfIsNaN(value)&#123;</span><br><span class="line">    <span class="built_in">return</span> value !== value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>另外，ES6 在<strong><code>Number</code>对象上</strong>也<strong>提供了<code>isNaN()</code>方法</strong>，和全局方法<code>isNaN()</code><strong>不同的是</strong>，它<strong>用于判断某个值本身是否为<code>NaN</code></strong>，而<strong>不需要进行类型转换</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(<span class="string">'123'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(<span class="string">'abc'</span>);    // <span class="literal">false</span> 本身不是NaN</span><br><span class="line">Number.isNaN(NaN);      // <span class="literal">true</span>　本身是NaN</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NaN&quot;&gt;&lt;a href=&quot;#NaN&quot; class=&quot;headerlink&quot; title=&quot;NaN&quot;&gt;&lt;/a&gt;NaN&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NaN&lt;/code&gt; 即 &lt;strong&gt;Not a Number&lt;/strong&gt;，不是一个数字。 在 JavaScript 中，&lt;strong&gt;整数和浮点数都统称为 &lt;code&gt;Number&lt;/code&gt; 类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除此之外，&lt;code&gt;Number&lt;/code&gt; 类型类型还有一个很特殊的值，即 &lt;strong&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/strong&gt; 。它&lt;strong&gt;是 &lt;code&gt;Number&lt;/code&gt; 对象上的一个静态属性，可以通过 Number.NaN 来访问&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>清除浮动的四种方式及其原理理解</title>
    <link href="https://chongtianhong.github.io/2018/05/23/clearFloat/"/>
    <id>https://chongtianhong.github.io/2018/05/23/clearFloat/</id>
    <published>2018-05-23T06:25:03.000Z</published>
    <updated>2018-08-27T03:44:16.417Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文介绍了四种清除浮动的方法，并尝试解释其原理。</li><li>在理解了各种清除浮动的原理之后，我们会发现，很多<strong>清除浮动的方法本质上其实是一样的</strong>。<a id="more"></a></li></ul><h4 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h4><ul><li><p>在讲清除浮动的方法之前，我们先来了解一下<strong>为什么要清除浮动</strong>，清除浮动的目的是什么，即，要解决什么样的问题。来看一个浮动的例子(略去了文字内容)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>其样式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在chrome中渲染的效果如下图所示：<br><img src="images/clearFloat1.png" stype="border:none" alt="浮动效果"></p></li><li>这肯定不是我们想要的渲染效果，它可能存在如下问题：<br>① <strong>文字围绕浮动元素排版</strong>，但我们可能希望文字（<code>.textDiv</code>）排列在浮动元素下方，或者，我们并不希望<code>.textDiv</code>两边有浮动元素存在。<br>② 浮动元素排版超出了其父级元素（<code>.topDiv</code>），<strong>父元素的高度出现了塌缩</strong>，若没有文字高度的支撑，不考虑边框，父级元素高度会塌缩成零。<br>③ <strong>浮动元素甚至影响到了其父元素的兄弟元素（<code>.bottomDiv</code>）排版</strong>。因为浮动元素脱离了文档流，<code>.bottomDiv</code>在计算元素位置的时候会忽略其影响，紧接着上一个元素的位置继续排列。</li><li>解决第一个问题，需要<strong>清除<code>.textDiv</code>周围的浮动</strong>。</li><li>解决第二、第三个问题，因为父元素的兄弟元素位置只受父元素位置的影响，就<strong>需要一种方法将父级元素的高度撑起来，将浮动元素包裹在其中</strong>，避免浮动元素影响父元素外部的元素排列。</li><li>接下来就开始介绍清除浮动的方法。</li></ul><h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><h5 id="利用clear样式"><a href="#利用clear样式" class="headerlink" title="利用clear样式"></a>利用clear样式</h5><ul><li><p>还是开篇的例子，我们给<strong>需要清除浮动的元素</strong>添加如下样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line"> </span><br><span class="line">    clear: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>清除浮动后的渲染效果如下：<br><img src="images/clearFloat2.png" stype="border:none" alt="清除浮动后的渲染效果"></p></li><li>解析：<ul><li>通过上面的样式，<code>.textDiv</code>告诉浏览器，我的<strong>左边不允许有浮动的元素存在</strong>，请清除掉我左边的浮动元素。</li><li>然而，因为<strong>浮动元素（.floatDiv）位置已经确定</strong>，浏览器在计算<code>.textDiv</code>的位置时，<strong>为满足其需求，将<code>.textDiv</code>渲染在浮动元素下方</strong>，保证了<code>.textDiv</code>左边没有浮动元素。</li><li>同时可以看出，<strong>父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响</strong>，这是因为<strong><code>.textDiv</code>仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的</strong>。</li><li>设置样式为<code>clear: both</code>也有相同的效果，即<strong>两边都不允许有浮动元素</strong>，clear就是对应方向的值，两边都不允许就是both。</li></ul></li><li><strong>注意</strong>：这个规则<strong>只能影响使用清除的元素本身，不能影响其他元素</strong>。</li><li><p>但是，如果我们把HTML中的<code>.floatDiv</code>和<code>.textDiv</code>55：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>无论<code>.textDiv</code>是否应用清除浮动，情况都是下面的样子：<br><img src="images/clearFloat3.png" stype="border:none" alt="交换位置后的结果"></p></li><li><strong><code>.textDiv</code>的位置先确定了</strong>，于是<strong>浮动元素就紧接着<code>.textDiv</code>下方渲染在父元素的左侧</strong>。然而，父元素的高度并没有被撑起来，没有将浮动影响“内化”，导致浮动影响到了接下来的元素排版。</li><li>看来，为达到撑起父元素高度的目的，<strong>使用clear清除浮动的方法</strong>还是<strong>有适用范围</strong>的。我们需要更加通用和可靠的方法。</li></ul><h5 id="父元素结束标签之前插入清除浮动的块级元素"><a href="#父元素结束标签之前插入清除浮动的块级元素" class="headerlink" title="父元素结束标签之前插入清除浮动的块级元素"></a>父元素结束标签之前插入清除浮动的块级元素</h5><ul><li><p>HTML结构如下，在<strong>有浮动的父级元素的末尾</strong>插入了一个<strong>没有内容的块级元素div</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"blankDiv"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>应用样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">// 区别在这里</span><br><span class="line">.blankDiv &#123;</span><br><span class="line">    clear: both; // or left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>渲染效果如下：<br><img src="images/clearFloat4.png" stype="border:none" alt="父元素结束标签之前插入清除浮动的块级元素渲染效果"></p></li><li>和第一个例子里<code>.textDiv</code>应用clear清除浮动，撑起父级元素高度的原理完全一样。这里强调一点，即，<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</li></ul><h5 id="利用伪元素（clearfix）"><a href="#利用伪元素（clearfix）" class="headerlink" title="利用伪元素（clearfix）"></a>利用伪元素（clearfix）</h5><ul><li><p>HTML结构如下，在<code>.topDiv</code>的div上再添加一个<code>clearfix</code>类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv clearfix"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 省略基本的样式</span><br><span class="line">// 区别在这里</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: <span class="string">'.'</span>;       /*生成内容作为最后一个元素，至于content里面是点还是其他都是可以的*/</span><br><span class="line">    height: 0;          /*避免生成内容破坏原有布局的高度*/</span><br><span class="line">    visibility:hidden;  /*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互*/</span><br><span class="line">    display: block;     /*使生成的元素以块级元素显示,占满剩余空间*/</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>该样式在<code>.clearfix</code>，即父级元素的最后，添加了一个:after伪元素，<strong>通过清除伪元素的浮动，达到撑起父元素高度的目的</strong>。</p></li><li>注意到该伪元素的<code>display</code>值为<code>block</code>，即，它是一个<strong>不可见的块级元素</strong>。你可能已经意识到，这也只不过是前一种清除浮动方法（添加空白div）的另一种变形，其底层逻辑也是完全一样的。这三种方法，其本质上是一样的。</li></ul><h5 id="利用overflow清除浮动"><a href="#利用overflow清除浮动" class="headerlink" title="利用overflow清除浮动"></a>利用overflow清除浮动</h5><ul><li>首先直观地看看，<code>overflow</code>是如何清除浮动的。</li><li><p>HTML结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"topDiv"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"floatDiv"</span>&gt;<span class="built_in">float</span> left&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"textDiv"</span>&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">"bottomDiv"</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>样式应用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line">.floatDiv &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border: 2px dotted red;</span><br><span class="line">    color: red;</span><br><span class="line">    margin: 4px;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.bottomDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    border: 2px dotted black;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.textDiv &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    border: 2px solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用CSS后的渲染效果如下：<br>&lt;img src=”images/clearFloat5.png” stype=”border:none” alt=”利用overflow清除浮动后的渲染效果&gt;</p></li><li>仅仅只<strong>在父级元素上添加了一个值为<code>auto</code>的<code>overflow</code>属性，父元素的高度立即被撑起</strong>，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染。</li><li>其实，<strong>这里的<code>overflow</code>值</strong>，还可以是<strong>除了”visible”之外的任何有效值，它们都能达到撑起父元素高度，清除浮动的目的</strong>。</li><li>不过，<strong>有的值可能会带来副作用</strong>，比如，scroll值会导致滚动条始终可见，hidden会使得超出边框部分不可见等。</li><li><strong>原理</strong>：当<strong>元素设置了<code>overflow</code>样式，且值不为<code>visible</code>时</strong>，该<strong>元素就建构了一个BFC</strong>。</li><li>在上面的例子中，<code>.topDiv</code>因设置了值为<code>auto</code>的<code>overflow</code>样式，所以<strong>该元素建构出一个BFC</strong>，按照第三个特点，<strong>BFC的高度是要包括浮动元素的</strong>，所以<code>.topDiv</code>的高度被撑起来，<strong>达到了清除浮动影响的目的</strong>。</li><li><strong>注意</strong>：这里<strong><code>overflow</code>的作用就是为了构建一个BFC区域，让内部浮动的影响都得以“内化”</strong>。而<strong>构建一个BFC区域的方法有很多种，<code>overflow</code>只是其中的一种</strong>，因此，我们也<strong>可以利用其它的方式构建BFC，且同样能达到清除浮动的目的</strong>。</li><li><p>BFC定义中说，<code>inline-block</code>同样也能构建BFC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.topDiv &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 2px solid black;</span><br><span class="line"> </span><br><span class="line">    // 区别在这里</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">// 其他样式相同，省略</span><br></pre></td></tr></table></figure></li><li><p>渲染效果和使用<code>overflow</code>的效果完全一样。</p></li></ul><h5 id="另外一些方法"><a href="#另外一些方法" class="headerlink" title="另外一些方法"></a>另外一些方法</h5><blockquote>给浮动元素父级设置高度</blockquote><ul><li>使用浮动后，<strong>父元素高度塌陷</strong>是因为<strong>给浮动元素的父级高度是自适应导致的</strong>，因此，可以<strong>给它设置适当的高度</strong>来解决这一问题，然而，缺点是<strong>在浮动元素高度不确定的时候不适用</strong>。</li></ul><blockquote>父级也设置浮动</blockquote><ul><li>缺点：需要给每个浮动元素父级添加浮动，浮动多了容易出现问题。</li></ul><blockquote>使用br清浮动</blockquote><ul><li><p><strong>br标签自带clear属性</strong>，将它的<strong>clear属性设置成both</strong>其实和添加空div原理是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"top"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;br clear=<span class="string">"both"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>缺点：<strong>不符合工作中结构、样式、行为，三者分离的要求</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文介绍了四种清除浮动的方法，并尝试解释其原理。&lt;/li&gt;
&lt;li&gt;在理解了各种清除浮动的原理之后，我们会发现，很多&lt;strong&gt;清除浮动的方法本质上其实是一样的&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="浮动" scheme="https://chongtianhong.github.io/tags/%E6%B5%AE%E5%8A%A8/"/>
    
      <category term="清除浮动" scheme="https://chongtianhong.github.io/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>ES6 类(Class)基本用法与静态属性 + 静态方法</title>
    <link href="https://chongtianhong.github.io/2018/05/22/ES6Class/"/>
    <id>https://chongtianhong.github.io/2018/05/22/ES6Class/</id>
    <published>2018-05-22T06:33:15.000Z</published>
    <updated>2018-08-24T14:41:56.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类-Class-的基本用法"><a href="#类-Class-的基本用法" class="headerlink" title="类(Class)的基本用法"></a>类(Class)的基本用法</h4><ul><li>在 ES6 规范中，引入了<code>Class</code>的概念。使得 JS 开发者终于告别了<strong>直接使用原型对象模仿面向对象中的类</strong>和<strong>类继承</strong>时代。</li><li>但是JS 中并没有一个真正的<code>Class</code>原始类型，<strong><code>Class</code></strong>仅仅只是对原型对象运用语法糖，<strong>作为对象的模板</strong>。所以，只有理解如何<strong>使用原型对象实现类和类继承</strong>，才能真正地用好<code>Class</code>。<a id="more"></a></li><li><p>下面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是<strong>构造方法</strong>，而<code>this</code>关键字则代表实例对象。也就是说，<strong>ES5的构造函数</strong><code>Point</code>，<strong>对应ES6的<code>Point</code>类的构造方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ES6定义类</span><br><span class="line">class Point &#123;</span><br><span class="line">    constructor(x, y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    // prototype属性</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等价于</span><br><span class="line">// ES5的构造函数</span><br><span class="line"><span class="keyword">function</span> Point(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype = <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'('</span> + this.x + <span class="string">', '</span> + this.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定义“类”的方法</strong>的时候，<strong>前面不需要加上<code>function</code>这个关键字</strong>，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔</strong>，加了会报错。</p></li><li><p><strong>构造函数的prototype属性</strong>，在ES6的“类”上面继续存在。事实上，<strong>类的所有方法都定义在类的prototype属性上面</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>方法可以很方便地<strong>一次向类添加多个方法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Point.prototype, &#123;</span><br><span class="line">    <span class="function"><span class="title">toString</span></span>()&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">toValue</span></span>()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>类的内部所有定义的方法</strong>，都是<strong>不可枚举的（non-enumerable）</strong>。这一点与ES5的行为不一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES5可枚举，ES6不可枚举</span><br><span class="line">Object.keys(Point.prototype)</span><br></pre></td></tr></table></figure></li><li><p>constructor方法是类的默认方法，<strong>通过new命令生成对象实例时，自动调用该方法</strong>。一个类必须有constructor方法，如果<strong>没有显式定义，一个空的constructor方法会被默认添加</strong>。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p></li><li><strong>类的构造函数，不使用new是没法调用的</strong>，会报错。</li><li><p>可以<strong>通过实例的<code>__proto__</code>属性</strong>为Class添加方法，<strong>可被所有的实例所共享</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Point(2,3);</span><br><span class="line">var p2 = new Point(3,2);</span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="title">function</span></span> () &#123; <span class="built_in">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // <span class="string">"Oops"</span></span><br><span class="line">p2.printName() // <span class="string">"Oops"</span></span><br><span class="line"></span><br><span class="line">var p3 = new Point(4,2);</span><br><span class="line">p3.printName() // <span class="string">"Oops"</span></span><br></pre></td></tr></table></figure></li><li><p>可见，<strong>使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎</strong>，不推荐使用，因为这<strong>会改变Class的原始定义，影响到所有实例</strong>。</p></li><li><code>Class</code><strong>不存在变量提升（hoist）</strong>。</li></ul><h4 id="typeof-class-“function”"><a href="#typeof-class-“function”" class="headerlink" title="typeof class == “function”"></a>typeof class == “function”</h4><ul><li>使用<code>Class</code>的语法，让开发者告别了使用 prototype 模仿面向对象的时代。但是，<strong><code>Class</code></strong>并不是 ES6 引入的全新概念，它的<strong>原理依旧是原型继承</strong>。</li><li>通过类型判断，我们可以得知，<strong><code>Class</code></strong>的并不是什么全新的数据类型，它<strong>实际只是 function (或者说 object)</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeof Person // <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><ul><li>在传统面向对象中，<strong>类</strong>是<strong>可以继承类</strong>的。这样子<strong>类</strong>就<strong>可以复制父类的方法，达到代码复用的目的</strong>。</li><li><p>ES6 也提供了类继承的语法<code>extends</code>，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        this.me = who;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">identify</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"I am "</span> + this.me;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">    constructor(who)&#123;</span><br><span class="line">        // super() 指的是调用父类</span><br><span class="line">        // 调用的同时，会绑定 this 。</span><br><span class="line">        // 如：Foo.call(this, who)</span><br><span class="line">        super(who);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">speak</span></span>()&#123;</span><br><span class="line">        alert( <span class="string">"Hello, "</span> + this.identify() + <span class="string">"."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b1 = new Bar( <span class="string">"b1"</span> );</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br></pre></td></tr></table></figure></li><li><p>当实例<code>b1</code>调用<code>speak</code>方法时，<code>b1</code>本身没有 <code>speak</code>，所以会到<code>Bar.prototype</code>原型对象上查找，并且调用原型对象上的<code>speak</code>方法。调用<code>identify</code>方式时，由于<code>this</code>指向的是<code>b1</code>对象。所以也会先在<code>b1</code>本身查找，然后沿着原型链，查找<code>Bar.prototype</code>，最后在<code>Foo.prototype</code>原型对象上找到<code>identify</code>方法，然后调用。</p></li><li>实际上，在 JavaScript 中，<strong>类继承的本质依旧是原型对象</strong>。</li></ul><h4 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h4><ul><li><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果<strong>在一个方法前，加上static关键字，就表示该方法不会被实例继承</strong>，而是<strong>直接通过类来调用</strong>，这就称为<strong>“静态方法”</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line">// 定义静态方法</span><br><span class="line">static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 通过类名直接调用</span><br><span class="line">console.log(StaticMethod.getAge());</span><br></pre></td></tr></table></figure></li><li><p><strong>静态方法只能在静态方法中调用，不能在实例方法中调用</strong>。</p></li></ul><h4 id="Class的静态属性和实例属性"><a href="#Class的静态属性和实例属性" class="headerlink" title="Class的静态属性和实例属性"></a>Class的静态属性和实例属性</h4><ul><li><p><strong>静态属性</strong>指的是<strong>Class本身的属性</strong>，即<code>Class.propname</code>，而不是定义在实例对象（this）上的属性。ES6使用静态属性和实例属性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line"></span><br><span class="line">// 定义实例属性</span><br><span class="line">// ES6实例属性只能在constructor构造函数中定义</span><br><span class="line"><span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.width = <span class="string">'40cm'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">&#125;</span><br><span class="line">// 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">width;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：目前ES6，只有这种写法可行，<strong>因为ES6明确规定，Class内部只有静态方法，没有静态属性</strong>。</p></li><li><p><strong>ES7</strong>有一个<strong>静态属性的提案</strong>，目前Babel转码器支持。安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，不同的stage封装了不同的插件，官方推荐是使用stage-1安装命令(根据自己的需求调整):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-preset-stage-0</span><br></pre></td></tr></table></figure></li><li><p>ES7使用<strong>静态属性</strong>和<strong>实例属性</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethod.js</span><br><span class="line"></span><br><span class="line">// ES7提案 定义静态属性</span><br><span class="line">static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"></span><br><span class="line">// ES7定义实例属性</span><br><span class="line">height = <span class="string">'150cm'</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>说明</strong>：<strong>ES7和ES6的静态属性和实例属性</strong>只是<strong>定义不一样</strong>，<strong>调用的方式是一样的</strong>。</p></li><li>Class的<strong>静态方法/Class静态属性</strong>和<strong>实例属性</strong>的整个案例:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// StaticMethodParent.js</span><br><span class="line"><span class="built_in">export</span> default class StaticMethodParent&#123;</span><br><span class="line">    static <span class="function"><span class="title">getCommon</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'父类的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// StaticMethod.js</span><br><span class="line">import StaticMethodParent from <span class="string">'./StaticMethodParent'</span></span><br><span class="line"> </span><br><span class="line">// 定义静态属性和静态方法</span><br><span class="line">class StaticMethod extends StaticMethodParent&#123;</span><br><span class="line">    // 因为ES6明确规定，Class内部只有静态方法，没有静态属性,所以ES6在类中定义静态属性都是错误的。</span><br><span class="line">    // static lastName = <span class="string">'pcaca'</span>;ES6错误</span><br><span class="line"> </span><br><span class="line">    // ES7提案 定义静态属性</span><br><span class="line">    // 安装babel-preset-stage-0 包含了0-3的stage，可根据需要添加，</span><br><span class="line">    // 不同的stage封装了不同的插件，官方推荐是使用stage-1</span><br><span class="line">    static lastName = <span class="string">'pcaca'</span>;</span><br><span class="line"> </span><br><span class="line">    // ES7定义实例属性</span><br><span class="line">    height = <span class="string">'150cm'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getHeight</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.height;//ES7的使用也要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // ES6实例属性只能在constructor构造函数中定义</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.width = <span class="string">'40cm'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</span><br><span class="line">    width;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">getWidth</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> this.width;//使用的时候需要加上this</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 定义静态方法</span><br><span class="line">    static <span class="function"><span class="title">getAge</span></span>()&#123;</span><br><span class="line">        // 子类可以调用父类的静态方法</span><br><span class="line">        console.log(super.getCommon());</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'获取Age的静态方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 定义静态属性</span><br><span class="line">StaticMethod.firstName = <span class="string">'pca'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">export</span> &#123;StaticMethod&#125;;</span><br><span class="line"> </span><br><span class="line">// index.js</span><br><span class="line">import &#123;StaticMethod&#125; from <span class="string">'./StaticMethod'</span>;</span><br><span class="line">console.log(StaticMethod.getAge());</span><br><span class="line">console.log(StaticMethod.getCommon());</span><br><span class="line">console.log(StaticMethod.firstName);</span><br><span class="line">console.log(StaticMethod.lastName);</span><br><span class="line"><span class="built_in">let</span> staticMethod = new StaticMethod();</span><br><span class="line">console.log(staticMethod.height);</span><br><span class="line">console.log(staticMethod.getHeight());</span><br><span class="line">console.log(staticMethod.width);</span><br><span class="line">console.log(staticMethod.getWidth());</span><br><span class="line">//staticMethod.getAge();//bundle.js:7906 Uncaught TypeError: staticMethod.getAge is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;类-Class-的基本用法&quot;&gt;&lt;a href=&quot;#类-Class-的基本用法&quot; class=&quot;headerlink&quot; title=&quot;类(Class)的基本用法&quot;&gt;&lt;/a&gt;类(Class)的基本用法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在 ES6 规范中，引入了&lt;code&gt;Class&lt;/code&gt;的概念。使得 JS 开发者终于告别了&lt;strong&gt;直接使用原型对象模仿面向对象中的类&lt;/strong&gt;和&lt;strong&gt;类继承&lt;/strong&gt;时代。&lt;/li&gt;
&lt;li&gt;但是JS 中并没有一个真正的&lt;code&gt;Class&lt;/code&gt;原始类型，&lt;strong&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/strong&gt;仅仅只是对原型对象运用语法糖，&lt;strong&gt;作为对象的模板&lt;/strong&gt;。所以，只有理解如何&lt;strong&gt;使用原型对象实现类和类继承&lt;/strong&gt;，才能真正地用好&lt;code&gt;Class&lt;/code&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Class" scheme="https://chongtianhong.github.io/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>使用Javascript监控前端相关数据</title>
    <link href="https://chongtianhong.github.io/2018/05/21/frontEndMonitor/"/>
    <id>https://chongtianhong.github.io/2018/05/21/frontEndMonitor/</id>
    <published>2018-05-21T12:40:59.000Z</published>
    <updated>2018-08-23T15:06:44.798Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。<strong>项目上线前期的粒度较大的错误</strong>我们都会<strong>在自测和QA测试中发现</strong>，然而<strong>上线之后的错误不是那么好发现</strong>。同时<strong>移动端的开发</strong>也面临着一个问题就是<strong>不好调试</strong>，所以<strong>web开发的错误监控</strong>是一个非常有用的措施。<a id="more"></a></li></ul><h4 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h4><ul><li>常见的web错误主要分为两类：<br>① <strong>运行时错误</strong>：这个错误往往是我们在代码书写时造成的，比如语法错误、逻辑错误，这样的错误通常在测试阶段就会被发现，但是也可能存在“漏网之鱼”。<br>② <strong>资源加载错误</strong>：这个错误通常是找不到文件或者是文件加载超时造成的。</li></ul><h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><ul><li>基于上面两种的错误类型，也有不同的错误捕获方式：</li></ul><blockquote>代码错误捕获：</blockquote><ul><li><p>使用<code>try…catch…</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">    // 运行可能出错的代码</span><br><span class="line"></span><br><span class="line">&#125;catch&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>windown.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote>资源加载错误：</blockquote><ul><li><p><code>bject.onerror</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var img =document.getElementById(<span class="string">'#img'</span>);</span><br><span class="line"></span><br><span class="line">img.onerror = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用window的Error事件代理，但是需要注意的是<strong>Error事件是不冒泡的</strong>，我们可以<strong>使用事件捕获进行代理</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(<span class="string">"error"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    // 捕获错误</span><br><span class="line"></span><br><span class="line">&#125;,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h4><ul><li>常见错误上报有两种： <strong>ajax</strong>、<strong>image对象</strong>推荐）。</li><li><strong>ajax上报</strong>就是在上文注释错误捕获的地方发起ajax请求，来向服务器发送错误信息。</li><li>利用<strong>image对象</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src =<span class="string">"http://post.error.com?"</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="跨域js文件错误获取"><a href="#跨域js文件错误获取" class="headerlink" title="跨域js文件错误获取"></a>跨域js文件错误获取</h4><ul><li><strong>跨域js文件获取是有限制的</strong>，如果想<strong>获取其他域下的js错误</strong>需要<strong>在script标签里添加crossorigin属性</strong>，然后<strong>服务器端要设置</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">'Access-Control-Allow-Origin: *'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="前端监控系统模块实现"><a href="#前端监控系统模块实现" class="headerlink" title="前端监控系统模块实现"></a>前端监控系统模块实现</h4><ul><li>项目开发完成外发后，没有一个监控系统，我们很难了解到发布出去的代码在用户机器上执行是否正确，所以需要建立<strong>前端代码性能相关的监控系统</strong>。</li><li>所以我们需要做以下的一些模块：</li></ul><h5 id="收集脚本执行错误"><a href="#收集脚本执行错误" class="headerlink" title="收集脚本执行错误"></a>收集脚本执行错误</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> error(msg, url, line)&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi"</span>; // 收集上报数据的信息</span><br><span class="line">    var m =[msg, url, line, navigator.userAgent, +new Date];// 收集错误信息，发生错误的脚本文件网络地址，用户代理信息，时间</span><br><span class="line">    var url = REPORT_URL + m.join(<span class="string">'||'</span>);// 组装错误上报信息内容URL</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = url;// 发送数据到后台cgi</span><br><span class="line">&#125;</span><br><span class="line">// 监听错误上报</span><br><span class="line">window.onerror = <span class="keyword">function</span>(msg,url,line)&#123;</span><br><span class="line">    error(msg,url,line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<strong>管理后台系统</strong>，我们可以看到页面上每次错误的信息，通过这些信息我们可以很快定位并且解决问题。</li></ul><h5 id="收集页面执行性能信息"><a href="#收集页面执行性能信息" class="headerlink" title="收集页面执行性能信息"></a>收集页面执行性能信息</h5><ul><li>performance包含<strong>页面加载到执行完成</strong>的整个生命周期中<strong>不同执行步骤的执行时间</strong>。</li><li><p>计算不同步骤时间相对于navigationStart的时间差，可以通过相应后台CGI收集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_performance</span></span>()&#123;</span><br><span class="line">    var REPORT_URL = <span class="string">"xxxx/cgi?perf="</span>;</span><br><span class="line">    var perf = (window.webkitPerformance ? window.webkitPerformance : window.msPerformance ),</span><br><span class="line">        points = [<span class="string">'navigationStart'</span>,<span class="string">'unloadEventStart'</span>,<span class="string">'unloadEventEnd'</span>,<span class="string">'redirectStart'</span>,<span class="string">'redirectEnd'</span>,<span class="string">'fetchStart'</span>,<span class="string">'domainLookupStart'</span>,<span class="string">'connectStart'</span>,<span class="string">'requestStart'</span>,<span class="string">'responseStart'</span>,<span class="string">'responseEnd'</span>,<span class="string">'domLoading'</span>,<span class="string">'domInteractive'</span>,<span class="string">'domContentLoadedEventEnd'</span>,<span class="string">'domComplete'</span>,<span class="string">'loadEventStart'</span>,<span class="string">'loadEventEnd'</span>];</span><br><span class="line">    var timing = pref.timing;</span><br><span class="line">    perf = perf  ? perf : window.performance;</span><br><span class="line">    <span class="keyword">if</span>( perf  &amp;&amp; timing ) &#123;</span><br><span class="line">        var arr = [];</span><br><span class="line">        var navigationStart = timing[points[0]];</span><br><span class="line">        <span class="keyword">for</span>(var i=0,l=points.length;i&lt;l;i++)&#123;</span><br><span class="line">            arr[i] = timing[points[i]] - navigationStart;</span><br><span class="line">        &#125;</span><br><span class="line">    var url = REPORT_URL + arr.join(<span class="string">"-"</span>);</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img=null;</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过后台接口收集和统计，我们可以对<strong>页面执行性能</strong>有很详细的了解。</p></li></ul><h5 id="统计每个页面的JS和CSS加载时间"><a href="#统计每个页面的JS和CSS加载时间" class="headerlink" title="统计每个页面的JS和CSS加载时间"></a>统计每个页面的JS和CSS加载时间</h5><ul><li>在<strong>JS或者CSS加载之前打上时间戳，加载之后打上时间戳</strong>，并且将数据（时间差）上报到后台。<strong>加载时间</strong>反映了<strong>页面白屏</strong>，<strong>可操作的等待时间</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;var cssLoadStart = +new Date&lt;/script&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx1.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"xxx2.css"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> media=<span class="string">"all"</span>&gt;</span><br><span class="line">&lt;sript&gt;</span><br><span class="line">    var cssLoadTime = (+new Date) - cssLoadStart;</span><br><span class="line">    var jsLoadStart = +new Date;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx1.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx2.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"xx3.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var jsLoadTime = (+new Date) - jsLoadStart;</span><br><span class="line">    var REPORT_URL = <span class="string">'xxx/cgi?data='</span></span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = img.onerror = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        img = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = REPORT_URL + cssLoadTime + <span class="string">'-'</span> + jsLoadTime;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><h5 id="new-Date"><a href="#new-Date" class="headerlink" title="+new Date"></a>+new Date</h5><ul><li>JavaScript中可以在某个元素前使用 ‘+’ 号，这个操作是<strong>将该元素转换成Number类型</strong>，如果<strong>转换失败</strong>，那么<strong>将得到 NaN</strong>。</li><li>所以，<code>+new Date</code>将会调用<code>Date.prototype</code>上的 <code>valueOf</code>方法，而根据 MDN 文档，<code>Date.prototype.valueOf</code>方法等同于<code>Date.prototype.getTime()</code>，得到毫秒。</li><li>所以下列代码效果相同：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(+new Date);</span><br><span class="line"> </span><br><span class="line">console.log(new Date().getTime());</span><br><span class="line"> </span><br><span class="line">console.log(new Date().valueOf());</span><br><span class="line"> </span><br><span class="line">console.log(new Date() * 1);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在当今的互联网时代，web开发越来越受到重视，网页能实现的功能也越来多，之前只能在客户端上运行的程序，也逐渐转到网页上，面对成千上万的用户，出现错误的概率也是越来大。&lt;strong&gt;项目上线前期的粒度较大的错误&lt;/strong&gt;我们都会&lt;strong&gt;在自测和QA测试中发现&lt;/strong&gt;，然而&lt;strong&gt;上线之后的错误不是那么好发现&lt;/strong&gt;。同时&lt;strong&gt;移动端的开发&lt;/strong&gt;也面临着一个问题就是&lt;strong&gt;不好调试&lt;/strong&gt;，所以&lt;strong&gt;web开发的错误监控&lt;/strong&gt;是一个非常有用的措施。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="前端监控" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Javascript" scheme="https://chongtianhong.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript定义类（class）的三种方法</title>
    <link href="https://chongtianhong.github.io/2018/05/20/ClassDefinition/"/>
    <id>https://chongtianhong.github.io/2018/05/20/ClassDefinition/</id>
    <published>2018-05-20T03:13:53.000Z</published>
    <updated>2018-08-23T15:09:25.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在<strong>面向对象编程</strong>中，<strong>类（class）是对象（object）的模板</strong>，定义了<strong>同一组对象（又称”实例”）共有的属性和方法</strong>。</li><li>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。</li><li>本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。<a id="more"></a><h4 id="构造函数法"><a href="#构造函数法" class="headerlink" title="构造函数法"></a>构造函数法</h4></li><li>这是经典方法，也是教科书必教的方法。</li><li><p>它用<strong>构造函数模拟”类”</strong>，在其内部用<code>this</code>关键字指代实例对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Cat</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">"大毛"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成实例的时候，使用<code>new</code>关键字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = new Cat();</span><br><span class="line">alert(cat1.name); // 大毛</span><br></pre></td></tr></table></figure></li><li><p>类的属性和方法，还可以<strong>定义在构造函数的prototype对象之上</strong>，<strong>实现不同实例属性和方法的共享</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype.makeSound = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(<span class="string">"喵喵喵"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法的主要缺点是，比较复杂，用到了<code>this</code>和<code>prototype</code>，编写和阅读都很费力。</p></li></ul><h4 id="Object-create-法"><a href="#Object-create-法" class="headerlink" title="Object.create()法"></a>Object.create()法</h4><ul><li>为了解决”构造函数法”的缺点，<strong>更方便地生成对象</strong>，Javascript的国际标准ECMAScript第五版，提出了一个新的方法<code>Object.create()</code>。</li><li><p>用这个方法，<strong>“类”</strong>就<strong>是一个对象</strong>，不是函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    name: <span class="string">"大毛"</span>,</span><br><span class="line">    makeSound: <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">        alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，直接用<code>Object.create()</code>生成实例，不需要用到<code>new</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Object.create(Cat);</span><br><span class="line">alert(cat1.name); // 大毛</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Object.create) &#123;</span><br><span class="line">    Object.create = <span class="keyword">function</span> (o) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="built_in">return</span> new F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种方法<strong>比”构造函数法”简单</strong>，但是<strong>不能实现私有属性和私有方法</strong>，<strong>实例对象之间也不能共享数据</strong>，<strong>对”类”的模拟不够全面</strong>。</p></li></ul><h4 id="极简主义法（推荐）"><a href="#极简主义法（推荐）" class="headerlink" title="极简主义法（推荐）"></a>极简主义法（推荐）</h4><ul><li>荷兰程序员Gabor de Mooij提出了一种比<code>Object.create()</code>更好的新方法，他称这种方法为”极简主义法”（minimalist approach）。这也是<strong>本文推荐的方法</strong>。</li><li>接下来介绍该方法的特点。</li></ul><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><ul><li>这种方法<strong>不使用<code>this</code>和<code>prototype</code></strong>，<strong>代码部署起来非常简单</strong>，这大概也是它被叫做”极简主义法”的原因。</li><li><p>首先，它也是<strong>用一个对象模拟”类”</strong>。在这个类里面，定义一个构造函数（方法）<code>createNew()</code>，用来生成实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // some code here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，<strong>在<code>createNew()</code>里面，定义一个实例对象</strong>，把这个<strong>实例对象作为返回值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(<span class="string">"喵喵喵"</span>); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用的时候，<strong>调用<code>createNew()</code>方法，就可以得到实例对象</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这种方法的好处是，<strong>容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造</strong>，因此可以方便地部署下面的特性。</p></li></ul><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul><li><strong>让一个类继承另一个类</strong>，实现起来很方便。只要<strong>在前者（继承者）的<code>createNew()</code>方法中，调用后者（被继承者）的<code>createNew()</code>方法</strong>即可。</li><li><p>先定义一个Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Animal = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var animal = &#123;&#125;;</span><br><span class="line">        animal.sleep = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"睡懒觉"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，在Cat的<code>createNew()</code>方法中，调用Animal的<code>createNew()</code>方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var cat = Animal.createNew();</span><br><span class="line">    cat.name = <span class="string">"大毛"</span>;</span><br><span class="line">    cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; alert(<span class="string">"喵喵喵"</span>); &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>这样得到的Cat实例，就会同时继承Cat类和Animal类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">cat1.sleep(); // 睡懒觉</span><br></pre></td></tr></table></figure></li></ul><h5 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h5><ul><li><p>在<code>createNew()</code>方法中，只要不是定义在cat对象上的方法和属性，都是私有的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        var sound = <span class="string">"喵喵喵"</span>;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上例的内部变量<code>sound</code>，外部无法读取，只有通过cat的公有方法<code>makeSound()</code>来读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">alert(cat1.sound); // undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h5><ul><li><p>有时候，我们<strong>需要所有实例对象，能够读写同一项内部数据</strong>。这个时候，只要<strong>把这个内部数据，封装在类对象的里面、createNew()方法的外面</strong>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">    sound : <span class="string">"喵喵喵"</span>,</span><br><span class="line">    createNew: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var cat = &#123;&#125;;</span><br><span class="line">        cat.makeSound = <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">            alert(Cat.sound); </span><br><span class="line">        &#125;;</span><br><span class="line">        cat.changeSound = <span class="keyword">function</span>(x)&#123; </span><br><span class="line">            Cat.sound = x; </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后，生成两个实例对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var cat1 = Cat.createNew();</span><br><span class="line">var cat2 = Cat.createNew();</span><br><span class="line">cat1.makeSound(); // 喵喵喵</span><br></pre></td></tr></table></figure></li><li><p>这时，如果有一个<strong>实例对象，修改了共享的数据，另一个实例对象也会受到影响</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat2.changeSound(<span class="string">"啦啦啦"</span>);</span><br><span class="line">cat1.makeSound(); // 啦啦啦</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;面向对象编程&lt;/strong&gt;中，&lt;strong&gt;类（class）是对象（object）的模板&lt;/strong&gt;，定义了&lt;strong&gt;同一组对象（又称”实例”）共有的属性和方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。&lt;/li&gt;
&lt;li&gt;本文总结了Javascript定义”类”的三种方法，同时讨论了每种方法的特点。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>defer和async的区别</title>
    <link href="https://chongtianhong.github.io/2018/05/19/asyncAndDefer/"/>
    <id>https://chongtianhong.github.io/2018/05/19/asyncAndDefer/</id>
    <published>2018-05-19T10:35:46.000Z</published>
    <updated>2018-08-22T14:42:14.840Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>script</code>标签用于<strong>加载脚本与执行脚本</strong>，直接使用<code>script</code>标签（不加<code>defer</code>或<code>async</code>属性）的话，<strong>HTML会按照顺序来加载并执行脚本</strong>，在<strong>脚本加载&amp;执行的过程中</strong>，会<strong>阻塞后续的DOM渲染</strong>。<a id="more"></a></li><li><p>使用<code>async</code>属性，<strong>加载和渲染后续文档元素的过程</strong>将和 script.js 的<strong>加载与执行</strong>并行进行（异步）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=<span class="string">"script.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>defer</code>属性，<strong>加载后续文档元素的过程</strong>将和script.js的<strong>加载</strong>并行进行（异步），但是<strong>script.js的执行要在所有元素解析完成之后</strong>、<strong>DOMContentLoaded 事件触发之前</strong>完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"myscript.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>从实用角度来说，<strong>把所有脚本都丢到HTML文档最后、&lt;/body&gt;之前</strong>是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可<strong>保证非脚本的其他一切元素</strong>能够<strong>以最快的速度得到加载和解析</strong>。</p></li><li>下图中，蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。<br><img src="/images/asyncAndDefer1.png" alt="脚本加载和执行过程" width="600" style="border:none"></li><li>此图告诉我们以下几个要点：<br>1.<code>defer</code> 和 async 在<strong>网络读取（下载）时都是异步的</strong>（相较于 HTML 解析）。<br>2.它们差别在于脚本下载完之后何时执行，显然<strong><code>defer</code>是最接近我们对于应用脚本加载和执行的要求的</strong>。<br>3.关于<code>defer</code>，HTML5规范要求脚本执行应该按照脚本出现的先后顺序执行，但<strong>实际情况下，延迟脚本不一定按照先后顺序执行</strong>。<br>4.<strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>，与声明顺序无关。<br>5.<code>async</code>对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它<strong>对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适</strong>的，最典型的例子：谷歌/百度统计。</li></ul><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><ul><li>如果<code>script</code>标签设置了<code>defer</code>属性，则浏览器会<strong>异步的下载该文件</strong>并且<strong>不会影响到后续DOM的渲染</strong>；</li><li>如果有<strong>多个设置了<code>defer</code>的<code>script</code>标签</strong>存在，则会<strong>按照顺序执行所有的<code>script</code></strong>；</li><li><code>defer</code>脚本会<strong>在文档渲染完毕后，DOMContentLoaded事件调用前执行</strong>。</li></ul><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul><li><code>async</code>的设置，会使得<strong><code>script</code>脚本异步的加载</strong>并在允许的情况下执行。</li><li><strong><code>async</code>的执行</strong>，并<strong>不会按着<code>script</code>在页面中的顺序来执行</strong>，而是<strong>谁先加载完谁执行</strong>。</li><li><strong>DOMContentLoaded事件的触发并不受设置了<code>async</code>属性的脚本加载的影响</strong>，也就是说，<strong><code>async</code>属性脚本的加载不计入DOMContentLoaded事件统计</strong>。在脚本加载完之前，有可能已经触发了DOMContentLoaded。如果给设置了<code>async</code>属性的脚本一定的时间，是<strong>有可能在DOMContentLoaded事件之前就执行</strong>的。</li><li>设置了<code>async</code>属性的脚本的执行是<strong>加载完成就会去执行</strong>，而不像defer那样要等待所有的脚本加载完后按照顺序执行。</li></ul><h4 id="图例分析"><a href="#图例分析" class="headerlink" title="图例分析"></a>图例分析</h4><ul><li>拿四个不同的颜色来标明各自代表的含义，蓝色为文档解析，紫色为脚本渲染，黄色为脚本执行，绿色为DOMContentLoaded。</li></ul><h5 id="普通script"><a href="#普通script" class="headerlink" title="普通script"></a>普通script</h5><ul><li>文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载（但是Chrome会做一个优化，如果遇到script脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载script所对应的资源，这样能够节省一部分下载的时间）。</li><li><strong>资源的下载是在解析过程中进行</strong>的，虽说script1脚本会很快的加载完毕，但是如果它前边的script2并没有加载&amp;执行，所以它只能处于一个挂起的状态，等待script2执行完毕后再执行。</li><li>当这两个脚本都执行完毕后，才会继续解析页面。<br><img src="/images/asyncAndDefer2.png" alt="普通script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="defer-1"><a href="#defer-1" class="headerlink" title="defer"></a>defer</h5><ul><li>文档解析时，遇到设置了<code>defer</code>的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。</li><li>会<strong>等到所有的<code>defer</code>脚本加载完毕并按照顺序执行，执行完毕后</strong>会<strong>触发DOMContentLoaded事件</strong>。<br><img src="/images/asyncAndDefer3.png" alt="设置defer属性script的加载和执行过程" width="600" style="border:none"></li></ul><h5 id="async-1"><a href="#async-1" class="headerlink" title="async"></a>async</h5><ul><li><code>async</code>脚本会在<strong>加载完毕后立即执行</strong>。</li><li><code>async</code>脚本的加载<strong>不计入DOMContentLoaded事件统计</strong>，也就是说下图两种情况都是有可能发生的。</li><li>情况一：<br><img src="/images/asyncAndDefer4.png" alt="设置async属性script的加载和执行过程情况1" width="600" style="border:none"></li><li>情况二：<br><img src="/images/asyncAndDefer5.png" alt="设置async属性script的加载和执行过程情况2" width="600" style="border:none"></li></ul><h4 id="推荐的应用场景"><a href="#推荐的应用场景" class="headerlink" title="推荐的应用场景"></a>推荐的应用场景</h4><h5 id="defer-2"><a href="#defer-2" class="headerlink" title="defer"></a>defer</h5><ul><li>如果<strong>脚本代码依赖于页面中的DOM元素</strong>（文档是否解析完毕），或者<strong>被其他脚本文件依赖</strong>。例：<ul><li>评论框</li><li>代码语法高亮</li><li>polyfill.js</li></ul></li></ul><h5 id="async-2"><a href="#async-2" class="headerlink" title="async"></a>async</h5><ul><li>如果<strong>脚本并不关心页面中的DOM元素</strong>（文档是否解析完毕），并且<strong>也不会产生其他脚本需要的数据</strong>。例：<ul><li>谷歌/百度统计</li></ul></li><li>如果不太能确定的话，用defer总是会比async稳定（保证脚本执行顺序性、文档渲染完成后才执行）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;script&lt;/code&gt;标签用于&lt;strong&gt;加载脚本与执行脚本&lt;/strong&gt;，直接使用&lt;code&gt;script&lt;/code&gt;标签（不加&lt;code&gt;defer&lt;/code&gt;或&lt;code&gt;async&lt;/code&gt;属性）的话，&lt;strong&gt;HTML会按照顺序来加载并执行脚本&lt;/strong&gt;，在&lt;strong&gt;脚本加载&amp;amp;执行的过程中&lt;/strong&gt;，会&lt;strong&gt;阻塞后续的DOM渲染&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Object.getOwnPropertyNames的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/"/>
    <id>https://chongtianhong.github.io/2018/05/18/ObejectGetOwnPropertyNames/</id>
    <published>2018-05-18T02:11:02.000Z</published>
    <updated>2018-08-22T14:30:04.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.getOwnPropertyNames()</code>方法返回一个由<strong>指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><code>Object.getOwnPropertyNames()</code>返回的数组中，<strong>枚举属性</strong>的顺序与通过<code>for…in</code>循环（或 Object.keys）迭代该对象属性时一致。数组中<strong>不可枚举属性的顺序未定义</strong>。</li><li><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">console.log(Object.getOwnPropertyNames(arr).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"length"</span>]</span><br><span class="line"></span><br><span class="line">// 类数组对象</span><br><span class="line">var obj = &#123; 0: <span class="string">"a"</span>, 1: <span class="string">"b"</span>, 2: <span class="string">"c"</span>&#125;;</span><br><span class="line">console.log(Object.getOwnPropertyNames(obj).sort()); // [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line"></span><br><span class="line">// 使用Array.forEach输出属性名和属性值</span><br><span class="line">Object.getOwnPropertyNames(obj).forEach(<span class="keyword">function</span>(val, idx, array) &#123;</span><br><span class="line">    console.log(val + <span class="string">" -&gt; "</span> + obj[val]);</span><br><span class="line">&#125;);</span><br><span class="line">// 输出</span><br><span class="line">// 0 -&gt; a</span><br><span class="line">// 1 -&gt; b</span><br><span class="line">// 2 -&gt; c</span><br><span class="line"></span><br><span class="line">//不可枚举属性</span><br><span class="line">var my_obj = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    getFoo: &#123;</span><br><span class="line">        value: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> this.foo; &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">my_obj.foo = 1;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyNames(my_obj).sort()); // [<span class="string">"foo"</span>, <span class="string">"getFoo"</span>]</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>只要获取到可枚举属性</strong>，可使用<code>Object.keys</code>或用<code>for…in</code>循环（<code>for…in</code>还会获取到原型链上的可枚举属性，不过<strong>可以使用<code>hasOwnProperty()</code>方法过滤掉</strong>）。</p></li><li>下面的例子演示了<code>Object.getOwnPropertyNames()</code>方法<strong>不会获取到原型链上的属性</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ParentClass</span></span>() &#123;&#125;</span><br><span class="line">ParentClass.prototype.inheritedMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ChildClass</span></span>() &#123;</span><br><span class="line">  this.prop = 5;</span><br><span class="line">  this.method = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildClass.prototype = new ParentClass;</span><br><span class="line">ChildClass.prototype.prototypeMethod = <span class="function"><span class="title">function</span></span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Object.getOwnPropertyNames(</span><br><span class="line">    new ChildClass()  // [<span class="string">"prop"</span>, <span class="string">"method"</span>]</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><blockquote>只获取不可枚举的属性</blockquote><ul><li><p>下面的例子使用了<code>Array.prototype.filter()</code>方法，从所有的属性名数组（使用<code>Object.getOwnPropertyNames()</code>方法获得）中去除可枚举的属性（使用<code>Object.keys()</code>方法获得），剩余的属性便是不可枚举的属性了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var target = myObject;</span><br><span class="line">var enum_and_nonenum = Object.getOwnPropertyNames(target);</span><br><span class="line">var enum_only = Object.keys(target);</span><br><span class="line">var nonenum_only = enum_and_nonenum.filter(<span class="keyword">function</span>(key) &#123;</span><br><span class="line">    var indexInEnum = enum_only.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (indexInEnum == -1) &#123;</span><br><span class="line">        // 没有发现在enum_only键集中意味着这个键是不可枚举的,</span><br><span class="line">        // 因此返回<span class="literal">true</span> 以便让它保持在过滤结果中</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(nonenum_only);</span><br></pre></td></tr></table></figure></li><li><p><strong>注</strong>：<code>Array.filter(filt_func)</code>方法<strong>创建一个新数组</strong>, 其包含<strong>通过</strong>所提供函数实现的<strong>测试的所有元素</strong>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在 ES5 中，如果参数不是一个原始对象类型，将抛出一个 TypeError  异常。</li><li>在 ES2015 中，非对象参数被强制转换为对象 。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(<span class="string">'foo'</span>);</span><br><span class="line">// [<span class="string">'length'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]  (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;方法返回一个由&lt;strong&gt;指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Object.keys的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/17/ObejectKeys/"/>
    <id>https://chongtianhong.github.io/2018/05/17/ObejectKeys/</id>
    <published>2018-05-17T01:44:26.000Z</published>
    <updated>2018-08-22T14:30:10.432Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>Object.keys()</code>方法会返回一个由一个<strong>给定对象的自身可枚举属性（不包括可枚举属性）</strong>组成的<strong>字符串数组</strong>。<a id="more"></a></li><li><p>看下面的题目，输出对象中值大于2的key的数组，即期待输出的结果为：<code>[“c”,”d”]</code>请问xxx处填什么？：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> xxx ;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>正确答案：xxx处应该填入<code>data[x] &lt; 2</code>，即代码修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;a: 1, b: 2, c: 3, d: 4&#125;;</span><br><span class="line">Object.keys(data).filter(<span class="keyword">function</span>(x) &#123; <span class="built_in">return</span> data[x] &gt; 2;&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>Object.keys()</code>是ES5中新增的方法，用来<strong>获取对象自身所有的可枚举的属性名</strong>，但<strong>不包括原型中的属性</strong>，然后返回一个<strong>由属性名组成的数组</strong>。</p></li><li>注意它同<code>for..in</code>一样<strong>不能保证属性按对象原来的顺序输出</strong>。数组中<strong>属性名的排列顺序和使用<code>for..in</code>循环遍历该对象时返回的顺序一致</strong>。</li><li><code>Array.filter(function)</code>对数组进行过滤返回符合条件的数组。</li><li><p>更多例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// simple array</span><br><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">console.log(Object.keys(arr)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object</span><br><span class="line">var obj = &#123; 0: <span class="string">'a'</span>, 1: <span class="string">'b'</span>, 2: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(obj)); // console: [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>]</span><br><span class="line"></span><br><span class="line">// array like object with random key ordering</span><br><span class="line">var anObj = &#123; 100: <span class="string">'a'</span>, 2: <span class="string">'b'</span>, 7: <span class="string">'c'</span> &#125;;</span><br><span class="line">console.log(Object.keys(anObj)); // console: [<span class="string">'2'</span>, <span class="string">'7'</span>, <span class="string">'100'</span>]</span><br><span class="line"></span><br><span class="line">// getFoo is a property <span class="built_in">which</span> isn<span class="string">'t enumerable</span></span><br><span class="line"><span class="string">var myObj = Object.create(&#123;&#125;, &#123;</span></span><br><span class="line"><span class="string">    getFoo: &#123;</span></span><br><span class="line"><span class="string">        value: function () &#123; return this.foo; &#125;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">myObj.foo = 1;</span></span><br><span class="line"><span class="string">console.log(Object.keys(myObj)); // console: ['</span>foo<span class="string">']</span></span><br></pre></td></tr></table></figure></li><li><p>如果想获取一个对象的所有属性，甚至包括不可枚举的，应使用<code>Object.getOwnPropertyNames</code>。</p></li><li><p><strong>注意</strong>：</p><ul><li>在ES5里，如果<strong>此方法的参数不是对象（而是一个原始值）</strong>，那么它<strong>会抛出 TypeError</strong>。</li><li>在ES2015中，非对象的参数将被强制转换为一个对象。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// TypeError: <span class="string">"foo"</span> is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.keys(<span class="string">"foo"</span>);</span><br><span class="line">// [<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>]                   (ES2015 code)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.keys()&lt;/code&gt;方法会返回一个由一个&lt;strong&gt;给定对象的自身可枚举属性（不包括可枚举属性）&lt;/strong&gt;组成的&lt;strong&gt;字符串数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>Object.create()的使用</title>
    <link href="https://chongtianhong.github.io/2018/05/16/ObjectCreate/"/>
    <id>https://chongtianhong.github.io/2018/05/16/ObjectCreate/</id>
    <published>2018-05-16T02:49:41.000Z</published>
    <updated>2018-08-22T14:27:55.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>Object.create()</code>是Object的内置方法，可以创建一个新对象，<strong>使用现有的对象</strong>来<strong>提供新创建的对象的<code>__proto__</code></strong>。 <a id="more"></a></li><li>语法：<code>Object.create ( proto, [ propertiesObject ] ) </code></li><li>该方法有两个参数：<ul><li>第一个<strong>参数proto</strong>是一个对象，作为新建对象的原型对象；</li><li>第二个<strong>参数propertiesObject</strong>是可选的，如果<strong>没有则指定为 undefined</strong>。该<strong>参数对象</strong>是一组属性与值，该对象的<strong>属性名称</strong>将是<strong>新创建的对象的属性名称</strong>，<strong>值</strong>是<strong>属性描述符</strong>（这些属性描述符的结构与Object.defineProperties()的第三个参数一样）。如果<strong>propertiesObject参数不是 null 或一个对象，则抛出一个 TypeError 异常</strong>。</li></ul></li><li>使用该方法，创建对象会执行以下步骤：<br>①方法内部定义一个新的空对象obj<br>②将obj.__proto__的对象指向传入的参数proto<br>③返回一个新的对象</li><li><p>例子1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    isHuman: <span class="literal">false</span>,</span><br><span class="line">    printIntroduction: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(`My name is <span class="variable">$&#123;this.name&#125;</span>. Am I human? <span class="variable">$&#123;this.isHuman&#125;</span>`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me = Object.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">"Matthew"</span>; // <span class="string">"name"</span> is a property <span class="built_in">set</span> on <span class="string">"me"</span>, but not on <span class="string">"person"</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; // inherited properties can be overwritten</span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line">// expected output: <span class="string">"My name is Matthew. Am I human? true"</span></span><br></pre></td></tr></table></figure></li><li><p>例子2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var o;</span><br><span class="line"></span><br><span class="line">// 创建一个原型为null的空对象</span><br><span class="line">o = Object.create(null);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line">// 以字面量方式创建的空对象就相当于:</span><br><span class="line">o = Object.create(Object.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = Object.create(Object.prototype, &#123;</span><br><span class="line">  // foo会成为所创建对象的数据属性</span><br><span class="line">    foo: &#123; </span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        value: <span class="string">"hello"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    // bar会成为所创建对象的访问器属性</span><br><span class="line">    bar: &#123;</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        get: <span class="function"><span class="title">function</span></span>() &#123; <span class="built_in">return</span> 10 &#125;,</span><br><span class="line">        <span class="built_in">set</span>: <span class="keyword">function</span>(value) &#123;</span><br><span class="line">        console.log(<span class="string">"Setting `o.bar` to"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Constructor</span></span>()&#123;&#125;</span><br><span class="line">o = new Constructor();</span><br><span class="line">// 上面的一句就相当于:</span><br><span class="line">o = Object.create(Constructor.prototype);</span><br><span class="line">// 当然，如果在Constructor函数中有一些初始化代码，Object.create不能执行那些代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个以另一个空对象为原型，且拥有一个属性p的对象</span><br><span class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">// 省略了的属性特性默认为<span class="literal">false</span>，所以属性p是不可写，不可枚举，不可配置的:</span><br><span class="line">o.p = 24</span><br><span class="line">o.p</span><br><span class="line">//42</span><br><span class="line"></span><br><span class="line">o.q = 12</span><br><span class="line"><span class="keyword">for</span> (var prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">    console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">//<span class="string">"q"</span></span><br><span class="line"></span><br><span class="line">delete o.p</span><br><span class="line">//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">//创建一个可写的，可枚举的，可配置的属性p</span><br><span class="line">o2 = Object.create(&#123;&#125;, &#123;</span><br><span class="line">    p: &#123;</span><br><span class="line">        value: 42, </span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="与使用关键字new对象的区别"><a href="#与使用关键字new对象的区别" class="headerlink" title="与使用关键字new对象的区别"></a>与使用关键字new对象的区别</h4><ul><li>使用<code>Object.create()</code>是将对象继承到<code>__proto__</code>属性上：</li><li><code>new Object()</code>方法的实质是，<strong>使用引用类型Object的构造函数创建了一个新的实例</strong>，<strong>这个实例拥有Object默认的方法</strong>如<code>toString</code>、<code>toLocaleString</code>等：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">test</span> = Object.create(&#123;x:123,y:345&#125;);</span><br><span class="line">console.log(<span class="built_in">test</span>);// &#123;&#125;</span><br><span class="line">console.log(test.x);// 123</span><br><span class="line">console.log(test.__proto__.x);// 3</span><br><span class="line">console.log(test.__proto__.x === test.x);// <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">var test1 = new Object(&#123;x:123,y:345&#125;);</span><br><span class="line">console.log(test1);// &#123;x:123,y:345&#125;</span><br><span class="line">console.log(test1.x);// 123</span><br><span class="line">console.log(test1.__proto__.x);// undefined</span><br><span class="line">console.log(test1.__proto__.x === test1.x);// <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">var test2 = &#123;x:123,y:345&#125;;</span><br><span class="line">console.log(test2);// &#123;x:123,y:345&#125;;</span><br><span class="line">console.log(test2.x);// 123</span><br><span class="line">console.log(test2.__proto__.x);// undefined</span><br><span class="line">console.log(test2.__proto__.x === test2.x);// <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.create()&lt;/code&gt;是Object的内置方法，可以创建一个新对象，&lt;strong&gt;使用现有的对象&lt;/strong&gt;来&lt;strong&gt;提供新创建的对象的&lt;code&gt;__proto__&lt;/code&gt;&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES5" scheme="https://chongtianhong.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>前端路由的两种实现原理</title>
    <link href="https://chongtianhong.github.io/2018/05/15/frontEndRouting/"/>
    <id>https://chongtianhong.github.io/2018/05/15/frontEndRouting/</id>
    <published>2018-05-15T07:14:00.000Z</published>
    <updated>2018-08-20T14:38:25.877Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在<strong>单页应用</strong>上，前端路由并不陌生。单页应用是指<strong>在浏览器中运行的应用，在使用期间页面不会重新加载</strong>。</li><li>早期的路由都是后端实现的，直接<strong>根据url来重载页面</strong>，当页面变得越来越复杂时，服务器端压力变大。</li><li>随着<strong>ajax</strong>的出现，页面实现<strong>非重载</strong>就能刷新数据，也给前端路由的出现奠定了基础。我们可以<strong>通过修改 url 来记录 ajax 的变化</strong>，从而实现<strong>前端路由</strong>。<a id="more"></a></li><li>从<strong>性能</strong>和<strong>用户体验</strong>的层面来比较的话，<strong>后端路由每次访问一个新页面的时候都要向服务器发送请求</strong>，然后<strong>服务器</strong>再<strong>响应请求</strong>，这个过程肯定会有延迟。而<strong>前端路由在访问一个新页面的时候仅仅是变换了一下路径</strong>而已，<strong>没有了网络延迟</strong>，对于<strong>用户体验</strong>来说会有<strong>相当大的提升</strong>。 </li><li>从<strong>用户的角度</strong>看，前端路由主要实现了两个功能（使用ajax更新页面状态的情况下）：<ul><li><strong>记录当前页面的状态</strong>（保存或分享当前页的url，再次打开该url时，网页还是保存（分享）时的状态）；</li><li><strong>可以使用浏览器的前进后退功能</strong>（如点击后退按钮，可以使页面回到使用ajax更新页面之前的状态，url也回到之前的状态）；</li></ul></li><li>作为<strong>开发者</strong>，要实现这两个功能，我们需要做到：<ul><li>改变url且不让浏览器向服务器发出请求；</li><li>监测 url 的变化；</li><li>截获 url 地址，并解析出需要的信息来匹配路由规则。</li></ul></li><li>路由常用的hash模式和history模式实际上就是实现了上面的功能。</li></ul><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><ul><li>history 是 HTML5 才有的新 API，可以用来<strong>操作浏览器的 session history (会话历史)</strong>。</li><li>History API 能让开发人员在<strong>不刷新整个页面的情况下修改站点的URL</strong>。这个功能很有用，例如通过一段JavaScript代码局部加载页面的内容，你希望<strong>通过改变当前页面的URL来反应出页面内容的变化</strong>，这时该功能可以派上用场。</li><li>举个例子，当用户从首页进入帮助页面时，我们<strong>通过Ajax来加载帮助页面的内容</strong>。然后这个用户又转到产品页面，我们需要再一次通<strong>过Ajax请求来替换页面的内容</strong>。当用户想分享页面的URL时，通过History API，我们可以改变页面的URL来反应内容的修改，这样不管是用户分享还是保存的URL都能和页面的内容对应起来。</li><li>要查看这个API提供了哪些功能非常简单，打开浏览器的开发者工具面板（F12），然后在控制台（console）中输入<code>history</code>。如果浏览器支持History API，将会看到这个对象下面附带了很多方法。关于每个API的用法，可以查看MDN的文档。<br><img src="/images/history.png" width="600" alt="History API提供的功能" style="border:none"></li><li>重点说其中的两个新增的API：<code>history.pushState</code>和<code>history.replaceState</code>。</li><li>这两个 API 都接收三个参数，分别是：<ul><li><strong>状态对象（state object）</strong>：一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。</li><li><strong>标题（title）</strong>：截止到目前，几乎所有的浏览器都忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。</li><li><strong>地址（URL）</strong>：<strong>新的历史记录条目的地址</strong>。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；<strong>不指定的话则为文档当前URL</strong>。</li></ul></li><li><strong>相同之处</strong>是两个 API 都会<strong>操作浏览器的历史记录</strong>，而<strong>不会引起页面的刷新</strong>。</li><li><strong>不同之处</strong>在于，<code>history.pushState</code>会<strong>增加一条新的历史记录</strong>，而<code>history.replaceState</code>则会<strong>替换当前的历史记录</strong>。</li><li><code>history.pushState</code>将我们传给它的URL添加到浏览器的历史记录中，从而改变了浏览器的history。</li><li><strong><code>history.replaceState</code>只是简单地替换了地址栏中的URL（当前的历史记录），不会产生新的记录</strong>。也就是说，<code>history.replaceState</code>改变了当前页面的URL，并没有发出任何request请求，当前窗口仍然停留在之前的页面。当我们点击浏览器的后退按钮时，页面并不会回退到我们通过<code>history.replaceState</code>修改之前的那个URL，而是直接回退到了上一个页面（即我们进入到这个页面之前的那个页面）。</li></ul><blockquote>举例说明</blockquote><ul><li><p>在<strong>百度首页</strong>打开控制台，在控制台输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, <span class="string">"https://www.baidu.com/?name=xbhong"</span>);</span><br></pre></td></tr></table></figure></li><li><p>观察此时的 url 变成了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/?name=xbhong</span><br></pre></td></tr></table></figure></li><li><p>其他用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, <span class="string">"https://www.baidu.com/name/xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name/xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"?name=xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com?name=xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"name=xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name=xbhong</span><br><span class="line"></span><br><span class="line">window.history.pushState(null, null, <span class="string">"/name/xbhong"</span>);</span><br><span class="line">//url: https://www.baidu.com/name/xbhong</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：这里的<strong>url不支持跨域</strong>，当我们把<code>www.baidu.com</code>换成<code>baidu.com</code>时就会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught DOMException: Failed to execute <span class="string">'pushState'</span> on <span class="string">'History'</span>: A <span class="built_in">history</span> state object with URL <span class="string">'https://baidu.com/?name=xbhong'</span> cannot be created <span class="keyword">in</span> a document with origin <span class="string">'https://www.baidu.com'</span> and URL <span class="string">'https://www.baidu.com/?name=xbhong'</span>.</span><br></pre></td></tr></table></figure></li><li><p>从上面的例子可以看到，每次<strong>改变url页面并没有刷新</strong>，而浏览器会产生历史记录（可查询到历史记录），这就是<strong>实现页面无刷新情况下改变url</strong>的前提。</p></li></ul><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><ul><li>这里的 hash 就是指<strong>url尾巴后的 # 号以及后面的字符</strong>。这里的 # 和 css 里的 # 是一个意思。hash 也称作<strong>锚点</strong>，本身是用来做<strong>页面定位</strong>的，它可以<strong>使对应 id 的元素显示在可视区域内</strong>。</li><li><strong>基于hash的前端路由</strong>优点是：能<strong>兼容低版本的浏览器</strong>。大型框架的路由系统大多都是hash（哈希）实现的。</li><li><strong>基本原理</strong>：当 url 的 hash 发生改变时，触发 hashchange 注册的回调，回调中去进行不同的操作，进行不同的内容的展示。</li><li>使用到的api：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash = <span class="string">'qq'</span> // 设置 url 的 <span class="built_in">hash</span>，会在当前url后加上 <span class="string">'#qq'</span></span><br><span class="line"></span><br><span class="line">var <span class="built_in">hash</span> = window.location.hash // <span class="string">'#qq'</span>  </span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="title">function</span></span>()&#123; </span><br><span class="line">    // 监听<span class="built_in">hash</span>变化，点击浏览器的前进后退会触发</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote>hash 模式能兼容低版本的浏览器，为什么需要History API</blockquote><ul><li>hash 能兼容到IE8， History API只能兼容到 IE10，使用History API的原因是：<ul><li><strong>hash 本来是拿来做页面定位的</strong>，如果拿来做路由的话，原来的锚点功能就不能用了。</li><li>hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 <strong>history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中</strong>。</li><li>路由的 history 模式比较美观（没有#）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;单页应用&lt;/strong&gt;上，前端路由并不陌生。单页应用是指&lt;strong&gt;在浏览器中运行的应用，在使用期间页面不会重新加载&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;早期的路由都是后端实现的，直接&lt;strong&gt;根据url来重载页面&lt;/strong&gt;，当页面变得越来越复杂时，服务器端压力变大。&lt;/li&gt;
&lt;li&gt;随着&lt;strong&gt;ajax&lt;/strong&gt;的出现，页面实现&lt;strong&gt;非重载&lt;/strong&gt;就能刷新数据，也给前端路由的出现奠定了基础。我们可以&lt;strong&gt;通过修改 url 来记录 ajax 的变化&lt;/strong&gt;，从而实现&lt;strong&gt;前端路由&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="Router" scheme="https://chongtianhong.github.io/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>Promise 的链式调用与中止</title>
    <link href="https://chongtianhong.github.io/2018/05/14/promiseChain/"/>
    <id>https://chongtianhong.github.io/2018/05/14/promiseChain/</id>
    <published>2018-05-14T07:04:43.000Z</published>
    <updated>2018-08-19T08:45:53.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文主要讲的是如何<strong>实现 Promise 的链式调用</strong>，也就是<code>promise().then().then().catch()</code>的形式，然后讨论如何<strong>在某一个 then() 里面中止 Promise</strong>。<a id="more"></a></li><li>在程序中，只要<strong>返回了一个 promise 对象</strong>，只要<strong>该 promise 对象不是 Rejected 或 Fulfilled 状态，then 方法就会继续调用</strong>。利用这个特性，可以<strong>处理多个异步逻辑</strong>。</li><li>但有时候某个 then 方法的执行结果可能会决定是否需要执行下一个 then，这个时候就需中止 promise，主要思想就是<strong>使用 reject 来中止 promise 的 then 继续执行</strong>。</li></ul><h4 id="回顾Promise知识点"><a href="#回顾Promise知识点" class="headerlink" title="回顾Promise知识点"></a>回顾Promise知识点</h4><ul><li><p><strong>Promise</strong>其实很简单，就<strong>是一个处理异步的方法</strong>。一般可以通过 new 方法来调用 Promise 的构造器实例化一个 promise 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步处理</span><br><span class="line">    // 处理结束后，调用 resolve 或 reject</span><br><span class="line">    //      成功时就调用 resolve</span><br><span class="line">    //      失败时就调用 reject</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>用<code>new Promise</code>实例化的 promise 对象有以下三个状态：</p><ul><li>“has-resolution” - <strong>Fulfilled</strong>。resolve(成功)时，此时会调用 onFulfilled;</li><li>“has-rejection” - <strong>Rejected</strong>。reject(失败)时，此时会调用 onRejected;</li><li>“unresolved” - <strong>Pending</strong>。既不是resolve也不是reject的状态，也就是promise对象刚被创建后的初始化状态等。</li></ul></li><li>Promise对象的状态改变，只有两种可能：<strong>从Pending变为Fulfilled</strong>和<strong>从Pending变为Rejected</strong>。只要这两种情况发生，<strong>状态</strong>就<strong>凝固</strong>了，<strong>不会再变</strong>了，会一直保持这个结果。<br><img src="/images/promiseProcess.png" alt="promise的状态变化示意图" width="600" style="border:none"></li></ul><h4 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h4><ul><li><code>then()</code>方法的作用是<strong>为Promise实例添加解决（fulfillment）和拒绝（rejection）状态的回调函数</strong>。</li><li><code>then()</code>方法会<strong>返回一个新的Promise实例</strong>，所以<strong><code>then()</code>方法后面可以继续跟另一个<code>then()</code>方法进行链式调用</strong>。</li><li><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// promise start</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">        resolve(<span class="string">'start'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p1</span><br><span class="line"><span class="keyword">function</span> p1(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p2</span><br><span class="line"><span class="keyword">function</span> p2(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((reject)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        reject(2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p3</span><br><span class="line"><span class="keyword">function</span> p3(data)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        resolve(3);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise p4</span><br><span class="line"><span class="keyword">function</span> p4(ex)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promose((resolve)=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        resolve(4);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(p1)</span><br><span class="line">    .<span class="keyword">then</span>(p2)</span><br><span class="line">    .<span class="keyword">then</span>(p3)</span><br><span class="line">    .catch(p4)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // end</span><br><span class="line">        console.log(<span class="string">'result of p4: '</span>, data);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的代码最终会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result of start:  start</span><br><span class="line">result of p1:  1</span><br><span class="line">ex:  2</span><br><span class="line">result of p4:  4</span><br></pre></td></tr></table></figure></li><li><p>可以看到，代码的执行逻辑是<code>promise start –&gt; promise p1 –&gt; promise p3 –&gt; promise p4 –&gt; end</code>。所以可总结出以下几点：</p><ul><li>promise 的 <strong>then 方法里面</strong>可以<strong>继续返回一个新的 promise 对象</strong>;</li><li>下一个 <strong>then 方法的参数</strong>是<strong>上一个 promise 对象的 resolve 参数</strong>;</li><li><strong>catch 方法的参数</strong>是其<strong>之前某个 promise 对象的 rejecte 参数</strong>;</li><li>一旦某个 then 方法里面的 <strong>promise 状态改变为了 rejected</strong>，则promise 方法连会<strong>跳过后面的 then 直接执行 catch</strong>;</li><li><strong>catch 方法</strong>里面依旧<strong>可以返回一个新的 promise 对象</strong>。</li></ul></li></ul><h4 id="如何中指promise的链式调用"><a href="#如何中指promise的链式调用" class="headerlink" title="如何中指promise的链式调用"></a>如何中指promise的链式调用</h4><ul><li>通过上面的例子，我们可以知道<strong> promise 的状态改变为 rejected 后，promise 就会跳过后面的 then 方法</strong>。</li><li>也就是说，当<strong>某个 then 里面发生异常后</strong>，就会<strong>跳过 then 方法</strong>，<strong>直接执行 catch</strong>。</li><li><p>所以，当在构造的 promise 方法链中，如果<strong>在某个 then 后面，不需要再执行 then 方法了，就可以把它当作一个异常来处理</strong>，返回一个异常信息给 catch，其参数可自定义，比如该异常的参数信息为 { notRealPromiseException: true}，然后在 catch 里面判断一下 notRealPromiseException 是否为 true，如果为 true，就说明不是程序出现异常，而是在正常逻辑里面中止 then 方法的执行。代码示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">start()</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise start</span><br><span class="line">        console.log(<span class="string">'result of start: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(1); // p1</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p1</span><br><span class="line">        console.log(<span class="string">'result of p1: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.reject(&#123;</span><br><span class="line">            notRealPromiseException: <span class="literal">true</span>,</span><br><span class="line">        &#125;); // p2</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">then</span>(data =&gt; &#123;</span><br><span class="line">        // promise p2</span><br><span class="line">        console.log(<span class="string">'result of p2: '</span>, data);</span><br><span class="line">        <span class="built_in">return</span> Promise.resolve(3); // p3</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(ex =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'ex: '</span>, ex);</span><br><span class="line">        <span class="keyword">if</span> (ex.notRealPromiseException) &#123;</span><br><span class="line">            // 一切正常，只是通过 catch 方法来中止 promise chain</span><br><span class="line">            // 也就是中止 promise p2 的执行</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // 真正发生异常</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样的做法可能不符合<code>catch</code>的语义。不过从某种意义上来说，promise 方法链没有继续执行，也可以算是一种“异常”。</p></li></ul><h4 id="Promise-all-与-Promise-race"><a href="#Promise-all-与-Promise-race" class="headerlink" title="Promise.all 与 Promise.race"></a>Promise.all 与 Promise.race</h4><ul><li>其实 promise 方法链更好用的一点是，当<strong>下一个操作依赖于上一个操作的结果</strong>的时候，可以很方便地<strong>通过 then 方法的参数来传递数据</strong>。</li><li>前面也提到过，<strong>下一个 then 方法的参数就是上一个 then 方法里面 resolve 的参数</strong>，所以当然就可以<strong>把上一个 then 方法的执行结果作为参数传递给下一个 then 方法</strong>。</li><li><p>还有些时候，可能 then 方法的执行顺序也没有太多要求，只需要 promise 方法链中的两个或多个 promise 全部都执行正确。这时，如果依旧一个一个去写 then 可能就比较麻烦，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p2</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">p3</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在<strong>只需要<code>p1</code>、<code>p2</code>、<code>p3</code>这三个 promise 都执行</strong>，并且 <strong>promise 最终状态都是 Fulfilled</strong>，那么如果还是使用链式调用，这时这样调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p1()</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p2();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> p3();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>代码貌似就不那么精炼了。这个时候就有了 <code>Promise.all</code> 这个方法。</p></li><li><code>Promise.all</code> 接收一个<strong>promise对象的数组</strong>作为参数，当这个数组里的所有 promise 对象<strong>全部变为 resolve</strong> 或 <strong>reject 状态</strong>的时候，它才会去调用 then 方法。</li><li><p>于是，调用这几个 promise 的代码就可以这样写了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([p1, p2, p3]).<span class="keyword">then</span>(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'all done'</span>);</span><br><span class="line">&#125;).catch(e =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'e: '</span>, e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// all <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>对于 <code>Promise.race</code>，其<strong>参数</strong>也跟 <code>Promise.all</code> 一样<strong>*是一个数组</strong>。只是<strong>数组中的任何一个 promise 对象如果变为 resolve 或者reject 的话，该函数就会返回</strong>，并<strong>使用这个 promise 对象的值进行 resolve 或者 reject</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本文主要讲的是如何&lt;strong&gt;实现 Promise 的链式调用&lt;/strong&gt;，也就是&lt;code&gt;promise().then().then().catch()&lt;/code&gt;的形式，然后讨论如何&lt;strong&gt;在某一个 then() 里面中止 Promise&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="Promise" scheme="https://chongtianhong.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Ajax中返回数据的格式和处理方法分析</title>
    <link href="https://chongtianhong.github.io/2018/05/13/ajaxDataType/"/>
    <id>https://chongtianhong.github.io/2018/05/13/ajaxDataType/</id>
    <published>2018-05-13T05:51:23.000Z</published>
    <updated>2018-08-18T12:35:57.196Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Ajax中常见的<strong>返回数据的格式</strong>有三种：分别为<strong>文本</strong>，<strong>XML</strong>和<strong>JSON</strong>。<a id="more"></a></li></ul><h4 id="Text-HTML格式"><a href="#Text-HTML格式" class="headerlink" title="Text/HTML格式"></a>Text/HTML格式</h4><ul><li>通过Ajax对象的<code>responseText</code>属性就可以获取到返回的文本信息。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxText(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(oAjax.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="XML格式"><a href="#XML格式" class="headerlink" title="XML格式"></a>XML格式</h4><ul><li>通过Ajax对象的<code>responseXML</code>属性就可以获取到返回的<strong>XML DOM</strong>对象。</li><li><p>解析<strong>XML DOM</strong>的数据就类似于HTML DOM 编程. 比如<strong>通过TagName获取标签对象</strong>(数组形式)，再从该数组中获取需要的标签对象，再从标签对象中获取文本值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(XML格式)</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据, 利用Json传递</span><br><span class="line">* @param tagName  要获取值的标签名</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxXML(url, jsonData, tagName, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   //拼 装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var oXml =  oAjax.responseXML; //返 回的是一个XML DOM对象</span><br><span class="line">            var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">            var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(tagValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>XML文件具有的几大特点：</p><ul><li>标签没有预定义，开发者根据自己的需求发明标签</li><li>结构清晰，具有自我描述性。从XML文档就可以看出数据的内容</li><li>都是双标签</li><li>和HTML相似，同样也具有树结构</li></ul></li></ul><h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><ul><li>由于JSON格式相比XML更小，传输更快，所以现在Ajax返回json数据格式的情况更多。</li><li>为了方便使用，封装成如下函数：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @<span class="keyword">function</span> 利用ajax动态交换数据(Text/HTML格式)，但是返回的是Json类型的文本数据</span><br><span class="line">* @param url   要提交请求的页面</span><br><span class="line">* @param jsonData  要提交的数据,利用Json传递</span><br><span class="line">* @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> ajaxJson(url, jsonData, getMsg)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>); // 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            var json = JSON.parse(oAjax.responseText);// 把传回来的字符串解析成json对象</span><br><span class="line">            <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                getMsg(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="三种格式的函数封装"><a href="#三种格式的函数封装" class="headerlink" title="三种格式的函数封装"></a>三种格式的函数封装</h4><ul><li>为了方便使用，可以把三个函数合并，合并后的函数如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @<span class="keyword">function</span> 利用ajax动态交换数据</span><br><span class="line"> * @param url   要提交请求的页面</span><br><span class="line"> * @param jsonData  要提交的数据,利用Json传递</span><br><span class="line"> * @param getMsg  这个函数可以获取到处理后的数据</span><br><span class="line"> * @param <span class="built_in">type</span>    接受的数据类型,text/xml/json</span><br><span class="line"> * @param tagName <span class="built_in">type</span> = xml 的时候这个参数设置为要获取的文本的标签名</span><br><span class="line"> * @<span class="built_in">return</span> 无</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> ajax(url,jsonData,getMsg,<span class="built_in">type</span>,tagName)&#123;</span><br><span class="line">    // 创建Ajax对象,ActiveXObject兼容IE5,6</span><br><span class="line">    var oAjax = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">    // 打开请求</span><br><span class="line">    oAjax.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);// 方法, URL, 异步传输</span><br><span class="line">    // 发送请求</span><br><span class="line">    var data = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(var d <span class="keyword">in</span> jsonData)   // 拼装数据</span><br><span class="line">        data += (d + <span class="string">'='</span> + jsonData[d] + <span class="string">'&amp;'</span>);</span><br><span class="line">    oAjax.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    oAjax.send(data);</span><br><span class="line">    // 接收返回,当服务器有东西返回时触发</span><br><span class="line">    oAjax.onreadystatechange = <span class="keyword">function</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(oAjax.readyState == 4 &amp;&amp; oAjax.status == 200)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'text'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(oAjax.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'json'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var json = JSON.parse(oAjax.responseText); // 把传回来的字符串解析成json对象</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(json);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">type</span> == <span class="string">'xml'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                var oXml =  oAjax.responseXML; // 返回的是一个XML DOM对象</span><br><span class="line">                var oTag = oXml.getElementsByTagName(tagName);</span><br><span class="line">                var tagValue = oTag[0].childNodes[0].nodeValue;</span><br><span class="line">                <span class="keyword">if</span>(getMsg)&#123;</span><br><span class="line">                    getMsg(tagValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Ajax中常见的&lt;strong&gt;返回数据的格式&lt;/strong&gt;有三种：分别为&lt;strong&gt;文本&lt;/strong&gt;，&lt;strong&gt;XML&lt;/strong&gt;和&lt;strong&gt;JSON&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Ajax" scheme="https://chongtianhong.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>浅谈arguments与arguments的妙用</title>
    <link href="https://chongtianhong.github.io/2018/05/12/arguments/"/>
    <id>https://chongtianhong.github.io/2018/05/12/arguments/</id>
    <published>2018-05-12T12:41:53.000Z</published>
    <updated>2018-08-18T12:38:49.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>每个函数都有一个<strong>arguments属性</strong>，表示函数的<strong>实参集合</strong>，这里的实参是重点，就是<strong>执行函数时实际传入的参数的集合</strong>。<a id="more"></a></li><li><strong>arguments</strong>不是数组而是一个<strong>对象</strong>，但它和数组很相似，所以通常称为<strong>类数组对象</strong>，以后看到类数组其实就表示<strong>arguments</strong>。</li><li><p><strong>arguments有length属性</strong>，表示函数实参个数，可以用<code>arguments[index]</code>显式调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(var i=0; i&lt; arguments.length; i++)&#123;</span><br><span class="line">        console.log(arguments[i]);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="string">"a"</span>, 17, [1, 2, 3], &#123;name:<span class="string">"javascript"</span>, <span class="built_in">type</span>:<span class="string">"language"</span>&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">a</span><br><span class="line">17</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&#123;name: <span class="string">"javascript"</span>, <span class="built_in">type</span>: <span class="string">"language"</span>&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><strong>arguments</strong>还有一个叫做<code>callee</code>的属性，这个属性是表示的是<strong>当前函数的一个引用</strong>，简单点说，这个属性里面存储的我们调用的这个函数的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">showcallee</span></span>() &#123;</span><br><span class="line">    var a = <span class="string">'这里是代码'</span>;</span><br><span class="line">    var b = <span class="string">'这是另一段代码'</span>;</span><br><span class="line">    var c = a + b;</span><br><span class="line"></span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">showcallee();</span><br><span class="line">// arguments.callee将完整地把这个函数的所有代码返回。</span><br></pre></td></tr></table></figure></li></ul><h4 id="arguments的妙用"><a href="#arguments的妙用" class="headerlink" title="arguments的妙用"></a>arguments的妙用</h4><h5 id="利用arguments实现方法的重载"><a href="#利用arguments实现方法的重载" class="headerlink" title="利用arguments实现方法的重载"></a>利用arguments实现方法的重载</h5><ul><li><p>由于<strong>Javascript</strong>是一种<strong>弱类型</strong>的语言，<strong>没有重载机制</strong>，当我们重写函数时，会将原来的函数直接覆盖，这里我们能<strong>利用arguments</strong>，来<strong>判断传入的实参类型与数量进行不同的操作</strong>，然后<strong>返回不同的数值</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">doAdd</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(arguments.length == 1) &#123;</span><br><span class="line">        alert(arguments[0] + 5);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arguments.length == 2) &#123;</span><br><span class="line">        alert(arguments[0] + arguments[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(10);//输出 <span class="string">"15"</span></span><br><span class="line">doAdd(40, 20);//输出 <span class="string">"60"</span></span><br></pre></td></tr></table></figure></li><li><p>当只有一个参数时，<code>doAdd()</code>函数给参数加 5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，<code>doAdd(10)</code>输出的是 “15”，而<code>doAdd(40, 20)</code>输出的是 “60”。</p></li></ul><h5 id="利用arguments-callee实现递归"><a href="#利用arguments-callee实现递归" class="headerlink" title="利用arguments.callee实现递归"></a>利用arguments.callee实现递归</h5><ul><li><p>用之前的方法来实现一个<strong>计算阶乘</strong>的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * factorial(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是当这个函数变成了一个匿名函数时，我们就可以利用<code>callee</code>来递归这个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123; </span><br><span class="line">    <span class="keyword">if</span>(num &lt;= 1) &#123; </span><br><span class="line">        <span class="built_in">return</span> 1; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">return</span> num * arguments.callee(num - 1); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：在<strong>严格模式</strong>中<code>arguments.callee</code>这个属性被<strong>禁止使用</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个函数都有一个&lt;strong&gt;arguments属性&lt;/strong&gt;，表示函数的&lt;strong&gt;实参集合&lt;/strong&gt;，这里的实参是重点，就是&lt;strong&gt;执行函数时实际传入的参数的集合&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="arguments" scheme="https://chongtianhong.github.io/tags/arguments/"/>
    
  </entry>
  
  <entry>
    <title>for循环、forEach、map、filter区别及效率分析</title>
    <link href="https://chongtianhong.github.io/2018/05/11/arrayMethodsComparation/"/>
    <id>https://chongtianhong.github.io/2018/05/11/arrayMethodsComparation/</id>
    <published>2018-05-11T11:55:57.000Z</published>
    <updated>2018-08-18T14:22:25.708Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>遍历数组</strong>最常用到的for循环，是最为熟知的一种方法，在ES5中定义了一些新的遍历方法，更加适用于函数式编程。</li><li>本文对各种数组遍历方法的区别和效率进行分析记录。<a id="more"></a></li><li><p>首先，写入以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var testData = []; // 数组初始化</span><br><span class="line">var x = 9999;</span><br><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; x; i++)&#123;</span><br><span class="line">    testData[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在每个遍历开始前和结束后取时间戳的差值，每个测试10次取平均值查看结果。<strong>以下测试结果基于Google浏览器</strong>。</p></li></ul><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><ul><li><p>对于普通的for循环来说:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt; testData.length; i++)&#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是7.3ms。</p></li><li><p>重新对for循环进行优化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0, len = testData.length; i &lt; len; i++)&#123;</span><br><span class="line">    code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是2.7ms。</p></li><li>但是当x = 99999，到达10^5级时，遍历时间分别是7ms和7.1ms，二者几乎没有差别；当 x = 999999时，遍历时间分别是，14.1ms和14.6ms，前者循环耗时比后者要少，即<strong>遍历数据从10^5级别开始，普通for循环相比优化的for循环效率更高</strong>。</li></ul><h5 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h5><ul><li><p>当使用forEach方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testData.forEach(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>取完平均值是2.1ms，x = 99999时，取值8.9ms，x = 999999时，取值39ms，由此可见，<strong>在10^4级别及以下forEach的效率占有绝对优势</strong>，但从10^5级别开始就走下坡了了。然而用<strong>火狐</strong>测过以后，结果却<strong>截然不同</strong>（见页底）。</p></li></ul><h5 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h5><ul><li><p>当使用map方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.map(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>传递给map()函数的调用方式和传递给forEach()函数的调用方式一样，但传递给map()函数应该有返回值。在<strong>Google浏览器</strong>环境下，<strong>耗时是forEach方法的基础上相应增加的</strong>。</p></li></ul><h5 id="filter方法"><a href="#filter方法" class="headerlink" title="filter方法"></a>filter方法</h5><ul><li><p>当使用filter方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.filter(<span class="keyword">function</span>(value, item, arr)&#123; </span><br><span class="line">    arr[item]++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>filter()方法返回的数组元素是调用的数组的一个子集，传递的函数用来进行逻辑判定的，该函数返回true或false，同样的的式子，在<strong>Google浏览器</strong>环境下，<strong>耗时相比较是map方法的40%左右</strong>。</p></li></ul><h5 id="不同浏览器的结果对比"><a href="#不同浏览器的结果对比" class="headerlink" title="不同浏览器的结果对比"></a>不同浏览器的结果对比</h5><ul><li>Google环境下的测试结果：<br><img src="/images/Google.jpg" alt="Google环境下的测试结果" width="600" style="border:none"></li><li>Firefox环境下的测试结果：<br><img src="/images/Firefox.jpg" alt="Firefox环境下的测试结果" width="600" style="border:none"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;遍历数组&lt;/strong&gt;最常用到的for循环，是最为熟知的一种方法，在ES5中定义了一些新的遍历方法，更加适用于函数式编程。&lt;/li&gt;
&lt;li&gt;本文对各种数组遍历方法的区别和效率进行分析记录。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Array" scheme="https://chongtianhong.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>30个你“不可能全部会做”的JavaScript题目及解析</title>
    <link href="https://chongtianhong.github.io/2018/05/10/30JSproblems/"/>
    <id>https://chongtianhong.github.io/2018/05/10/30JSproblems/</id>
    <published>2018-05-10T06:32:18.000Z</published>
    <updated>2018-08-21T14:23:32.436Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文记录了30个<code>你“不可能全部会做”的JavaScript题目</code>，并对各个答案进行分析。<a id="more"></a></li></ul><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line"></span><br><span class="line">　　B.[1,2,3]</span><br><span class="line"></span><br><span class="line">　　C.[0,1,2]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[typeof null, null instanceof Object]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"object"</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　B.[null,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="string">"object"</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[3,2,1].reduce(Math.pow),[].reduce(Math.pow)]</span><br><span class="line"></span><br><span class="line">　　A.报错</span><br><span class="line"></span><br><span class="line">　　B.[9,0]</span><br><span class="line"></span><br><span class="line">　　C.[9,NaN]</span><br><span class="line"></span><br><span class="line">　　D.[9,undefined]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var val = <span class="string">'value'</span>;</span><br><span class="line">console.info(<span class="string">'Value id '</span> + (val === <span class="string">'value'</span>)?<span class="string">'Something'</span>:<span class="string">'Nothing'</span>);</span><br><span class="line"></span><br><span class="line">　　A.Something</span><br><span class="line"></span><br><span class="line">　　B.Nothing</span><br><span class="line"></span><br><span class="line">　　C.NaN</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">'World'</span>;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　<span class="keyword">if</span>(typeof name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">　　　　var name = <span class="string">"Jack"</span>;</span><br><span class="line">　　　　console.info(<span class="string">'Goodbye '</span>+ name);</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Hello '</span> + name);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">　　A.Goodbye Jack</span><br><span class="line"></span><br><span class="line">　　B.Hello Jack</span><br><span class="line"></span><br><span class="line">　　C.Goodbye undefined</span><br><span class="line"></span><br><span class="line">　　D.Hello undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var END = 9007199254740992;</span><br><span class="line">var START = END -100;</span><br><span class="line">var count = 0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var i = START ; i &lt;= END ; i++)&#123;</span><br><span class="line">　　count ++;</span><br><span class="line">&#125;</span><br><span class="line">console.info(count);</span><br><span class="line"></span><br><span class="line">　　A.0</span><br><span class="line"></span><br><span class="line">　　B.100</span><br><span class="line"></span><br><span class="line">　　C.101</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0, 1, 2];</span><br><span class="line">arr[10] = 10;</span><br><span class="line">arr.filter(<span class="keyword">function</span>(x)&#123;<span class="built_in">return</span> x === undefined&#125;);</span><br><span class="line"></span><br><span class="line">　　A.[undefined x 7]</span><br><span class="line"></span><br><span class="line">　　B.[0, 1, 2, 10]</span><br><span class="line"></span><br><span class="line">　　C.[]</span><br><span class="line"></span><br><span class="line">　　D.[undefined]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var two = 0.2;</span><br><span class="line">var one = 0.1;</span><br><span class="line">var eight = 0.8;</span><br><span class="line">var six = 0.6;</span><br><span class="line">[two - one == one, eight - six == two];</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showCase(value)&#123;</span><br><span class="line"></span><br><span class="line">　　switch(value)&#123;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case A'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case B'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> undefined :</span><br><span class="line">　　　　　　console.info(<span class="string">'undefined'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　default:</span><br><span class="line">　　　　　　console.info(<span class="string">'Do not know!'</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(new String(<span class="string">'A'</span>));</span><br><span class="line"></span><br><span class="line">　　A.Case A</span><br><span class="line"></span><br><span class="line">　　B.Case B</span><br><span class="line"></span><br><span class="line">　　C.Do not know</span><br><span class="line"></span><br><span class="line">　　D.undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showCase(value)&#123;</span><br><span class="line"></span><br><span class="line">　　switch(value)&#123;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case A'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">　　　　　　console.info(<span class="string">'Case B'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　<span class="keyword">case</span> undefined :</span><br><span class="line">　　　　　　console.info(<span class="string">'undefined'</span>);</span><br><span class="line">　　　　　　<span class="built_in">break</span>;</span><br><span class="line">　　　　default:</span><br><span class="line">　　　　　　console.info(<span class="string">'Do not know!'</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">showCase(String(<span class="string">'A'</span>));</span><br><span class="line"></span><br><span class="line">　　A.Case A</span><br><span class="line"></span><br><span class="line">　　B.Case B</span><br><span class="line"></span><br><span class="line">　　C.Do not know</span><br><span class="line"></span><br><span class="line">　　D.undefined</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目11"><a href="#题目11" class="headerlink" title="题目11"></a>题目11</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isOdd(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> num % 2 == 1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> isEven(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> num % 2 == 0; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> isSane(num)&#123;</span><br><span class="line">　　<span class="built_in">return</span> isEven(num)||isOdd(num);</span><br><span class="line">&#125;</span><br><span class="line">var values = [7, 4, <span class="string">'13'</span>, -9, Infinity];</span><br><span class="line">values.map(isSane);</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　D.[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目12"><a href="#题目12" class="headerlink" title="题目12"></a>题目12</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[parseInt(3,8),parseInt(3,2),parseInt(3,0)]</span><br><span class="line"></span><br><span class="line">　　A.[3,3,3]</span><br><span class="line"></span><br><span class="line">　　B.[3,3,NaN]</span><br><span class="line"></span><br><span class="line">　　C.[3,NaN,NaN]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目13"><a href="#题目13" class="headerlink" title="题目13"></a>题目13</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(Array.prototype)</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目14"><a href="#题目14" class="headerlink" title="题目14"></a>题目14</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [0];</span><br><span class="line"><span class="keyword">if</span>([0])&#123;</span><br><span class="line">　　console.info(a == <span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　console.info(<span class="string">"else"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.<span class="string">"else"</span></span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目15"><a href="#题目15" class="headerlink" title="题目15"></a>题目15</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[]==[]</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目16"><a href="#题目16" class="headerlink" title="题目16"></a>题目16</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'5'</span> + 3), (<span class="string">'5'</span>- 3)]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"53"</span>, 2]</span><br><span class="line"></span><br><span class="line">　　B.[8, 2]</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目17"><a href="#题目17" class="headerlink" title="题目17"></a>题目17</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1+-+++-+1</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目18"><a href="#题目18" class="headerlink" title="题目18"></a>题目18</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array(3);</span><br><span class="line">arr[0] = 2</span><br><span class="line">arr.map(<span class="keyword">function</span>(elem)&#123;<span class="built_in">return</span> <span class="string">'1'</span>;&#125;);</span><br><span class="line"></span><br><span class="line">　　A.[2,1,1]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line"></span><br><span class="line">　　C.[2,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目19"><a href="#题目19" class="headerlink" title="题目19"></a>题目19</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sidEffecting(arr)&#123;</span><br><span class="line">　　arr[0] = arr[2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> bar(a, b, c)&#123;</span><br><span class="line">　　c = 10;</span><br><span class="line">    // arguments = [1, 1, 10]</span><br><span class="line">　　sidEffecting(arguments);</span><br><span class="line">　　<span class="built_in">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">bar(1,1,1);</span><br><span class="line"></span><br><span class="line">　　A.3</span><br><span class="line"></span><br><span class="line">　　B.12</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目20"><a href="#题目20" class="headerlink" title="题目20"></a>题目20</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 111111111111111110000,</span><br><span class="line">b = 1111;</span><br><span class="line">console.info(a+b);</span><br><span class="line"></span><br><span class="line">　　A.111111111111111111111</span><br><span class="line"></span><br><span class="line">　　B.111111111111111110000</span><br><span class="line"></span><br><span class="line">　　C.NaN</span><br><span class="line"></span><br><span class="line">　　D.Infinity</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目21"><a href="#题目21" class="headerlink" title="题目21"></a>题目21</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var x = [].reverse;</span><br><span class="line">x();</span><br><span class="line"></span><br><span class="line">　　A.[]</span><br><span class="line"></span><br><span class="line">　　B.undefined</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.window</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目22"><a href="#题目22" class="headerlink" title="题目22"></a>题目22</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.MIN_VALUE &gt; 0</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目23"><a href="#题目23" class="headerlink" title="题目23"></a>题目23</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1&lt;2&lt;3,3&lt;2&lt;1]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="literal">true</span>,<span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">　　C.报错</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目24"><a href="#题目24" class="headerlink" title="题目24"></a>题目24</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 == [[[2]]]</span><br><span class="line"></span><br><span class="line">　　A.true</span><br><span class="line"></span><br><span class="line">　　B.false</span><br><span class="line"></span><br><span class="line">　　C.undefined</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目25"><a href="#题目25" class="headerlink" title="题目25"></a>题目25</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[3.toString(),3..toString(),3...toString()]</span><br><span class="line"></span><br><span class="line">　　A.[<span class="string">"3"</span>,error,error]</span><br><span class="line"></span><br><span class="line">　　B.[<span class="string">"3"</span>,<span class="string">"3.0"</span>,error]</span><br><span class="line"></span><br><span class="line">　　C.[error,<span class="string">"3"</span>,error]</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目26"><a href="#题目26" class="headerlink" title="题目26"></a>题目26</h5><ul><li>以下表达式的运行结果是：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　var x1 = y1 = 1;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.info(y1);</span><br><span class="line">console.info(x1);</span><br><span class="line"></span><br><span class="line">　　A.1，1</span><br><span class="line"></span><br><span class="line">　　B.error，error</span><br><span class="line"></span><br><span class="line">　　C.1，error</span><br><span class="line"></span><br><span class="line">　　D.其他</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目27"><a href="#题目27" class="headerlink" title="题目27"></a>题目27</h5><ul><li>列举IE和FF脚本兼容性的问题。</li></ul><h5 id="题目28"><a href="#题目28" class="headerlink" title="题目28"></a>题目28</h5><ul><li>以下函数有什么问题？如何改进？<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">initButtons</span></span>()&#123;</span><br><span class="line">    var body = document.body, button;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0;i &lt; 5; i++)&#123;</span><br><span class="line">        button = document.createElement(<span class="string">"button"</span>);</span><br><span class="line">        button.innerHTML = <span class="string">"Button"</span> + i;</span><br><span class="line">        button.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(e)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        body.appendChild(button);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">initButtons();</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目29"><a href="#题目29" class="headerlink" title="题目29"></a>题目29</h5><ul><li>写一段代码，判断一个字符串中出现次数最多的字符，并统计出现的次数。</li></ul><h5 id="题目30"><a href="#题目30" class="headerlink" title="题目30"></a>题目30</h5><ul><li>请问一下两段代码有什么不同？<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代码一</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>()&#123;        </span><br><span class="line">    /*代码块*/        </span><br><span class="line">    setTimeout(arguments.callee, 10);    </span><br><span class="line">&#125;, 10);   </span><br><span class="line"></span><br><span class="line">// 代码二</span><br><span class="line">setInterval(<span class="function"><span class="title">function</span></span>()&#123;        </span><br><span class="line">　　/*代码块*/    </span><br><span class="line">&#125;, 10);</span><br></pre></td></tr></table></figure></li></ul><h4 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h4><h5 id="题目1-1"><a href="#题目1-1" class="headerlink" title="题目1"></a>题目1</h5><ul><li>解析:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">map对数组的每个元素调用定义的回调函数并返回包含结果的数组。</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(parseInt)对于数组中每个元素调用paresInt。</span><br><span class="line">map中回调函数的语法：<span class="keyword">function</span> callbackfn(value, index, array1)，可使用最多三个参数来声明回调函数。第一参数value，数组元素的值；第二个参数index，数组元素的数组所以；array1，包含该元素的数组对象。</span><br><span class="line">map在作用parseInt函数时，其实传入了元素的值(作为需要转化为十进制的字符串)，以及所对应的索引(作为转化的基数)。</span><br><span class="line">因此，题目等同于[parseInt(1,0), parseInt(2,1), parseInt(3,2)]</span><br><span class="line">最终返回[1, NaN, NaN]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目2-1"><a href="#题目2-1" class="headerlink" title="题目2"></a>题目2</h5><ul><li>解析:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">typeof用以获取一个变量或者表达式的类型。null是个特殊的Object类型的值，表示空引用的意思。</span><br><span class="line">instanceof 表示某个变量是否是某个对象的实例。</span><br><span class="line">typeof null ==== <span class="string">'object'</span></span><br><span class="line">null instanceof Object === <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="题目3-1"><a href="#题目3-1" class="headerlink" title="题目3"></a>题目3</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。其效果就是：</span><br><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br><span class="line">pow() 方法可返回 x 的 y 次幂的值。[3,2,1].reduce(Math.pow);等同于：</span><br><span class="line"><span class="keyword">function</span> testFuc(x,y)&#123;</span><br><span class="line">    console.info(x +<span class="string">" : "</span>+y);</span><br><span class="line">    <span class="built_in">return</span> Math.pow(x,y);</span><br><span class="line">&#125;</span><br><span class="line">console.info([3,2,1].reduce(testFuc));</span><br><span class="line">3 : 2  =&gt; Math.pow(3,2) == 9</span><br><span class="line">9 : 1  =&gt; Math.pow(9,1) == 9</span><br><span class="line">9 ==&gt; 最终结果</span><br><span class="line"></span><br><span class="line">但是要注意：Array的reduce()不能作用在空数组上，会报 Uncaught TypeError: Reduce of empty array with no initial value 错误。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目4-1"><a href="#题目4-1" class="headerlink" title="题目4"></a>题目4</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">先执行字符串拼接，再执行三元表达式判断</span><br><span class="line"><span class="string">'Value id '</span> + <span class="literal">true</span> 结果为 <span class="string">'Value id true'</span></span><br><span class="line">字符串不为空，因此为<span class="literal">true</span>，所以返回<span class="string">'Something'</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="题目5-1"><a href="#题目5-1" class="headerlink" title="题目5"></a>题目5</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">判断语句被包裹在立即调用函数里，函数中声明了一个局部变量name，</span><br><span class="line">变量在函数内部进行变量提升，在进行判断时，</span><br><span class="line">name已经声明但尚未初始化，因此，进入了<span class="keyword">if</span>(<span class="literal">true</span>)的语句块中，</span><br><span class="line">name被初始化为<span class="string">"Jack"</span>，最终输出Goodbye Jack。</span><br><span class="line">与C系语言不同的是，JavaScript是函数级作用域(<span class="keyword">function</span>-level scope)，只有函数才会创建新的作用域。 </span><br><span class="line">。在<span class="keyword">if</span>语句块中，声明新的变量，这些变量会影响到外部作用域。</span><br><span class="line">如：</span><br><span class="line">var x = 1; </span><br><span class="line">console.log(x); // 1 </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">var x = 2; </span><br><span class="line">console.log(x); //2 </span><br><span class="line">&#125; </span><br><span class="line">console.log(x);// 2 </span><br><span class="line">若将题目改成：</span><br><span class="line">var name = <span class="string">'World'</span>;</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">　　<span class="keyword">if</span>(typeof name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Goodbye '</span>+ name);</span><br><span class="line">　　&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　　　console.info(<span class="string">'Hello '</span> + name);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">将得到Hello World的结果</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目6-1"><a href="#题目6-1" class="headerlink" title="题目6"></a>题目6</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">10进制的整数的精确表达范围是-9007199254740992(-2^53)到9007199254740992(2^53)</span><br><span class="line">END = 9007199254740992 ,START = 9007199254740892目的是计算的END和START之间的差。</span><br><span class="line">但是2的53次方计算出的结果由于精度问题使得i++失效。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目7-1"><a href="#题目7-1" class="headerlink" title="题目7"></a>题目7</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">filter不会接触到没有被赋值的元素，</span><br><span class="line">即在arr中，长度为11但实际数值元素列表为[0, 1, 2, 10]，</span><br><span class="line">因此，最终返回一个空的数组[]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目8-1"><a href="#题目8-1" class="headerlink" title="题目8"></a>题目8</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">两个浮点数相加或者相减，将会导致一定的正常的数据转换造成的精度丢失问题</span><br><span class="line">eight - six = 0.20000000000000007。</span><br><span class="line">更严谨的做法是(eight - six ).totoFiexd(1)或者用Math.round()方法回归整数运算。</span><br><span class="line">判断两个浮点数是否相等，还是建议用逼近的比较，比如<span class="keyword">if</span>((a-b) &lt; 1E-10)</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目9-1"><a href="#题目9-1" class="headerlink" title="题目9"></a>题目9</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">使用new String()使用构造函数调用将一个全新的对象作为this变量的值，并且隐式返回这个新对象作为调用的结果，</span><br><span class="line">因此showCase()接收的参数为String &#123;0: “A”&#125;而不是我们所认为的“A”，为一个对象。</span><br><span class="line">switch是进行绝对等于判断，new String(<span class="string">'A'</span>) !== <span class="string">'A'</span> 而 new String(<span class="string">'A'</span>) == <span class="string">'A'</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="题目10-1"><a href="#题目10-1" class="headerlink" title="题目10"></a>题目10</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">直接调用String(“A”)创建的变量和”A”无异。</span><br><span class="line">例子：</span><br><span class="line">var a = <span class="string">"123"</span>; // 只是设置变量</span><br><span class="line">b = new String(<span class="string">'123'</span>); // 设置一个成员</span><br><span class="line"></span><br><span class="line">var a = <span class="string">"123"</span>;</span><br><span class="line">a.sex = 1;</span><br><span class="line">alert(a.sex); // 输出未定义，因为不是成员，没有这属性</span><br><span class="line"></span><br><span class="line">b = new String(<span class="string">'123'</span>);</span><br><span class="line">b.sex = 1;</span><br><span class="line">alert(b.sex); // 输出1，成员的属性</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目11-1"><a href="#题目11-1" class="headerlink" title="题目11"></a>题目11</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">该函数判断num是否为正整数，</span><br><span class="line"><span class="string">'13'</span>被强制转换为数值13，-9%2结果为-1，Infinity%2为NaN。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目12-1"><a href="#题目12-1" class="headerlink" title="题目12"></a>题目12</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">最终结果为[3, NaN, 3]； </span><br><span class="line">parseInt() 函数可解析一个字符串，并返回一个整数。</span><br><span class="line">当参数 radix 的值为 0，或没有设置该参数时，则数字将以 10 为基础来解析。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目13-1"><a href="#题目13-1" class="headerlink" title="题目13"></a>题目13</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Array.prototype为[]，因此Array.isArray(Array.prototype)为<span class="literal">true</span></span><br><span class="line">Array.isArray(a)是一个判断a是否为数组的方法。</span><br><span class="line">判断对象是否为数组的方法： </span><br><span class="line">1）ES5函数isArray()，该函数测试对象的内部[[Class]]属性是否为Array:</span><br><span class="line">Arrray.isArray(a);</span><br><span class="line">2）判断对象的构造函数是否为Array:</span><br><span class="line">a.constructor === Array</span><br><span class="line">3）使用对象内部[[Class]]属性创建结果字符串：</span><br><span class="line">Object.prototype.toString.call(a)</span><br><span class="line">4）使用instanceof操作符测试对象是否继承自Array： </span><br><span class="line">（但由于，一个页面的iframe不会继承自另外一个页面的iframe，该方法不可靠）</span><br><span class="line">a instanceof Array</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目14-1"><a href="#题目14-1" class="headerlink" title="题目14"></a>题目14</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">由于Boolean([0]) === <span class="literal">true</span></span><br><span class="line">因此进入<span class="keyword">if</span>为<span class="literal">true</span>的语句块中，</span><br><span class="line">由于a为数组(对象)，与布尔值进行相对等于比较，需要两边都转化为数值后在进行判断。</span><br><span class="line">左边[0]先转化为字符串<span class="string">"0"</span>，接着转化为数值0，而右边<span class="literal">true</span>转化为数值1。</span><br><span class="line">因此a == <span class="literal">true</span>最终返回为<span class="literal">false</span>。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目15-1"><a href="#题目15-1" class="headerlink" title="题目15"></a>题目15</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">数组在Javascript中是对象，对象使用 == 比较都是对引用（存放在栈内存的指针）的比较。</span><br><span class="line">简单的说，就是，如果是同一个对象，就相等，如果不是同一个对象，就不等。</span><br><span class="line">每次使用 [] 都是新建一个数组对象，所以 [] == [] 这个语句里建了两个数据对象，所以它们不等。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目16-1"><a href="#题目16-1" class="headerlink" title="题目16"></a>题目16</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">执行<span class="string">'5'</span> + 3，加号具备拼接字符串功能，会将3强制转换为字符串<span class="string">'3'</span>和<span class="string">'5'</span>拼接。 </span><br><span class="line">执行<span class="string">'5'</span> - 3，减号只具备数值运算的功能，因此会将<span class="string">'5'</span>转化为数值，进行5-3的数值运算</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目17-1"><a href="#题目17-1" class="headerlink" title="题目17"></a>题目17</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目18-1"><a href="#题目18-1" class="headerlink" title="题目18"></a>题目18</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">区分赋值和声明。</span><br><span class="line">虽然var arr = Array(3);创建一个长度为3的数组，</span><br><span class="line">但是实际只有一个元素被赋值，因此arr的实际长度为1，即最终参与map的只有一个元素，返回[<span class="string">"1"</span>]</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目19-1"><a href="#题目19-1" class="headerlink" title="题目19"></a>题目19</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：D</span><br><span class="line">解析：</span><br><span class="line">按照执行步骤，无需多疑，最终结果为10+1+10=21</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目20-1"><a href="#题目20-1" class="headerlink" title="题目20"></a>题目20</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答案：B</span><br><span class="line">解析：</span><br><span class="line">js的精确整数最大为：Math.pow(2,53) - 1 = 9007199254740991. </span><br><span class="line">var a = 111111111111111110000, </span><br><span class="line">max = 9007199254740992; </span><br><span class="line">a的值大于JavaScript所能表示的最大整数精度，因此和任何数值相加将会导致失真。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目21-1"><a href="#题目21-1" class="headerlink" title="题目21"></a>题目21</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">正确调用方式为x.call(arr) =&gt; x.call([])</span><br><span class="line">Array.prototype为[]，[].reverse相当于Array.prototype.reverse，</span><br><span class="line">将它call(arr)之后，Array.prototype.reverse中的this就指向了arr对象了。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目22-1"><a href="#题目22-1" class="headerlink" title="题目22"></a>题目22</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">Number.MIN_VALUE表示的最小值为5e-324，</span><br><span class="line">Number.MIN_VALUE代表的并不是负最小，而是最接近0的一个数，因此Number.MIN_VALUE&gt;0。 </span><br><span class="line">负最小值可以使用-Number.MAX_VALUE表示，为1.7976931348623157e+308。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目23-1"><a href="#题目23-1" class="headerlink" title="题目23"></a>题目23</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">1&lt;2，返回<span class="literal">true</span>，执行<span class="literal">true</span>&lt;3，会强制将<span class="literal">true</span>转换为1，1&lt;3，最终返回<span class="literal">true</span>。 </span><br><span class="line">3&lt;2，返回<span class="literal">false</span>，执行<span class="literal">false</span>&lt;1,会强制将<span class="literal">false</span>转换为0，0&lt;1，最终返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目24-1"><a href="#题目24-1" class="headerlink" title="题目24"></a>题目24</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答案：A</span><br><span class="line">解析：</span><br><span class="line">使用a==b判断a和b对象是否相等，可以会将b对象强制转换为a对象的类型，即执行2 == [[[2]]]，会隐式调用parseInt([[[2]]])将[[[2]]]强制转化为数字基本量，即2，2==2，最终返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目25-1"><a href="#题目25-1" class="headerlink" title="题目25"></a>题目25</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">Number中的toString(a)，能够将数值转化成为a进制的值。但a缺省时，默认转化为十进制。 </span><br><span class="line">一般使用方法为：var n = 3; (3).toString(); </span><br><span class="line">执行3.toString()，因为3只是为数值型变量，为非Number实例，因此对于3不能直接调用toString方法。</span><br><span class="line">而执行3..toString()，会强制将3转化为数字实例，因此能够被解释，输出3，同样可以使用(3).toString()达到一样的效果。</span><br><span class="line">3...toString()会报<span class="string">"Unexpected token ."</span>的错。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目26-1"><a href="#题目26-1" class="headerlink" title="题目26"></a>题目26</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案：C</span><br><span class="line">解析：</span><br><span class="line">在立即调用函数内执行，var x1 = y1 =1; 创建局部变量x1和全局变量y1。</span><br><span class="line">函数外部试图访问函数内部的变量x1，将会导致错误。可以访问全局变量y1。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目27-1"><a href="#题目27-1" class="headerlink" title="题目27"></a>题目27</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">列举IE和FF脚本兼容性的问题 </span><br><span class="line">（1）window.event </span><br><span class="line">表示当前的事件对象，IE有这个对象，FF没有 </span><br><span class="line">（2）获取事件源 </span><br><span class="line">IE用srcElement获取事件源，而FF用target获取事件源 </span><br><span class="line">（3）添加、移除事件</span><br><span class="line">IE：</span><br><span class="line">element.attachEvent(<span class="string">"onclick"</span>,<span class="keyword">function</span>)</span><br><span class="line">element.detachEvent(<span class="string">"onclick"</span>,<span class="keyword">function</span>)</span><br><span class="line">FF:</span><br><span class="line">element.addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>,<span class="literal">true</span>)</span><br><span class="line">element.removeEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>,<span class="literal">true</span>)</span><br><span class="line">``` </span><br><span class="line"><span class="comment">##### 题目28</span></span><br><span class="line">+ 解析：</span><br><span class="line">``` bash</span><br><span class="line">解析：</span><br><span class="line">题目所给出的代码，除了有addEventListener不兼容IE浏览器的问题之外，最突出的一个问题是： </span><br><span class="line">虽然在页面上会显示五个按钮，但是点击任意一个按钮，最终都会显示5。</span><br><span class="line">要想点击相关按钮，弹出相应的1，2，3，4，5的值，需要理解闭包原理实现和使用立即回调函数。修改后的代码如下：</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">initButtons</span></span>()&#123; </span><br><span class="line">    var body = document.body, button; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; 5; i++)&#123; </span><br><span class="line">        (<span class="keyword">function</span>(j)&#123; </span><br><span class="line">            button = document.createElement(<span class="string">"button"</span>); </span><br><span class="line">            button.innerHTML = <span class="string">"Button"</span> + j; </span><br><span class="line">            button.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(e)&#123; </span><br><span class="line">                alert(j); </span><br><span class="line">            &#125;, <span class="literal">false</span>); </span><br><span class="line">            body.appendChild(button); </span><br><span class="line">        &#125;)(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">initButtons();</span><br><span class="line">闭包存储的是外部变量的引用而非值。 </span><br><span class="line">立即调用的函数表达式，是一种不可或缺的解决javascript缺少块级作用域的方法。</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目29-1"><a href="#题目29-1" class="headerlink" title="题目29"></a>题目29</h5><ul><li>解析：可使用常规方法和正则表达式匹配两种算法来求解。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> toGetTheMostCharsByArray(s)&#123; </span><br><span class="line">    var r = &#123;&#125;; </span><br><span class="line">    <span class="keyword">for</span>(var i = 0; i &lt; s.length; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!r[s[i]])&#123; </span><br><span class="line">            r[s[i]] = 1; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            r[s[i]]++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    var max = &#123; </span><br><span class="line">        <span class="string">"value"</span> : s[0], </span><br><span class="line">        <span class="string">"num"</span> : r[s[0]] </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(var n <span class="keyword">in</span> r)&#123;//对象使用<span class="keyword">in</span>关键字，因为没有length </span><br><span class="line">        <span class="keyword">if</span>(r[n]&gt;max.num)&#123; </span><br><span class="line">            max.num = r[n]; </span><br><span class="line">            max.value = n;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">return</span> max; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> toGetTheMostCharsByRegex(s)&#123; </span><br><span class="line">    var a = s.split(<span class="string">''</span>); </span><br><span class="line">    a.sort(); </span><br><span class="line">    s = a.join(<span class="string">''</span>); </span><br><span class="line"></span><br><span class="line">    var regex = /(\w)\1+/g ;//\1代表重复的 </span><br><span class="line"></span><br><span class="line">    var max = &#123; </span><br><span class="line">        <span class="string">"value "</span>　:s[0], </span><br><span class="line">        <span class="string">"num"</span> :  0 </span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    s.replace(regex, <span class="keyword">function</span>(a, b)&#123; </span><br><span class="line">        // a为重复的字符串</span><br><span class="line">        // b为重复字符</span><br><span class="line">        <span class="keyword">if</span>(max.num &lt; a.length)&#123; </span><br><span class="line">            max.num = a.length; </span><br><span class="line">            max.value= b; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="built_in">return</span> max; </span><br><span class="line">&#125; </span><br><span class="line">var <span class="built_in">test</span> = <span class="string">"efdfssssfrhth"</span>; </span><br><span class="line">console.info(<span class="string">"使用常规方法　，出现最多的字符串为："</span>+toGetTheMostCharsByArray(<span class="built_in">test</span>).value+<span class="string">" ，出现次数："</span>+toGetTheMostCharsByArray(<span class="built_in">test</span>).num); </span><br><span class="line">console.info(<span class="string">"使用字符串匹配，出现最多的字符串为："</span>+toGetTheMostCharsByRegex(<span class="built_in">test</span>).value+<span class="string">" ，出现次数："</span>+toGetTheMostCharsByRegex(<span class="built_in">test</span>).num);</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目30-1"><a href="#题目30-1" class="headerlink" title="题目30"></a>题目30</h5><ul><li>解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript的引擎是单线程的，且是基于事件驱动的。</span><br><span class="line">setTimeout和setInterval都是往事件队列中增加一个待处理时间而已，setTimeout只触发一次，而setInterval是循环触发。</span><br><span class="line">代码一可使得setTimeout循环触发。但是，执行完这段代码块才挂起时间，所以两次执行时间会大于10毫秒。</span><br><span class="line">代码二是自动在10的时候挂上这个事件，所以两次事件的相隔会小于等于10毫秒。 </span><br><span class="line">当线程阻塞在一个事件的时候，不管是使用setInterval还是setTimeout都需要等待当前事件处理完才能执行。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文记录了30个&lt;code&gt;你“不可能全部会做”的JavaScript题目&lt;/code&gt;，并对各个答案进行分析。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="习题" scheme="https://chongtianhong.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
