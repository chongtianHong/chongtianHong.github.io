<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-10-11T14:20:19.953Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VScode中用sftp自动上传 | 服务端用pm2自动重启</title>
    <link href="https://chongtianhong.github.io/2018/07/04/sftpAndPM2/"/>
    <id>https://chongtianhong.github.io/2018/07/04/sftpAndPM2/</id>
    <published>2018-07-04T02:04:26.000Z</published>
    <updated>2018-10-11T14:20:19.953Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h4><h5 id="sftp-的安装和配置"><a href="#sftp-的安装和配置" class="headerlink" title="sftp 的安装和配置"></a>sftp 的安装和配置</h5><ul><li><p>在Visual Studio Code 中<strong>安装 sftp 扩展</strong>，安装完成后在<strong>工作空间</strong>中，按<code>Ctrl + Shift + P</code>并输入：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp config</span><br></pre></td></tr></table></figure></li><li><p>这个指令会在<code>.vscode</code>中添加<code>sftp.json</code>文件，按需求修改其中的项目，示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">""</span>,     // 服务器ip</span><br><span class="line">    <span class="string">"port"</span>: 22,     // 端口，sftp模式是22</span><br><span class="line">    <span class="string">"username"</span>: <span class="string">""</span>, // 用户名</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">""</span>, // 密码</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"sftp"</span>, // 模式</span><br><span class="line">    <span class="string">"agent"</span>: null,  </span><br><span class="line">    <span class="string">"privateKeyPath"</span>: null,</span><br><span class="line">    <span class="string">"passphrase"</span>: null,</span><br><span class="line">    <span class="string">"passive"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"interactiveAuth"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"remotePath"</span>: <span class="string">"/root/node/build/"</span>,  // 服务器上的文件地址</span><br><span class="line">    <span class="string">"context"</span>: <span class="string">"./server/build"</span>,        // 本地的文件地址</span><br><span class="line">    </span><br><span class="line">    <span class="string">"uploadOnSave"</span>: <span class="literal">true</span>,   // 监听保存并上传</span><br><span class="line">    <span class="string">"syncMode"</span>: <span class="string">"update"</span>,</span><br><span class="line">    <span class="string">"watcher"</span>: &#123;            // 监听外部文件</span><br><span class="line">        <span class="string">"files"</span>: <span class="literal">false</span>,     // 外部文件的绝对路径</span><br><span class="line">        <span class="string">"autoUpload"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"autoDelete"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"ignore"</span>: [             // 忽略项</span><br><span class="line">        <span class="string">"**/.vscode/**"</span>,</span><br><span class="line">        <span class="string">"**/.git/**"</span>,</span><br><span class="line">        <span class="string">"**/.DS_Store"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：其中的注释不能保留。</p></li></ul><h5 id="sftp-的使用"><a href="#sftp-的使用" class="headerlink" title="sftp 的使用"></a>sftp 的使用</h5><ul><li><p>按<code>Ctrl + Shift + P</code>并输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sftp Upload</span><br></pre></td></tr></table></figure></li><li><p>即可将项目上传到服务器中。类似的指令还有：</p></li></ul><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">SFTP Upload</td><td style="text-align:center">上传到服务器，没有则创建，有则覆盖，多则忽略</td></tr><tr><td style="text-align:center">SFTP Download</td><td style="text-align:center">下载到本地，规则同上</td></tr><tr><td style="text-align:center">SFTP Sync To Remote</td><td style="text-align:center">同步到服务器，多则删除</td></tr><tr><td style="text-align:center">SFTP Sync To Local</td><td style="text-align:center">同步到本地，多则删除</td></tr></tbody></table><ul><li>若想单独操作项目中的某个文件，则右键，选择以上指令即可。</li></ul><h4 id="pm2-自动重载"><a href="#pm2-自动重载" class="headerlink" title="pm2 自动重载"></a>pm2 自动重载</h4><h5 id="安装-pm2"><a href="#安装-pm2" class="headerlink" title="安装 pm2"></a>安装 pm2</h5><ul><li><p>登录服务器，输入以下指令安装pm2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g pm2</span><br></pre></td></tr></table></figure></li><li><p>检查是否安装成功，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 -v</span><br></pre></td></tr></table></figure></li><li><p>如果和下面一样出现版本信息，则安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_16_centos ~]<span class="comment"># pm2 -v</span></span><br><span class="line">2.9.1</span><br></pre></td></tr></table></figure></li><li><p>如果没有出现版本信息，而是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_16_centos ~]<span class="comment"># pm2 -v</span></span><br><span class="line">-bash: pm2: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure></li><li><p>则可能是<strong>npm的环境变量没有配置好</strong>，参考<a href="http://www.cnblogs.com/AmosLee94/p/8337956.html" target="_blank" rel="noopener">CentOS 中永久修改环境变量</a>。</p></li></ul><h5 id="通过pm2启动node-js服务并监听文件变化时自动重启"><a href="#通过pm2启动node-js服务并监听文件变化时自动重启" class="headerlink" title="通过pm2启动node.js服务并监听文件变化时自动重启"></a>通过pm2启动node.js服务并监听文件变化时自动重启</h5><ul><li><p>使用指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start server.js --watch</span><br></pre></td></tr></table></figure></li><li><p>成功则显示如下：<br><img src="" alt="进程成功开启"></p></li><li>补充：执行<code>pm2 list</code>，可以看到node进程列表。如果要开启，执行<code>pm2 start + 对应id</code>，关闭则使用：<code>pm2 stop + 对应id</code>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>如果你是希望编写的代码保存后，自动上传、并且不用再切换到xshell中去操作远程端（使用<code>rz -bey</code>从本地win上传文件到远端linux、使用<code>sz –bey </code>从远端linux传输文件到本地win）。那么上面的方法已经实现了。</li><li>但是事情往往没有那么简单，<strong>sftp的保存并上传功能</strong>，<strong>只能监听到保存这一动作</strong>，而<strong>无法监听到构建工具构建出来的文件</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;sftp&quot;&gt;&lt;a href=&quot;#sftp&quot; class=&quot;headerlink&quot; title=&quot;sftp&quot;&gt;&lt;/a&gt;sftp&lt;/h4&gt;&lt;h5 id=&quot;sftp-的安装和配置&quot;&gt;&lt;a href=&quot;#sftp-的安装和配置&quot; class=&quot;headerlink&quot; title=&quot;sftp 的安装和配置&quot;&gt;&lt;/a&gt;sftp 的安装和配置&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Visual Studio Code 中&lt;strong&gt;安装 sftp 扩展&lt;/strong&gt;，安装完成后在&lt;strong&gt;工作空间&lt;/strong&gt;中，按&lt;code&gt;Ctrl + Shift + P&lt;/code&gt;并输入：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="工具使用" scheme="https://chongtianhong.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux cd命令</title>
    <link href="https://chongtianhong.github.io/2018/07/03/cdOfLinux/"/>
    <id>https://chongtianhong.github.io/2018/07/03/cdOfLinux/</id>
    <published>2018-07-03T06:54:59.000Z</published>
    <updated>2018-10-10T13:51:24.343Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Linux cd命令用于<strong>切换当前工作目录至 dirName(目录参数)</strong>。</li><li>其中 dirName 表示法可为<strong>绝对路径</strong>或<strong>相对路径</strong>。若<strong>目录名称省略</strong>，则<strong>变换至使用者的 home 目录</strong> (也就是<strong>刚 login 时所在的目录</strong>)。<a id="more"></a></li><li>另外，”~” 也表示为 <strong>home 目录</strong> 的意思，”.” 则是表示<strong>目前所在的目录</strong>，”..” 则表示<strong>目前目录位置的上一层目录</strong>。</li><li><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [dirName]</span><br></pre></td></tr></table></figure></li><li><p>dirName为<strong>要切换的目标目录</strong>。</p></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li><p>跳到<code>/usr/bin/</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br></pre></td></tr></table></figure></li><li><p>跳到自己的<code>home 目录</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">或</span><br><span class="line"><span class="built_in">cd</span></span><br></pre></td></tr></table></figure></li><li><p>跳到<code>目前目录的上上两层</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux cd命令用于&lt;strong&gt;切换当前工作目录至 dirName(目录参数)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;其中 dirName 表示法可为&lt;strong&gt;绝对路径&lt;/strong&gt;或&lt;strong&gt;相对路径&lt;/strong&gt;。若&lt;strong&gt;目录名称省略&lt;/strong&gt;，则&lt;strong&gt;变换至使用者的 home 目录&lt;/strong&gt; (也就是&lt;strong&gt;刚 login 时所在的目录&lt;/strong&gt;)。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="linux" scheme="https://chongtianhong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>iframe的知识点</title>
    <link href="https://chongtianhong.github.io/2018/07/02/iframe/"/>
    <id>https://chongtianhong.github.io/2018/07/02/iframe/</id>
    <published>2018-07-02T07:34:10.000Z</published>
    <updated>2018-10-09T14:57:25.552Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>有人说，iframe是<strong>能耗最高</strong>的一个元素，<strong>尽量减少使用</strong>。也有人说，iframe的<strong>安全性太差</strong>，<strong>尽量减少使用</strong>。</li><li>尽管如此，但是<strong>iframe的强大功能是不容忽视的</strong>，而且现在不乏公司正在使用它。<a id="more"></a></li><li>&lt;iframe&gt;标签<strong>规定一个内联框架</strong>。一个内联框架被用来<strong>在当前 HTML 文档中嵌入另一个文档</strong>。</li><li>所有的主流浏览器都支持&lt;iframe&gt;标签。我们可以<strong>把提示的文字放到 &lt;iframe&gt; 和 &lt;/iframe&gt;里面</strong>，这样<strong>不支持 &lt;iframe&gt;的浏览器就会出现提示的文字</strong>。</li></ul><h4 id="iframe-的使用"><a href="#iframe-的使用" class="headerlink" title="iframe 的使用"></a>iframe 的使用</h4><ul><li><p>通常我们使用iframe可以直接<strong>在iframe标签指定src</strong>，规定想要<strong>嵌套的页面URL</strong>就可以了。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">    &lt;iframe&gt; 标签规定一个内联框架</span><br><span class="line">    这里写p 标签是为了看align的效果</span><br><span class="line">--&gt;</span><br><span class="line">&lt;p style=<span class="string">"overflow: hidden;"</span>&gt;这是一些文本。 这是一些文本。 这是一些文本。这是一些文本。 这是一些文本。 这是一些文本。</span><br><span class="line">    &lt;iframe name=<span class="string">"myiframe"</span> id=<span class="string">"myrame"</span> src=<span class="string">"external_file.html"</span> frameborder=<span class="string">"0"</span> align=<span class="string">"left"</span> width=<span class="string">"200"</span> height=<span class="string">"200"</span> scrolling=<span class="string">"no"</span>&gt;</span><br><span class="line">        &lt;p&gt;你的浏览器不支持iframe标签&lt;/p&gt;</span><br><span class="line">    &lt;/iframe&gt;</span><br><span class="line">这是一些文本。 这是一些文本。 这是一些文本。这是一些文本。 这是一些文本。 这是一些文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>iframe 的常用属性：</p><ul><li><strong>name</strong>：规定 &lt;iframe&gt; 的名称。</li><li><strong>width</strong>：规定 &lt;iframe&gt; 的宽度。</li><li><strong>height</strong>：规定 &lt;iframe&gt; 的高度。</li><li><strong>src</strong>：规定在 &lt;iframe&gt; 中显示的文档的 URL。</li><li><strong>frameborder</strong>：规定是否显示 &lt;iframe&gt; 周围的边框。 (0为无边框，1位有边框)。</li><li><strong>align</strong>：规定如何根据周围的元素来对齐 &lt;iframe&gt;。　(left,right,top,middle,bottom)。</li><li><strong>scrolling</strong>：规定是否在 &lt;iframe&gt; 中显示滚动条。 (yes,no,auto)</li></ul></li><li>上面代码中将 iframe 的src属性设置为自己本地的一个html页面。</li></ul><h4 id="iframe里面的内容获取"><a href="#iframe里面的内容获取" class="headerlink" title="iframe里面的内容获取"></a>iframe里面的内容获取</h4><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var iframe = document.getElementById(<span class="string">"myrame"</span>); //获取iframe标签</span><br><span class="line">var iwindow = iframe.contentWindow; //获取iframe的window对象</span><br><span class="line">var idoc = iwindow.document; //获取iframe的document对象</span><br><span class="line">console.log(idoc.documentElement); //获取iframe的html</span><br><span class="line">console.log(<span class="string">"body"</span>, idoc.body);</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用iframe的优缺点"><a href="#使用iframe的优缺点" class="headerlink" title="使用iframe的优缺点"></a>使用iframe的优缺点</h4><ul><li>iframe的<strong>优点</strong>：<br>① iframe能够<strong>原封不动地把嵌入的网页展现出来</strong>。<br>② 如果有多个网页调用iframe，只需要修改iframe的内容，就可以<strong>实现对调用iframe的每一个页面内容的更改，方便快捷</strong>。<br>③ 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以<strong>增加代码的可重用性</strong>。<br>④ 如果<strong>遇到加载缓慢的第三方内容</strong>，如图标和广告等，<strong>可以用iframe来解决</strong>。</li><li>iframe的<strong>缺点</strong>：<br>① 会<strong>产生很多页面</strong>，不容易管理。<br>② 在几个框架中都出现上下、左右滚动条时，这些滚动条除了会<strong>挤占已经非常有限的页面空间</strong>外，还会<strong>分散访问者的注意力</strong>。<br>③ 使用框架结构时，必须保<strong>证正确设置所有的导航链接</strong>，否则会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下访问者便被陷住了，因为此时他没有其他地点可去，导致<strong>链接死循环</strong>。<br>④ 很多的移动设备（PDA手机）无法完全显示框架，设备兼容性差。<br>⑤ iframe框架页面会<strong>增加服务器的http请求</strong>，对于大型网站是不可取的。</li><li>注意：由于诸多的缺点，不符合标准网页设计的理念，已经被抛弃，目前的<strong>HTML5不再支持此标签</strong>。</li></ul><h4 id="为什么少用iframe"><a href="#为什么少用iframe" class="headerlink" title="为什么少用iframe"></a>为什么少用iframe</h4><ul><li>iframes 提供了一个简单的方式<strong>把一个网站的内容嵌入到另一个网站中</strong>。但我们需要<strong>慎重的使用iframe</strong>。iframe的创建比其它包括scripts和css的 DOM 元素的创建慢了 1-2 个数量级。</li><li>使用 iframe 的页面一般不会包含太多 iframe，所以创建 DOM 节点所花费的时间不会占很大的比重。但<strong>带来一些其它的问题</strong>：<strong>onload 事件</strong>以及<strong>连接池(connection pool)</strong>。</li></ul><h5 id="Iframes-阻塞页面加载"><a href="#Iframes-阻塞页面加载" class="headerlink" title="Iframes 阻塞页面加载"></a>Iframes 阻塞页面加载</h5><ul><li>及时触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload 事件加载延迟后，它给用户的感觉就是这个网页非常慢。</li><li>window 的 onload 事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发。在 Safari 和 Chrome 里，<strong>通过 JavaScript 动态设置 iframe 的 SRC 可以避免这种阻塞情况</strong>。</li></ul><h5 id="唯一的连接池"><a href="#唯一的连接池" class="headerlink" title="唯一的连接池"></a>唯一的连接池</h5><ul><li>浏览器只能开少量的连接到web服务器。比较老的浏览器，包含 Internet Explorer 6 &amp; 7 和 Firefox 2，只能对一个域名(hostname)同时打开两个连接。这个数量的限制在新版本的浏览器中有所提高。Safari 3+ 和 Opera 9+ 可同时对一个域名打开 4 个连接，Chrome 1+, IE 8 以及 Firefox 3 可以同时打开 6 个。你可以通过这篇文章查看具体的数据表：Roundup on Parallel Connections.</li><li>有人可能希望 iframe 会有自己独立的连接池，但不是这样的。<strong>绝大部分浏览器，主页面和其中的 iframe 是共享这些连接的</strong>。这意味着 iframe 在加载资源时可能用光了所有的可用连接，从而阻塞了主页面资源的加载。如果 iframe 中的内容比主页面的内容更重要，这当然是很好的。但通常情况下，iframe 里的内容是没有主页面的内容重要的。这时 iframe 中用光了可用的连接就是不值得的了。一种<strong>解决办法</strong>是，<strong>在主页面上重要的元素加载完毕后，再动态设置 iframe 的 SRC</strong>。</li><li>美国前 10 大网站都使用了 iframe。大部分情况下，他们用它来加载广告。这是可以理解的，也是一种符合逻辑的解决方案，用一种简单的办法来加载广告服务。但请记住，iframe 会给你的页面性能带来冲击。只要可能，不要使用 iframe。当确实需要时，谨慎的使用它们。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;有人说，iframe是&lt;strong&gt;能耗最高&lt;/strong&gt;的一个元素，&lt;strong&gt;尽量减少使用&lt;/strong&gt;。也有人说，iframe的&lt;strong&gt;安全性太差&lt;/strong&gt;，&lt;strong&gt;尽量减少使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;尽管如此，但是&lt;strong&gt;iframe的强大功能是不容忽视的&lt;/strong&gt;，而且现在不乏公司正在使用它。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
      <category term="iframe" scheme="https://chongtianhong.github.io/tags/iframe/"/>
    
  </entry>
  
  <entry>
    <title>linux常用指令学习记录</title>
    <link href="https://chongtianhong.github.io/2018/07/01/linux/"/>
    <id>https://chongtianhong.github.io/2018/07/01/linux/</id>
    <published>2018-07-01T12:17:26.000Z</published>
    <updated>2018-10-08T14:27:23.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>本文主要为学习贴，用来记录一些linux上的常用指令以供参考。<a id="more"></a></li></ul><h4 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h4><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><ul><li><p>cat命令常用来查看文件内容，命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat [-AbEnTv] FILENAME</span></span><br></pre></td></tr></table></figure></li><li><p>选项参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-A：相当于vTE的整合选项，可列出一些特殊字符而不是空白而已</span><br><span class="line">-b：列出行号，仅列出非空白行的行号，空白行不显示行号</span><br><span class="line">-E：将结尾的断行字符$显示出来</span><br><span class="line">-n：列出行号，连同空白行也显示行号，与-b选项不同</span><br><span class="line">-T：将[tab]按键以 ^I 显示出来</span><br><span class="line">-v：列出一些看不出来的特殊字符</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本文主要为学习贴，用来记录一些linux上的常用指令以供参考。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="linux" scheme="https://chongtianhong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>webSocket</title>
    <link href="https://chongtianhong.github.io/2018/06/30/webSocket/"/>
    <id>https://chongtianhong.github.io/2018/06/30/webSocket/</id>
    <published>2018-06-30T08:34:10.000Z</published>
    <updated>2018-10-06T09:58:55.755Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webSocket是什么"><a href="#webSocket是什么" class="headerlink" title="webSocket是什么"></a>webSocket是什么</h4><ul><li><strong>webSocket是HTML5新出的一种协议</strong>，底层是<strong>基于TCP/IP协议</strong>的。跟http没有关系，只是复用了http握手通道，用来升级协议。<a id="more"></a></li></ul><h4 id="webSocket的作用"><a href="#webSocket的作用" class="headerlink" title="webSocket的作用"></a>webSocket的作用</h4><ul><li>轮询：客户端<strong>以一定的时间间隔</strong>向服务端发出请求，以<strong>频繁请求</strong>的方式来<strong>保持客户端和服务器端的同步</strong>。缺点：<ul><li>浏览器需要不断的向服务器发出请求，然而<strong>HTTP请求可能包含较长的头部</strong>，其中<strong>真正有效的数据可能只是很小的一部分</strong>，显然这样会<strong>浪费很多的带宽等资源</strong>。</li></ul></li><li>长轮询：浏览器向服务器发送请求，<strong>服务器将请求保持打开一段时间</strong>。如果在该时间段内收到通知，则将包含该消息的响应发送到客户端。如果在设定的时间段内未收到通知，则服务器发送响应以终止打开的请求。缺点：<ul><li>当具有<strong>较高的消息量</strong>时，长轮询<strong>不会提供比传统轮询更大的性能改进</strong>；</li><li><strong>服务器端</strong>会<strong>阻塞请求</strong>直到<strong>有数据传递</strong>或<strong>超时</strong>才返回。</li></ul></li><li>使用webSocket<strong>浏览器和服务器只需要完成一次握手</strong>，两者之间就直接可以<strong>创建持久性的连接</strong>，并进行<strong>双向数据传输</strong>。优点：<ul><li>能更好的<strong>节省服务器资源和带宽</strong>；</li><li>支持<strong>双向通信</strong>，<strong>实时性更强</strong>；</li><li>可以发送<strong>文本</strong>，也可以发送<strong>二进制数据</strong>。</li></ul></li></ul><h4 id="webSocket的使用"><a href="#webSocket的使用" class="headerlink" title="webSocket的使用"></a>webSocket的使用</h4><blockquote>服务端</blockquote><ul><li>代码如下，监听8080端口。当有新的连接请求到达时，打印日志，同时向客户端发送消息。当收到到来自客户端的消息时，同样打印日志：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var app = require(<span class="string">'express'</span>)();</span><br><span class="line">var server = require(<span class="string">'http'</span>).Server(app);</span><br><span class="line">var WebSocket = require(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line">var wss = new WebSocket.Server(&#123; port: 8080 &#125;);</span><br><span class="line"></span><br><span class="line">// 当有新的连接请求到达时</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="keyword">function</span> connection(ws) &#123; </span><br><span class="line">    console.log(<span class="string">'server: receive connection.'</span>);</span><br><span class="line">    // 当收到到来自客户端的消息时</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="keyword">function</span> incoming(message) &#123;</span><br><span class="line">        console.log(<span class="string">'server: received: %s'</span>, message);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 向客户端发送消息</span><br><span class="line">    ws.send(<span class="string">'world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure></li></ul><blockquote>客户端</blockquote><ul><li><p>代码如下，向8080端口发起WebSocket连接。连接建立后，打印日志，同时向服务端发送消息。接收到来自服务端的消息后，同样打印日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 向8080端口发起WebSocket连接</span><br><span class="line">    var ws = new WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line">    // 连接建立后</span><br><span class="line">    ws.onopen = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">'ws onopen'</span>);</span><br><span class="line">        ws.send(<span class="string">'from client: hello'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    // 接收到来自服务端的消息后</span><br><span class="line">    ws.onmessage = <span class="keyword">function</span> (e) &#123;</span><br><span class="line">        console.log(<span class="string">'ws onmessage'</span>);</span><br><span class="line">        console.log(<span class="string">'from server: '</span> + e.data);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>服务端</strong>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server: receive connection.</span><br><span class="line">server: received from client: hello</span><br></pre></td></tr></table></figure></li><li><p>客户端输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client: ws onopen</span><br><span class="line">client: ws onmessage</span><br><span class="line">client: received from server: world</span><br></pre></td></tr></table></figure></li></ul><h4 id="webSocket应用场景"><a href="#webSocket应用场景" class="headerlink" title="webSocket应用场景"></a>webSocket应用场景</h4><ul><li>社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要<strong>高实时</strong>的场景。</li></ul><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/" target="_blank" rel="noopener">Comet：基于 HTTP 长连接的“服务器推”技术</a></li><li><a href="https://juejin.im/post/5a4e6a43f265da3e303c4787" target="_blank" rel="noopener">WebSocket：5分钟从入门到精通</a></li><li>&lt;&lt;web性能优化权威指南&gt;&gt;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;webSocket是什么&quot;&gt;&lt;a href=&quot;#webSocket是什么&quot; class=&quot;headerlink&quot; title=&quot;webSocket是什么&quot;&gt;&lt;/a&gt;webSocket是什么&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;webSocket是HTML5新出的一种协议&lt;/strong&gt;，底层是&lt;strong&gt;基于TCP/IP协议&lt;/strong&gt;的。跟http没有关系，只是复用了http握手通道，用来升级协议。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="webSocket" scheme="https://chongtianhong.github.io/tags/webSocket/"/>
    
      <category term="HTML5" scheme="https://chongtianhong.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>display:none与visibility:hidden的对比</title>
    <link href="https://chongtianhong.github.io/2018/06/29/displayAndVisibility/"/>
    <id>https://chongtianhong.github.io/2018/06/29/displayAndVisibility/</id>
    <published>2018-06-29T06:45:36.000Z</published>
    <updated>2018-10-04T14:12:16.391Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深入display-none"><a href="#深入display-none" class="headerlink" title="深入display:none"></a>深入display:none</h4><ul><li>我们都清楚当元素设置<code>display:none</code>后，<strong>界面上将不会显示该元素，并且该元素不占布局空间</strong>，但我们<strong>仍然可以通过JavaScript操作该元素</strong>。<a id="more"></a></li><li>这个涉及到<strong>浏览器的渲染原理</strong>：浏览器会<strong>解析HTML标签生成DOM Tree</strong>，<strong>解析CSS生成CSSOM</strong>，然后<strong>将DOM Tree和CSSOM合成生成Render Tree</strong>，元素在Render Tree中对应0或多个盒子，然后<strong>浏览器以盒子模型的信息布局和渲染界面</strong>。而<strong>设置为<code>display:none</code>的元素</strong>则在Render Tree中没有生成对应的盒子模型，因此<strong>后续的布局、渲染工作自然与它无关</strong>，至于<strong>DOM操作还是可以的</strong>。</li><li>但除了上面的知识点外，还有以下8个是我们需要注意的：</li></ul><blockquote>1、原生默认display:none的元素</blockquote><ul><li>其实<strong>浏览器原生元素</strong>中有不少自带<code>display:none</code>的元素，如<code>link</code>，<code>script</code>，<code>style</code>，<code>dialog</code>，<code>input[type=hidden]</code>等。</li></ul><blockquote>2、HTML5中新增<strong>hidden布尔属性</strong>，让开发者自定义元素的隐藏</blockquote><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 兼容原生不支持hidden属性的浏览器  */</span><br><span class="line">[hidden]&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span hidden&gt;Hide and Seek: You can<span class="string">'t see me!&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>3、父元素为display:none，后代元素都不可见</blockquote><ul><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.hidden&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">.visible&#123;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*** START ***</span><br><span class="line">&lt;div class=<span class="string">"hidden"</span>&gt;</span><br><span class="line">    I<span class="string">'m parent!</span></span><br><span class="line"><span class="string">    &lt;div class="visible"&gt; I'</span>m son! &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">*** END ***</span><br></pre></td></tr></table></figure></li><li><p>浏览器直接显示为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** START ***</span><br><span class="line">*** END ***</span><br></pre></td></tr></table></figure></li></ul><blockquote>4、无法获取焦点</blockquote><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span>&gt;</span><br><span class="line">&lt;div tabindex=<span class="string">"1"</span> style=<span class="string">"display:none"</span>&gt;hidden&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>5、无法响应任何事件，无论是捕获、命中目标和冒泡阶段均不可以</blockquote><ul><li>由于<strong><code>display:none</code>的元素根本不会在界面上渲染</strong>，就是连一个像素的都不占，因此自然<strong>无法通过鼠标点击命中</strong>，而<strong>元素也无法获取焦点</strong>，那么<strong>也不能成为键盘事件的命中目标</strong>。</li><li>当父元素的<code>display</code>为<code>none</code>时，子元素的<code>display</code>必定为<code>none</code>，因此元素也没有机会位于事件捕获或冒泡阶段的路径上，因此<strong><code>display:none</code>的元素无法响应事件</strong>。</li></ul><blockquote>6、不耽误form表单提交数据</blockquote><ul><li>虽然我们无法看到<code>display:none</code>的元素，但<strong>当表单提交时，依然会将隐藏的input元素的值提交上去</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"id"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"gguid"</span> style=<span class="string">"display:none"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>7、display变化时将触发reflow</blockquote><ul><li>撇开<code>display:none</code>，我们看看<strong><code>display:block</code>表示元素位于BFC中</strong>，而<strong><code>display:inline</code>则表示元素位于IFC中</strong>，也就是说<strong>display就是用于设置元素所属的布局上下文</strong>，若<strong>修改display值</strong>则表示<strong>元素采用的布局方式已发生变化</strong>，因此，<strong>display变化时将触发reflow</strong>。</li></ul><blockquote>8、display:none让transition失效</blockquote><ul><li>详情请参考<a href="https://www.cnblogs.com/fsjohnhuang/p/9143035.html" target="_blank" rel="noopener">CSS魔法堂：Transition就这么好玩</a></li></ul><h4 id="深入visibility"><a href="#深入visibility" class="headerlink" title="深入visibility"></a>深入visibility</h4><ul><li>visibility有两个不同的作用：<br>① 用于<strong>隐藏表格的行和列</strong><br>② 用于<strong>在不触发布局的情况下隐藏元素</strong></li><li>visibility有四个有效值：<br>① visible：在界面上显示元素。<br>② hidden：让元素在见面上不可视，但保留元素原来占有的位置。<br>③ collapse：用于表格子元素(如tr,tbody,col,colgroup)时效果和<code>display:none</code>一样，用于其他元素上时则效果与<code>visibility:hidden</code>一样。不过由于各浏览器实现效果均有出入，因此<strong>一般不会使用这个值</strong>。<br>④ inherit：继承父元素的visibility值。</li></ul><h4 id="visibility-hidden的注意事项"><a href="#visibility-hidden的注意事项" class="headerlink" title="visibility:hidden的注意事项"></a>visibility:hidden的注意事项</h4><ul><li>参照上面对<code>display:none</code>列出的8点注意事项，可对照列出<code>visibility:hidden</code>的注意事项：</li></ul><blockquote>1、父元素为visibility:hidden，而子元素可以设置为visibility:visible并且生效</blockquote><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border: solid 2px blue;</span><br><span class="line">&#125;</span><br><span class="line">.visible&#123;</span><br><span class="line">    visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">.hidden&#123;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=<span class="string">"hidden"</span>&gt;</span><br><span class="line">    I<span class="string">'m Parent.</span></span><br><span class="line"><span class="string">    &lt;div class="visible"&gt;</span></span><br><span class="line"><span class="string">        I'</span>m Son.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>2、和display:none一样无法获得焦点</blockquote><blockquote>3、可在冒泡阶段响应事件</blockquote><ul><li>由于设置为<code>visibility:hidden</code>的元素其子元素可以为<code>visibility:visible</code>，因此隐藏的元素有可能位于事件冒泡的路径上，因此下面代码中，将鼠标移至属性为<code>.visible</code>的元素时，<code>.hidden</code>会的元素响应hover事件显示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border: solid 2px blue;</span><br><span class="line">&#125;</span><br><span class="line">.visible&#123;</span><br><span class="line">    visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">.hidden&#123;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.hidden:hover&#123;</span><br><span class="line">    visibility: visible;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=<span class="string">"hidden"</span>&gt;</span><br><span class="line">    I<span class="string">'m Parent.</span></span><br><span class="line"><span class="string">    &lt;div class="visible"&gt;</span></span><br><span class="line"><span class="string">        I'</span>m Son.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote>4、和display:none一样不妨碍form表单的提交</blockquote><blockquote>5、Transition对visibility的变化有效</blockquote><blockquote>6、visibility变化不会触发reflow</blockquote><ul><li>由于从<code>visible</code>设置为<code>hidden</code>时，<strong>不会改变元素布局相关的属性</strong>，因此<strong>不会触发reflow</strong>，只是静静地和其他渲染变化一起等待浏览器定时<strong>重绘</strong>界面。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;深入display-none&quot;&gt;&lt;a href=&quot;#深入display-none&quot; class=&quot;headerlink&quot; title=&quot;深入display:none&quot;&gt;&lt;/a&gt;深入display:none&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;我们都清楚当元素设置&lt;code&gt;display:none&lt;/code&gt;后，&lt;strong&gt;界面上将不会显示该元素，并且该元素不占布局空间&lt;/strong&gt;，但我们&lt;strong&gt;仍然可以通过JavaScript操作该元素&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="display" scheme="https://chongtianhong.github.io/tags/display/"/>
    
      <category term="visibility" scheme="https://chongtianhong.github.io/tags/visibility/"/>
    
  </entry>
  
  <entry>
    <title>关于jsonp实现跨域访问，以及存在的安全问题</title>
    <link href="https://chongtianhong.github.io/2018/06/28/josnpAndSecurity/"/>
    <id>https://chongtianhong.github.io/2018/06/28/josnpAndSecurity/</id>
    <published>2018-06-28T05:43:38.000Z</published>
    <updated>2018-10-01T14:46:17.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id="jsonp跨域访问的实现"><a href="#jsonp跨域访问的实现" class="headerlink" title="jsonp跨域访问的实现"></a>jsonp跨域访问的实现</h4><ul><li><strong>跨域的安全限制都是对浏览器端来说的</strong>，服务器端是不存在跨域安全限制的。</li><li><strong>浏览器的同源策略</strong>限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。</li><li>如果<strong>协议，端口和主机</strong>对于两个页面是<strong>相同</strong>的，<strong>则两个页面具有相同的源</strong>，否则就是不同源的。</li><li>如果要<strong>在脚本里发起跨域请求</strong>，则要进行一些特殊处理了。例如，可以采用<strong>后台代理</strong>的方式，把请求发到自己的服务端，再通过后台代码发起请求，再将数据返回前端。<a id="more"></a></li><li><a href="https://www.cnblogs.com/chiangchou/p/jsonp.html" target="_blank" rel="noopener">一篇博客</a>对<strong>使用jquery的jsonp如何发起跨域请求及其原理</strong>进行了详细地介绍。</li></ul><h4 id="jsonp可能导致的安全问题"><a href="#jsonp可能导致的安全问题" class="headerlink" title="jsonp可能导致的安全问题"></a>jsonp可能导致的安全问题</h4><ul><li>了解了jsonp之后，可以看到，<strong>jsonp主要就是用来实现跨域的数据获取</strong>。</li><li>如果跨域的接口是暴露在公网上的，如果跨域接口是public级别，则无所谓安全问题，如果跨域接口是private级别，则<strong>必须对访问者做校验验证来访的Request的合法性</strong>的。目前已知的有<strong>Referer校验</strong>和<strong>Token校验</strong>。</li></ul><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><div class="note info">HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。</div><ul><li>这里通过对header中的访问发起者的来源进行验证来保证安全性，但是这个<strong>Referer是存在被绕过的可能的</strong>，绕过的主要原理就是“不发送Referer” ，如<ul><li>使用data URI方案 </li><li>从HTTPS向HTTP发起请求</li></ul></li></ul><h5 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h5><div class="note info">主要是指能代表用户身份的标识</div><ul><li>这个部分破解的难度较高，但是通过在运行非同源跨域的网站植入恶意代码，间接依靠“白名单”站点来获取Token发起跨域访问，可以同时绕过Referer和Token的问题，但是植入恶意代码的难度较高。</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>总的来说<strong>Referer和Token校验是标准</strong>，必须要使用的，<strong>可以解决常规安全问题</strong>，<strong>最稳妥的是不使用jsonp</strong>，改用别的跨域方案（H5 提供的跨域方案postMessage、CORS、WebSocket）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;jsonp跨域访问的实现&quot;&gt;&lt;a href=&quot;#jsonp跨域访问的实现&quot; class=&quot;headerlink&quot; title=&quot;jsonp跨域访问的实现&quot;&gt;&lt;/a&gt;jsonp跨域访问的实现&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨域的安全限制都是对浏览器端来说的&lt;/strong&gt;，服务器端是不存在跨域安全限制的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器的同源策略&lt;/strong&gt;限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;协议，端口和主机&lt;/strong&gt;对于两个页面是&lt;strong&gt;相同&lt;/strong&gt;的，&lt;strong&gt;则两个页面具有相同的源&lt;/strong&gt;，否则就是不同源的。&lt;/li&gt;
&lt;li&gt;如果要&lt;strong&gt;在脚本里发起跨域请求&lt;/strong&gt;，则要进行一些特殊处理了。例如，可以采用&lt;strong&gt;后台代理&lt;/strong&gt;的方式，把请求发到自己的服务端，再通过后台代码发起请求，再将数据返回前端。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="跨域" scheme="https://chongtianhong.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="jsonp" scheme="https://chongtianhong.github.io/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>从NodeJS搭建中间层再谈前后端分离</title>
    <link href="https://chongtianhong.github.io/2018/06/27/frontEndSeparation2/"/>
    <id>https://chongtianhong.github.io/2018/06/27/frontEndSeparation2/</id>
    <published>2018-06-27T11:36:44.000Z</published>
    <updated>2018-09-29T14:14:12.634Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>后端</strong>出于性能和别的原因，<strong>提供的接口所返回的数据格式也许不太适合前端直接使用</strong>，前端所需的<strong>排序功能</strong>、<strong>筛选功能</strong>，以及到了<strong>视图层的页面展现</strong>，也许都<strong>需要对接口所提供的数据进行二次处理</strong>。</li><li>这些处理虽可以放在前端来进行，但也许<strong>数据量一大便会浪费浏览器性能</strong>。因而现今，<strong>增加node端</strong>便是一种良好的解决方案。<a id="more"></a></li><li>下面关于微信小程序demo的<strong>server端代码</strong>中，通过<strong>http模块</strong>对真实后台（网易云音乐API）发起http请求，然后通过<strong>express模块</strong>搭建后端服务。</li><li><p>发起请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// http.js</span><br><span class="line">var formatURL = require(<span class="string">'./formatURL.js'</span>);</span><br><span class="line">var http = require(<span class="string">'http'</span>);</span><br><span class="line">const POSThttp = <span class="keyword">function</span>(request)&#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        <span class="built_in">let</span> body = <span class="string">''</span>;</span><br><span class="line">        // http模块拿到真实后台api的数据</span><br><span class="line">        http.get(formatURL(request.body.musicname), <span class="keyword">function</span>(res)&#123;</span><br><span class="line">        res.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">            body += data;</span><br><span class="line">        &#125;).on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">            // 格式化</span><br><span class="line">            const &#123;</span><br><span class="line">            name,</span><br><span class="line">            audio: musicUrl,</span><br><span class="line">            page,</span><br><span class="line">            album: &#123;</span><br><span class="line">                name: musicName,</span><br><span class="line">                picUrl,</span><br><span class="line">            &#125;,</span><br><span class="line">            artists: [&#123;</span><br><span class="line">                name: singer,</span><br><span class="line">            &#125;],</span><br><span class="line">            &#125; = JSON.parse(body).result.songs[0];</span><br><span class="line">            const reply = &#123;</span><br><span class="line">            name,</span><br><span class="line">            picUrl,</span><br><span class="line">            musicUrl,</span><br><span class="line">            page,</span><br><span class="line">            singer,</span><br><span class="line">            &#125;;</span><br><span class="line">            resolve(reply);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = POSThttp;</span><br></pre></td></tr></table></figure></li><li><p>得到数据传回前端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var POSThttp = require(<span class="string">'./POSThttp.js'</span>);</span><br><span class="line">var bodyParser = require(<span class="string">'body-parser'</span>);</span><br><span class="line">// 使用body-parser解析post请求的参数，如果没有，req.body为undefined。</span><br><span class="line">var app = express();</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;</span><br><span class="line">    extended: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line">app.post(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    POSThttp(req).<span class="keyword">then</span>((data) =&gt; &#123;</span><br><span class="line">        res.send(data);</span><br><span class="line">    &#125;).catch((err) =&gt; &#123;</span><br><span class="line">        res.send(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">'open wx-audio server successful!'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上面的几十行代码也就<strong>实现了一个简单的中间层的demo</strong>，并做到了<strong>在中间层格式化参数</strong>，<strong>便于前端进行使用</strong>的过程。</p></li></ul><h4 id="为什么需要中间层？"><a href="#为什么需要中间层？" class="headerlink" title="为什么需要中间层？"></a>为什么需要中间层？</h4><ul><li>其实这个问题，我认为跟面试常考的题：“为什么需要前后端分离？”是类似的，现今大公司的老项目（包括百度、搜狐等公司所采用的后端渲染等），或多或少都会存在这样的一些问题：<ul><li><strong>前端代码越来越复杂</strong></li><li><strong>前后端</strong>依旧<strong>高度耦合</strong></li><li>无法良好的支持<strong>跨终端</strong></li></ul></li></ul><h4 id="前辈们提出的解决方案"><a href="#前辈们提出的解决方案" class="headerlink" title="前辈们提出的解决方案"></a>前辈们提出的解决方案</h4><ul><li>前端代码越来越复杂，我们希望尽可能地减少工作量，开始使用类似<strong>MV*的分层结构</strong>，使前端后分离成为必要。</li><li>前端需要处理更多的工作，希望有权操控<code>View</code>，<code>Router</code>（如：SPA的尝试）</li><li><strong>各种终端设备的兴起</strong>，需要我们<strong>把页面适配到更多的地方</strong>。</li><li>开始：我们所尝试的<strong>CLIENT-SIDE MV* 框架</strong>，<strong>后端</strong>暴露数据接口、处理业务逻辑，<strong>前端</strong>接收数据、处理渲染逻辑。</li></ul><div class="note info">关于MVC的定义：<br>MVC是一种设计模式，它将应用划分为3个部分：数据（模型）、展现层（视图）和用户交互（控制器）。换句话说，一个事件的发生是这样的过程：<br>　　1. 用户和应用产生交互。<br>　　2. 控制器的事件处理器被触发。<br>　　3. 控制器从模型中请求数据，并将其交给视图。<br>　　4. 视图将数据呈现给用户。<br>我们不用类库或框架就可以实现这种MVC架构模式。关键是要将MVC的每部分按照职责进行划分，将代码清晰地分割为若干部分，并保持良好的解耦。这样可以对每个部分进行独立开发、测试和维护。</div><ul><li>如：<code>Backbone</code>，<code>EmberJS</code>，<code>KnockoutJS</code>，<code>AngularJS</code>等框架。</li><li>但这样的方式仍旧存在问题：</li></ul><h5 id="各层职责重叠"><a href="#各层职责重叠" class="headerlink" title="各层职责重叠"></a>各层职责重叠</h5><ul><li>Client-side Model 是 Server-side Model 的加工</li><li>Client-side View 跟 Server-side是 不同层次的东西</li><li>Client-side的Controller 跟 Sever-side的Controller 各搞各的</li><li>Client-side的Route 但是 Server-side 可能没有</li></ul><h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5><ul><li><strong>渲染，取值都在客户端进行</strong>，有性能的问题</li><li>需要等待资源到齐才能进行，会有<strong>短暂白屏与闪动</strong></li><li>在移动设备<strong>低速网路</strong>的体验奇差无比</li></ul><h5 id="重用问题"><a href="#重用问题" class="headerlink" title="重用问题"></a>重用问题</h5><ul><li><strong>模板</strong>无法重用，造成维护上的麻烦与不一致</li><li><strong>逻辑</strong>无法重用，前端的校验后端仍须再做一次</li><li><strong>路由</strong>无法重用，前端的路由在后端未必存在</li></ul><h5 id="跨终端问题"><a href="#跨终端问题" class="headerlink" title="跨终端问题"></a>跨终端问题</h5><ul><li>业务太靠前，导致不同端重复实现</li><li>逻辑太靠前，造成维护上的不易</li></ul><h5 id="渲染都在客户端，模板无法重用，SEO实现麻烦"><a href="#渲染都在客户端，模板无法重用，SEO实现麻烦" class="headerlink" title="渲染都在客户端，模板无法重用，SEO实现麻烦"></a>渲染都在客户端，模板无法重用，SEO实现麻烦</h5><h4 id="NodeJS作为中间层的全栈开发方案"><a href="#NodeJS作为中间层的全栈开发方案" class="headerlink" title="NodeJS作为中间层的全栈开发方案"></a>NodeJS作为中间层的全栈开发方案</h4><ul><li>参考<code>淘宝前后端分离解决方案</code>中的一张图：<br><img src="/images/frontEndSeparation.png" alt="淘宝前后端分离解决方案配图" width="600" style="border:none"></li><li>有了NodeJS之后，<strong>前端可以更加专注于视图层</strong>，而让<strong>更多的数据逻辑放在Node层处理</strong>。</li><li>除了上图列举的作用，我们使用Node层还可以有下面的好处：<ul><li>渲染页面，体验优化</li><li>中间层带来的性能问题，在异步ajax转成同步渲染过程中得到平衡</li></ul></li><li>NodeJS对于<strong>数据的运算、逻辑处理</strong>及<strong>数据库的操作</strong>不如java方便、快捷、稳定，因此，将NodeJS作为中间层，<strong>从底层java获取数据、对数据做简单的处理</strong>后返回给客户端。</li><li>对于前端来说，NodeJS的学习成本是相当低的：我们无需学习一门新的语言，就能做到以前开发帮我们做的事情，一切都显得那么自然。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;后端&lt;/strong&gt;出于性能和别的原因，&lt;strong&gt;提供的接口所返回的数据格式也许不太适合前端直接使用&lt;/strong&gt;，前端所需的&lt;strong&gt;排序功能&lt;/strong&gt;、&lt;strong&gt;筛选功能&lt;/strong&gt;，以及到了&lt;strong&gt;视图层的页面展现&lt;/strong&gt;，也许都&lt;strong&gt;需要对接口所提供的数据进行二次处理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;这些处理虽可以放在前端来进行，但也许&lt;strong&gt;数据量一大便会浪费浏览器性能&lt;/strong&gt;。因而现今，&lt;strong&gt;增加node端&lt;/strong&gt;便是一种良好的解决方案。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="前后端分离" scheme="https://chongtianhong.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>jQuery ajax()使用serialize()提交form数据</title>
    <link href="https://chongtianhong.github.io/2018/06/27/serializeOfJQuery/"/>
    <id>https://chongtianhong.github.io/2018/06/27/serializeOfJQuery/</id>
    <published>2018-06-27T02:06:17.000Z</published>
    <updated>2018-09-28T13:55:08.805Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>jQuery的<code>serialize()</code>方法通过<strong>序列化表单值</strong>，<strong>创建URL编码文本字符串</strong>，我们就可以选择一个或多个表单元素，也可以直接选择form将其序列化，如：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">""</span>&gt;</span><br><span class="line">First name: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"FirstName"</span> value=<span class="string">"Bill"</span> /&gt;&lt;br /&gt;</span><br><span class="line">Last name: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"LastName"</span> value=<span class="string">"Gates"</span> /&gt;&lt;br /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log($(<span class="string">"form"</span>).serialize()); // FirstName=Bill&amp;LastName=Gates</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这样，我们就可以把序列化的值传给<code>ajax()</code>作为url的参数，轻松使用<code>ajax()</code>提交form表单了，而不需要一个一个获取表单中的值然后传给<code>ajax()</code>，举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'your url'</span>,</span><br><span class="line">    data: $(<span class="string">"form"</span>).serialize(),</span><br><span class="line">    success: <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用<code>$.post()</code>、<code>$.get()</code>和<code>$.getJSON()</code>也是一样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.get(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.getJSON(<span class="string">'your url'</span>, $(<span class="string">"form"</span>).serialize(), <span class="keyword">function</span>(data) &#123;</span><br><span class="line">        // your code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;jQuery的&lt;code&gt;serialize()&lt;/code&gt;方法通过&lt;strong&gt;序列化表单值&lt;/strong&gt;，&lt;strong&gt;创建URL编码文本字符串&lt;/strong&gt;，我们就可以选择一个或多个表单元素，也可以直接选择form将其序列化，如：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="jQuery" scheme="https://chongtianhong.github.io/tags/jQuery/"/>
    
      <category term="ajax" scheme="https://chongtianhong.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>DOM插入操作优化：DocumentFragment</title>
    <link href="https://chongtianhong.github.io/2018/06/26/documentFragment/"/>
    <id>https://chongtianhong.github.io/2018/06/26/documentFragment/</id>
    <published>2018-06-26T02:58:35.000Z</published>
    <updated>2018-09-28T13:55:09.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>在进行<strong>DOM操作</strong>中，我们经常使用<strong>新建元素</strong>然后<strong>将其插入到文档中</strong>的操作。</li><li><p>若是非常小（对页面的改动很小）的插入操作或许在性能上没有什么，但是<strong>若需要很多的插入操作和改动</strong>，继续使用类似于下面的代码则会很有问题。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(<span class="string">"ul"</span>);</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    var li = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于<strong>每一次对文档的插入都会引起重新渲染</strong>（计算元素的尺寸，显示背景，内容等），所以<strong>进行多次插入操作使得浏览器发生了很多次渲染，效率是比较低的</strong>。这是我们提倡<strong>通过减少页面的渲染来提高DOM操作的效率</strong>的原因。</p></li><li>一个优化的方法是<strong>将要创建的元素写到一个字符串上</strong>，然后<strong>一次性写到innerHTML上</strong>，这种利用浏览器对innerHTML的解析确实是相比上面的多次插入快了很多。但是<strong>构造字符串灵活性上面比较差，很难符合创建各种各样的DOM元素的需求</strong>。</li><li>利用<code>DocumentFragment</code>，可以弥补这两个方法的不足。</li><li><code>DocumentFragment</code>是<strong>没有父节点</strong>的<strong>最小的文档对象</strong>，用于存储HTML和XML片段。<code>DocumentFragment</code>对象继承Node，所以它<strong>有Node的所有属性方法</strong>，完全可以操作Node(NodeList)那样操作<code>DocumentFragment</code>。此外<strong>W3C对<code>DocumentFragment</code>也定义了一些另外的属性和方法</strong>，但是由于多数浏览器都没有实现，<strong>从兼容性上来说不推荐使用这些属性</strong>。具体有哪些属性方法可以参考MDN说明。</li><li>创建<code>DocumentFragment</code>的方法有两种，<code>document.createDocumentFragment()</code>和<code>new Fragment()</code>。对于<code>document.createDocumentFragment()</code>，所有浏览器都支持（包括IE6），而构造函数方法就不是所有浏览器都有效了（IE没有实现该方法）。所以<strong>从兼容性上来说推荐使用<code>document.createDocumentFragment()</code></strong>。</li><li>上面也提到，使用<code>DocumentFragment</code>与一般的Node无异，可以当作是DOM对象一样操作。在使用<code>appendChild</code>，<code>insertBefore</code>等方法时，<strong>被添加（插入）的是片段的所有子节点</strong>，而非本身。</li><li><p>因为<strong>文档片段存在于内存中</strong>，并不在DOM中，所以<strong>将子元素插入到文档片段中时不会引起页面回流</strong>（对元素位置和几何上的计算），因此使用<code>DocumentFragment</code>可以起到<strong>性能优化</strong>的作用。例如上面的代码就可以改成下面的片段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    var li = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>由于<code>DocumentFragment</code>的优势，很多JavaScript库都是用它来创建HTML的，包括jQuery。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>DocumentFragment</code>节点不属于文档树，继承的<code>parentNode</code>属性总是 <code>null</code>。</li><li><code>DocumentFragment</code>节点有一种特殊的行为，该行为使得它非常有用，即<strong>当请求把一个<code>DocumentFragment</code>节点插入文档树时，插入的不是<code>DocumentFragment</code>自身，而是它的所有子孙节点</strong>。这使得<code>DocumentFragment</code>成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。</li><li>重点就在于<strong><code>DocumentFragment</code>节点不属于文档树</strong>。因此<strong>当把创建的节点添加到该对象时，并不会导致页面的回流</strong>，因此性能就自然上去了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在进行&lt;strong&gt;DOM操作&lt;/strong&gt;中，我们经常使用&lt;strong&gt;新建元素&lt;/strong&gt;然后&lt;strong&gt;将其插入到文档中&lt;/strong&gt;的操作。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若是非常小（对页面的改动很小）的插入操作或许在性能上没有什么，但是&lt;strong&gt;若需要很多的插入操作和改动&lt;/strong&gt;，继续使用类似于下面的代码则会很有问题。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="DOM" scheme="https://chongtianhong.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>页面添加锚点的三种方式</title>
    <link href="https://chongtianhong.github.io/2018/06/25/methodOfAddingAnchorPoints/"/>
    <id>https://chongtianhong.github.io/2018/06/25/methodOfAddingAnchorPoints/</id>
    <published>2018-06-25T02:15:36.000Z</published>
    <updated>2018-09-27T15:01:56.883Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>HTML中的链接</strong>，正确的说法应该称作”<strong>锚点</strong>“。</li><li>锚点链接（也叫书签链接）常常用于那些内容庞大繁琐的网页，通过<strong>点击命名锚点</strong>，不仅让我们能<strong>指向文档</strong>，还能<strong>指向页面里的特定段落</strong>，更能当作<strong>“精准链接”的便利工</strong>具，让链接对象接近焦点。便于浏览者查看网页内容。类似于我们阅读书籍时的目录页码或章回提示。</li><li>在需要<strong>指定到页面的特定部分</strong>时，<strong>标记锚点</strong>是最佳的方法。　<a id="more"></a></li></ul><h4 id="锚点链接对SEO的作用"><a href="#锚点链接对SEO的作用" class="headerlink" title="锚点链接对SEO的作用"></a>锚点链接对SEO的作用</h4><ul><li>锚链接是一个非常重要的概念，在网页中增加恰当的锚链接，会让所在网页和所指向网页的重要程度有所提升，从而影响到关键词排名。<strong>锚链接对SEO的作用</strong>主要体现在以下几个方面：</li></ul><p><blockquote>对锚链接所在的页面的作用</blockquote>　　</p><ul><li>正常来讲，<strong>页面中增加的锚链接都和页面本身有一定的关系</strong>，因此，<strong>锚文本可以作为锚链接所在的页面的内容的评估</strong>。例如：本篇文章中含有“SEO”的链接，那么，说明本篇文章和SEO有一定关系。</li></ul><p><blockquote>对锚链接所指向页面的作用</blockquote>　　</p><ul><li>锚链接能精确的描述所指向页面的内容，因此，<strong>锚链接能可以对所指向页面的评估</strong>。</li></ul><p><blockquote>锚链接对关键词排名的影响</blockquote>　　</p><ul><li><strong>锚链接对于关键字排名的意义</strong>在于它可以<strong>让内容页随机链接在一起</strong>，<strong>让蜘蛛可以很好的抓取更多页面</strong>，<strong>权重</strong>也能<strong>均匀的传递</strong>，同时<strong>增强页面的相关性</strong>，<strong>最终提升网站的关键词排名</strong>。</li></ul><h4 id="锚点的添加方式"><a href="#锚点的添加方式" class="headerlink" title="锚点的添加方式"></a>锚点的添加方式</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><ul><li><p>给锚点文本标签添加id，使用&lt;a href=”#”&gt;&lt;/a&gt;来定位，当单击a链接时，就会跳到id为a01的p标签处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#a01"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p id=<span class="string">"a01"</span>&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>这样的定位<strong>可以针对任何标签来定位</strong>。</p></li></ul><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><ul><li><p>给a标签的文本添加锚点，单击链接可跳到name为a01的a标签处：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#a01"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br><span class="line">&lt;a name=<span class="string">"a01"</span> href=“<span class="comment">#”&gt;练习&lt;/a&gt;</span></span><br><span class="line">&lt;p&gt;练习&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用name属性<strong>只能针对a标签来定位</strong>，而对div等其他标签就不能起到定位作用。</p></li></ul><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><ul><li>使用JS中<strong>与页面（容器）滚动相关的API</strong> <code>scrollIntoView</code>，可让当前的元素滚动到浏览器窗口的可视区域内。</li><li>调用方法为<code>element.scrollIntoView()</code>，参数默认为true。<ul><li>参数为true时调用该函数，页面（或容器）发生滚动，使element的顶部与视图（容器）顶部对齐；</li><li>参数为false时，使element的底部与视图（容器）底部对齐。</li></ul></li><li><strong>注意</strong>：只有当页面（容器）可滚动时此API才能起作用。</li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li onclick=<span class="string">"javascript:document.getElementById('here').scrollIntoView()"</span>&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTML中的链接&lt;/strong&gt;，正确的说法应该称作”&lt;strong&gt;锚点&lt;/strong&gt;“。&lt;/li&gt;
&lt;li&gt;锚点链接（也叫书签链接）常常用于那些内容庞大繁琐的网页，通过&lt;strong&gt;点击命名锚点&lt;/strong&gt;，不仅让我们能&lt;strong&gt;指向文档&lt;/strong&gt;，还能&lt;strong&gt;指向页面里的特定段落&lt;/strong&gt;，更能当作&lt;strong&gt;“精准链接”的便利工&lt;/strong&gt;具，让链接对象接近焦点。便于浏览者查看网页内容。类似于我们阅读书籍时的目录页码或章回提示。&lt;/li&gt;
&lt;li&gt;在需要&lt;strong&gt;指定到页面的特定部分&lt;/strong&gt;时，&lt;strong&gt;标记锚点&lt;/strong&gt;是最佳的方法。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
      <category term="锚点" scheme="https://chongtianhong.github.io/tags/%E9%94%9A%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用CDN可以加快网络速度</title>
    <link href="https://chongtianhong.github.io/2018/06/24/CDN/"/>
    <id>https://chongtianhong.github.io/2018/06/24/CDN/</id>
    <published>2018-06-24T10:26:12.000Z</published>
    <updated>2018-09-20T16:08:17.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>大多数人都知道，一个用户在打开一个新网站的时候，如果网站打开的速度过慢，用户是很难继续浏览的。</li><li>因此，很多网站的运营人员想方设法的<strong>提高网站的加载速度</strong>。网站的加载速度是一个成功网站的必备要素之一，速度不够快，会<strong>降低转化率</strong>。<a id="more"></a></li><li>本文将简单地介绍下CDN，<strong>CDN是帮助一个网站能够快速打开的有效和实用方法</strong>。</li></ul><h4 id="网站打开速度慢的原因"><a href="#网站打开速度慢的原因" class="headerlink" title="网站打开速度慢的原因"></a>网站打开速度慢的原因</h4><ul><li><strong>网站打开速度慢</strong>受很多因素的影响，简单归纳下常见的几个原因：<ul><li><strong>共享主机服务器</strong>不堪重负，<strong>响应速度慢</strong>；</li><li><strong>网站的图片和内容太大</strong>，需要花费很多时间下载；</li><li>网站使用了太多不同的脚本和图片，这些<strong>脚本和图片没有针对快速加载网站进行优化，加载时间长</strong>；</li><li>网站的服务器位置与网站的访问者<strong>位于不同的地理位置</strong>。</li></ul></li><li>其实还有许多其他的原因，但这些以上列举的几点是最主要的。</li></ul><h4 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h4><ul><li>CDN指的是<strong>内容分发网络</strong>。其基本思路是<strong>尽可能的避开互联网上</strong>有可能影响<strong>数据传输速度</strong>和<strong>稳定性</strong>的瓶颈和环节，使内容传输的更快、更稳定。</li><li>CDN是通过<strong>在网络各处放置节点服务器</strong>所构成的在现有的互联网基础之上的一层<strong>智能虚拟网络</strong>，它能够实<strong>时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间</strong>等综合信息<strong>将用户的请求重新导向离用户最近的服务节点上</strong>。</li><li>CDN系统的目的是使用户可就<strong>近取得所需内容</strong>，<strong>解决Internet网络拥挤</strong>的状况，<strong>提高用户访问网站的响应速度</strong>。</li><li>CDN起到<strong>内容分发</strong>的作用，就是<strong>网站的内容是被复制到各个地区的不同服务器上面</strong>，这个距离离访问者所在地越近越好。</li><li>下图就展示了未使用CDN和使用CDN的区别图，显而易见，<strong>使用CDN可以提高访问速度</strong>：<br><img src="/images/CDN.png" alt="未使用CDN和使用CDN的区别图" width="600" style="border:none"></li></ul><h4 id="网站使用CDN加速的好处"><a href="#网站使用CDN加速的好处" class="headerlink" title="网站使用CDN加速的好处"></a>网站使用CDN加速的好处</h4><ul><li><strong>网站加速，利于Google的排名</strong>：Google 把网站的打开速度当做一个比较重要的指标，所以网站打开的速度会影响Google排名。使用CDN之后，网站打开速度变快，就可以减少跳出率，也可以增加用户对网站的友好体验。</li><li><strong>有利于提高网站的转化率</strong>：毫无疑问，用户的访问网站的时间提高了，跳出率减少了，当然会利于网站的转化率和销售量。现在大环境下的人们都比较浮躁，我想谁都没有耐心去等一个需要10秒才能打开的网站，这样的网站一开始就不友好，更别想提高网站的转化率了。</li><li><strong>提升网站的稳定性和安全性</strong>：CDN因为节点分散，攻击者比较难下手，攻击一个节点仅仅是影响一个节点的缓存访问而已，并且CDN的“内容路由”会自动的启用另一个节点，如果CDN服务节点数量够多，那么攻击者需要的流量包就会呈几何级的增加，这样攻击成本自然就高了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;大多数人都知道，一个用户在打开一个新网站的时候，如果网站打开的速度过慢，用户是很难继续浏览的。&lt;/li&gt;
&lt;li&gt;因此，很多网站的运营人员想方设法的&lt;strong&gt;提高网站的加载速度&lt;/strong&gt;。网站的加载速度是一个成功网站的必备要素之一，速度不够快，会&lt;strong&gt;降低转化率&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CDN加速" scheme="https://chongtianhong.github.io/tags/CDN%E5%8A%A0%E9%80%9F/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>大流量的下兜底容灾方案（转）</title>
    <link href="https://chongtianhong.github.io/2018/06/23/frontEndDisasterRecoveryPlan/"/>
    <id>https://chongtianhong.github.io/2018/06/23/frontEndDisasterRecoveryPlan/</id>
    <published>2018-06-23T08:55:16.000Z</published>
    <updated>2018-09-20T14:40:25.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>随着网络的普及，上网的成本和门槛越来越低，很多网站的流量也是蹭蹭蹭的往上涨，而<strong>页面上的数据来源也不确定</strong>，可能<strong>来自多个平台</strong>，也可能是有<strong>专门的人员在手动维护</strong>。由于<strong>数据来源众多，出错的概率</strong>也会<strong>增加</strong>，为了<strong>降低页面在大流量下的维护成本</strong>，本文做了一些阐述。<a id="more"></a></li></ul><h4 id="兜底容灾的必要性"><a href="#兜底容灾的必要性" class="headerlink" title="兜底容灾的必要性"></a>兜底容灾的必要性</h4><ul><li>一个日均承载几千万上亿流量的网页，会经常出现以下问题：<br>① 某个<strong>接口挂了</strong>，前端拿不到数据或者拿到的数据不够，<strong>页面展示就会出问题</strong>，出现空白或者某个模块直接出错。<br>② <strong>用户因为网络问题</strong>或者<strong>安装了某些插件</strong>，导致页面广告、接口请求挂掉，从而页面出现问题。</li><li><strong>前者的概率不是很大</strong>，因为<strong>网页上的请求 QPS 都是预先评估过的</strong>，只要前端请求没有成倍激增，并且后端压力都在系统监控范围内，不会出太大的岔子。但是一旦出问题，页面上就有可能空白一大块，<strong>如果后端排查和处理问题不及时</strong>，很可能从<strong>小问题演变成故障</strong>。</li><li>而<strong>第二个问题比较严峻</strong>，据统计，不管网站做的多简洁，总是会有千分之一的<strong>用户因为网络或者浏览器插件问题导致页面访问失败</strong>或者<strong>部分接口请求失败</strong>，比如一个 pv 一亿的网站，按照千分之一计算，一个接口每天会有 10w 左右的 pv 请求失败，而请求接口一多，页面上整体的请求失败量就很高了，这个数据会达到几百万。</li></ul><h4 id="如何兜底，如何容灾"><a href="#如何兜底，如何容灾" class="headerlink" title="如何兜底，如何容灾"></a>如何兜底，如何容灾</h4><ul><li><strong>兜底容灾的方案</strong>有很多，<strong>目的</strong>就是让<strong>请求失败而页面展示依然正常</strong>。下面说一说常用的几个方案：</li></ul><h5 id="再请求一次"><a href="#再请求一次" class="headerlink" title="再请求一次"></a>再请求一次</h5><ul><li><p>照顾到用户体验，同时也<strong>考虑到一个请求的正常发送、接受时间</strong>，我们<strong>把超时时间设置为 5s</strong>，<strong>超过 5s 或者请求的结果状态为 failed ，则重新请求一次</strong>。所以我们可以重新封装下 Ajax 模块，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 设置请求次数</span><br><span class="line">var tryTimes = 2;</span><br><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    timeout: 5000,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    // try</span><br><span class="line">    tryTimes: tryTimes</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这种处理方案<strong>对于提交订单、选中商品到购物车的页面比较合适</strong>，因为操作流是确定的，提交一次不成功，很自然的想到再提交一次，只是<strong>用户等待的不同阶段应该用不同的文案来提醒</strong>。</p></li><li>而<strong>对于展示类的数据请求，不太适合多次失败尝试</strong>。所以首页未采用这种方案。</li></ul><h5 id="缓存每一次请求到本地"><a href="#缓存每一次请求到本地" class="headerlink" title="缓存每一次请求到本地"></a>缓存每一次请求到本地</h5><ul><li><p>现在的<strong>浏览器都支持本地储存</strong>（无论使用 userData 还是 localStorage），<strong>当每次请求到达用户浏览器的时候，把请求的数据缓存一份到本地储存</strong>，那么下次请求失败就可以使用上次缓存的数据了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    success: <span class="keyword">function</span>(data)&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">        cache(DATAKEY, data);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 请求失败，获取本地缓存数据</span><br><span class="line">        var data = cache(DATAKEY);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>这种方式是比较常用的，<strong>每次请求成功都会缓存最新的数据</strong>。不过这里存在两个问题：<br>① 如果<strong>用户第一次访问就失败了</strong>，假设新用户是比较多的。<br>② <strong>缓存的数据是否具有时效性</strong>，如果缓存的数据过期了：比如是一个推荐接口，推荐的商品用户已经购买过了，但是访问的时候接口挂掉，依然显示用户购买过的商品，这个逻辑是不太能接受的。</p></li><li>对<strong>于第一次访问</strong>的情况，这个概率是相当低的，但是要提出另外的解决方案来避免新用户访问页面显示空白的情况发生。</li><li>而对于第二个问题，<strong>有缓存总比没有数据的好</strong>，就算数据过期，但是依然是正确的链接，所以<strong>基本可以接受</strong>。</li></ul><h5 id="备用接口（硬兜底）"><a href="#备用接口（硬兜底）" class="headerlink" title="备用接口（硬兜底）"></a>备用接口（硬兜底）</h5><ul><li>当<strong>后端接口返回失败，用户本地也没有数据缓存</strong>的时候，则可以<strong>采用备用接口</strong>的方式（通过<strong>访问CDN对应地址</strong>拉取数据渲染）。</li><li><p>当<strong>后端为网页接口准备一个备用接口</strong>后，前端请求时可以做个包装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    // 备份接口</span><br><span class="line">    backUrl: backUrl</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>一旦请求失败，<strong>进入备用数据接口请求备份数据</strong>。</p></li><li>同样的，这里也存在一个问题：如果接口是个性化的，则每个用户访问这个接口拿到的数据都不一样，那么这个备份接口该如何推数据？如果备用接口的数据跟正常接口一样，那还不如直接去请求两次。所以这里提到的备用接口，主要是<strong>数据的硬兜底</strong>，硬兜底的来源有两个：<br>① <strong>运营</strong>维护一份数据，推送到 CDN，每一份数据都有一个固定的地址；<br>② <strong>后端</strong>向 CDN push 一份通用数据。我们知道<strong>个性化都是使用 cookie 去识别用户的</strong>，对于没有浏览器记录的新用户就没有 cookie，此时会推一份通用的数据，这个<strong>通用的数据可以作为接口的备份源</strong>。</li></ul><h4 id="兜底容错实践"><a href="#兜底容错实践" class="headerlink" title="兜底容错实践"></a>兜底容错实践</h4><ul><li>我们很容易得到如下的操作流程：<br><img src="/images/frontEndDisasterRecoveryPlan1.png" alt="兜底容错实践操作流程1" width="600" style="border:none"></li><li>而这里存在的问题是：<br>① 获取缓存数据后，不好对数据格式进行判断，一般来说，<strong>只有有效的数据才能存到本地储存中</strong>，而判断是否有效往往存在误差；<br>② <strong>兜底数据没有及时更新</strong>；<br>③ <strong>程序只会报警</strong>，但是<strong>不会自动修复</strong>。</li><li>存在的隐患是：<br>① <strong>前端每次改版</strong>，如更换接口、更换人员，<strong>兜底数据没有及时更新</strong>；<br>② 如果<strong>兜底数据也存在错误</strong>，则页面一定出现空白天窗。</li><li>所以对整个流程做了一些改进：<br><img src="/images/frontEndDisasterRecoveryPlan2.png" alt="兜底容错实践操作流程2" width="600" style="border:none"></li><li>数据经过统一平台输出，在输出之前，我们将数据推一份到 CDN 作为备份，产生另一个接口，一旦原始接口请求失败，则直接请求备份的接口，这个在<strong>规则对应</strong>和<strong>即时更新</strong>上可以做到很好！那么基本的流程就是这样：<br><img src="/images/frontEndDisasterRecoveryPlan3.png" alt="兜底容错实践操作流程2的基本流程" width="200" style="border:none"></li><li>不过为了确保无误，我的建议是，<strong>页面上每个接口必须对应一个运营手填的数据</strong>，这个<strong>作为最后的硬兜底</strong>，而<strong>这个硬兜底也会被缓存到本地</strong>，整个流程就形成一个闭环。那么，剩下的工作就只有监控和警报了。</li><li><p>下面是一串伪代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var url = interfaceURL;</span><br><span class="line">var backUrl = interfaceBackURL;</span><br><span class="line">var hardBackUrl = hardDataURL;</span><br><span class="line">var cacheTime = 10day;</span><br><span class="line"></span><br><span class="line">Ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    backurl: backUrl,</span><br><span class="line">    success: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">        cache(DATAKEY, data, cacheTime);</span><br><span class="line">        show(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 请求失败，获取本地缓存数据</span><br><span class="line">        var data = cache(DATAKEY);</span><br><span class="line">        <span class="keyword">if</span>(data) &#123;</span><br><span class="line">            Reporter.send(/*WARN*/);</span><br><span class="line">            show(data); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Reporter.send(/*ERROR*/);</span><br><span class="line">            _failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 请求硬兜底</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_failed</span></span>() &#123;</span><br><span class="line">    Ajax(&#123;</span><br><span class="line">        url: hadrBackUrl,</span><br><span class="line">        success: <span class="keyword">function</span>(data)&#123;</span><br><span class="line">        // 缓存数据到本地</span><br><span class="line">            cache(DATAKEY, data, cacheTime);</span><br><span class="line">            show(data);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            Reporter.send(/*SUPER_ERROR*/);</span><br><span class="line">            show(data); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意到，我们在上面使用了缓存失效时间，考虑到数据的及时性，设置为 10 天。backUrl 是 url 的备份地址，hardBackUrl 是运营填写的备份数据，整个流程都在闭环之中，所以出问题的概率就大大降低了，即便是后端接口出错，我们也可以看着监控信息，放心的给后端开发打个电话，告知下等待修复，而不是急急忙忙，担惊受怕。</p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>本文提供的都是伪代码，而这些伪代码的实现并不复杂，也没必要写成组件，主要是提供思路，如何<strong>处理大流量高并发下的异步数据接口的兜底容灾</strong>。</li></ul><div class="note info">原文出处：<a href="https://www.barretlee.com/blog/2015/09/16/backup-solution-at-big-traffic/" target="_blank" rel="noopener">大流量的下兜底容灾方案</a></div>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;随着网络的普及，上网的成本和门槛越来越低，很多网站的流量也是蹭蹭蹭的往上涨，而&lt;strong&gt;页面上的数据来源也不确定&lt;/strong&gt;，可能&lt;strong&gt;来自多个平台&lt;/strong&gt;，也可能是有&lt;strong&gt;专门的人员在手动维护&lt;/strong&gt;。由于&lt;strong&gt;数据来源众多，出错的概率&lt;/strong&gt;也会&lt;strong&gt;增加&lt;/strong&gt;，为了&lt;strong&gt;降低页面在大流量下的维护成本&lt;/strong&gt;，本文做了一些阐述。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="兜底" scheme="https://chongtianhong.github.io/tags/%E5%85%9C%E5%BA%95/"/>
    
      <category term="容灾" scheme="https://chongtianhong.github.io/tags/%E5%AE%B9%E7%81%BE/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之WXS模块</title>
    <link href="https://chongtianhong.github.io/2018/06/22/wxsOfMiniProgram/"/>
    <id>https://chongtianhong.github.io/2018/06/22/wxsOfMiniProgram/</id>
    <published>2018-06-22T02:37:08.000Z</published>
    <updated>2018-09-19T14:17:03.756Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>WXS（WeiXin Script）是<strong>小程序</strong>的一套<strong>脚本语言</strong>，<strong>与 wxml 结合</strong>，可以构建出页面的结构。</li><li>WXS 代码可以编写在wxml文件中的 &lt;wxs&gt; 标签内，或以 <code>.wxs</code> 为后缀名的文件内。<a id="more"></a></li></ul><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><ul><li>每一个 <code>.wxs</code> 文件和 &lt;wxs&gt; 标签都是一个<strong>单独的模块</strong>。</li><li><strong>每个模块</strong>都有自己<strong>独立的作用域</strong>。即在一个模块里面定义的变量与函数，<strong>默认为私有的</strong>，<strong>对其他模块不可见</strong>。</li><li>一个模块要想<strong>对外暴露其内部的私有变量与函数</strong>，只能<strong>通过 <code>module.exports</code> 实现</strong>。</li></ul><h5 id="wxs-文件"><a href="#wxs-文件" class="headerlink" title=".wxs 文件"></a>.wxs 文件</h5><ul><li><p>在微信开发者工具里面，右键可以直接创建 <code>.wxs</code> 文件，在其中直接编写 WXS 脚本。示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/comm.wxs</span><br><span class="line">*/ </span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from comm.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span>(d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    foo: foo,</span><br><span class="line">    bar: bar</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上述例子在 <code>/pages/comm.wxs</code> 的文件里面编写了 WXS 代码。该 <code>.wxs</code> 文件<strong>可以被其他的 <code>.wxs</code> 文件 或 WXML 中的 <wxs> 标签引用</wxs></strong>。</p></li></ul><h5 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h5><ul><li>每个 wxs 模块均有一个<strong>内置的 module 对象</strong>。</li><li>module 对象有一个<code>exports</code>属性。 通过该属性，可以<strong>对外共享</strong>本模块的<strong>私有变量与函数</strong>。</li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/tools.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from tools.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span> (d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    FOO: foo,</span><br><span class="line">    bar: bar,</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.msg = <span class="string">"some msg"</span>;</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- page/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../tools.wxs"</span> module=<span class="string">"tools"</span> /&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.msg&#125;&#125; &lt;/view&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;tools.bar(tools.FOO)&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some msg</span><br><span class="line"><span class="string">'hello world'</span> from tools.wxs</span><br></pre></td></tr></table></figure></li></ul><h5 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h5><ul><li>在<code>.wxs</code>模块中<strong>引用其他 wxs 文件模块</strong>，可以<strong>使用 <code>require</code>函数</strong>。</li><li>引用的时候，要注意如下几点：<ul><li>只能引用<code>.wxs</code>文件模块，且<strong>必须使用相对路径</strong>。</li><li>wxs 模块均为<strong>单例</strong>，wxs 模块在第一次被引用时，会自动初始化为单例对象。<strong>多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象</strong>。</li><li>如果一个 <strong>wxs 模块在定义之后，一直没有被引用</strong>，则该模块<strong>不会被解析与运行</strong>。</li></ul></li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/tools.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var foo = <span class="string">"'hello world' from tools.wxs"</span>;</span><br><span class="line">var bar = <span class="keyword">function</span> (d) &#123;</span><br><span class="line">    <span class="built_in">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    FOO: foo,</span><br><span class="line">    bar: bar,</span><br><span class="line">&#125;;</span><br><span class="line">module.exports.msg = <span class="string">"some msg"</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>logic.wxs</code>模块中引用<code>tools.wxs</code>文件模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/logic.wxs</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">var tools = require(<span class="string">"./tools.wxs"</span>);</span><br><span class="line"></span><br><span class="line">console.log(tools.FOO);</span><br><span class="line">console.log(tools.bar(<span class="string">"logic.wxs"</span>));</span><br><span class="line">console.log(tools.msg);</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- /page/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../logic.wxs"</span> module=<span class="string">"logic"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>控制台输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span> from tools.wxs</span><br><span class="line">logic.wxs</span><br><span class="line">some msg</span><br></pre></td></tr></table></figure></li></ul><h5 id="wxs标签"><a href="#wxs标签" class="headerlink" title="wxs标签"></a>wxs标签</h5><ul><li>&lt;wxs&gt;标签有两个属性，如下表所示：</li></ul><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">module</td><td style="text-align:center">String</td><td style="text-align:center">当前 &lt;wxs&gt; 标签的模块名。必填字段</td></tr><tr><td style="text-align:center">src</td><td style="text-align:center">String</td><td style="text-align:center">引用 .wxs 文件的相对路径。仅当本标签为<strong>单闭合标签</strong>或<strong>标签的内容为空</strong>时有效</td></tr></tbody></table><blockquote>module 属性</blockquote><ul><li>module 属性是<strong>当前 &lt;wxs&gt; 标签的模块名</strong>。在单个 wxml 文件内，<strong>建议其值唯一</strong>。有重复模块名则<strong>按照先后顺序覆盖</strong>（后者覆盖前者）。<strong>不同文件之间的 wxs 模块名不会相互覆盖</strong>。</li><li>module 属性值的命名必须符合下面两个规则：<ul><li>首字符必须是：字母（a-zA-Z），下划线（_）</li><li>剩余字符可以是：字母（a-zA-Z），下划线（_）， 数字（0-9）</li></ul></li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--wxml--&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs module=<span class="string">"foo"</span>&gt;</span><br><span class="line">    var some_msg = <span class="string">"hello world"</span>;</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        msg : some_msg,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;foo.msg&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure></li><li><p>上面例子声明了一个名字为<code>foo</code>的模块，将<code>some_msg</code>变量暴露出来，供当前页面使用。</p></li></ul><blockquote>src 属性</blockquote><ul><li>src 属性可以用来<strong>引用其他的 wxs 文件模块</strong>。</li><li><p>示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">/pages/index/index.js</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">"'hello wrold' from js"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>wxml的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- /pages/index/index.wxml --&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs src=<span class="string">"./../comm.wxs"</span> module=<span class="string">"some_comms"</span>&gt;&lt;/wxs&gt;</span><br><span class="line">&lt;!-- 也可以直接使用单标签闭合的写法</span><br><span class="line">    &lt;wxs src=<span class="string">"./../comm.wxs"</span> module=<span class="string">"some_comms"</span> /&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 some_comms 模块里面的 foo --&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;some_comms.bar(some_comms.foo)&#125;&#125; &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 some_comms 模块里面的 bar 函数，且参数为 page/index/index.js 里面的 msg --&gt;</span><br><span class="line">&lt;view&gt; &#123;&#123;some_comms.bar(msg)&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li><li><p>页面输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span> from comm.wxs</span><br><span class="line"><span class="string">'hello wrold'</span> from js</span><br></pre></td></tr></table></figure></li><li><p>上述例子在文件<code>/page/index/index.wxml</code>中通过 &lt;wxs&gt; 标签引用了<code>/page/comm.wxs</code>模块。</p></li><li>注意：<ul><li>&lt;wxs&gt; 模块只能在<strong>定义模块的 WXML 文件</strong>中被访问到。使用 &lt;include&gt; 或 &lt;import&gt; 时，&lt;wxs&gt; 模块不会被引入到对应的 WXML 文件中。</li><li>&lt;template&gt; 标签中，只能使用定义该 &lt;template&gt; 的 WXML 文件中定义的 &lt;wxs&gt; 模块。</li></ul></li></ul><h4 id="微信小程序，用js还是wxs？"><a href="#微信小程序，用js还是wxs？" class="headerlink" title="微信小程序，用js还是wxs？"></a>微信小程序，用js还是wxs？</h4><ul><li>在开发微信小程序的时候，应该<strong>根据情况</strong>，选择使用js或wxs。</li><li>wxs是专门用于wxml页面的，如果我们有<strong>在页面中使用js脚本</strong>的需求可以使用wxs来实现。</li><li>wxs和js<strong>不能互相直接调用</strong>。</li><li>wxs其实就是封装后的js，用法跟js一模一样。有些功能，用wxs和js都能实现，但是有时会发现用wxs<strong>更方便、直接</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;WXS（WeiXin Script）是&lt;strong&gt;小程序&lt;/strong&gt;的一套&lt;strong&gt;脚本语言&lt;/strong&gt;，&lt;strong&gt;与 wxml 结合&lt;/strong&gt;，可以构建出页面的结构。&lt;/li&gt;
&lt;li&gt;WXS 代码可以编写在wxml文件中的 &amp;lt;wxs&amp;gt; 标签内，或以 &lt;code&gt;.wxs&lt;/code&gt; 为后缀名的文件内。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="https://chongtianhong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="WXS" scheme="https://chongtianhong.github.io/tags/WXS/"/>
    
  </entry>
  
  <entry>
    <title>使用moment.js轻松管理日期和时间</title>
    <link href="https://chongtianhong.github.io/2018/06/21/momentJS/"/>
    <id>https://chongtianhong.github.io/2018/06/21/momentJS/</id>
    <published>2018-06-21T02:33:16.000Z</published>
    <updated>2018-09-19T14:09:06.287Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><strong>moment.js</strong>是一个非常好用的时间处理插件，对js中的date对象进行了一层封装，使之具有更加强大日期处理能力。</li><li><strong>moment.js</strong>里面包含了非常多而且有用的<strong>对时间进行操作</strong>的方法，例如：时间加减法、比较大小/差值计算、isBefore/isAfter，还支持非常多的时间格式及语言。<a id="more"></a></li></ul><h4 id="moment-js"><a href="#moment-js" class="headerlink" title="moment.js"></a>moment.js</h4><ul><li>Momentjs<strong>支持多个环境</strong>，既可以<strong>在浏览器中使用</strong>，也可以<strong>脱离浏览器的环境在nodejs中使用</strong>。</li></ul><h5 id="node"><a href="#node" class="headerlink" title="node"></a>node</h5><ul><li>在Node.js中使用momentjs的话需要<strong>安装moment模块</strong>，然后<strong>加载模块</strong>就行了。命令如下: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install moment </span><br><span class="line">var moment = require(<span class="string">'moment'</span>);</span><br><span class="line">moment().format();</span><br></pre></td></tr></table></figure></li></ul><h5 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h5><ul><li>在浏览器中使用，则用下面方法引入momentjs文件即可，使用的时候在Node.js和浏览器中并没有什么区别。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"moment.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    moment().format();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>下面将对一些常用方法进行介绍，更多内容可到<a href="http://momentjs.cn/" target="_blank" rel="noopener">Moment.js 中文网</a>获取。</li></ul><blockquote>日期格式化</blockquote><ul><li><p>当前时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>); // 2018-06-14 23:36:09</span><br></pre></td></tr></table></figure></li><li><p>今天是星期几：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'d'</span>); // 4</span><br></pre></td></tr></table></figure></li><li><p>转换当前时间的Unix时间戳：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'X'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote>字符串转日期</blockquote><ul><li>代码示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'2018-06-14'</span>).toDate();</span><br><span class="line">moment(<span class="string">'2018-06-14 10:20:15'</span>).toDate();</span><br></pre></td></tr></table></figure></li></ul><blockquote>时间戳转日期</blockquote><ul><li>代码示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(1448896064621).toDate();</span><br></pre></td></tr></table></figure></li></ul><blockquote>相对时间</blockquote><ul><li><p>时间加减：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'years'</span>);       // 加7年</span><br><span class="line">moment().add(7, <span class="string">'month'</span>);       // 加7个月</span><br><span class="line">moment().add(7, <span class="string">'days'</span>);        // 加7天</span><br><span class="line">moment().add(7, <span class="string">'hours'</span>);       // 加7小时</span><br><span class="line">moment().add(7, <span class="string">'minutes'</span>);     // 加7分钟</span><br><span class="line">moment().add(7, <span class="string">'seconds'</span>);     // 加7秒钟</span><br><span class="line"> </span><br><span class="line">moment().subtract(7, <span class="string">'years'</span>);  // 减7年</span><br><span class="line">moment().subtract(7, <span class="string">'month'</span>);  // 减7个月</span><br><span class="line">moment().subtract(7, <span class="string">'days'</span>);   // 减7天</span><br><span class="line">moment().subtract(7, <span class="string">'hours'</span>);  // 减7小时</span><br><span class="line">moment().subtract(7, <span class="string">'minutes'</span>);// 减7分钟</span><br><span class="line">moment().subtract(7, <span class="string">'seconds'</span>);// 减7秒钟</span><br><span class="line"></span><br><span class="line">moment().subtract(7, <span class="string">'days'</span>).format(<span class="string">'YYYY年MM月DD日'</span>); // 7天前的日期</span><br><span class="line">moment().add(7, <span class="string">'days'</span>).format(<span class="string">'YYYY年MM月DD日'</span>); // 7天后的日期</span><br><span class="line">moment().subtract(7, <span class="string">'hours'</span>).format(<span class="string">'HH:mm:ss'</span>); // 7小时前的时间</span><br><span class="line">moment().add(7, <span class="string">'hours'</span>).format(<span class="string">'HH:mm:ss'</span>); // 7小时后的时间</span><br></pre></td></tr></table></figure></li><li><p>moment.js的函数<strong>支持链式写法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'days'</span>).add(1, <span class="string">'months'</span>);</span><br></pre></td></tr></table></figure></li><li><p>20160601相对当前日期是2年前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">"20160601"</span>, <span class="string">"YYYYMMDD"</span>).fromNow(); // 2 years ago</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h4><ul><li>moment.js提供了丰富的说明文档，使用它还可以<strong>创建日历项目</strong>等复杂的日期时间应用。</li><li>在日常开发中最常用的是<strong>格式化时间</strong>，下面将常用的格式制作成表格说明：</li></ul><table><thead><tr><th style="text-align:center">格式代码</th><th style="text-align:center">说明</th><th style="text-align:center">返回值例子</th></tr></thead><tbody><tr><td style="text-align:center">M</td><td style="text-align:center">数字表示的月份，没有前导零</td><td style="text-align:center">1到12</td></tr><tr><td style="text-align:center">MM</td><td style="text-align:center">数字表示的月份，有前导零</td><td style="text-align:center">01到12</td></tr><tr><td style="text-align:center">MMM</td><td style="text-align:center">三个字母缩写表示的月份</td><td style="text-align:center">Jan到Dec</td></tr><tr><td style="text-align:center">MMMM</td><td style="text-align:center">月份，完整的文本格式</td><td style="text-align:center">January到December</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">季度</td><td style="text-align:center">1到4</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">月份中的第几天，没有前导零</td><td style="text-align:center">1到31</td></tr><tr><td style="text-align:center">DD</td><td style="text-align:center">月份中的第几天，有前导零</td><td style="text-align:center">01到31</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">星期中的第几天，数字表示</td><td style="text-align:center">0到6，0表示周日，6表示周六</td></tr><tr><td style="text-align:center">ddd</td><td style="text-align:center">三个字母缩写表示星期中的第几天</td><td style="text-align:center">Sun到Sat</td></tr><tr><td style="text-align:center">dddd</td><td style="text-align:center">星期几，完整的星期文本</td><td style="text-align:center">从Sunday到Saturday</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">年份中的第几周</td><td style="text-align:center">如42：表示第42周</td></tr><tr><td style="text-align:center">YYYY</td><td style="text-align:center">四位数字完整表示的年份</td><td style="text-align:center">如：2014 或 2000</td></tr><tr><td style="text-align:center">YY</td><td style="text-align:center">两位数字表示的年份</td><td style="text-align:center">如：14 或 98</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">大写的AM PM</td><td style="text-align:center">AM PM</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">小写的am pm</td><td style="text-align:center">am pm</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">小时，24小时制，无前导零</td><td style="text-align:center">0到23</td></tr><tr><td style="text-align:center">HH</td><td style="text-align:center">小时，24小时制，有前导零</td><td style="text-align:center">00到23</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">小时，12小时制，无前导零</td><td style="text-align:center">0到12</td></tr><tr><td style="text-align:center">hh</td><td style="text-align:center">小时，12小时制，有前导零</td><td style="text-align:center">00到12</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">没有前导零的分钟数</td><td style="text-align:center">0到59</td></tr><tr><td style="text-align:center">mm</td><td style="text-align:center">有前导零的分钟数</td><td style="text-align:center">00到59</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">没有前导零的秒数</td><td style="text-align:center">0到59</td></tr><tr><td style="text-align:center">ss</td><td style="text-align:center">有前导零的描述</td><td style="text-align:center">00到59</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">Unix时间戳</td><td style="text-align:center">1411572969</td></tr></tbody></table><h4 id="写法示例"><a href="#写法示例" class="headerlink" title="写法示例"></a>写法示例</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment() // 当前时间</span><br><span class="line">moment(<span class="string">"1995-12-25"</span>) // 1995-12-25</span><br><span class="line">moment(<span class="string">"12-25-1995"</span>, <span class="string">"MM-DD-YYYY"</span>) // 1995-12-25</span><br><span class="line">moment(&#123; year :2010, month :3, day :5, hour :15, minute :10, second :3, millisecond :123&#125;)</span><br><span class="line">moment(Date.now() - 24 * 60 * 60 * 1000) // 昨天</span><br><span class="line">moment(new Date(2011, 9, 16)) // 2011-10-16</span><br></pre></td></tr></table></figure><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'YYYY年MM月DD日 HH:mm:ss'</span>) // 2016年11月11日 22:05:19</span><br><span class="line">moment().format(<span class="string">'hh:m:ss'</span>) // 10:5:19</span><br><span class="line">moment().format(<span class="string">'[YYYY]'</span>) // <span class="string">"YYYY"</span>。[] 里的会原样输出。</span><br></pre></td></tr></table></figure><h5 id="转化成-Date-对象"><a href="#转化成-Date-对象" class="headerlink" title="转化成 Date 对象"></a>转化成 Date 对象</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().toDate()</span><br></pre></td></tr></table></figure><h5 id="获取-设置时间信息"><a href="#获取-设置时间信息" class="headerlink" title="获取/设置时间信息"></a>获取/设置时间信息</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">moment().second() //获得 秒</span><br><span class="line">moment().second(Number) //设置 秒。0 到 59</span><br><span class="line">moment().minute() //获得 分</span><br><span class="line">moment().minute(Number) //设置 分。0 到 59</span><br><span class="line">// 类似的用法</span><br><span class="line">moment().hour() // 小时</span><br><span class="line">moment().date() // 一个月里的第几天</span><br><span class="line">moment().day() // 星期几</span><br><span class="line">moment().dayOfYear() // 一年里的第几天</span><br><span class="line">moment().week() // 一年里的第几周</span><br><span class="line">moment().month() // 第几个月</span><br><span class="line">moment().quarter() // 一年里的第几个季度</span><br><span class="line">moment().year() // 年</span><br><span class="line">moment().daysInMonth() // 当前月有多少天</span><br></pre></td></tr></table></figure><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().add(7, <span class="string">'days'</span>) // 之后的第7天。第2个参数还可以是 <span class="string">'months'</span>, <span class="string">'years'</span> 等。注意是复数。</span><br><span class="line">moment().add(7, <span class="string">'d'</span>）// 与上面一行代码的运行结果一样。</span><br><span class="line">moment().subtract(1, <span class="string">'months'</span>) // 上个月</span><br><span class="line"></span><br><span class="line">moment().startOf(<span class="string">'week'</span>) // 这周的第一天</span><br><span class="line">moment().startOf(<span class="string">'hour'</span>) // 与 moment().minutes(0).seconds(0).milliseconds(0)等效。</span><br><span class="line">// 还支持 <span class="string">'year'</span>，<span class="string">'month'</span> 等</span><br><span class="line"></span><br><span class="line">moment().endOf(<span class="string">'week'</span>) // 这周的最后一天</span><br></pre></td></tr></table></figure><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 早于</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2010-10-21'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2010-12-31'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBefore(<span class="string">'2011-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 是否相等</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2010-10-20'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2009-12-31'</span>, <span class="string">'year'</span>)  // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isSame(<span class="string">'2010-01-01'</span>, <span class="string">'year'</span>)  // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 晚于</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2010-10-19'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2010-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isAfter(<span class="string">'2009-12-31'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 是否在时间范围内</span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-10-19'</span>, <span class="string">'2010-10-25'</span>) // <span class="literal">true</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2010-01-01'</span>, <span class="string">'2012-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">false</span></span><br><span class="line">moment(<span class="string">'2010-10-20'</span>).isBetween(<span class="string">'2009-12-31'</span>, <span class="string">'2012-01-01'</span>, <span class="string">'year'</span>) // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">moment().isLeapYear() // 是否是闰年</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;moment.js&lt;/strong&gt;是一个非常好用的时间处理插件，对js中的date对象进行了一层封装，使之具有更加强大日期处理能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;moment.js&lt;/strong&gt;里面包含了非常多而且有用的&lt;strong&gt;对时间进行操作&lt;/strong&gt;的方法，例如：时间加减法、比较大小/差值计算、isBefore/isAfter，还支持非常多的时间格式及语言。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Node.js" scheme="https://chongtianhong.github.io/tags/Node-js/"/>
    
      <category term="moment.js" scheme="https://chongtianhong.github.io/tags/moment-js/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序动态修改页面标题</title>
    <link href="https://chongtianhong.github.io/2018/06/20/setNavigationBarTitle/"/>
    <id>https://chongtianhong.github.io/2018/06/20/setNavigationBarTitle/</id>
    <published>2018-06-20T02:55:36.000Z</published>
    <updated>2018-09-19T14:16:25.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在微信小程序的开发中，如果页面的状态改变，需要<strong>动态的修改微信小程序的页面的标题</strong>，可以通过<strong>微信小程序提供的API</strong>，<code>wx.setNavigationBarTitle</code>来实现动态的修改微信小程序的页面标题。<a id="more"></a></li></ul><h4 id="静态设置页面标题"><a href="#静态设置页面标题" class="headerlink" title="静态设置页面标题"></a>静态设置页面标题</h4><ul><li>在<strong>对应页面的json文件</strong>里面加入下面代码就可以<strong>实现页面标题的设置</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"当前页标题"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="动态设置页面标题"><a href="#动态设置页面标题" class="headerlink" title="动态设置页面标题"></a>动态设置页面标题</h4><ul><li><p>下面是动态修改微信小程序的页面标题的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var sign = 1;</span><br><span class="line">    var <span class="built_in">times</span> = setInterval(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(sign &gt; 10 )</span><br><span class="line">        &#123;</span><br><span class="line">            clearInterval(<span class="built_in">times</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            var tmpTitle = <span class="string">'微信小程序的页面标题'</span> + sign++;</span><br><span class="line">            wx.setNavigationBarTitle(&#123;</span><br><span class="line">            title: tmpTitle,</span><br><span class="line">            success: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"当前微信小程序的页面标题为\""</span> + tmpTitle + <span class="string">"\""</span> );</span><br><span class="line">            &#125;,</span><br><span class="line">            complete: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"动态修改微信小程序的页面标题-complete"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>关键的操作是<code>wx.setNavigationBarTitle({ title: tmpTitle })</code>。</p></li><li><code>wx.setNavigationBarTitle</code>的API也<strong>支持</strong>在执行修改小程序页面标题的成功、失败和完成的状态的<strong>回调事件</strong>。</li><li>注意<code>wx.setNavigationBarTitle</code>要在onready之后设置<br>（onload也是在onready）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在微信小程序的开发中，如果页面的状态改变，需要&lt;strong&gt;动态的修改微信小程序的页面的标题&lt;/strong&gt;，可以通过&lt;strong&gt;微信小程序提供的API&lt;/strong&gt;，&lt;code&gt;wx.setNavigationBarTitle&lt;/code&gt;来实现动态的修改微信小程序的页面标题。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="https://chongtianhong.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="setNavigationBarTitle" scheme="https://chongtianhong.github.io/tags/setNavigationBarTitle/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（五）事件类型之鼠标事件</title>
    <link href="https://chongtianhong.github.io/2018/06/19/mouseEventOfEventType/"/>
    <id>https://chongtianhong.github.io/2018/06/19/mouseEventOfEventType/</id>
    <published>2018-06-19T11:46:45.000Z</published>
    <updated>2018-09-19T14:09:10.472Z</updated>
    
    <content type="html"><![CDATA[<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><ul><li>DOM3级事件中定义了9个鼠标事件：<ul><li><code>mousedown</code>：<strong>鼠标按钮被按下（左键或者右键）</strong>时触发。不能通过键盘触发。</li><li><code>mouseup</code>：<strong>鼠标按钮被释放弹起</strong>时触发。不能通过键盘触发。</li><li><code>click</code>：<strong>单击鼠标左键</strong>或者<strong>按下回车键</strong>时触发。这点对确保易访问性很重要，意味着<code>onclick</code>事件处理程序<strong>既可以通过键盘也可以通过鼠标执行</strong>。</li><li><code>dblclick</code>：<strong>双击鼠标左键</strong>时触发。</li><li><code>mouseover</code>：鼠标移入目标元素上方。鼠标移到其后代元素上时会触发。</li><li><code>mouseout</code>：鼠标移出目标元素上方。</li><li><code>mouseenter</code>：鼠标移入元素范围内触发，该事件<strong>不冒泡</strong>，即<strong>鼠标移到其后代元素上时不会触发</strong>。</li><li><code>mouseleave</code>：鼠标移出元素范围时触发，该事件<strong>不冒泡</strong>，即<strong>鼠标移到其后代元素时不会触发</strong>。</li><li><code>mousemove</code>：<strong>鼠标在元素内部移动</strong>时不断触发。不能通过键盘触发。</li></ul></li></ul><h5 id="事件触发的顺序"><a href="#事件触发的顺序" class="headerlink" title="事件触发的顺序"></a>事件触发的顺序</h5><ul><li><p>举例：通过双击按钮，看一下所触发的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"mousedown"</span>, <span class="keyword">function</span>(event) &#123;</span><br><span class="line">            console.log(<span class="string">"mousedown"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"mouseup"</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">"mouseup"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            console.log(<span class="string">"click"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"dblclick"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            console.log(<span class="string">"dblclick"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>事件触发的顺序如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mousedown</span><br><span class="line">mouseup</span><br><span class="line">click</span><br><span class="line">mousedown</span><br><span class="line">mouseup</span><br><span class="line">click</span><br><span class="line">dbclick</span><br></pre></td></tr></table></figure></li></ul><h5 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h5><ul><li><code>mouseover</code>事件<strong>会冒泡</strong>，这意味着，鼠标移到其后代元素上时会触发。</li><li><code>mouseenter</code>事件<strong>不冒泡</strong>，这意味着，鼠标移到其后代元素上时不会触发。</li><li><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head lang=<span class="string">"en"</span>&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            <span class="comment">#outer&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 200px;</span><br><span class="line">                top:0;</span><br><span class="line">                left: 0;</span><br><span class="line">                bottom:0;</span><br><span class="line">                right: 0;</span><br><span class="line">                margin: auto;</span><br><span class="line">                background-color: pink;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#inner&#123;</span></span><br><span class="line">                position: absolute;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height:100px;</span><br><span class="line">                top:50%;</span><br><span class="line">                left:50%;</span><br><span class="line">                margin-left: -50px;</span><br><span class="line">                margin-top: -50px;;</span><br><span class="line">                background-color: orange;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">#outer,#inner&#123;</span></span><br><span class="line">                border-radius:50%;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">                &lt;div id=<span class="string">"inner"</span>&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var parentDiv = document.getElementById(<span class="string">"outer"</span>);</span><br><span class="line">            parentDiv.addEventListener(<span class="string">"mouseover"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">                console.log(<span class="string">"父div的mouseover事件被触发"</span>);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseenter"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseenter事件被触发"</span>);</span><br><span class="line">            //&#125;,<span class="literal">false</span>);</span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseout"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseout事件被触发"</span>);</span><br><span class="line">            //&#125;, <span class="literal">false</span>);</span><br><span class="line">            //parentDiv.addEventListener(<span class="string">"mouseleave"</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            //    console.log(<span class="string">"父div的mouseleave事件被触发"</span>);</span><br><span class="line">            //&#125;, <span class="literal">false</span>);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>当<strong>鼠标从外面移入圆心</strong>，外面圆的<code>mouseover</code>事件被触发2次，第二次是<strong>里面圆的<code>mouseover</code>事件冒泡到外面圆</strong>而触发的。</p></li><li>当鼠标从外面移入圆心，外面圆的<code>mouseenter</code>事件被触发一次，因为<strong><code>mouseenter</code>事件不冒泡</strong>，鼠标移到后代元素不会触发。</li><li>另外，<code>mouseover</code>对应<code>mouseout</code>，<code>mouseenter</code>对应<code>mouseleave</code>。效果可以取消上面代码的注释来看。</li></ul><h5 id="鼠标左键和右键"><a href="#鼠标左键和右键" class="headerlink" title="鼠标左键和右键"></a>鼠标左键和右键</h5><ul><li>IE下鼠标的左键是1，右键是2。</li><li>ff和chrome下，鼠标左键是0，右键是2。</li><li>示例代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">document.onmousedown = <span class="keyword">function</span> (ev) &#123;</span><br><span class="line">    var oEvent = ev || event; //IE浏览器直接使用event或者window.event得到事件本身。</span><br><span class="line">    alert(oEvent.button); // IE下鼠标的 左键是1 ，  右键是2   ff和chrome下 鼠标左键是0  右键是2</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="mouseover和mousemove的区别"><a href="#mouseover和mousemove的区别" class="headerlink" title="mouseover和mousemove的区别"></a>mouseover和mousemove的区别</h5><ul><li><code>mousemove</code>事件通过鼠标在元素上移动来触发。事件处理函数会被传递一个事件对象event，<code>event.clientX</code>和 <code>event.clientY</code>属性代表鼠标的坐标。</li><li><code>mouseover</code>事件会在<strong>鼠标移入对象</strong>时触发。</li><li>一般情况下<code>mouseover</code>即可，特殊情况才用<code>mousemove</code>，因为<strong><code>mousemove</code>更耗资源</strong>，比如要<strong>监控鼠标坐标的变化</strong>等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;鼠标事件&quot;&gt;&lt;a href=&quot;#鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;鼠标事件&quot;&gt;&lt;/a&gt;鼠标事件&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;DOM3级事件中定义了9个鼠标事件：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mousedown&lt;/code&gt;：&lt;stron
      
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（四）event的公共成员（属性和方法）</title>
    <link href="https://chongtianhong.github.io/2018/06/18/publicMembersOfEvent/"/>
    <id>https://chongtianhong.github.io/2018/06/18/publicMembersOfEvent/</id>
    <published>2018-06-18T12:34:43.000Z</published>
    <updated>2018-09-18T14:49:55.187Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件对象的公共成员"><a href="#事件对象的公共成员" class="headerlink" title="事件对象的公共成员"></a>事件对象的公共成员</h4><h5 id="DOM中的event的公共成员"><a href="#DOM中的event的公共成员" class="headerlink" title="DOM中的event的公共成员"></a>DOM中的event的公共成员</h5><ul><li><code>event</code>对象包含与<strong>创建它的特定事件有关</strong>的属性和方法。触发的事件类型不一样，可用的属性和方法不一样。但是，DOM中所有事件都有以下<strong>公共成员</strong>。【注意<code>bubbles</code>属性和<code>cancelable</code>属性】<a id="more"></a></li></ul><table><thead><tr><th style="text-align:center">属性/方法</th><th style="text-align:center">类型</th><th style="text-align:center">读/写</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">bubbles</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">表明事件是否冒泡</td></tr><tr><td style="text-align:center">stopPropagation()</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法</td></tr><tr><td style="text-align:center">stopImmediatePropagation()</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增）</td></tr><tr><td style="text-align:center">cancelable</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">表明是否可以取消事件的默认行为</td></tr><tr><td style="text-align:center">preventDefault()</td><td style="text-align:center">Function</td><td style="text-align:center">只读</td><td style="text-align:center">取消事件的默认行为。如果cancelable是true，则可以使用这个方法</td></tr><tr><td style="text-align:center">defaultPrevented</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">为true表示已经调用了preventDefault()(DOM3级事件中新增)</td></tr><tr><td style="text-align:center">currentTarget</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">其事件处理程序当前正在处理事件的那个元素（currentTarget始终===this，即处理事件的元素）</td></tr><tr><td style="text-align:center">target</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">直接事件目标，真正触发事件的目标</td></tr><tr><td style="text-align:center">detail</td><td style="text-align:center">Integer</td><td style="text-align:center">只读</td><td style="text-align:center">与事件相关的细节信息</td></tr><tr><td style="text-align:center">eventPhase</td><td style="text-align:center">Integer</td><td style="text-align:center">只读</td><td style="text-align:center">调用事件处理程序的阶段：1表示捕获阶段，2表示处于目标阶段，3表示冒泡阶段</td></tr><tr><td style="text-align:center">trusted</td><td style="text-align:center">Boolean</td><td style="text-align:center">只读</td><td style="text-align:center">为true表示事件是由浏览器生成的。为false表示事件是由开发人员通过JavaScript创建的（DOM3级事件中新增）</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">String</td><td style="text-align:center">只读</td><td style="text-align:center">被触发的事件的类型</td></tr><tr><td style="text-align:center">view</td><td style="text-align:center">AbstractView</td><td style="text-align:center">只读</td><td style="text-align:center">关联</td></tr></tbody></table><blockquote>对比currentTarget和target</blockquote><ul><li>在事件处理程序内部，<strong>对象this始终等于currentTarget的值</strong>，而<strong>target则只是包含事件的实际目标</strong>。</li><li><p>举例：页面有个按钮，在body（按钮的父节点）中注册click事件，点按钮时click事件会<strong>冒泡到body进行处理</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        document.body.onclick = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"body中注册的click事件"</span>);</span><br><span class="line">            console.log(<span class="string">"this === event.currentTarget? "</span> + (this === event.currentTarget)); // <span class="literal">true</span></span><br><span class="line">            console.log(<span class="string">"currentTarget === document.body? "</span> + (event.currentTarget === document.body)); // <span class="literal">true</span></span><br><span class="line">            console.log(<span class="string">'event.target === document.getElementById("btn")? '</span> + (event.target === document.getElementById(<span class="string">"btn"</span>))); // <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body中注册的click事件</span><br><span class="line">this === event.currentTarget? <span class="literal">true</span> // this始终等于currentTarget</span><br><span class="line">currentTarget === document.body? <span class="literal">true</span> // 属于body上注册的事件，所以currentTarget为body</span><br><span class="line">event.target === document.getElementById(<span class="string">"btn"</span>)? <span class="literal">true</span> // 按钮触发的事件，所以target为button</span><br></pre></td></tr></table></figure></li></ul><blockquote>通过type属性，可以在一个函数中处理多个事件</blockquote><ul><li><strong>原理</strong>：通过检测<code>event.type</code>属性，对不同事件进行不同处理。</li><li><p><strong>举例</strong>：定义一个<code>handler</code>函数用来处理3种事件：click，mouseover，mouseout：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var handler = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            switch (event.type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">                    alert(<span class="string">"clicked"</span>);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">                    event.target.style.backgroundColor = <span class="string">"pink"</span>;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">                    event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.onclick = handler;</span><br><span class="line">        btn.onmouseover = handler;</span><br><span class="line">        btn.onmouseout = handler;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行效果：</p><ul><li><strong>点击</strong>按钮，弹出框；</li><li>鼠标<strong>经过</strong>按钮，按钮背景色变为粉色；</li><li>鼠标<strong>离开</strong>按钮，按钮背景色恢复默认颜色。</li></ul></li></ul><blockquote>stopPropagation()和stopImmediatePropagation()对比</blockquote><ul><li><strong>同</strong>：<code>stopPropagation()</code>和<code>stopImmediatePropagation()</code>都可以用来<strong>取消事件的进一步捕获或冒泡</strong>。</li><li><strong>异</strong>：二者的区别在于<strong>当一个事件有多个事件处理程序时</strong>，<code>stopImmediatePropagation()</code>可以<strong>阻止之后事件处理程序被调用</strong>。</li><li><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"buttn click listened once"</span>);</span><br><span class="line">            // event.stopPropagation(); // 取消注释查看效果</span><br><span class="line">            // event.stopImmediatePropagation(); // 取消注释查看效果</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(<span class="string">"button click listened twice"</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        document.body.onclick = <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"body clicked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>若不使用<code>stopPropagation()</code>和<code>stopImmediatePropagation()</code>，运行效果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buttn click listened once</span><br><span class="line">button click listened twice</span><br><span class="line">body clicked</span><br></pre></td></tr></table></figure></li><li><p>若给<strong>按钮的第一个事件处理程序</strong>添加<code>stopPropagation()</code>，将<strong>阻止事件进一步冒泡</strong>，所以body上的事件处理程序不被触发，运行效果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buttn click listened once</span><br><span class="line">button click listened twice</span><br></pre></td></tr></table></figure></li><li><p>若给<strong>按钮的第一个事件处理程序</strong>添加<code>stopImmediatePropagation()</code>，将<strong>阻止之后事件处理程序被调用</strong>，所以第二个事件处理程序不被触发，同时事件冒泡也被阻止，运行效果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buttn click listened once</span><br></pre></td></tr></table></figure></li></ul><blockquote>eventPhase</blockquote><ul><li><code>eventPhase</code>值在<strong>捕获阶段</strong>为1，处于<strong>目标阶段</strong>为2，<strong>冒泡阶段</strong>为3。</li></ul><table><thead><tr><th style="text-align:center">常量</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">Event.CAPTURING_PHASE</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Event.AT_TARGET</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Event.BUBBLING_PHASE</td><td style="text-align:center">3</td></tr></tbody></table><ul><li><p>可以通过下面代码查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">btn.onclick = <span class="keyword">function</span> (event) &#123;</span><br><span class="line">console.log(event.CAPTURING_PHASE); // 1</span><br><span class="line">console.log(event.AT_TARGET); // 2</span><br><span class="line">console.log(event.BUBBLING_PHASE); // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.onclick = <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"按钮DOM0级方法添加事件处理程序eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为true时eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>,<span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为false时eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">            document.body.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">                console.log(<span class="string">"body上添加事件处理程序，且在捕获阶段eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        document.body.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"body上添加事件处理程序，且在冒泡阶段eventPhase值为？"</span> + event.eventPhase);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">body上添加事件处理程序，且在捕获阶段eventPhase值为？1</span><br><span class="line">按钮DOM0级方法添加事件处理程序eventPhase值为？2</span><br><span class="line">按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为<span class="literal">true</span>时eventPhase值为？2</span><br><span class="line">按钮DOM2级方法添加事件处理程序，且addEventListener第三个参数为<span class="literal">false</span>时eventPhase值为？2</span><br><span class="line">body上添加事件处理程序，且在冒泡阶段eventPhase值为？3</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">捕获阶段调用事件处理程序，eventPhase值为1</span><br><span class="line">处于目标阶段，eventPhase值为2</span><br><span class="line">冒泡阶段调用事件处理程序，eventPhase值为3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><h5 id="IE中event的公共成员"><a href="#IE中event的公共成员" class="headerlink" title="IE中event的公共成员"></a>IE中event的公共成员</h5><ul><li>IE中的event的属性和方法和DOM一样会随着事件类型的不同而不同，但是也有一些是所有对象都有的公共成员，且这些成员大部分有对应的DOM属性或方法。</li></ul><table><thead><tr><th style="text-align:center">属性/方法</th><th style="text-align:center">类型</th><th style="text-align:center">读/写</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">cancelBubble</td><td style="text-align:center">Boolean</td><td style="text-align:center">读/写</td><td style="text-align:center">默认为false，但将其设置为true就可以取消事件冒泡（与DOM中stopPropagation()方法的作用相同）</td></tr><tr><td style="text-align:center">returnValue()</td><td style="text-align:center">Boolean</td><td style="text-align:center">读/写</td><td style="text-align:center">默认为true，但将其设置为false就可以取消事件的默认行为（与DOM中的preventDefault()方法的作用相同）</td></tr><tr><td style="text-align:center">srcElement()</td><td style="text-align:center">Element</td><td style="text-align:center">只读</td><td style="text-align:center">事件的目标（与DOM中的target属性相同）</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">String</td><td style="text-align:center">只读</td><td style="text-align:center">被触发的事件的类型</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件对象的公共成员&quot;&gt;&lt;a href=&quot;#事件对象的公共成员&quot; class=&quot;headerlink&quot; title=&quot;事件对象的公共成员&quot;&gt;&lt;/a&gt;事件对象的公共成员&lt;/h4&gt;&lt;h5 id=&quot;DOM中的event的公共成员&quot;&gt;&lt;a href=&quot;#DOM中的event的公共成员&quot; class=&quot;headerlink&quot; title=&quot;DOM中的event的公共成员&quot;&gt;&lt;/a&gt;DOM中的event的公共成员&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;event&lt;/code&gt;对象包含与&lt;strong&gt;创建它的特定事件有关&lt;/strong&gt;的属性和方法。触发的事件类型不一样，可用的属性和方法不一样。但是，DOM中所有事件都有以下&lt;strong&gt;公共成员&lt;/strong&gt;。【注意&lt;code&gt;bubbles&lt;/code&gt;属性和&lt;code&gt;cancelable&lt;/code&gt;属性】
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（三）事件对象</title>
    <link href="https://chongtianhong.github.io/2018/06/17/eventObject/"/>
    <id>https://chongtianhong.github.io/2018/06/17/eventObject/</id>
    <published>2018-06-17T05:15:29.000Z</published>
    <updated>2018-09-17T15:13:21.008Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><ul><li>在<strong>触发DOM上的事件时</strong>都会<strong>产生一个对象</strong>，这个对象则称为<strong>事件对象</strong>。<a id="more"></a></li></ul><h5 id="认识事件对象"><a href="#认识事件对象" class="headerlink" title="认识事件对象"></a>认识事件对象</h5><ul><li>事件<strong>在浏览器中</strong>是<strong>以对象的形式存在</strong>的，即<strong>event</strong>。触发一个事件，就会产生一个事件对象event，<strong>该对象包含着所有与事件有关的信息</strong>。包括<strong>导致事件的元素</strong>、<strong>事件的类型</strong>以及其他<strong>与特定事件相关的信息</strong>。</li><li>例如：<strong>鼠标操作</strong>产生的event中会<strong>包含鼠标位置的信息</strong>；<strong>键盘操作</strong>产生的event中会<strong>包含与按下的键有关的信息</strong>。</li><li>所有浏览器都支持event对象，但支持方式不同，在DOM中<strong>event对象必须作为唯一的参数传给事件处理函数</strong>，在IE中<strong>event是window对象的一个属性</strong>。</li></ul><h5 id="html事件处理程序中event"><a href="#html事件处理程序中event" class="headerlink" title="html事件处理程序中event"></a>html事件处理程序中event</h5><ul><li><p>下面的例子会创建一个包含局部变量event的函数。可通过event直接访问事件对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span> onclick=<span class="string">"console.log('html事件处理程序'+event.type)"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li><p>当点击input按钮时，控制台将输出<code>html事件处理程序click</code>。</p></li></ul><h5 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h5><ul><li><strong>DOM0级</strong>和<strong>DOM2级</strong>事件处理程序都会<strong>把event作为参数传入</strong>。</li><li><p><strong>根据习惯来：可以用e，或者ev或者event</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">        btn.onclick = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">            console.log(<span class="string">"DOM0 &amp; click"</span>);</span><br><span class="line">            console.log(event.type);    // click</span><br><span class="line">        &#125;</span><br><span class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">            console.log(<span class="string">"DOM2 &amp; click"</span>);</span><br><span class="line">            console.log(event.type);    // click</span><br><span class="line">        &#125;,<span class="literal">false</span>);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>DOM中事件对象重要<strong>属性和方法</strong>总结如下：</p><ul><li><strong>属性</strong>：<br>①<code>type</code>属性，用于<strong>获取事件类型</strong>。<br>②<code>target</code>属性，用于<strong>获取事件目标事件加在哪个元素上</strong>。（更具体target.nodeName）</li><li><strong>方法</strong>：<br>①<code>stopPropagation()</code>方法用于<strong>阻止事件冒泡</strong>。<br>②<code>preventDefault()</code>方法<strong>阻止事件的默认行为</strong>(移动端用的多)。</li></ul></li></ul><h5 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h5><ul><li><p>第一种情况：通过<strong>DOM0级</strong>方法添加事件处理程序时，<strong>event对象作为window对象的一个属性</strong>存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">    btn.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var event = window.event;</span><br><span class="line">       console.log(event.type); // click</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二种情况：通过<code>attachEvent()</code>添加的事件处理程序，<strong>event对象作为参数传入</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input id=<span class="string">"btn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">    btn.attachEvent(<span class="string">"onclick"</span>, <span class="keyword">function</span> (event) &#123;</span><br><span class="line">        console.log(event.type); // click</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li><li><p>IE中事件对象<strong>重要属性</strong>总结如下：</p><ul><li><p><strong>属性</strong>：<br>①<code>type</code>属性，用于<strong>获取事件类型</strong>。<br>②<code>srcElement</code>属性，用于<strong>获取事件目标事件加在哪个元素上</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//兼容性处理</span><br><span class="line"><span class="keyword">function</span> showMsg(event)&#123;</span><br><span class="line">    event = event || window.event; // IE8以前必须是通过window获取event，DOM中就是个简单的传参</span><br><span class="line">    var ele = event.target || event.srcElement; // 获取目标元素，DOM中用target，IE中用srcElement</span><br><span class="line">    alert(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③<code>cancelBubble</code>属性用于<strong>阻止事件冒泡</strong>。IE中<code>cancelBubble</code>为属性而不是方法，<strong>true表示阻止冒泡</strong>。<br>④<code>returnValue</code>属性<strong>阻止事件的默认行为</strong>，<code>false</code>表示<strong>阻止事件的默认行为</strong>。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件对象&quot;&gt;&lt;a href=&quot;#事件对象&quot; class=&quot;headerlink&quot; title=&quot;事件对象&quot;&gt;&lt;/a&gt;事件对象&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;触发DOM上的事件时&lt;/strong&gt;都会&lt;strong&gt;产生一个对象&lt;/strong&gt;，这个对象则称为&lt;strong&gt;事件对象&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件（二）事件处理程序</title>
    <link href="https://chongtianhong.github.io/2018/06/16/eventHandler/"/>
    <id>https://chongtianhong.github.io/2018/06/16/eventHandler/</id>
    <published>2018-06-16T03:44:32.000Z</published>
    <updated>2018-10-03T13:22:47.788Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><ul><li><a href="http://xbhong.top/2018/06/15/eventFlow/#more" target="_blank" rel="noopener">JavaScript事件（一）事件流</a>中提到，事件是<strong>用户</strong>或<strong>浏览器自身</strong>执行的某种动作，如<code>click</code>，<code>load</code>和<code>mouseover</code>都是事件的名字。</li><li><strong>响应某个事件的函数</strong>就叫<strong>事件处理程序</strong>（也叫事件处理函数、事件句柄）。<a id="more"></a></li><li>事件处理程序的名字以”on”开头，因此<code>click</code>事件的事件处理程序就是<strong>onclick</strong>，<code>load</code>事件的事件处理程序就是<strong>onload</strong>。</li><li><strong>为事件指定事件处理程序的方法</strong>主要有3种，分别是<strong>HTML事件处理程序</strong>、<strong>DOM0级事件处理程序</strong>和<strong>DOM2级事件处理程序</strong>。</li></ul><h5 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h5><ul><li>事件直接加在HTML元素上。这种方式也有两种方法，都很简单：</li><li><p>第一种：直接<strong>在HTML元素中定义事件处理程序及包含的动作</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span> onclick=<span class="string">"alert('clicked!')"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二种：HTML元素中定义事件处理程序，<strong>执行的动作</strong>则<strong>调用其他地方定义的脚本</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span> onclick=<span class="string">"showMessage()"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">showMessage</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>知识点：<br>1）通过<strong>event变量</strong>可以<strong>直接访问事件本身</strong>，比如<code>onclick=”alert(event.type)”</code>会弹出<code>click</code>事件。<br>2）<strong>this值等于事件的目标元素</strong>，这里目标元素是input。比如<code>onclick=”alert(this.value)”</code>可以得到input元素的value值。</p></li></ul><h5 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h5><ul><li>把一个<strong>函数赋值</strong>给一个<strong>事件处理程序属性</strong>。**</li><li>这种方法简单而且跨浏览器，但是<strong>只能为一个元素添加一个事件处理函数</strong>，即这种方法<strong>无法为元素添加多个相同事件的事件处理函数</strong>，则<strong>后面的会覆盖前面的</strong>。</li><li><p><strong>添加</strong>事件处理程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">/*</span><br><span class="line">    第一步：myBtn = document.getElementById(<span class="string">"myBtn"</span>);取得btn对象</span><br><span class="line">    第二步：myBtn.onclick其实相当于给myBtn添加了一个onclick的属性。</span><br><span class="line">    第三步：myBtn.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    把函数赋值给onclick事件处理程序属性。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong>事件处理程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myBtn.onclick = null;</span><br></pre></td></tr></table></figure></li></ul><h5 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h5><ul><li>DOM2级事件处理程序可以<strong>为一个元素添加多个事件处理程序</strong>。其定义了两个方法用于添加和删除事件处理程序：<code>addEventListener()</code>和<code>removeEventListener()</code>。</li><li><strong>所有的DOM节点都包含这2个方法</strong>。</li><li>这两个方法都需要3个参数：<strong>事件名</strong>，<strong>事件处理函数</strong>，<strong>布尔值</strong>。布尔值为<code>true</code>时，在捕获阶段处理事件；为<code>false</code>时，在冒泡阶段处理事件。布尔值默认为<code>false</code>。</li><li><p><strong>添加事件处理程序</strong>：现在为按钮添加两个事件处理函数，一个弹出“hello”，一个弹出“world”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"world"</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除事件处理程序</strong>：通过<code>addEventListener()</code>添加的事件处理程序必须通过<code>removeEventListener()</code>删除，且<strong>参数一致</strong>。</p></li><li><p><strong>注意</strong>：通过<code>addEventListener()</code>添加的<strong>匿名函数将无法删除</strong>。下面这段代码将不起作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myBtn.removeEventListener(<span class="string">"click"</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    alert(<span class="string">"world"</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>看似该<code>removeEventListener()</code>与上面的<code>addEventListener()</code>参数一致，实则<strong>第二个参数中匿名函数是完全不同的</strong>。所以<strong>为了能删除事件处理程序</strong>，代码可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handler = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">    myBtn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4><h5 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h5><ul><li><strong>IE8及以下浏览器不支持<code>addEventListener()</code></strong>，在实际开发中如果要兼容到IE8及以下浏览器。</li><li><p>如果用原生的绑定事件，需要做兼容处理，可利用jquery的bind代替。语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).<span class="built_in">bind</span>(event, data, <span class="keyword">function</span>)</span><br></pre></td></tr></table></figure></li><li><p>其中：</p><ul><li><code>event</code>是必需的。规定添加到元素的一个或多个事件。可由空格分隔多个事件。必须是有效的事件。</li><li><code>data</code>是可选的。规定传递到函数的额外数据。</li><li><code>function</code>是必需的。规定当事件发生时运行的函数。</li></ul></li><li>例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).<span class="built_in">bind</span>(<span class="string">"click"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    $(<span class="string">"p"</span>).slideToggle();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h5 id="IE8事件绑定"><a href="#IE8事件绑定" class="headerlink" title="IE8事件绑定"></a>IE8事件绑定</h5><ul><li>IE8及以下版本浏览器实现了与DOM中类似的两个方法：<code>attachEvent()</code>和<code>detachEvent()</code>。</li><li>这两个方法都需要两个参数：<strong>事件处理程序名称</strong>和<strong>事件处理程序函数</strong>。由于<strong>IE8及更早版本只支持事件冒泡</strong>，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。</li><li><strong>注意</strong>是<strong>事件处理程序名称</strong>而不是事件名称，所以要加上on，是<strong>onclick</strong>而不是click。</li><li>知识点：<ul><li>IE11只支持<code>addEventListener</code>。</li><li>IE9，IE10对<code>attachEvent</code>和<code>addEventListener</code>都支持。</li><li>IE8及以下版本只支持<code>attachEvent</code>。</li></ul></li><li><p>可以拿下面代码在IE各个版本浏览器中进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handlerIE = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"helloIE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    var handlerDOM = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(<span class="string">"helloDOM"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.addEventListener(<span class="string">"click"</span>, handlerDOM, <span class="literal">false</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, handlerIE);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加事件处理程序</strong>：现在为按钮添加两个事件处理函数，一个弹出<code>“hello”</code>，一个弹出<code>“world”</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(<span class="string">"world"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>这里运行效果值得注意一下：</p><ul><li><strong>IE8以下浏览器</strong>中先弹出“world”，再弹出“hello”。<strong>和DOM中事件触发顺序相反</strong>。</li><li><strong>IE9及以上浏览器</strong>先弹出“hello”，再弹出“world”。<strong>和DOM中事件触发顺序相同</strong>。</li></ul></li><li><strong>删除事件处理程序</strong>：通过<code>attachEvent</code>添加的事件处理程序必须通过<code>detachEvent</code>方法删除，且参数一致。</li><li><p>和DOM事件一样，<strong>添加的匿名函数将无法删除</strong>。所以为了能删除事件处理程序，代码可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    var handler = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        alert(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">    myBtn.detachEvent(<span class="string">"onclick"</span>, handler);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>IE事件处理程序</strong>中还有一个地方需要注意：<strong>作用域</strong>。</p></li><li>使用<code>attachEvent</code>方法，事件处理程序会在<strong>全局作用域</strong>中运行，因此<strong>this等于window</strong>。在编写跨浏览器的代码时，需牢记这点。</li><li>而<strong>DOM2</strong>或<strong>DOM0</strong>级的方法<strong>作用域都是在元素内部，this值为目标元素</strong>。</li><li>下面例子会弹出true：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myBtn"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"click me!"</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var myBtn = document.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">    myBtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        alert(this === window);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事件处理程序&quot;&gt;&lt;a href=&quot;#事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;事件处理程序&quot;&gt;&lt;/a&gt;事件处理程序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://xbhong.top/2018/06/15/eventFlow/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript事件（一）事件流&lt;/a&gt;中提到，事件是&lt;strong&gt;用户&lt;/strong&gt;或&lt;strong&gt;浏览器自身&lt;/strong&gt;执行的某种动作，如&lt;code&gt;click&lt;/code&gt;，&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;mouseover&lt;/code&gt;都是事件的名字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应某个事件的函数&lt;/strong&gt;就叫&lt;strong&gt;事件处理程序&lt;/strong&gt;（也叫事件处理函数、事件句柄）。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="事件" scheme="https://chongtianhong.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
</feed>
