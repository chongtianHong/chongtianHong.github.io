<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/c972cec44268ea709ae89f880845ea12</icon>
  <subtitle>知耻而后勇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongtianhong.github.io/"/>
  <updated>2018-08-03T15:38:07.074Z</updated>
  <id>https://chongtianhong.github.io/</id>
  
  <author>
    <name>Xiaobing Hong</name>
    <email>450707109@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue的计算属性和侦听器</title>
    <link href="https://chongtianhong.github.io/2018/04/23/vueComputed/"/>
    <id>https://chongtianhong.github.io/2018/04/23/vueComputed/</id>
    <published>2018-04-23T14:51:42.000Z</published>
    <updated>2018-08-03T15:38:07.074Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>计算属性是需要<strong>复杂的逻辑</strong>和很多<strong>组件基础状态</strong>最后才能得到其<strong>正确值</strong>的属性。</li><li><strong>模板内的表达式</strong>非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。<a id="more"></a></li><li><p>如下面的代码所示，模板不再是简单的声明式逻辑，这里是想要显示变量 message 的翻转字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>当我们想要<strong>在模板中多次引用此处的翻转字符串</strong>时，就会更加难以处理。</p></li><li>所以，对于任何<strong>复杂逻辑</strong>，我们都应当<strong>使用计算属性</strong>。</li></ul><h4 id="计算属性的使用方法"><a href="#计算属性的使用方法" class="headerlink" title="计算属性的使用方法"></a>计算属性的使用方法</h4><ul><li><p>在Vue里面，所有的计算属性都写在 vue 实例的 <code>computed</code> 属性中，这个<strong>计算属性就是一个函数</strong>，<strong>返回值</strong>为最后<strong>属性的值</strong>。如下面的例子所示，totalPrice 就是一个计算属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  <span class="function"><span class="title">totalPrice</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> (this.good.price*this.good.count)*this.discount+this.deliver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义完成之后，我们就可以像用普通属性一样去用计算属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h2&gt;本店起送金额￥20&lt;/h2&gt;</span><br><span class="line">    &lt;h3&gt;配送费￥5&lt;/h3&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      您购买了&#123;&#123;good.name&#125;&#125;共&#123;&#123;good.count&#125;&#125;份===￥&#123;&#123;good.price&#125;&#125;/份</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;总价：&#123;&#123;totalPrice&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    good:&#123;id:1,price:10,name:<span class="string">'红烧牛肉盖饭'</span>,count:1&#125;,</span><br><span class="line">    discount:0.8,</span><br><span class="line">    deliver:5</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    <span class="function"><span class="title">totalPrice</span></span>()&#123;</span><br><span class="line">      <span class="built_in">return</span> (this.good.price*this.good.count)*this.discount+this.deliver;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>计算属性的方法可以包含很多繁重的逻辑，最终返回我们需要的值。</p></li><li>通过计算属性的使用，View层的代码会变的非常精简，且容易维护。</li></ul><h4 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h4><ul><li><p>我们可以通过在表达式中调用方法来达到同样的效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;总价：&#123;&#123;totalPrice()&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>同时，将computed属性换成methods属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">totalPrice</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> (this.good.price*this.good.count)*this.discount+this.deliver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可见，我们可以将<strong>同一函数</strong>定义为一个方法而不是一个计算属性。两种方式的<strong>最终结果是完全相同的</strong>。</p></li><li>然而，不同的是<strong>计算属性是基于它们的依赖进行缓存的</strong>。计算属性<strong>只有在它的相关依赖发生改变时</strong>才会<strong>重新求值</strong>。</li><li>这就意味着只要<strong>函数使用的变量</strong>还没有发生改变，<strong>多次访问</strong>totalPrice<strong>计算属性</strong>会<strong>立即返回之前的计算结果</strong>，而<strong>不必再次执行函数</strong>。</li><li><p>注意：因为 Date.now() 不是响应式依赖，因此下面例子的计算属性将不再更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> Date.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相比之下，每当<strong>触发重新渲染</strong>时，<strong>调用方法将总会再次执行函数</strong>。</p></li></ul><blockquote>如何选择这两个属性</blockquote><ul><li>性能开销比较大假设我们有一个的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</li></ul><h4 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h4><ul><li>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听（watch）属性。</li><li>当我们有一些数据需要随着其它数据变动而变动时，也可以使用侦听（watch）属性。</li><li><p>然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。如下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"demo"</span>&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="keyword">function</span> (val) &#123;</span><br><span class="line">      this.fullName = val + <span class="string">' '</span> + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="keyword">function</span> (val) &#123;</span><br><span class="line">      this.fullName = this.firstName + <span class="string">' '</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      <span class="built_in">return</span> this.firstName + <span class="string">' '</span> + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><ul><li><p>计算属性默认只有 getter ，不过在需要时也可以提供一个 setter ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      <span class="built_in">return</span> this.firstName + <span class="string">' '</span> + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span> (newValue) &#123;</span><br><span class="line">      var names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></li><li><p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;计算属性是需要&lt;strong&gt;复杂的逻辑&lt;/strong&gt;和很多&lt;strong&gt;组件基础状态&lt;/strong&gt;最后才能得到其&lt;strong&gt;正确值&lt;/strong&gt;的属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模板内的表达式&lt;/strong&gt;非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="Vue.js" scheme="https://chongtianhong.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>关于Vue.nextTick()的使用</title>
    <link href="https://chongtianhong.github.io/2018/04/22/nextTick/"/>
    <id>https://chongtianhong.github.io/2018/04/22/nextTick/</id>
    <published>2018-04-22T03:10:13.000Z</published>
    <updated>2018-08-01T14:31:12.027Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><code>Vue.nextTick()</code>的官方解释是：在下次 DOM 更新循环结束之后执行延迟回调。在<strong>修改数据之后立即使用</strong>这个方法，获取更新后的 DOM。</li><li>放在<code>Vue.nextTick()</code>回调函数中的执行的应该是涉及DOM操作的JavaScript代码。<a id="more"></a></li><li>Vue的<strong>响应式原理</strong>：在data选项里所有属性都会被watcher监控，当修改了data的某一个值，并不会立即反映到视图中。Vue会将我们<strong>对data的更改放到watcher的一个队列中</strong>（异步），只有在<strong>当前任务空闲时才会去执行watcher队列任务</strong>。这就有一个延迟时间。</li><li>虽然我们看起来是直接反映到视图的，其实并不是，只是浏览器引擎在很短的时间内就比较完了数据的前后差异并更新到视图里。</li></ul><blockquote>Vue.nextTick()的由来</blockquote><ul><li>由于VUE的数据驱动视图更新，是异步的，即<strong>修改数据时，视图不会立刻更新</strong>，而是<strong>等同一事件循环中的所有数据变化完成之后</strong>，再<strong>统一进行视图更新</strong>。</li></ul><blockquote>Vue.nextTick()触发的时机</blockquote><ul><li>结合nextTick的由来，可以推出每个事件循环中，nextTick触发的时机：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同一事件循环中的代码执行完毕 -&gt; DOM 更新 -&gt; nextTick callback触发</span><br></pre></td></tr></table></figure></li></ul><h4 id="Vue-nextTick-的使用时机"><a href="#Vue-nextTick-的使用时机" class="headerlink" title="Vue.nextTick()的使用时机"></a>Vue.nextTick()的使用时机</h4><ul><li>在<strong>Vue生命周期的<code>created()</code>钩子函数中进行的DOM操作</strong>一定要放在<code>Vue.nextTick()</code>的回调函数中。<ul><li>原因是<strong>在<code>created()</code>钩子函数执行的时候，DOM 其实还未进行任何渲染</strong>，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的JavaScript代码放进<code>Vue.nextTick()</code>的回调函数中。</li></ul></li><li>在<strong>Vue生命周期的<code>mounted()</code>钩子函数中进行的DOM操作</strong>不需要使用<code>Vue.nextTick()。<ul><li>因为该<strong>钩子函数执行时所有的DOM挂载和渲染都已完成</strong>，此时在该钩子函数中进行任何DOM操作都不会有问题 。</li></ul></code></li><li>在<strong>数据变化后要执行的某个操作</strong>，而这个操作需要使用<strong>随数据改变而改变的DOM结构</strong>的时候，这个操作都应该放进<code>Vue.nextTick()</code>的回调函数中。</li></ul><blockquote>原因</blockquote><ul><li>Vue是<strong>异步执行DOM更新</strong>的，一旦观察到数据变化，Vue就会开启一个队列，然后把在<strong>同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列</strong>。<strong>如果这个watcher被触发多次，只会被推送到队列一次</strong>。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOM操作。而<strong>在下一个事件循环时</strong>，Vue会<strong>清空队列，并进行必要的DOM更新</strong>。</li><li>当设置 <code>vm.someData = ‘new value’</code>时，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时想要根据更新的 DOM 状态去做某些事情，就会出现问题。<strong>为了在数据变化之后等待 Vue 完成更新 DOM </strong>，可以<strong>在数据变化之后立即使用 <code>Vue.nextTick(callback)</code></strong>，这样回调函数<strong>在 DOM 更新完成后就会调用</strong>。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>前面提到，在修改数据之后立即使用<code>Vue.nextTick(callback)</code><strong>，能实现等待 DOM 更新后执行callback。它跟全局方法 <code>Vue.nextTick</code>* 一样，不同的是</strong>回调的 this 自动绑定到调用它的实例**上。</li><li><p>DOM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p ref=<span class="string">"myWidth"</span> v-if=<span class="string">"showMe"</span>&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"getMyWidth"</span>&gt;获取p元素宽度&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>script</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">'Hello Vue.js'</span>,</span><br><span class="line">        showMe: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">getMyWidth</span></span>() &#123;</span><br><span class="line">            this.showMe = <span class="literal">true</span>;</span><br><span class="line">            //this.message = this.<span class="variable">$refs</span>.myWidth.offsetWidth;// 报错 TypeError: this.<span class="variable">$refs</span>.myWidth is undefined</span><br><span class="line">            this.<span class="variable">$nextTick</span>(()=&gt;&#123;</span><br><span class="line">                // DOM元素更新后执行，此时能拿到p元素的属性</span><br><span class="line">                this.message = this.<span class="variable">$refs</span>.myWidth.offsetWidth;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Vue.nextTick()&lt;/code&gt;的官方解释是：在下次 DOM 更新循环结束之后执行延迟回调。在&lt;strong&gt;修改数据之后立即使用&lt;/strong&gt;这个方法，获取更新后的 DOM。&lt;/li&gt;
&lt;li&gt;放在&lt;code&gt;Vue.nextTick()&lt;/code&gt;回调函数中的执行的应该是涉及DOM操作的JavaScript代码。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Vue" scheme="https://chongtianhong.github.io/tags/Vue/"/>
    
      <category term="DOM更新" scheme="https://chongtianhong.github.io/tags/DOM%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2中ref属性的使用方法</title>
    <link href="https://chongtianhong.github.io/2018/04/21/vue-ref/"/>
    <id>https://chongtianhong.github.io/2018/04/21/vue-ref/</id>
    <published>2018-04-21T03:51:52.000Z</published>
    <updated>2018-08-01T14:31:12.136Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>ref</code>被用来给<strong>元素</strong>或<strong>子组件注册引用信息</strong>。</li><li>引用信息将会注册在<strong>父组件</strong>的<code>$refs</code>对象上。<ul><li>如果在普通的DOM元素上使用，引用指向的就是DOM元素；</li><li>如果用在子组件上，引用就指向组件实例。<a id="more"></a></li></ul></li><li><p>DOM元素上使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 访问DOM元素</span><br><span class="line">&lt;p ref=<span class="string">"p"</span>&gt;hello&lt;/p&gt;</span><br><span class="line">var domEle = vm.<span class="variable">$refs</span>.p</span><br></pre></td></tr></table></figure></li><li><p>尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个引用 ID。</p></li><li><p>子组件上使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;user-profile ref=<span class="string">"profile"</span>&gt;&lt;/user-profile&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var parent = new Vue(&#123; el: <span class="string">'#parent'</span> &#125;)</span><br><span class="line">// 访问子组件实例</span><br><span class="line">var child = parent.<span class="variable">$refs</span>.profile</span><br></pre></td></tr></table></figure></li><li><p>当<code>v-for</code>用于元素或组件的时候，引用信息将是包含DOM节点或组件实例的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">　　&lt;li ref=<span class="string">"refCon"</span>&gt;1&lt;/li&gt;</span><br><span class="line">　　&lt;li ref=<span class="string">"refCon"</span>&gt;2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// js</span><br><span class="line">created: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.<span class="variable">$nextTick</span>(() =&gt; &#123;</span><br><span class="line">        console.log(this.<span class="variable">$refs</span>.refCon) </span><br><span class="line">        // 打印结果：&lt;li&gt;2&lt;/li&gt; 本以为会获得一个数组</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果要获得数组，应该在li里面使用v-for遍历：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"> &lt;li v-for=<span class="string">"item in people"</span> ref=<span class="string">"refContent"</span>&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// js</span><br><span class="line">data: &#123;</span><br><span class="line">    people:[<span class="string">'三姑'</span>,<span class="string">'四婶'</span>,<span class="string">'五叔'</span>,<span class="string">'六姨'</span>,<span class="string">'七舅姥爷'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">created: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    this.<span class="variable">$nextTick</span>(() =&gt; &#123;</span><br><span class="line">        console.log(this.<span class="variable">$refs</span>.refContent) // 数组</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于<code>ref</code>注册时间的重要说明：因为<code>ref</code>本身是作为渲染结果被创建的，<strong>在初始渲染的时候不能访问它们，因为它们还不存在</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// js</span><br><span class="line">data: &#123;</span><br><span class="line">   people:[<span class="string">'三姑'</span>,<span class="string">'四婶'</span>,<span class="string">'五叔'</span>,<span class="string">'六姨'</span>,<span class="string">'七舅姥爷'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">created: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">   console.log(this.<span class="variable">$refs</span>.refContent)</span><br><span class="line">   // undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>$refs</code>也不是响应式的，因此不应该视图用它在模板中做数据绑定。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt;被用来给&lt;strong&gt;元素&lt;/strong&gt;或&lt;strong&gt;子组件注册引用信息&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;引用信息将会注册在&lt;strong&gt;父组件&lt;/strong&gt;的&lt;code&gt;$refs&lt;/code&gt;对象上。&lt;ul&gt;
&lt;li&gt;如果在普通的DOM元素上使用，引用指向的就是DOM元素；&lt;/li&gt;
&lt;li&gt;如果用在子组件上，引用就指向组件实例。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Vue" scheme="https://chongtianhong.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>理解Object.defineProperty的作用</title>
    <link href="https://chongtianhong.github.io/2018/04/20/Object-defineProperty/"/>
    <id>https://chongtianhong.github.io/2018/04/20/Object-defineProperty/</id>
    <published>2018-04-20T01:41:21.000Z</published>
    <updated>2018-08-01T14:31:10.085Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>对象是由多个<strong>键/值对</strong>组成的<strong>无序的集合</strong>。对象中<strong>每个属性</strong>对应<strong>任意类型的值</strong>。</li><li><p>定义对象可以使用构造函数或字面量的形式：</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();  // 或var obj = &#123;&#125;</span><br><span class="line">obj.name = <span class="string">"张三"</span>;  // 添加属性</span><br><span class="line">obj.say = <span class="function"><span class="title">function</span></span>()&#123;&#125;;  // 添加方法</span><br></pre></td></tr></table></figure></li><li><p>除了以上添加属性的方式，还可以使用<code>Object.defineProperty()</code>方法定义新属性或修改原有的属性。</p></li><li><code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</li><li>vue.js的<strong>双向数据绑定</strong>就是通过<code>Object.defineProperty()</code>方法实现的，俗称<strong>属性拦截器</strong>。</li></ul><h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><div class="info">Object.defineProperty(obj, prop, descriptor)</div><ul><li><p>参数说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj：必需。要在其上定义属性的对象。</span><br><span class="line">prop：必需。需定义或修改的属性的名称。</span><br><span class="line">descriptor：必需。将被定义或修改的属性描述符。</span><br></pre></td></tr></table></figure></li><li><p>返回值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被传递给函数的对象，即第一个参数obj。</span><br></pre></td></tr></table></figure></li></ul><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><ul><li>通过<strong>赋值操作</strong>添加的普通属性是<strong>可枚举</strong>的，能够在属性枚举期间呈现出来（<code>for…in</code> 或 <code>Object.keys</code> 方法），这些<strong>属性的值可以被改变</strong>，也<strong>可以被删除</strong>。</li><li>注意：<code>Object.defineProperty()</code>方法允许<strong>精确添加或修改对象的属性</strong>。这个方法<strong>允许修改默认的额外选项（或配置</strong>）。<strong>默认情况</strong>下，使用<code>Object.defineProperty()</code>方法<strong>添加的属性值</strong>是<strong>不可修改</strong>的。</li></ul><h5 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h5><ul><li>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符</strong>和<strong>存取描述符</strong>。</li><li><strong>数据描述符</strong>用于在修改或定义对象的某个属性的时候，给这个属性添加一些特性。</li><li><strong>存取描述符</strong>是由一对getter-setter函数功能来描述的属性。</li><li>描述符必须是这两种形式之一；<strong>不能同时是两者</strong>。</li><li><strong>数据描述符</strong>和<strong>存取描述符</strong>均具有以下可选键值：<ul><li><strong>configurable</strong>：当且仅当该属性的 configurable 为 true 时，该<strong>属性描述符</strong>才能够被改变，同时<strong>该属性也能从对应的对象上被删除</strong>。<strong>默认为 false</strong>。</li><li><strong>enumerable</strong>：当且仅当该属性的enumerable为true时，该属性才能够<strong>出现在对象的枚举属性中</strong>。<strong>默认为 false</strong>。</li></ul></li><li><strong>数据描述符</strong>同时具有以下可选键值： <ul><li><strong>value</strong>：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<strong>默认为 undefined</strong>。</li><li><strong>writable</strong>：当且仅当该属性的writable为true时，value才能<strong>被赋值运算符改变</strong>。<strong>默认为 false</strong>。</li></ul></li><li><strong>存取描述符</strong>同时具有以下可选键值：<ul><li><strong>get</strong>：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined（<strong>默认为 undefined</strong>）。<strong>当访问该属性时，该方法会被执行</strong>，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。</li><li><strong>set</strong>：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined（<strong>默认为 undefined</strong>）。<strong>当属性值修改时，触发执行该方法</strong>。该方法将<strong>接受唯一参数</strong>，即<strong>该属性新的参数值</strong>。</li></ul></li><li>如果一个描述符不具有value, writable, get 和 set 任意一个关键字，那么它将被认为是一个<strong>数据描述符</strong>。</li><li>如果一个描述符同时有(value或writable)和(get或set)关键字，将会<strong>产生一个异常</strong>（描述符必须是这两种形式之一，<strong>不能同时是两者</strong>。）。</li><li>注意：一旦使用<code>Object.defineProperty()</code>方法给对象添加属性，那么如果<strong>不设置属性的特性</strong>，那么configurable、enumerable、writable这些值都为默认的false。</li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="创建属性"><a href="#创建属性" class="headerlink" title="创建属性"></a>创建属性</h6><ul><li>如果对象中<strong>不存在指定的属性</strong>，<code>Object.defineProperty()</code>就<strong>创建这个属性</strong>。</li><li>当描述符中省略某些字段时，这些字段将使用它们的默认值。<ul><li>拥有布尔值的字段的默认值都是false。</li><li>value，get和set字段的默认值为undefined。</li></ul></li><li>一个没有get/set/value/writable定义的属性被称为“通用的”，并被认为是一个使用了<strong>数据描述符</strong>的属性。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;; // 创建一个新对象</span><br><span class="line"></span><br><span class="line">// 在对象中添加一个属性与数据描述符的示例</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value : 37,</span><br><span class="line">  writable : <span class="literal">true</span>,</span><br><span class="line">  enumerable : <span class="literal">true</span>,</span><br><span class="line">  configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">// 对象o拥有了属性a，值为37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在对象中添加一个属性与存取描述符的示例</span><br><span class="line">var bValue;</span><br><span class="line">Object.defineProperty(o, <span class="string">"b"</span>, &#123;</span><br><span class="line">  get : <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> bValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">set</span> : <span class="keyword">function</span>(newValue)&#123;</span><br><span class="line">    bValue = newValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable : <span class="literal">true</span>,</span><br><span class="line">  configurable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">o.b = 38;</span><br><span class="line">// 对象o拥有了属性b，值为38</span><br><span class="line">// o.b的值现在总是与bValue相同，除非重新定义o.b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数据描述符和存取描述符不能混合使用</span><br><span class="line">Object.defineProperty(o, <span class="string">"conflict"</span>, &#123;</span><br><span class="line">  value: 0x9f91102, </span><br><span class="line">  get: <span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">    <span class="built_in">return</span> 0xdeadbeef; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line">// throws a TypeError: value appears only <span class="keyword">in</span> data descriptors, get appears only <span class="keyword">in</span> accessor descriptors</span><br></pre></td></tr></table></figure></li></ul><h6 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h6><ul><li>如果<strong>属性已经存在</strong>，<code>Object.defineProperty()</code>将尝试<strong>根据描述符中的值</strong>以及<strong>对象当前的配置</strong>来<strong>修改这个属性</strong>。<ul><li>如果旧描述符将其<strong>configurable 属性设置为false</strong>，则该<strong>属性被认为是“不可配置的”</strong>，并且没有属性描述符可以被改变（除了单向改变 writable 为 false）。</li><li>当属性不可配置时，不能在数据和访问器属性类型之间切换。</li></ul></li><li>当试图改变不可配置属性（除了writable 属性之外）的值时会抛出TypeError，除非当前值和新值相同。</li></ul><blockquote>Writable 属性</blockquote><ul><li><p>当writable属性设置为false时，该属性被称为“不可写”。它不能被重新分配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;; // 创建一个新对象</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: 37,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(o.a); // 37</span><br><span class="line">o.a = 25; // 不会抛出错误</span><br><span class="line">// 然而在use strict模式下会报错, 尽管当前值和新值相同</span><br><span class="line">console.log(o.a); // 37, 非可写属性不能被重新分配</span><br></pre></td></tr></table></figure></li><li><p>如示例所示，试图写入非可写属性不会改变它，也不会引发错误。</p></li></ul><blockquote>Enumerable 特性</blockquote><ul><li>enumerable定义了对象的属性是否可以在 <code>for…in</code> 循环和 <code>Object.keys()</code> 中被枚举。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123; value : 1, enumerable:<span class="literal">true</span> &#125;);</span><br><span class="line">Object.defineProperty(o, <span class="string">"b"</span>, &#123; value : 2, enumerable:<span class="literal">false</span> &#125;);</span><br><span class="line">Object.defineProperty(o, <span class="string">"c"</span>, &#123; value : 3 &#125;); // enumerable默认为<span class="literal">false</span></span><br><span class="line">o.d = 4; // 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var i <span class="keyword">in</span> o) &#123;    </span><br><span class="line">  console.log(i);  </span><br><span class="line">&#125;</span><br><span class="line">// 打印 <span class="string">'a'</span> 和 <span class="string">'d'</span> (<span class="keyword">in</span> undefined order)</span><br><span class="line"></span><br><span class="line">Object.keys(o); // [<span class="string">"a"</span>, <span class="string">"d"</span>]</span><br><span class="line"></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'a'</span>); // <span class="literal">true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'b'</span>); // <span class="literal">false</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'c'</span>); // <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>Configurable 特性</blockquote><ul><li>configurable特性表示<strong>对象的属性是否可以被删除</strong>，以及<strong>除writable特性外</strong>的<strong>其他特性是否可以被修改</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123; </span><br><span class="line">    get: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;, </span><br><span class="line">    configurable: <span class="literal">false</span> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// throws a TypeError</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;configurable : <span class="literal">true</span>&#125;); </span><br><span class="line">// throws a TypeError</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;enumerable : <span class="literal">true</span>&#125;); </span><br><span class="line">// throws a TypeError (<span class="built_in">set</span> was undefined previously) </span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;<span class="built_in">set</span> : <span class="function"><span class="title">function</span></span>()&#123;&#125;&#125;); </span><br><span class="line">// throws a TypeError (even though the new get does exactly the same thing) </span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;get : <span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> 1;&#125;&#125;);</span><br><span class="line">// throws a TypeError</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;value : 12&#125;);</span><br><span class="line"></span><br><span class="line">console.log(o.a); // logs 1</span><br><span class="line">delete o.a; // Nothing happens</span><br><span class="line">console.log(o.a); // logs 1</span><br></pre></td></tr></table></figure></li></ul><h6 id="添加多个属性和默认值"><a href="#添加多个属性和默认值" class="headerlink" title="添加多个属性和默认值"></a>添加多个属性和默认值</h6><ul><li>考虑特性被赋予的<strong>默认特性值</strong>非常重要，通常，使用点运算符和<code>Object.defineProperty()</code>为对象的属性赋值时，数据描述符中的属性默认值是不同的，如下例所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">o.a = 1;</span><br><span class="line">// 等同于 :</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value : 1,</span><br><span class="line">  writable : <span class="literal">true</span>,</span><br><span class="line">  configurable : <span class="literal">true</span>,</span><br><span class="line">  enumerable : <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 另一方面，</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123; value : 1 &#125;);</span><br><span class="line">// 等同于 :</span><br><span class="line">Object.defineProperty(o, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value : 1,</span><br><span class="line">  writable : <span class="literal">false</span>,</span><br><span class="line">  configurable : <span class="literal">false</span>,</span><br><span class="line">  enumerable : <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h6 id="一般的-Setters-和-Getters"><a href="#一般的-Setters-和-Getters" class="headerlink" title="一般的 Setters 和 Getters"></a>一般的 Setters 和 Getters</h6><ul><li><p>下面的例子展示了如何实现一个自存档对象。 当设置temperature 属性时，archive 数组会获取日志条目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Archiver</span></span>() &#123;</span><br><span class="line">    var temperature = null;</span><br><span class="line">    var archive = [];</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(this, <span class="string">'temperature'</span>, &#123;</span><br><span class="line">        get: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'get!'</span>);</span><br><span class="line">            <span class="built_in">return</span> temperature;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">set</span>: <span class="keyword">function</span>(value) &#123;</span><br><span class="line">            temperature = value;</span><br><span class="line">            archive.push(&#123; val: temperature &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    this.getArchive = <span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">        <span class="built_in">return</span> archive; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arc = new Archiver();</span><br><span class="line">arc.temperature; // <span class="string">'get!'</span></span><br><span class="line">arc.temperature = 11;</span><br><span class="line">arc.temperature = 13;</span><br><span class="line">arc.getArchive(); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span><br></pre></td></tr></table></figure></li><li><p>另一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var pattern = &#123;</span><br><span class="line">    get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'I alway return this string, whatever you have assigned'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        this.myname = <span class="string">'this is my name string'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">TestDefineSetAndGet</span></span>() &#123;</span><br><span class="line">    Object.defineProperty(this, <span class="string">'myproperty'</span>, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance = new TestDefineSetAndGet();</span><br><span class="line">instance.myproperty = <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line">console.log(instance.myproperty);</span><br><span class="line">// <span class="string">'I alway return this string, whatever you have assigned'</span></span><br><span class="line"></span><br><span class="line">console.log(instance.myname);</span><br><span class="line">// <span class="string">'this is my name string'</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h4><ul><li>Object对象有一个freeze方法，也用于实现对象属性和方法的不可更改：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用方法：</span><br><span class="line">const arr = [1,2,3,4];</span><br><span class="line">Object.freeze(arr);  // 变量arr不可更改</span><br><span class="line">arr.push(5);  // 报错：不能添加属性</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对象是由多个&lt;strong&gt;键/值对&lt;/strong&gt;组成的&lt;strong&gt;无序的集合&lt;/strong&gt;。对象中&lt;strong&gt;每个属性&lt;/strong&gt;对应&lt;strong&gt;任意类型的值&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义对象可以使用构造函数或字面量的形式：&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="Object" scheme="https://chongtianhong.github.io/tags/Object/"/>
    
      <category term="defineProperty" scheme="https://chongtianhong.github.io/tags/defineProperty/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中获取时间new Date()方法小结</title>
    <link href="https://chongtianhong.github.io/2018/04/19/newDate/"/>
    <id>https://chongtianhong.github.io/2018/04/19/newDate/</id>
    <published>2018-04-19T08:07:41.000Z</published>
    <updated>2018-07-30T14:28:09.297Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>Date 对象用于处理日期和时间。</li><li>创建 Date 对象的语法：<code>new Date()</code><a id="more"></a></li><li><p>以下四种方法同样可以创建 Date 对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date(); // Date 对象会自动把当前日期和时间保存为其初始值</span><br><span class="line">var d = new Date(milliseconds); // 1524126419000</span><br><span class="line">var d = new Date(dateString); // <span class="string">"2018-04-19"</span></span><br><span class="line">var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);</span><br></pre></td></tr></table></figure></li><li><p>自动获取今天星期几：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dayMap = <span class="string">'日一二三四五六'</span>.split(<span class="string">""</span>);</span><br><span class="line">dayMap[new Date().getDay()] // <span class="string">"四"</span></span><br></pre></td></tr></table></figure></li><li><p>获取今天日期格式（—-年–月–日）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myDate = new Date();</span><br><span class="line">myDate.getFullYear() + <span class="string">'年'</span>+ (myDate.getMonth() + 1) + <span class="string">'月'</span> + myDate.getDate() + <span class="string">'日'</span>   </span><br><span class="line">// <span class="string">"2018年4月19日"</span></span><br></pre></td></tr></table></figure></li><li><p>详解 Date 对象包含的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myDate = new Date();</span><br><span class="line">myDate.getFullYear();    // 从 Date 对象以四位数字返回年份。</span><br><span class="line">myDate.getMonth();       // 从 Date 对象返回月份 (0 ~ 11)。</span><br><span class="line">myDate.getDate();        // 从 Date 对象返回一个月中的某一天 (1 ~ 31)。</span><br><span class="line">myDate.getFullYear()+<span class="string">'年'</span>+(myDate.getMonth()+1)+<span class="string">'月'</span>+myDate.getDate()+<span class="string">'日'</span>;     // <span class="string">"2018年4月19日"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myDate.getDay();                        // 从 Date 对象返回一周中的某一天 (0 ~ 6)。</span><br><span class="line">myDate.getTime();                       // 返回 1970 年 1 月 1 日至今的毫秒数(时间戳)</span><br><span class="line">myDate.getHours();                      // 返回 Date 对象的小时 (0 ~ 23)。</span><br><span class="line">myDate.getMinutes();                    // 返回 Date 对象的分钟 (0 ~ 59)。</span><br><span class="line">myDate.getSeconds();                    // 返回 Date 对象的秒数 (0 ~ 59)。</span><br><span class="line">myDate.getMilliseconds();               // 返回 Date 对象的毫秒(0 ~ 999)。</span><br><span class="line">myDate.toLocaleDateString();            // 根据本地时间格式，把 Date 对象的日期部分转换为字符，如： <span class="string">"2018/4/19"</span></span><br><span class="line">var mytime=myDate.toLocaleTimeString(); // 根据本地时间格式，把 Date 对象的时间部分转换为字符串，如：<span class="string">"下午4:15:47"</span></span><br><span class="line">myDate.toLocaleString( );               // 根据本地时间格式，把 Date 对象转换为字符串，如：<span class="string">"2018/4/19 下午4:15:47"</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="JS获取当前时间戳的方法"><a href="#JS获取当前时间戳的方法" class="headerlink" title="JS获取当前时间戳的方法"></a>JS获取当前时间戳的方法</h4><ul><li><p>第一种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timestamp = Date.parse(new Date()); // 1524126419000</span><br></pre></td></tr></table></figure></li><li><p>第二种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timestamp = (new Date()).valueOf(); // 1524126419696</span><br></pre></td></tr></table></figure></li><li><p>第三种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timestamp = new Date().getTime(); // 1524126419696</span><br></pre></td></tr></table></figure></li><li><p>区别：</p><ul><li>第一种：获取的时间戳是把毫秒改成000显示，即<strong>精确到秒</strong>。</li><li>第二种和第三种是获取了<strong>当前毫秒</strong>的时间戳。</li></ul></li><li>可以用第二种或第三种方法<strong>计算时间差</strong>。</li><li>在JavaScript中单独调用new Date()，例如<code>document.write(new Date());</code>，显示的结果是：<code>Thu Apr 19 2018 16:32:10 GMT+0800 (中国标准时间)</code> 这种格式的时间，但是<strong>用new Date() 参与计算时</strong>，会<strong>自动转换为</strong>从1970.1.1开始的<strong>毫秒数</strong>。</li><li>再看以下例子，用于将字符串形式的日期转换成日期对象：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var strTime = <span class="string">"2018-04-19"</span>;  //字符串日期格式           </span><br><span class="line">var date = new Date(Date.parse(strTime.replace(/-/g, <span class="string">"/"</span>))); // 转换成Data();</span><br><span class="line">var month = date.getMonth() + 1; //获取当前月份</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Date 对象用于处理日期和时间。&lt;/li&gt;
&lt;li&gt;创建 Date 对象的语法：&lt;code&gt;new Date()&lt;/code&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Date" scheme="https://chongtianhong.github.io/tags/Date/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中filter的用法</title>
    <link href="https://chongtianhong.github.io/2018/04/18/filter/"/>
    <id>https://chongtianhong.github.io/2018/04/18/filter/</id>
    <published>2018-04-18T07:37:48.000Z</published>
    <updated>2018-07-30T14:28:09.202Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li><li>filter是数组的一个常用的操作，它用于<strong>把Array的某些元素过滤掉</strong>，然后<strong>返回剩下的元素</strong>。</li><li><strong>注意</strong>： filter() <strong>不会对空数组进行检测</strong>。</li><li><strong>注意</strong>： filter() <strong>不会改变原始数组</strong>。<a id="more"></a></li><li>和map()类似，Array的filter()也接收一个函数。</li><li>和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</li><li><p>例如，在一个Array中，<strong>删掉偶数，只保留奇数</strong>，可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 4, 5, 6, 9, 10, 15];</span><br><span class="line">var result = arr.filter(<span class="keyword">function</span> (x) &#123;</span><br><span class="line">    <span class="built_in">return</span> x % 2 !== 0;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // [1, 5, 9, 15]</span><br></pre></td></tr></table></figure></li><li><p>把一个Array中的空字符串删掉，可以这么写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, null, undefined, <span class="string">'C'</span>, <span class="string">'  '</span>];</span><br><span class="line">var result = arr.filter(<span class="keyword">function</span> (s) &#123;</span><br><span class="line">    <span class="built_in">return</span> s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br></pre></td></tr></table></figure></li><li><p>可见，用filter()这个<strong>高阶函数</strong>，关键在于正确实现一个<strong>“筛选”函数</strong>。</p></li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><ul><li>filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示<strong>Array的某个元素</strong>。回调函数还可以接收另外两个参数，表示<strong>元素的位置</strong>和<strong>数组本身</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">var r = arr.filter(<span class="keyword">function</span> (element, index, self) &#123;</span><br><span class="line">    console.log(element); // 依次打印<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span></span><br><span class="line">    console.log(index); // 依次打印0, 1, 2</span><br><span class="line">    console.log(self); // self就是变量arr</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote>去除Array的重复元素</blockquote><ul><li><p>利用filter，可以巧妙地去除Array的重复元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">var result;</span><br><span class="line">var arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">result = arr.filter(<span class="keyword">function</span> (element, index, self) &#123;</span><br><span class="line">    <span class="built_in">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result.toString()); // <span class="string">"apple,strawberry,banana,pear,orange"</span></span><br></pre></td></tr></table></figure></li><li><p>去除重复元素依靠的是<strong>indexOf总是返回第一个元素的位置</strong>，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。</p></li></ul><blockquote>筛选出素数</blockquote><ul><li><p>可以尝试用filter()筛选出素数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> get_primes(arr) &#123;</span><br><span class="line">    var i;</span><br><span class="line">    <span class="built_in">return</span> arr.filter(<span class="keyword">function</span>(element) &#123;  </span><br><span class="line">            var flag = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span>(element &lt; 2)&#123;  </span><br><span class="line">            flag = <span class="literal">false</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span>(var i = 2; i &lt; element; i++)&#123;  </span><br><span class="line">                <span class="keyword">if</span> (element % i == 0)&#123;  </span><br><span class="line">                    flag = <span class="literal">false</span>;  </span><br><span class="line">                    <span class="built_in">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">return</span> flag;  </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试:</span><br><span class="line">var result;</span><br><span class="line">var arr = [];</span><br><span class="line"><span class="keyword">for</span> (var x = 1; x &lt; 100; x++) &#123;</span><br><span class="line">    arr.push(x);</span><br><span class="line">&#125;</span><br><span class="line">result = get_primes(arr);</span><br><span class="line"><span class="keyword">if</span> (result.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) &#123;</span><br><span class="line">    console.log(<span class="string">'测试通过!'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    console.log(<span class="string">'测试失败: '</span> + result.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试通过!</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。&lt;/li&gt;
&lt;li&gt;filter是数组的一个常用的操作，它用于&lt;strong&gt;把Array的某些元素过滤掉&lt;/strong&gt;，然后&lt;strong&gt;返回剩下的元素&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;： filter() &lt;strong&gt;不会对空数组进行检测&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;： filter() &lt;strong&gt;不会改变原始数组&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Array" scheme="https://chongtianhong.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常用实例的实现与封装</title>
    <link href="https://chongtianhong.github.io/2018/04/17/commonInstancesOfJS/"/>
    <id>https://chongtianhong.github.io/2018/04/17/commonInstancesOfJS/</id>
    <published>2018-04-17T02:24:47.000Z</published>
    <updated>2018-08-01T15:17:55.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>在开发的过程中，会遇到很多常见的实例操作。比如<strong>数组去重</strong>，<strong>关键词高亮</strong>，<strong>打乱数组</strong>等。</li><li>这些操作，代码一般不会很多，实现的逻辑也不会很难，如果重复写的话，会造成代码冗余，开发效率也不用。</li><li>为了实现复用，可以<strong>把一些常见的操作封装成函数</strong>存放在工具类集合utils.js中，需要调用的时候，引入工具包调用对应的方法即可。<a id="more"></a></li></ul><blockquote><br>1. 下面代码，均使用es5版本实现。<br>2. 下面的代码，都是存放在工具类集合utils.js中，在对应的js文件中使用require引入模块，然后使用utils.[方法名]调用方法。<br></blockquote><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><h5 id="去除字符串空格"><a href="#去除字符串空格" class="headerlink" title="去除字符串空格"></a>去除字符串空格</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 去除空格  <span class="built_in">type</span> 1-所有空格  2-前后空格  3-前空格 4-后空格</span><br><span class="line">*  utils.trim(<span class="string">'  1235asd'</span>,1)</span><br><span class="line">*  result：<span class="string">'1235asd'</span></span><br><span class="line">*/ 这个方法有原生的方案代替，但是考虑到有时候开发PC站需要兼容IE8，所以就还是继续保留</span><br><span class="line"><span class="keyword">function</span> trim(str, <span class="built_in">type</span>) &#123;</span><br><span class="line">    switch (<span class="built_in">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> 1:</span><br><span class="line">            <span class="built_in">return</span> str.replace(/\s+/g, <span class="string">""</span>); // 所有空格</span><br><span class="line">        <span class="keyword">case</span> 2:</span><br><span class="line">            <span class="built_in">return</span> str.replace(/(^\s*)|(\s*$)/g, <span class="string">""</span>); // 前后空格</span><br><span class="line">        <span class="keyword">case</span> 3:</span><br><span class="line">            <span class="built_in">return</span> str.replace(/(^\s*)/g, <span class="string">""</span>); // 前空格</span><br><span class="line">        <span class="keyword">case</span> 4:</span><br><span class="line">            <span class="built_in">return</span> str.replace(/(\s*$)/g, <span class="string">""</span>); // 后空格</span><br><span class="line">        default:</span><br><span class="line">            <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字母大小写切换"><a href="#字母大小写切换" class="headerlink" title="字母大小写切换"></a>字母大小写切换</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="built_in">type</span></span><br><span class="line">* 1: 首字母大写</span><br><span class="line">* 2：首页母小写</span><br><span class="line">* 3：大小写转换</span><br><span class="line">* 4：全部大写</span><br><span class="line">* 5：全部小写</span><br><span class="line">*/</span><br><span class="line">// utils.changeCase(<span class="string">'asdasd'</span>,1)</span><br><span class="line">// result：<span class="string">'Asdasd'</span></span><br><span class="line"><span class="keyword">function</span> changeCase(str, <span class="built_in">type</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> ToggleCase(str) &#123; // 大小写转换</span><br><span class="line">        var itemText = <span class="string">""</span></span><br><span class="line">        str.split(<span class="string">""</span>).forEach(</span><br><span class="line">            <span class="keyword">function</span> (item) &#123;</span><br><span class="line">                <span class="keyword">if</span> (/^([a-z]+)/.<span class="built_in">test</span>(item)) &#123;</span><br><span class="line">                    itemText += item.toUpperCase();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (/^([A-Z]+)/.<span class="built_in">test</span>(item)) &#123;</span><br><span class="line">                    itemText += item.toLowerCase();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    itemText += item;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="built_in">return</span> itemText;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (<span class="built_in">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> 1: // 首字母大写</span><br><span class="line">            <span class="built_in">return</span> str.replace(/\b\w+\b/g, <span class="keyword">function</span> (word) &#123; // \b匹配的是字之间的看不见的边界,每个单词前后都有 \b</span><br><span class="line">                <span class="built_in">return</span> word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">case</span> 2: // 首页母小写</span><br><span class="line">            <span class="built_in">return</span> str.replace(/\b\w+\b/g, <span class="keyword">function</span> (word) &#123;</span><br><span class="line">                <span class="built_in">return</span> word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">case</span> 3: // 大小写转换</span><br><span class="line">            <span class="built_in">return</span> ToggleCase(str);</span><br><span class="line">        <span class="keyword">case</span> 4: // 全部大写</span><br><span class="line">            <span class="built_in">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">case</span> 5: // 全部小写</span><br><span class="line">            <span class="built_in">return</span> str.toLowerCase();</span><br><span class="line">        default:</span><br><span class="line">            <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符串循环复制"><a href="#字符串循环复制" class="headerlink" title="字符串循环复制"></a>字符串循环复制</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* repeatStr(str-&gt;字符串, count-&gt;次数)</span><br><span class="line">*  utils.repeatStr(<span class="string">'123'</span>,3)</span><br><span class="line">*/ result：<span class="string">'123123123'</span></span><br><span class="line"><span class="keyword">function</span> repeatStr(str, count) &#123;</span><br><span class="line">    var text = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        text += str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//utils.replaceAll(<span class="string">'这里是上海，中国第三大城市，广东省省会，简称穗，'</span>,<span class="string">'上海'</span>,<span class="string">'广州'</span>)</span><br><span class="line">//result：<span class="string">'这里是广州，中国第三大城市，广东省省会，简称穗，'</span></span><br><span class="line"><span class="keyword">function</span> replaceAll(str, AFindText, ARepText) &#123;</span><br><span class="line">    raRegExp = new RegExp(AFindText, <span class="string">"g"</span>);</span><br><span class="line">    <span class="built_in">return</span> str.replace(raRegExp, ARepText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="检测字符串"><a href="#检测字符串" class="headerlink" title="检测字符串"></a>检测字符串</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 检测字符串</span><br><span class="line">*  utils.checkType(<span class="string">'165226226326'</span>,<span class="string">'Phone'</span>)</span><br><span class="line">*/ result：<span class="literal">false</span></span><br><span class="line"><span class="keyword">function</span> checkType(str, <span class="built_in">type</span>) &#123;</span><br><span class="line">    switch (<span class="built_in">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Email'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Phone'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'tel'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Number'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^[0-9]$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'English'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^[a-zA-Z]+$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Text'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^\w+$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Chinese'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^[\u4E00-\u9FA5]+$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Lower'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^[a-z]+$/.<span class="built_in">test</span>(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'Upper'</span>:</span><br><span class="line">            <span class="built_in">return</span> /^[A-Z]+$/.<span class="built_in">test</span>(str);</span><br><span class="line">        default:</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="检测密码强度"><a href="#检测密码强度" class="headerlink" title="检测密码强度"></a>检测密码强度</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// utils.checkPwd(<span class="string">'12asdASAD'</span>)</span><br><span class="line">// result：3(强度等级为3)</span><br><span class="line"><span class="keyword">function</span> checkPwd(str) &#123;</span><br><span class="line">    var nowLv = 0;</span><br><span class="line">    <span class="keyword">if</span> (str.length &lt; 6) &#123;</span><br><span class="line">        <span class="built_in">return</span> nowLv</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (/[0-9]/.<span class="built_in">test</span>(str)) &#123;</span><br><span class="line">        nowLv++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (/[a-z]/.<span class="built_in">test</span>(str)) &#123;</span><br><span class="line">        nowLv++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (/[A-Z]/.<span class="built_in">test</span>(str)) &#123;</span><br><span class="line">        nowLv++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (/[\.|-|_]/.<span class="built_in">test</span>(str)) &#123;</span><br><span class="line">        nowLv++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> nowLv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="生成随机码"><a href="#生成随机码" class="headerlink" title="生成随机码"></a>生成随机码</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* count取值范围0-36</span><br><span class="line">*  utils.randomWord(10)</span><br><span class="line">*  result：<span class="string">"2584316588472575"</span></span><br><span class="line">*  utils.randomWord(14)</span><br><span class="line">*  result：<span class="string">"9b405070dd00122640c192caab84537"</span></span><br><span class="line">*  utils.randomWord(36)</span><br><span class="line">*/ result：<span class="string">"83vhdx10rmjkyb9"</span></span><br><span class="line"><span class="keyword">function</span> randomWord(count) &#123;</span><br><span class="line">    <span class="built_in">return</span> Math.random().toString(count).substring(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="计算特定字符串在长字符串中的出现次数"><a href="#计算特定字符串在长字符串中的出现次数" class="headerlink" title="计算特定字符串在长字符串中的出现次数"></a>计算特定字符串在长字符串中的出现次数</h5><ul><li>例如：需要在字符串’sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967’中找出’blog’的出现次数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* var strTest=<span class="string">'sad44654blog5a1sd67as9dablog4s5d16zxc4sdweasjkblogwqepaskdkblogahseiuadbhjcibloguyeajzxkcabloguyiwezxc967'</span></span><br><span class="line">*  utils.countStr(strTest,<span class="string">'blog'</span>)</span><br><span class="line">*/ result：6</span><br><span class="line"><span class="keyword">function</span> countStr(str, strSplit) &#123;</span><br><span class="line">    <span class="built_in">return</span> str.split(strSplit).length - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="格式化处理字符串"><a href="#格式化处理字符串" class="headerlink" title="格式化处理字符串"></a>格式化处理字符串</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* utils.formatText(<span class="string">'1234asda567asd890'</span>)</span><br><span class="line">*  result：<span class="string">"12,34a,sda,567,asd,890"</span></span><br><span class="line">*  utils.formatText(<span class="string">'1234asda567asd890'</span>, 4, <span class="string">' '</span>)</span><br><span class="line">*  result：<span class="string">"1 234a sda5 67as d890"</span></span><br><span class="line">*  utils.formatText(<span class="string">'1234asda567asd890'</span>, 4, <span class="string">'-'</span>)</span><br><span class="line">*/ result：<span class="string">"1-234a-sda5-67as-d890"</span></span><br><span class="line"><span class="keyword">function</span> formatText(str, size, delimiter) &#123;</span><br><span class="line">    var _size = size || 3;</span><br><span class="line">    var _delimiter = delimiter || <span class="string">','</span>;</span><br><span class="line">    var regText = <span class="string">'\\B(?=(\\w&#123;'</span> + _size + <span class="string">'&#125;)+(?!\\w))'</span>;</span><br><span class="line">    var reg = new RegExp(regText, <span class="string">'g'</span>);</span><br><span class="line">    <span class="built_in">return</span> str.replace(reg, _delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="找出最长单词"><a href="#找出最长单词" class="headerlink" title="找出最长单词"></a>找出最长单词</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* utils.longestWord(<span class="string">'Find the Longest word in a String'</span>)</span><br><span class="line">*  result：&#123;el:<span class="string">'Longest'</span>, max:7&#125;;</span><br><span class="line">*  utils.longestWord(<span class="string">'Find|the|Longest|word|in|a|String'</span>,<span class="string">'|'</span>)</span><br><span class="line">*/ result：&#123;el:<span class="string">'Longest'</span>, max:7&#125;;</span><br><span class="line"><span class="keyword">function</span> longestWord(str, splitType) &#123;</span><br><span class="line">    var _splitType = splitType || /\s+/g,</span><br><span class="line">        _max = 0, _item=<span class="string">''</span>;</span><br><span class="line">    var strArr = str.split(_splitType);</span><br><span class="line">    strArr.forEach(<span class="keyword">function</span> (item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_max &lt; item.length) &#123;</span><br><span class="line">            _max = item.length</span><br><span class="line">            _item=item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">return</span> &#123;el: _item, max:_max&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="句中每个单词首字母大写"><a href="#句中每个单词首字母大写" class="headerlink" title="句中每个单词首字母大写"></a>句中每个单词首字母大写</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* utils.titleCaseUp(<span class="string">'this is a title'</span>)</span><br><span class="line">*/ result: <span class="string">"This Is A Title"</span></span><br><span class="line"><span class="keyword">function</span> titleCaseUp(str, splitType) &#123;</span><br><span class="line">    var _splitType = splitType || /\s+/g;</span><br><span class="line">    var strArr = str.split(_splitType),</span><br><span class="line">        result = <span class="string">""</span>, _this = this</span><br><span class="line">    strArr.forEach(<span class="keyword">function</span> (item) &#123;</span><br><span class="line">        result += _this.changeCase(item, 1) + <span class="string">' '</span>; // 首字母大写</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">return</span> this.trim(result, 4) // 去除字符串后空格 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> removeRepeatArray(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.filter(<span class="keyword">function</span> (item, index, self) &#123;</span><br><span class="line">        <span class="built_in">return</span> self.indexOf(item) === index;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组顺序打乱"><a href="#数组顺序打乱" class="headerlink" title="数组顺序打乱"></a>数组顺序打乱</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> upsetArr(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.sort(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> Math.random() - 0.5; // 负：位置不变，正：交换顺序</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组最大值最小值"><a href="#数组最大值最小值" class="headerlink" title="数组最大值最小值"></a>数组最大值最小值</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//数组最大值</span><br><span class="line"><span class="keyword">function</span> maxArr(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> Math.max.apply(null, arr);</span><br><span class="line">&#125;,</span><br><span class="line">//数组最小值</span><br><span class="line"><span class="keyword">function</span> minArr(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> Math.min.apply(null, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组求和，平均值"><a href="#数组求和，平均值" class="headerlink" title="数组求和，平均值"></a>数组求和，平均值</h5><ul><li>这一块的封装，主要是针对数字类型的数组:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 求和</span><br><span class="line"><span class="keyword">function</span> sumArr(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.reduce(<span class="keyword">function</span>(pre, cur) &#123;</span><br><span class="line">        <span class="built_in">return</span> pre + cur</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求数组平均值</span><br><span class="line"><span class="keyword">function</span> covArr(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> this.sumArr(arr) / arr.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="从数组中随机获取元素"><a href="#从数组中随机获取元素" class="headerlink" title="从数组中随机获取元素"></a>从数组中随机获取元素</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* utils.randomOne([1,2,3,6,8,5,4,2,6])</span><br><span class="line">*  result: 2</span><br><span class="line">*  utils.randomOne([1,2,3,6,8,5,4,2,6])</span><br><span class="line">*  result: 8</span><br><span class="line">*  utils.randomOne([1,2,3,6,8,5,4,2,6])</span><br><span class="line">*  result: 8</span><br><span class="line">*  utils.randomOne([1,2,3,6,8,5,4,2,6])</span><br><span class="line">*/ result: 1</span><br><span class="line"><span class="keyword">function</span> randomOne(arr) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr[Math.floor(Math.random() * arr.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="返回数组（字符串）一个元素出现的次数"><a href="#返回数组（字符串）一个元素出现的次数" class="headerlink" title="返回数组（字符串）一个元素出现的次数"></a>返回数组（字符串）一个元素出现的次数</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* utils.getEleCount(<span class="string">'asd56+asdasdwqe'</span>, <span class="string">'a'</span>)</span><br><span class="line">*  result：3</span><br><span class="line">*  utils.getEleCount([1, 2, 3, 4, 5, 66, 77, 22, 55, 22], 22)</span><br><span class="line">*/ result：2</span><br><span class="line"><span class="keyword">function</span> getEleCount(obj, ele) &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    var len = obj.length;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ele === obj[i]) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="得到n1-n2下标的数组"><a href="#得到n1-n2下标的数组" class="headerlink" title="得到n1-n2下标的数组"></a>得到n1-n2下标的数组</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* utils.getArrayNum([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 5, 9)</span><br><span class="line">*  result：[5, 6, 7, 8, 9]</span><br><span class="line">*  getArrayNum([0,1,2,3,4,5,6,7,8,9],2) //不传第二个参数, 默认返回从n1到数组结束的元素</span><br><span class="line">*/ result：[2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"><span class="keyword">function</span> getArrayNum(arr, n1, n2) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.slice(n1, n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除值为val的数组元素"><a href="#删除值为val的数组元素" class="headerlink" title="删除值为val的数组元素"></a>删除值为val的数组元素</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 数组元素的值含有<span class="string">'test'</span>的都删除</span><br><span class="line">*  utils.removeArrayForValue([<span class="string">'test'</span>,<span class="string">'test1'</span>,<span class="string">'test2'</span>,<span class="string">'test'</span>,<span class="string">'aaa'</span>],<span class="string">'test'</span>, <span class="string">'1'</span>)</span><br><span class="line">*  result：[<span class="string">"aaa"</span>]   </span><br><span class="line">*  数组元素的值全等于<span class="string">'test'</span>才被删除</span><br><span class="line">*  utils.removeArrayForValue([<span class="string">'test'</span>,<span class="string">'test1'</span>,<span class="string">'test2'</span>,<span class="string">'test'</span>,<span class="string">'aaa'</span>],<span class="string">'test'</span>)</span><br><span class="line">*/ result：[<span class="string">"test1"</span>, <span class="string">"test2"</span>, <span class="string">"aaa"</span>]</span><br><span class="line"><span class="keyword">function</span> removeArrayForValue(arr, val, <span class="built_in">type</span>) &#123;</span><br><span class="line">    <span class="built_in">return</span> arr.filter(<span class="keyword">function</span> (item) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">type</span> ? item.indexOf(val) === -1 : item !== val</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* utils.steamroller([1,2,[4,5,[1,23]]])</span><br><span class="line">*/ result: [1, 2, 4, 5, 1, 23]</span><br><span class="line"><span class="keyword">function</span> steamroller(arr) &#123;</span><br><span class="line">    var newArr = [],  _this = this;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Array.isArray(arr[i])) &#123;</span><br><span class="line">            // 如果是数组，调用(递归)steamroller 将其扁平化</span><br><span class="line">            // 然后再 push 到 newArr 中</span><br><span class="line">            newArr.push.apply(newArr, _this.steamroller(arr[i]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // 不是数组直接 push 到 newArr 中</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><h5 id="cookie的设置、获取和删除"><a href="#cookie的设置、获取和删除" class="headerlink" title="cookie的设置、获取和删除"></a>cookie的设置、获取和删除</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 设置cookie</span><br><span class="line"><span class="keyword">function</span> setCookie(name, value, iDay) &#123;</span><br><span class="line">    var oDate = new Date();</span><br><span class="line">    oDate.setDate(oDate.getDate() + iDay);</span><br><span class="line">    document.cookie = name + <span class="string">'='</span> + value + <span class="string">';expires='</span> + oDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取cookie</span><br><span class="line"><span class="keyword">function</span> getCookie(name) &#123;</span><br><span class="line">    var arr = document.cookie.split(<span class="string">';'</span>);</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var arr2 = arr[i].split(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr2[0] == name) &#123;</span><br><span class="line">            <span class="built_in">return</span> arr2[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除cookie</span><br><span class="line"><span class="keyword">function</span> removeCookie(name) &#123;</span><br><span class="line">    this.setCookie(name, 1, -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="清除对象中值为空的属性"><a href="#清除对象中值为空的属性" class="headerlink" title="清除对象中值为空的属性"></a>清除对象中值为空的属性</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* utils.filterParams(&#123;a: <span class="string">""</span>, b: null, c: <span class="string">"010"</span>, d: 123&#125;)</span><br><span class="line">*/ Object &#123;c: <span class="string">"010"</span>, d: 123&#125;</span><br><span class="line"><span class="keyword">function</span> filterParams(obj) &#123;</span><br><span class="line">    var _newPar = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (var key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj[key] === 0 || obj[key] === <span class="literal">false</span> || obj[key]) &amp;&amp; obj[key].toString().replace(/(^\s*)|(\s*$)/g, <span class="string">''</span>) !== <span class="string">''</span>) &#123;</span><br><span class="line">            _newPar[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> _newPar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="随机返回一个范围的数字"><a href="#随机返回一个范围的数字" class="headerlink" title="随机返回一个范围的数字"></a>随机返回一个范围的数字</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* utils.randomNumber(5, 10)</span><br><span class="line">*  返回5-10的随机整数，包括5，10</span><br><span class="line">*  utils.randomNumber(10)</span><br><span class="line">*  返回0-10的随机整数，包括0，10</span><br><span class="line">*  utils.randomNumber()</span><br><span class="line">*/ 返回0-255的随机整数，包括0，255</span><br><span class="line">randomNumber: <span class="keyword">function</span> (n1, n2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arguments.length === 2) &#123;</span><br><span class="line">        <span class="built_in">return</span> Math.round(n1 + Math.random() * (n2 - n1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === 1) &#123;</span><br><span class="line">        <span class="built_in">return</span> Math.round(Math.random() * n1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> Math.round(Math.random() * 255)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Date日期时间部分"><a href="#Date日期时间部分" class="headerlink" title="Date日期时间部分"></a>Date日期时间部分</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 到某一个时间的倒计时</span><br><span class="line">*  utils.getEndTime(<span class="string">'2018/4/22 16:0:0'</span>)</span><br><span class="line">*/ result：<span class="string">"剩余时间5天 5小时 35 分钟13 秒"</span></span><br><span class="line"><span class="keyword">function</span> getEndTime(endTime) &#123;</span><br><span class="line">    var startDate = new Date(); // 开始时间，当前时间 2018/4/17 10:24:47</span><br><span class="line">    var endDate = new Date(endTime); // 结束时间，需传入时间参数</span><br><span class="line">    var t = endDate.getTime() - startDate.getTime(); // 时间差的毫秒数</span><br><span class="line">    var d = 0,</span><br><span class="line">        h = 0,</span><br><span class="line">        m = 0,</span><br><span class="line">        s = 0;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= 0) &#123;</span><br><span class="line">        d = Math.floor(t / 1000 / 3600 / 24);</span><br><span class="line">        h = Math.floor(t / 1000 / 60 / 60 % 24);</span><br><span class="line">        m = Math.floor(t / 1000 / 60 % 60);</span><br><span class="line">        s = Math.floor(t / 1000 % 60);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"剩余时间"</span> + d + <span class="string">"天 "</span> + h + <span class="string">"小时 "</span> + m + <span class="string">" 分钟"</span> + s + <span class="string">" 秒"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="手机类型判断"><a href="#手机类型判断" class="headerlink" title="手机类型判断"></a>手机类型判断</h5> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> browserInfo(<span class="built_in">type</span>) &#123;</span><br><span class="line">    switch (<span class="built_in">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'android'</span>:</span><br><span class="line">            <span class="built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="string">'android'</span>) !== -1</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'iphone'</span>:</span><br><span class="line">            <span class="built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="string">'iphone'</span>) !== -1</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'ipad'</span>:</span><br><span class="line">            <span class="built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="string">'ipad'</span>) !== -1</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'weixin'</span>:</span><br><span class="line">            <span class="built_in">return</span> navigator.userAgent.toLowerCase().indexOf(<span class="string">'micromessenger'</span>) !== -1</span><br><span class="line">        default:</span><br><span class="line">            <span class="built_in">return</span> navigator.userAgent.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在开发的过程中，会遇到很多常见的实例操作。比如&lt;strong&gt;数组去重&lt;/strong&gt;，&lt;strong&gt;关键词高亮&lt;/strong&gt;，&lt;strong&gt;打乱数组&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;这些操作，代码一般不会很多，实现的逻辑也不会很难，如果重复写的话，会造成代码冗余，开发效率也不用。&lt;/li&gt;
&lt;li&gt;为了实现复用，可以&lt;strong&gt;把一些常见的操作封装成函数&lt;/strong&gt;存放在工具类集合utils.js中，需要调用的时候，引入工具包调用对应的方法即可。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="封装" scheme="https://chongtianhong.github.io/tags/%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>内存缓存和硬盘缓存的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/16/fromCacheType/"/>
    <id>https://chongtianhong.github.io/2018/04/16/fromCacheType/</id>
    <published>2018-04-16T08:37:51.000Z</published>
    <updated>2018-07-29T09:10:46.667Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>在Chrome浏览器中的控制台Network中size栏通常会有<strong>三种状态</strong>: <ul><li><strong>from memory cache</strong></li><li><strong>from disk cache</strong></li><li><strong>资源本身的大小</strong>(如：1.5k)<a id="more"></a></li></ul></li><li><strong>from memory cache</strong>代表使用内存中的缓存，<strong>from disk cache</strong>则代表使用的是硬盘中的缓存，浏览器读取<strong>命中强缓存资源</strong>的顺序为<strong>memory –&gt; disk</strong>：<ul><li>先去内存看，如果有，直接加载；</li><li>如果内存没有，则取硬盘获取，如果有直接加载；</li><li>如果硬盘也没有，那么就进行网络请求；</li><li>加载到的资源缓存到硬盘和内存。</li></ul></li></ul><h4 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h4><blockquote>from memory cache</blockquote><ul><li>from memory cache代表<strong>使用内存中的缓存</strong>，即请求的资源是直接从内存中拿到的，不会请求服务器。</li><li>一般已经加载过该资源且资源已经缓存在了内存当中，<strong>当关闭该页面时，此资源就被内存释放掉了</strong>，<strong>再次重新打开相同页面时不会出现from memory cache的情况</strong>。</li><li><strong>内存缓存(from memory cache)</strong>：内存缓存具有两个特点，分别是<strong>快速读取</strong>和<strong>时效性</strong>：<ul><li><strong>快速读取</strong>：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li><strong>时效性</strong>：一旦该进程关闭，则该进程的内存则会清空。</li></ul></li></ul><blockquote>from disk cache</blockquote><ul><li>from disk cache表示此资源是从<strong>磁盘</strong>当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器。但<strong>此资源不会随着该页面的关闭而释放掉</strong>，因为是存在硬盘当中的，下次打开仍会出现from disk cache的情况。</li><li><strong>硬盘缓存(from disk cache</strong>)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，<strong>速度比内存缓存慢</strong>。</li></ul><blockquote>资源本身大小数值</blockquote><ul><li>当HTTP状态码为200时，资源是实实在在从服务器请求后获取得到的（不是缓存数据），该数字是资源本身的大小；</li><li>当HTTP状态码为304时，该数字是<strong>与服务端通信报文的大小</strong>，并<strong>不是该资源本身的大小</strong>，该资源是从本地获取的（协商缓存）。</li></ul><h4 id="Chrome采取措施的准则"><a href="#Chrome采取措施的准则" class="headerlink" title="Chrome采取措施的准则"></a>Chrome采取措施的准则</h4><ul><li>如下表所示：</li></ul><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">200</td><td style="text-align:center">from memory cache</td><td style="text-align:center">不请求网络资源，资源在内存当中，一般<code>脚本</code>、<code>字体</code>、<code>图片</code>会存在内存当中</td></tr><tr><td style="text-align:center">200</td><td style="text-align:center">from disk cache</td><td style="text-align:center">不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如<code>CSS</code>等</td></tr><tr><td style="text-align:center">200</td><td style="text-align:center">资源大小数值</td><td style="text-align:center">从服务器下载最新资源</td></tr><tr><td style="text-align:center">304</td><td style="text-align:center">报文大小</td><td style="text-align:center">请求服务端发现资源没有更新，使用本地资源（协商缓存）</td></tr></tbody></table><ul><li>可以看到，<strong>200和304</strong>是Chrome在<strong>请求资源时最常见的两种HTTP状态码</strong>。</li><li>由此可见<strong>样式表一般在磁盘中</strong>，不会缓存到内存中去，因为CSS样式加载一次即可渲染出网页。</li><li>但是，<strong>脚本</strong>却<strong>可能随时会执行</strong>，如果脚本在磁盘当中，在执行该脚本需要从磁盘中取到内存当中来。这样的IO开销是比较大的，有可能会导致浏览器失去响应。因此，<strong>脚本一般在内存中</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在Chrome浏览器中的控制台Network中size栏通常会有&lt;strong&gt;三种状态&lt;/strong&gt;: &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;from memory cache&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;from disk cache&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源本身的大小&lt;/strong&gt;(如：1.5k)
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="强缓存" scheme="https://chongtianhong.github.io/tags/%E5%BC%BA%E7%BC%93%E5%AD%98/"/>
    
      <category term="浏览器缓存" scheme="https://chongtianhong.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>浏览器强缓存和协商缓存</title>
    <link href="https://chongtianhong.github.io/2018/04/15/browserCache/"/>
    <id>https://chongtianhong.github.io/2018/04/15/browserCache/</id>
    <published>2018-04-15T05:36:26.000Z</published>
    <updated>2018-07-29T08:37:59.758Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>浏览器缓存</strong>是浏览器在<strong>本地磁盘</strong>对用户<strong>最近请求过的文档</strong>进行存储，当访问者再次访问同一页面时，浏览器就可以直接<strong>从本地磁盘加载文档</strong>。</li><li>浏览器缓存有下面的优点：<ul><li>减少冗余的数据传输；</li><li>减少服务器负担；</li><li>加快客户端加载网页的速度。<a id="more"></a></li></ul></li></ul><h4 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h4><ul><li>根据<strong>是否需要重新向服务器发起请求</strong>来分类，浏览器缓存可以分为<strong>强缓存</strong>和<strong>协商缓存</strong>两大类。强缓存不发请求到服务器，协商缓存会发请求到服务器。</li><li>两类缓存规则<strong>可以同时存在</strong>，<strong>强缓存优先级高于协商缓存</strong>，也就是说，当执行强缓存的规则时，<strong>如果强缓存生效，直接使用强缓存，不再执行协商缓存规则</strong>。</li><li>对于<strong>强缓存</strong>，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存；不在时间内，则执行协商缓存策略。</li><li>对于<strong>协商缓存</strong>，将缓存信息中的<code>Etag</code>对应的<code>If-None-Match</code>和<code>Last-Modified</code>对应的<code>If-Modified-Since</code>通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li><li>浏览器<strong>第一次</strong>请求时：<br><img src="/images/firstRequest.png" alt="浏览器第一次请求" style="border:none"></li><li>由上图可以看到，在<strong>客户端第一次请求数据</strong>时，此时<strong>缓存数据库中没有对应的缓存数据</strong>，<strong>需要请求服务器</strong>，<strong>服务器返回后，将数据存储至缓存数据库中</strong>。</li><li>浏览器<strong>后续</strong>在进行请求时：<br><img src="/images/afterRequest.png" alt="浏览器后续请求" style="border:none"></li><li>可以看到，浏览器后续在进行请求时，<strong>如果资源已经被浏览器缓存下来</strong>，在缓存失效之前，再次请求时，默认的处理方式为：<ul><li>默认会<strong>先检查是否命中强缓存（cache-control和expires信息）</strong>，如果强缓存命中则直接读取缓存，包括缓存header信息；</li><li><strong>如果强缓存没有命中</strong>，则发请求到服务器，<strong>请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match）</strong>，由<strong>服务器</strong>根据请求中的相关header信息来<strong>检查是否命中协商缓存</strong>，若协商缓存命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并<strong>不返回资源内容</strong>，它会告知浏览器可以直接从缓存获取（返回304状态码）；</li><li>如果强缓存和协商缓存都没有命中，服务器则返回最新的资源。</li></ul></li><li>强缓存与协商缓存的<strong>共同点</strong>是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据。</li><li>强缓存与协商缓存的<strong>区别</strong>，可以用下表来进行描述：</li></ul><table><thead><tr><th style="text-align:center">&nbsp;</th><th style="text-align:center">获取资源形式</th><th style="text-align:center">状态码</th><th style="text-align:center">是否发请求到服务器</th></tr></thead><tbody><tr><td style="text-align:center">强缓存</td><td style="text-align:center">从缓存取</td><td style="text-align:center">200(from cache)</td><td style="text-align:center">否，直接从缓存取</td></tr><tr><td style="text-align:center">协商缓存</td><td style="text-align:center">从缓存取</td><td style="text-align:center">304(not modified)</td><td style="text-align:center">是，通过服务器来告知缓存是否可用</td></tr></tbody></table><h4 id="强缓存相关的header字段"><a href="#强缓存相关的header字段" class="headerlink" title="强缓存相关的header字段"></a>强缓存相关的header字段</h4><ul><li>当浏览器对某个资源的请求命中了强缓存时，返回的http状态码为200，在chrome的开发者工具的network里面size会显示为<code>from cache</code>。</li><li>强缓存<strong>直接从缓存中获取资源</strong>而不经过服务器。</li><li>与强缓存相关的header字段有两个：分别是<code>Expires</code>和<code>Cache-Control</code>，它们都用来表示<strong>资源在客户端缓存的有效期</strong>。</li></ul><blockquote>Expires</blockquote><ul><li><p><code>Expires</code>是http1.0提出的一个表示资源过期时间的header，它描述的是一个<strong>绝对时间</strong>，由服务器返回，用GMT格式的字符串表示，如：<code>Expires:Thu, 31 Dec 2037 23:55:55 GMT</code>，它的缓存原理是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；</span><br><span class="line">2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</span><br><span class="line">3.浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；</span><br><span class="line">4.如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</span><br></pre></td></tr></table></figure></li><li><p><code>Expires</code>是较老的强缓存管理header，由于它是<strong>服务器返回的一个绝对时间</strong>，在<strong>服务器时间与客户端时间相差较大</strong>时，<strong>缓存管理容易出现问题</strong>，比如随意修改下客户端时间，就能影响缓存命中的结果。</p></li></ul><blockquote>Cache-Control</blockquote><ul><li><p>由于<code>Expires</code>存在着缺陷，在http1.1的时候，提出了一个新的header，就是<code>Cache-Control</code>，主要是利用该字段的<code>max-age</code>值来进行判断，是一个<strong>相对时间</strong>，在配置缓存的时候，以秒为单位，用数值表示，如：<code>Cache-Control:max-age=315360000</code>，它的缓存原理是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；</span><br><span class="line">2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</span><br><span class="line">3.浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；</span><br><span class="line">4.如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</span><br></pre></td></tr></table></figure></li><li><p><code>Cache-Control</code>除了设置max-age值外，还有下面几个比较常用的设置值：</p><ul><li><code>no-cache</code>：<strong>不使用本地缓存</strong>。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li><li><code>no-store</code>：<strong>直接禁止浏览器缓存数据</strong>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li><li><code>public</code>：可以被<strong>所有的用户的浏览器缓存</strong>，包括终端用户和CDN等中间代理服务器。</li><li><code>private</code>：只能被<strong>终端用户的浏览器缓存</strong>，不允许CDN等中继缓存服务器对其缓存。<strong>如果<code>Cache-Control</code>仅指定了max-age，则默认为private</strong>。</li></ul></li><li><code>Cache-Control</code>描述的是一个<strong>相对时间</strong>，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<strong><code>Expires</code>，Cache-Control的缓存管理更有效，安全一些</strong>。</li><li>这两个header可以只启用一个，也可以同时启用，当response header中的<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>。</li><li>注：在<strong>无法确定客户端的时间是否与服务端的时间同步</strong>的情况下，Cache-Control相比于expires是更好的选择，所以<strong>同时存在时，只有Cache-Control生效</strong>。</li><li>以博客的请求为例，<strong>状态码为灰色的请求</strong>则代表使用了<strong>强制缓存</strong>，请求对应的Size值则代表该缓存存放的位置，分别为<strong>from memory cache</strong> 和 <strong>from disk cache</strong>。<br><img src="images/fromCache.jpg" stype="border:none" alt="博客的请求例子"></li><li><strong>from memory cache</strong>代表使用<strong>内存中</strong>的缓存，<strong>from disk cache</strong>则代表使用的是<strong>硬盘</strong>中的缓存，浏览器读取缓存的顺序为先从内存（memory）中读，再从硬盘（disk）中读。</li></ul><h4 id="协商缓存相关的header字段"><a href="#协商缓存相关的header字段" class="headerlink" title="协商缓存相关的header字段"></a>协商缓存相关的header字段</h4><ul><li><strong>协商缓存</strong>都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而<strong>让服务器判断请求资源是否可以使用缓存访问</strong>。</li><li>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，<strong>如果协商缓存命中</strong>，<strong>请求响应返回的http状态码为304并且会显示一个Not Modified的字符串</strong>。</li><li><strong>协商缓存</strong>主要涉及到两组header字段，这两组搭档都是<strong>成对出现</strong>的，即第一次<strong>请求的响应头</strong>带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的<strong>请求字段</strong>（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</li></ul><blockquote>Last-Modified/If-Modified-Since</blockquote><ul><li><p>二者的值都是GMT格式的时间字符串，它们的<strong>控制缓存的原理</strong>是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</span><br><span class="line">2.浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时服务器返回的Last-Modified的值：</span><br><span class="line">3.服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间对比判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化则正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header(既然资源没有变化，那么Last-Modified也就不会改变)，这是服务器返回304时的response header：</span><br><span class="line">4.浏览器收到304的响应后，就会从缓存中加载资源。</span><br><span class="line">5.如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</span><br></pre></td></tr></table></figure></li><li><p>Last-Modified/If-Modified-Since都是<strong>根据服务器时间</strong>返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会存在<strong>服务器上资源其实有变化，但是最后修改时间却没有变化的情况</strong>，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会<strong>影响协商缓存的可靠性</strong>。</p></li></ul><blockquote>Etag/If-None-Match</blockquote><ul><li>这两个值是<strong>由服务器生成</strong>的每个资源的<strong>唯一标识字符串</strong>，只要<strong>资源有变化就这个值就会改变</strong>，<strong>跟最后修改时间没有关系</strong>，所以能很好的补充Last-Modified的问题。</li><li>其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，<strong>由于ETag重新生成过，response header中还会把这个ETag返回</strong>，即使这个ETag跟之前的没有变化。</li></ul><blockquote>既生Last-Modified何生Etag</blockquote><ul><li>HTTP1.1中Etag的出现主要是<strong>为了解决几个Last-Modified比较难解决的问题</strong>：<ul><li><strong>一些文件也许会周期性的更改</strong>，但是他的内容并不改变(<strong>仅仅改变的修改时间</strong>)，这个时候我们并<strong>不希望客户端认为这个文件被修改了，而重新请求</strong>；</li><li><strong>某些文件修改非常频繁，比如在秒以下的时间内进行修改</strong>，(比方说1s内修改了N次)，<strong>If-Modified-Since能检查到的粒度是秒级的</strong>，<strong>这种修改无法判断</strong>(或者说UNIX记录MTIME只能精确到秒)；</li><li><strong>某些服务器不能精确的得到文件的最后修改时间</strong>。</li></ul></li><li>这时，<strong>利用Etag能够更加准确的控制缓存</strong>，因为Etag是服务器自动生成或者由开发者生成的<strong>对应资源在服务器端的唯一标识符</strong>。</li><li>Last-Modified与ETag是可以一起使用的，服务器会<strong>优先验证ETag</strong>，一致的情况下，才会<strong>继续比对Last-Modified</strong>，最后才决定是否返回304。</li><li>然而，在<strong>性能</strong>上，<strong>Etag要逊于Last-Modified</strong>，毕竟Last-Modified只需要记录时间，而<strong>Etag需要服务器通过算法来计算出一个hash值</strong>。</li></ul><h4 id="用户的行为对缓存的影响"><a href="#用户的行为对缓存的影响" class="headerlink" title="用户的行为对缓存的影响"></a>用户的行为对缓存的影响</h4><ul><li>当使用<code>Ctrl + F5</code><strong>强制刷新网页</strong>时，直接从服务器加载，跳过强缓存和协商缓存。</li><li>当使用<code>F5</code><strong>刷新网页</strong>时，跳过强缓存，但是会检查协商缓存。</li></ul><h4 id="强缓存如何重新加载缓存缓存过的资源"><a href="#强缓存如何重新加载缓存缓存过的资源" class="headerlink" title="强缓存如何重新加载缓存缓存过的资源"></a>强缓存如何重新加载缓存缓存过的资源</h4><ul><li>上面说到，使用<strong>强缓存</strong>时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源。</li><li>可以通过<strong>更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源</strong>来解决这一情况。可采用附加特征参数的方法：<ul><li>在URL后面加上一个随机数：<code>“fresh=” + Math.random();。</code></li><li>在URL后面加上时间戳：<code>“nowtime=” + new Date().getTime();</code>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;浏览器缓存&lt;/strong&gt;是浏览器在&lt;strong&gt;本地磁盘&lt;/strong&gt;对用户&lt;strong&gt;最近请求过的文档&lt;/strong&gt;进行存储，当访问者再次访问同一页面时，浏览器就可以直接&lt;strong&gt;从本地磁盘加载文档&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;浏览器缓存有下面的优点：&lt;ul&gt;
&lt;li&gt;减少冗余的数据传输；&lt;/li&gt;
&lt;li&gt;减少服务器负担；&lt;/li&gt;
&lt;li&gt;加快客户端加载网页的速度。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="强缓存" scheme="https://chongtianhong.github.io/tags/%E5%BC%BA%E7%BC%93%E5%AD%98/"/>
    
      <category term="协商缓存" scheme="https://chongtianhong.github.io/tags/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    
      <category term="HTTP" scheme="https://chongtianhong.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>什么是无样式内容闪烁?如何避免?</title>
    <link href="https://chongtianhong.github.io/2018/04/14/FOUC/"/>
    <id>https://chongtianhong.github.io/2018/04/14/FOUC/</id>
    <published>2018-04-14T03:27:46.000Z</published>
    <updated>2018-07-29T03:57:02.657Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是FOUC-无样式内容闪烁"><a href="#什么是FOUC-无样式内容闪烁" class="headerlink" title="什么是FOUC(无样式内容闪烁)"></a>什么是FOUC(无样式内容闪烁)</h4><ul><li>如果使用<code>@import</code>方法对CSS进行导入，会导致某些页面在Windows下的Internet Explorer出现一些奇怪的现象：<strong>以无样式显示页面内容的瞬间闪烁</strong>，这种现象称之为<strong>文档样式短暂失效</strong>(Flash of Unstyled Content)，简称为FOUC。<a id="more"></a></li></ul><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul><li>原理：当<strong>样式表晚于结构性html加载</strong>，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将<strong>重新渲染页面</strong>，也就出现了<strong>短暂的花屏现象</strong>。</li><li>FOUC的产生主要是由于<strong>浏览器先显示已加载的HTML内容，等到CSS加载完成后重新对内容添加样式</strong>导致，主要代表有<strong>Firefox</strong>。导致FOUC的原因有以下三种：<ul><li>使用<code>@import</code>导入样式表。</li><li>将样式表放在页面底部。</li><li>有几个样式表，放在页面不同位置。</li></ul></li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>使用LINK标签将样式表放在文档HEAD中。</li></ul><h4 id="白屏和FOUC"><a href="#白屏和FOUC" class="headerlink" title="白屏和FOUC"></a>白屏和FOUC</h4><ul><li>白屏和FOUC（无样式内容闪烁）的产生主要<strong>与浏览器的渲染机制有关</strong>：<ul><li>有的浏览器是<strong>等待HTML和CSS全部加载完成后再进行渲染</strong>（白屏原因）；</li><li>有的浏览器是<strong>先显示已加载的HTML内容，等到CSS加载完成后再重新对内容添加样式</strong>（FOUC原因）。</li></ul></li></ul><blockquote>白屏的产生</blockquote><ul><li>白屏的产生有三种情况：<ul><li>将CSS文件放在HTML文档的最后。</li><li>使用<code>@import</code>导入样式表（通过<code>@import</code>引入的CSS文件会被最后加载）。</li><li>将JS文件放在头部，未使用defer或async延迟或异步加载JS文件，导致JS阻塞HTML和CSS的加载。</li></ul></li></ul><blockquote>白屏的原理分析</blockquote><ul><li>对于-webkit内核的浏览器（IE也会产生），在<strong>进行网页渲染时</strong>，会同时<strong>加载HTML和CSS</strong>分别<strong>构建DOM树和CSSOM树</strong>，等<strong>两者都构建完成后</strong>，再<strong>绘制渲染树</strong>，然后<strong>将页面显示出来</strong>。</li><li>如果在HTML中将CSS放置在文档最后，那么会导致<strong>CSSOM晚于DOM树的建立，浏览器需要等待CSSOM的建立，然后才进行网页内容的绘制</strong>，这个等待的过程，没有内容显示，就<strong>导致了白屏的产生</strong>。</li><li>因此，在开发中，需要<strong>使用LINK标签将样式表放在文档HEAD中，让其与HTML内容同时被加载</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是FOUC-无样式内容闪烁&quot;&gt;&lt;a href=&quot;#什么是FOUC-无样式内容闪烁&quot; class=&quot;headerlink&quot; title=&quot;什么是FOUC(无样式内容闪烁)&quot;&gt;&lt;/a&gt;什么是FOUC(无样式内容闪烁)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果使用&lt;code&gt;@import&lt;/code&gt;方法对CSS进行导入，会导致某些页面在Windows下的Internet Explorer出现一些奇怪的现象：&lt;strong&gt;以无样式显示页面内容的瞬间闪烁&lt;/strong&gt;，这种现象称之为&lt;strong&gt;文档样式短暂失效&lt;/strong&gt;(Flash of Unstyled Content)，简称为FOUC。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="浏览器渲染机制" scheme="https://chongtianhong.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    
      <category term="CSS" scheme="https://chongtianhong.github.io/tags/CSS/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>href和src的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/13/hrefAndSrc/"/>
    <id>https://chongtianhong.github.io/2018/04/13/hrefAndSrc/</id>
    <published>2018-04-13T02:48:03.000Z</published>
    <updated>2018-07-29T03:20:25.771Z</updated>
    
    <content type="html"><![CDATA[<ul><li>src和href之间存在区别：<ul><li><code>src</code>是引入，用于替换当前元素；</li><li><code>href</code>是引用，用于在当前文档和引用资源之间确立联系。 </li></ul></li><li><strong>注意</strong>：JS、CSS中如有重定义，后定义函数将覆盖前定义函数。<a id="more"></a></li></ul><blockquote>href</blockquote><ul><li><code>href</code>表示<strong>超文本引用</strong>（hypertext reference），用在link和a等元素上，<code>href</code>引用的内容与该页面有关联，是<strong>在当前元素和引用资源之间建立联系</strong>。</li><li><code>href</code>引用的内是外部资源而非网页不可或缺的一部分，因此在遇到<code>href</code>时浏览器会在下载CSS文件的<strong>同时去处理网页的其他部分</strong>。</li><li>注意：建议<strong>使用link方式来加载css</strong>而不是使用@import。</li></ul><blockquote>补充：link和@import的区别</blockquote><ul><li>两者都是外部引用CSS的方式，但是存在一定的区别：<ul><li>区别1：<strong>link是XHTML标签</strong>，除了加载CSS外，还可以定义RSS、定义rel连接属性等其他事务；<strong>@import属于CSS范畴，只能加载CSS</strong>。</li><li>区别2：<strong>link</strong>引用CSS时，在<strong>页面载入时同时加载</strong>；<strong>@import</strong>需要<strong>页面网页完全载入以后加载</strong>。</li><li>区别3：<strong>link是XHTML标签，无兼容问题</strong>；<strong>@import</strong>是在CSS2.1提出的，<strong>低版本的浏览器不支持</strong>。</li><li>区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul></li></ul><blockquote>src</blockquote><ul><li><code>src</code>表示<strong>外部资源引入</strong>，用于<strong>替换当前元素</strong>，用在img，script，iframe等元素上，<code>src</code>是<strong>页面内容不可缺少的一部分</strong>。</li><li>在遇到<code>src</code>时浏览器会<strong>等待这一部分下载运行结束</strong>才会继续处理下面的网页，这也是为什么&lt;script&gt;标签最好放在网页底部。（在加载js文件时，浏览器会阻止页面的渲染）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;src和href之间存在区别：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;src&lt;/code&gt;是引入，用于替换当前元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;href&lt;/code&gt;是引用，用于在当前文档和引用资源之间确立联系。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：JS、CSS中如有重定义，后定义函数将覆盖前定义函数。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTML" scheme="https://chongtianhong.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>querySelector与getElementBy等的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/12/querySelector/"/>
    <id>https://chongtianhong.github.io/2018/04/12/querySelector/</id>
    <published>2018-04-12T14:45:24.000Z</published>
    <updated>2018-07-29T02:39:41.222Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>常见的获取元素的方法有3种，分别是通过元素ID、通过标签名字和通过类名字来获取。</li><li><code>querySelector</code> 和 <code>querySelectorAll</code> 方法的作用是根据 CSS 选择器规范，使用和jquery查询方式一样，可以便捷定位文档中指定元素。<a id="more"></a></li></ul><blockquote>通过元素ID获取元素</blockquote><ul><li>DOM提供了一个名为<code>getElementById</code>的方法，这个方法将返回一个与之对应id属性的节点对象，它是<code>document</code>对象特有的函数，只能通过其来调用该方法，使用方法如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(<span class="string">'idName'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote>通过标签名字获取元素</blockquote><ul><li><code>getElementsByTagName</code>方法返回一个对象数组（准确的说是HTMLCollection集合）,返回元素的顺序是它们在文档中的顺序,传递给 <code>getElementsByTagName()</code> 方法的字符串可以不区分大小写,使用方法如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(tagName);</span><br></pre></td></tr></table></figure></li></ul><blockquote>通过类名字获取元素</blockquote><ul><li>DOM还提供了<code>getElementsByClassName</code>方法来获取指定class名的元素,该方法返回文档中所有指定类名的元素集合，作为 NodeList 对象。NodeList 对象代表一个有顺序的节点列表。NodeList 对象 我们可通过节点列表中的节点索引号来访问列表中的节点(索引号由0开始), 所以有时使用时要指定下标，使用方法如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByClassName(<span class="string">'className'</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote>使用<code>querySelector</code> 和 <code>querySelectorAll</code> 方法更便捷地定位元素</blockquote><ul><li><code>querySelector()</code> 方法返回匹配指定 CSS 选择器元素的第一个元素。该方法<strong>只返回匹配指定选择器的第一个元素</strong>。</li><li>如果要返回所有匹配元素，需要使用 <code>querySelectorAll()</code> 方法替代．</li><li>由于<code>querySelector()</code>是按css规范来实现的，所以它<strong>传入的字符串中第一个字符不能是数字</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 获取文档中 id=<span class="string">"demo"</span> 的元素</span><br><span class="line">document.querySelector(<span class="string">"#demo"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中第一个 &lt;p&gt; 元素</span><br><span class="line">document.querySelector(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中 class=<span class="string">"example"</span> 的第一个元素</span><br><span class="line">document.querySelector(<span class="string">".example"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中 class=<span class="string">"example"</span> 的第一个 &lt;p&gt; 元素</span><br><span class="line">document.querySelector(<span class="string">"p.example"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中有 <span class="string">"target"</span> 属性的第一个 &lt;a&gt; 元素</span><br><span class="line">document.querySelector(<span class="string">"a[target]"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中class = <span class="string">"li"</span> 的div</span><br><span class="line">document.querySelectorAll(<span class="string">"div .li"</span>);</span><br><span class="line"></span><br><span class="line">// 获取文档中id = <span class="string">"k"</span>的节点下的第一个span节点</span><br><span class="line">document.querySelector(<span class="string">"#k span"</span>);</span><br><span class="line"></span><br><span class="line">// 对于多个选择器，使用逗号隔开，只返回一个匹配的元素。</span><br><span class="line">document.querySelector(<span class="string">"h2, h3"</span>).style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">// 如果文档中 &lt;h2&gt; 元素位于 &lt;h3&gt; 元素之前，&lt;h2&gt; 元素将会被设置指定的背景颜色。</span><br><span class="line">// 如果文档中 &lt;h3&gt; 元素位于 &lt;h2&gt; 元素之前，&lt;h3&gt; 元素将会被设置指定的背景颜色。</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>query选择符选出来的元素及元素数组</strong>是<strong>静态</strong>的，而<strong>getElement</strong>这种方法<strong>选出的元素是动态的</strong>。<ul><li>静态的意思是，选出的所有元素的数组，<strong>不会随着文档操作而改变</strong>。</li></ul></li><li>在使用的时候<strong>getElement</strong>这种方法<strong>性能比较好</strong>，<strong>query选择符</strong>则<strong>比较方便</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;常见的获取元素的方法有3种，分别是通过元素ID、通过标签名字和通过类名字来获取。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;querySelector&lt;/code&gt; 和 &lt;code&gt;querySelectorAll&lt;/code&gt; 方法的作用是根据 CSS 选择器规范，使用和jquery查询方式一样，可以便捷定位文档中指定元素。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="CSS选择器" scheme="https://chongtianhong.github.io/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>理解JS中的call、apply、bind方法</title>
    <link href="https://chongtianhong.github.io/2018/04/11/bind/"/>
    <id>https://chongtianhong.github.io/2018/04/11/bind/</id>
    <published>2018-04-11T12:01:33.000Z</published>
    <updated>2018-07-28T12:28:09.092Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在JavaScript中，<code>call</code>、<code>apply</code>和<code>bind</code>是Function对象自带的三个方法，这三个方法的主要作用是<strong>改变函数中的this指向</strong>。</p><a id="more"></a></li><li><p><code>call</code>、<code>apply</code>和<code>bind</code>方法的<strong>共同点</strong>：</p><ul><li><code>call</code>、<code>apply</code>、<code>bind</code> 三者都是用来改变函数的this对象的指向的；</li><li><code>call</code>、<code>apply</code>、<code>bind</code> 三者<strong>第一个参数都是this要指向的对象</strong>，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值，即本次调用的上下文（context），这就是this关键字的值）；</li><li><code>call</code>、<code>apply</code>、<code>bind</code> 三者都可以<strong>利用后续参数传参</strong>。</li></ul></li><li><p><code>bind</code>方法与<code>call</code>、<code>apply</code>两个方法的区别：</p><ul><li><code>bind</code>方法是返回对应函数，便于<strong>稍后调用</strong>；</li><li><code>call</code>、<code>apply</code>则是<strong>立即调用</strong>。</li></ul></li><li>可见，当我们希望<strong>改变上下文环境之后并非立即执行</strong>，而是<strong>回调执行</strong>的时候，使用 <code>bind()</code>方法。而 <code>apply/call</code> 则会<strong>立即执行</strong>函数。</li></ul><blockquote>call()</blockquote><ul><li>语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])</li><li>定义：调用一个对象的一个方法，以另一个对象替换当前对象。</li><li>说明： call 方法可以用来<strong>代替另一个对象调用一个方法</strong>。</li><li>call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</li><li>thisObj的取值有以下4种情况：<br>（1） 不传，或者传null,undefined，函数中的this指向window对象；<br>（2） 传递另一个函数的函数名，函数中的this指向这个函数的引用；<br>（3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean；<br>（4） 传递一个对象，函数中的this指向这个对象。</li><li>例子：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;   </span><br><span class="line">  console.log(this);   //输出函数a中的this对象</span><br><span class="line">&#125;       </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;&#125;       </span><br><span class="line">var c=&#123;name:<span class="string">"call"</span>&#125;;    //定义对象c  </span><br><span class="line"></span><br><span class="line">a.call();   //window</span><br><span class="line">a.call(null);   //window</span><br><span class="line">a.call(undefined);   //window</span><br><span class="line">a.call(1);   //Number</span><br><span class="line">a.call(<span class="string">''</span>);   //String</span><br><span class="line">a.call(<span class="literal">true</span>);   //Boolean</span><br><span class="line">a.call(b);   //<span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;&#125;</span><br><span class="line">a.call(c);   //Object</span><br></pre></td></tr></table></figure></li></ul><blockquote>apply和call的区别</blockquote><ul><li>对于<code>call</code>、<code>apply</code>二者而言，<strong>作用完全一样</strong>，只是<strong>接受参数的方式不太一样</strong>。</li><li><code>call</code>需要<strong>把参数按顺序传递</strong>进去，而<code>apply</code>则是<strong>把参数放在数组里后将整个数组传入</strong>。</li><li>在JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话：<ul><li>当参数是明确知道数量时用<code>call</code>；</li><li>而不确定的时候用<code>apply</code>，然后把参数 push 进数组传递进去。</li><li>当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。</li></ul></li></ul><blockquote>bind()</blockquote><ul><li><code>bind</code>是在 ES5 中扩展的方法（IE6,7,8不支持）。<code>bind</code>方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 <code>bind</code>方法的第一个参数作为 this，传入 <code>bind</code> 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</li><li><p><code>bind</code>方法的返回值是函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = <span class="string">'李四'</span></span><br><span class="line">var foo = &#123;</span><br><span class="line">    name: <span class="string">"张三"</span>,</span><br><span class="line">    logName: <span class="keyword">function</span>(age) &#123;</span><br><span class="line">        console.log(this.name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var fooNew = foo.logName;</span><br><span class="line">var fooNewBind = foo.logName.bind(foo);</span><br><span class="line">fooNew(10)//李四,10</span><br><span class="line">fooNewBind(11)//张三,11（因为<span class="built_in">bind</span>改变了fooNewBind里面的this指向）</span><br></pre></td></tr></table></figure></li><li><p>在Javascript中，多次使用<code>bind()</code>是无效的。更深层次的原因， <code>bind()</code>的实现，相当于使用函数在内部包了一个 <code>call</code>/<code>apply</code> ，第二次<code>bind()</code>相当于再包住第一次<code>bind()</code>,故第二次以后的<code>bind()</code>是无法生效的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bar = <span class="function"><span class="title">function</span></span>()&#123;   </span><br><span class="line">    console.log(this.x);   </span><br><span class="line">&#125;</span><br><span class="line">var foo=&#123; </span><br><span class="line">    x:3   </span><br><span class="line">&#125;   </span><br><span class="line">bar();  // undefined</span><br><span class="line"></span><br><span class="line">bar.bind(foo)(); // 3</span><br><span class="line"> /*或*/</span><br><span class="line">var func = bar.bind(foo);   </span><br><span class="line">func(); // 3</span><br></pre></td></tr></table></figure></li><li><p>由于<strong>箭头函数没有自己的this</strong>，所以当然也就<strong>不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变this的指向</strong>。</p></li><li>箭头函数的this总是指向词法作用域，也就是外层调用者。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;在JavaScript中，&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;和&lt;code&gt;bind&lt;/code&gt;是Function对象自带的三个方法，这三个方法的主要作用是&lt;strong&gt;改变函数中的this指向&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="this" scheme="https://chongtianhong.github.io/tags/this/"/>
    
      <category term="call" scheme="https://chongtianhong.github.io/tags/call/"/>
    
      <category term="apply" scheme="https://chongtianhong.github.io/tags/apply/"/>
    
      <category term="bind" scheme="https://chongtianhong.github.io/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ES6箭头函数中的this</title>
    <link href="https://chongtianhong.github.io/2018/04/10/arrowFunction/"/>
    <id>https://chongtianhong.github.io/2018/04/10/arrowFunction/</id>
    <published>2018-04-10T13:34:05.000Z</published>
    <updated>2018-07-28T14:14:53.021Z</updated>
    
    <content type="html"><![CDATA[<ul><li>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的<strong>区别</strong>：<ul><li>箭头函数内部的this是<strong>词法作用域，由上下文确定</strong>。</li><li>箭头函数中的this是在<strong>定义函数的时候绑定</strong>，而不是在执行函数的时候绑定。<a id="more"></a></li></ul></li><li>由于this在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>、<code>bind()</code>调用箭头函数时，无法对this进行绑定（无法使用<code>call()</code>或者<code>apply()</code>、<code>bind()</code>改变this的指向），即传入的第一个参数被忽略。内部的this指向<strong>父执行上下文</strong>里面的this。</li><li>箭头函数中，this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是<strong>箭头函数根本没有自己的this</strong>，导致内部的this就是<strong>外层代码块</strong>的this。正是因为它没有this，所以也就<strong>不能用作构造函数</strong>。</li><li><p>箭头函数中的this是在<strong>定义函数的时候绑定</strong>，看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 11;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    x: 22,</span><br><span class="line">    say: ()=&gt;&#123;</span><br><span class="line">        console.log(this.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();  //输出的值为11</span><br></pre></td></tr></table></figure></li><li><p>所谓的<strong>定义时候绑定</strong>，就是this是继承自<strong>父执行上下文中的this</strong>，比如这里的箭头函数中的this.x，箭头函数本身与say平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而<strong>obj的父执行上下文就是window</strong>，因此这里的this.x实际上表示的是window.x，因此输出的是11。</p></li><li><p>而对于下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</span><br><span class="line">        <span class="built_in">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); // 25</span><br></pre></td></tr></table></figure></li><li><p>例子中箭头函数本身是在getAge方法中定义的，因此，getAge方法的<strong>父执行上下文</strong>是obj，因此这里的this指向则为obj对象。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的&lt;strong&gt;区别&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;箭头函数内部的this是&lt;strong&gt;词法作用域，由上下文确定&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;箭头函数中的this是在&lt;strong&gt;定义函数的时候绑定&lt;/strong&gt;，而不是在执行函数的时候绑定。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="ES6" scheme="https://chongtianhong.github.io/tags/ES6/"/>
    
      <category term="箭头函数" scheme="https://chongtianhong.github.io/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    
      <category term="this" scheme="https://chongtianhong.github.io/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>JS原型链</title>
    <link href="https://chongtianhong.github.io/2018/04/09/prototype/"/>
    <id>https://chongtianhong.github.io/2018/04/09/prototype/</id>
    <published>2018-04-09T11:07:52.000Z</published>
    <updated>2018-07-28T11:51:39.828Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JavaScript可以通过<strong>构造函数</strong>和<strong>原型链</strong>实现继承。</li><li><strong>所有的实例对象</strong>都可以<strong>继承构造函数中的属性和方法</strong>，但是，<strong>同一个构造函数</strong>的<strong>实例对象之间无法共享属性或方法</strong>。</li><li>为了解决构造函数的这个缺点，JavaScript提供了<strong>prototype属性</strong>。<a id="more"></a></li></ul><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h4><ul><li>JavaScript中每个数据类型都是对象（除了null和undefined），而每个对象都继承自另外一个对象（原型对象），只有<strong>null</strong>除外，它<strong>没有自己的原型对象</strong>。</li><li><strong>原型对象上的所有属性和方法，都会被对象实例所共享</strong>。原型对象的作用，就是定义所有对象实例所<strong>共享</strong>的属性和方法。</li><li><strong>通过构造函数生成对象实例</strong>时，会<strong>将对象实例的原型（_proto_属性）指向构造函数的prototype属性</strong>。<strong>每一个构造函数都有一个prototype属性</strong>，这个属性就是<strong>对象实例的原型对象</strong>。prototype既是属性，又是对象：<ul><li>对于<strong>构造函数</strong>来说，<strong>prototype是作为构造函数的属性</strong>；</li><li>对于<strong>对象实例</strong>来说，<strong>prototype是对象实例的原型对象</strong>。</li></ul></li><li>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象上。如果<strong>实例对象自身有某个属性或方法</strong>，就<strong>不会去原型对象上查找</strong>。当某个<strong>对象实例没有该属性和方法时</strong>，就会<strong>到原型对象上去查找</strong>。</li></ul><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul><li>由于<strong>原型对象本身对于对象实例来说也是对象</strong>，它<strong>也有自己的原型</strong>，所以形成了一条<strong>原型链（prototype chain）</strong>。</li><li>即每个对象和原型都有原型，对象的原型指向原型对象，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。</li><li>所有一切的对象的<strong>原型顶端</strong>，都是<strong>Object.prototype</strong>，即Object构造函数的prototype属性指向的那个对象。</li><li><strong>Object.prototype对象</strong>也有自己的<strong>原型对象</strong>，即<strong>null对象</strong>（没有任何属性和方法），而null对象<strong>没有自己的原型</strong>。</li></ul><h4 id="原型链（prototype-chain）的特点"><a href="#原型链（prototype-chain）的特点" class="headerlink" title="原型链（prototype chain）的特点"></a>原型链（prototype chain）的特点</h4><ul><li>读取对象的某个属性时，JavaScript引擎先寻找<strong>对象本身</strong>的属性，如果找不到，就到它的<strong>原型</strong>去找，如果还是找不到，就到<strong>原型的原型</strong>去找。如果直到<strong>最顶层的Object.prototype</strong>还是找不到，则<strong>返回undefined</strong>。</li><li>如果<strong>对象自身</strong>和它的<strong>原型</strong>，都定义了一个<strong>同名属性</strong>，那么<strong>优先读取对象自身的属性</strong>，这叫做“覆盖”（overiding）。</li><li>一级级向上<strong>在原型链寻找某个属性，对性能是有影响的</strong>。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</li></ul><h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><ul><li>prototype对象有一个constructor属性，默认指向<strong>prototype对象所在的构造函数</strong>。</li><li><p>prototype是构造函数的属性，而constructor则是原型对象的属性。关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造函数.prototype.constructor===构造函数</span><br><span class="line">console.log(A.hasOwnProperty(<span class="string">'prototype'</span>)); //<span class="literal">true</span></span><br><span class="line">console.log(A.prototype.hasOwnProperty(<span class="string">'constructor'</span>)); //<span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>另外，实例的构造函数属性（constructor）指向构造函数。</p></li></ul><h4 id="hasOwnProperty-函数"><a href="#hasOwnProperty-函数" class="headerlink" title="hasOwnProperty()函数"></a>hasOwnProperty()函数</h4><ul><li><code>hasOwnProperty()</code>函数用于指示一个<strong>对象自身(不包括原型链)是否具有指定名称的属性</strong>。如果有，返回true，否则返回false。</li><li>该方法属于Object对象，由于所有的对象都”继承”了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。</li><li>语法:<code>object.hasOwnProperty(propertyName)</code></li><li>此方法<strong>不会检查对象的原型链</strong>中是否存在该属性，该属性只有是<strong>对象本身的一个成员才会返回true</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;JavaScript可以通过&lt;strong&gt;构造函数&lt;/strong&gt;和&lt;strong&gt;原型链&lt;/strong&gt;实现继承。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有的实例对象&lt;/strong&gt;都可以&lt;strong&gt;继承构造函数中的属性和方法&lt;/strong&gt;，但是，&lt;strong&gt;同一个构造函数&lt;/strong&gt;的&lt;strong&gt;实例对象之间无法共享属性或方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;为了解决构造函数的这个缺点，JavaScript提供了&lt;strong&gt;prototype属性&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="原型链" scheme="https://chongtianhong.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS中的进制转换</title>
    <link href="https://chongtianhong.github.io/2018/04/08/numBaseConversion/"/>
    <id>https://chongtianhong.github.io/2018/04/08/numBaseConversion/</id>
    <published>2018-04-08T10:21:18.000Z</published>
    <updated>2018-07-28T14:28:12.408Z</updated>
    
    <content type="html"><![CDATA[<ul><li>JavaScript可以很简单地实现任意进制的转化，核心函数是全局函数<code>parseInt(str, radix)</code>与<code>Number.toString(radix)</code>。</li><li><code>parseInt(str, radix)</code>可以实现<strong>把任意进制字符串转为十进制返回</strong>。</li><li><code>Number.toString(radix)</code>可以实现<strong>2、8、10、16进制的数据相互转换</strong>，并<strong>以字符串形式输出</strong>。<a id="more"></a></li></ul><h4 id="parseInt-str-radix"><a href="#parseInt-str-radix" class="headerlink" title="parseInt(str,radix)"></a>parseInt(str,radix)</h4><ul><li><code>parseInt(str, radix)</code>将字符串str按照radix进制编码方式<strong>转换为十进制</strong>返回</li><li>如果省略radix参数，则数字将以 10 为基数来解析。</li><li>radix参数值介于 2 ~ 36 之间。如果该参数小于 2 或者大于 36，则<code>parseInt(str, radix)</code>的结果将返回 NaN。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//2进制到10进制</span><br><span class="line">parseInt(<span class="string">'10'</span>,2) // 2</span><br><span class="line"></span><br><span class="line">//2进制到10进制</span><br><span class="line">parseInt(<span class="string">'100'</span>,2) // 4</span><br><span class="line"></span><br><span class="line">//16进制到10进制</span><br><span class="line">parseInt(<span class="string">'12'</span>, 16) // 18</span><br><span class="line"></span><br><span class="line">//8进制到10进制</span><br><span class="line">parseInt(<span class="string">'12'</span>,8); // 10</span><br><span class="line">parseInt(<span class="string">'23'</span>,8) // 19</span><br></pre></td></tr></table></figure></li></ul><h4 id="Number-toString-radix"><a href="#Number-toString-radix" class="headerlink" title="Number.toString(radix)"></a>Number.toString(radix)</h4><ul><li>Number的一个方法：<code>toString(radix)</code>返回<strong>表示该数字</strong>的<strong>指定进制形式</strong>的<strong>字符串</strong>。</li><li>可以实现<strong>2进制，8进制，10进制，16进制之间的相互转换</strong>，并<strong>以字符串形式输出</strong>。</li><li><p>radix支持 [2, 36] 之间的整数，默认为10。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//10进制转为16进制</span><br><span class="line">(66).toString(16) // <span class="string">"42"</span></span><br><span class="line">(10).toString(16) // <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">//8进制转为16进制</span><br><span class="line">(012).toString(16) // <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">//16进制转为10进制</span><br><span class="line">(0x16).toString(10) // <span class="string">"22"</span></span><br><span class="line"></span><br><span class="line">//16进制转为8进制</span><br><span class="line">(0x16).toString(8) // =&gt;<span class="string">"26"</span></span><br><span class="line"></span><br><span class="line">//10进制转为2进制 </span><br><span class="line">(1111).toString(2) // <span class="string">"10001010111"</span></span><br><span class="line"></span><br><span class="line">//8进制转为2进制</span><br><span class="line">(01111).toString(2) // <span class="string">"1001001001"</span></span><br><span class="line"></span><br><span class="line">//16进制转为2进制</span><br><span class="line">(0x16).toString(2) // <span class="string">"10110"</span></span><br></pre></td></tr></table></figure></li><li><p>一个笔试题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var n = (2).toString();</span><br><span class="line">console.log(typeof(n));</span><br><span class="line">//<span class="string">'string'</span></span><br></pre></td></tr></table></figure></li><li><p>数字2通过<code>toString()</code>方法转为字符串，没有参数，默认转为10进制。最后n变成”2’，类型为字符串。</p></li></ul><h4 id="实现把m进制的数字转为n进制"><a href="#实现把m进制的数字转为n进制" class="headerlink" title="实现把m进制的数字转为n进制"></a>实现把m进制的数字转为n进制</h4><ul><li><p>实现把m进制的数字num转为n进制的方法是：先用<code>parseInt(str,radix)</code>将m进制的数字转化为十进制，再把十进制的数字用<code>toString()</code>方法返回n进制的形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> main(num, m, n)&#123;</span><br><span class="line">    var s = num + <span class="string">''</span>;</span><br><span class="line">    var result = parseInt(s, m).toString(n); </span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(main(36, 8, 6)); // 50</span><br></pre></td></tr></table></figure></li><li><p>注意：Number类型下的<code>toString()</code>函数容易忽略。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;JavaScript可以很简单地实现任意进制的转化，核心函数是全局函数&lt;code&gt;parseInt(str, radix)&lt;/code&gt;与&lt;code&gt;Number.toString(radix)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parseInt(str, radix)&lt;/code&gt;可以实现&lt;strong&gt;把任意进制字符串转为十进制返回&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.toString(radix)&lt;/code&gt;可以实现&lt;strong&gt;2、8、10、16进制的数据相互转换&lt;/strong&gt;，并&lt;strong&gt;以字符串形式输出&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="进制转换" scheme="https://chongtianhong.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript强制类型转换与隐式类型转换</title>
    <link href="https://chongtianhong.github.io/2018/04/07/typeConversion/"/>
    <id>https://chongtianhong.github.io/2018/04/07/typeConversion/</id>
    <published>2018-04-07T13:44:51.000Z</published>
    <updated>2018-07-27T15:16:54.743Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在JavaScript中<strong>声明变量不需指定类型</strong>，<strong>对变量赋值</strong>也<strong>没有类型检查</strong>，同时JavaScript<strong>允许隐式类型转换</strong>。这些特征说明JavaScript属于<strong>弱类型的语言</strong>。<a id="more"></a></li></ul><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li>通过手动进行类型转换，Javascript提供了以下转型函数：<ul><li>转换为<strong>数值</strong>类型：<code>Number(mix)</code>、<code>parseInt(string,radix)</code>、<code>parseFloat(string)</code></li><li>转换为<strong>字符串</strong>类型：<code>toString(radix)</code>、<code>String(mix)</code></li><li>转换为<strong>布尔</strong>类型：<code>Boolean(mix)</code></li></ul></li><li>注意：<strong>NaN</strong>是JavaScript中唯一一个<strong>不等于自己</strong>的值。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(NaN == NaN) === <span class="literal">false</span></span><br><span class="line">Boolean(0)                // =&gt; <span class="literal">false</span> - 零</span><br><span class="line">Boolean(new object())     // =&gt; <span class="literal">true</span> - 对象</span><br><span class="line">Number(undefined)         // =&gt;   NaN</span><br><span class="line">Number(null)              // =&gt; 0</span><br><span class="line">String(null)              // =&gt; <span class="string">"null"</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>1、Number(mix)函数</blockquote><ul><li><p><code>Number(mix)</code>函数可以将任意类型的参数mix转换为数值类型。其规则为：<br>（1）如果是<strong>布尔值</strong>，true和false分别被转换为1和0。<br>（2）如果是<strong>数字值</strong>，返回本身。<br>（3）如果是<strong>null</strong>，返回0.<br>（4）如果是<strong>undefined</strong>，返回NaN。<br>（5）如果是<strong>字符串</strong>，遵循以下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 如果字符串中只包含数字，则将其转换为十进制（忽略前导0）。</span><br><span class="line">· 如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0）。</span><br><span class="line">· 如果是空字符串，将其转换为0。</span><br><span class="line">· 如果字符串中包含非以上格式，则将其转换为NaN。</span><br></pre></td></tr></table></figure><p>（6）如果是<strong>对象</strong>，则调用对象的<code>valueOf()</code>方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。</p></li><li>下表列出了对象的valueOf()的返回值：</li></ul><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">Array</td><td style="text-align:center">数组的元素被转换为字符串，这些字符串由逗号分隔，连接在一起。其操作与 Array.toString 和 Array.join 方法相同。</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">Boolean 值。</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td></tr><tr><td style="text-align:center">Function</td><td style="text-align:center">函数本身。</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">数字值。</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">对象本身。这是默认情况。</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">字符串值。</td></tr></tbody></table><ul><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number(<span class="string">"hello CSSer!"</span>); // NaN</span><br><span class="line">Number(<span class="string">"0×8"</span>); // NaN</span><br><span class="line">Number(<span class="string">""</span>); // 0</span><br><span class="line">Number(<span class="string">"020dd"</span>); NaN</span><br><span class="line">Number(<span class="string">"070"</span>); // 70</span><br><span class="line">Number(<span class="literal">true</span>); // 1</span><br></pre></td></tr></table></figure></li></ul><blockquote>2、parseInt(string, radix)函数</blockquote><ul><li><code>parseInt(string, radix)函数</code>可将字符串转换为整数类型的数值，它也有一定的规则：<br>（1）忽略字符串前面的空格，直至找到第一个非空字符。<br>（2）如果<strong>第一个字符不是数字符号或者负号</strong>，返回NaN。<br>（3）如果<strong>第一个字符是数字</strong>，则<strong>继续解析直至字符串解析完毕</strong>或者<strong>遇到一个非数字符号</strong>为止。<br>（4）如果<strong>指定radix参数</strong>，则<strong>以radix为基数进行解析</strong>。</li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parseInt(<span class="string">"hello CSSer!"</span>); // NaN</span><br><span class="line">parseInt(<span class="string">"0×8"</span>); // 0</span><br><span class="line">parseInt(<span class="string">""</span>); // NaN</span><br><span class="line">parseInt(<span class="string">"020dd"</span>); // 20</span><br><span class="line">parseInt(<span class="string">"070"</span>); // 70</span><br><span class="line">parseInt(<span class="string">"22.5"</span>); // 22</span><br></pre></td></tr></table></figure></li></ul><blockquote>3、parseFloat(string)函数</blockquote><ul><li><code>parseFloat(string)</code>函数可将字符串转换为浮点数类型的数值。它的规则与parseInt基本相同，但也有点区别：<ul><li>字符串中<strong>第一个小数点符号是有效的</strong>，另外parseFloat会<strong>忽略所有前导0</strong>，如果字符串包含一个可解析为整数的数，则<strong>返回整数值</strong>而不是浮点数值。</li></ul></li></ul><blockquote>4、toString(radix)函数</blockquote><ul><li><strong>除undefined和null之外</strong>的所有类型的值<strong>都具有toString()方法</strong>，其作用是<strong>返回对象的字符串表示</strong>。</li></ul><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">Array</td><td style="text-align:center">将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">返回日期的文字表示法。</td></tr><tr><td style="text-align:center">Error</td><td style="text-align:center">返回一个包含相关错误信息的字符串。</td></tr><tr><td style="text-align:center">Function</td><td style="text-align:center">返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code] }</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">对象本身。这是默认情况。</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">返回 String 对象的值。</td></tr><tr><td style="text-align:center">默认</td><td style="text-align:center">返回 “[object objectname]”，其中 objectname 是对象类型的名称。</td></tr></tbody></table><blockquote>5、String(mix)函数</blockquote><ul><li><code>String(mix)</code>函数可将任何类型的值转换为字符串，其规则为：<br>（1）如果有<code>toString()</code>方法，则调用该方法（不传递radix参数）并返回结果。<br>（2）如果是<code>null</code>，返回”null”。<br>（3）如果是<code>undefined</code>，返回”undefined”。</li></ul><blockquote>6、Boolean(mix)函数</blockquote><ul><li><code>Boolean(mix)</code>函数会将任何类型的值转换为布尔值。</li><li>以下值会被转换为false：<code>false</code>、<code>“”</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>，其余任何值都会被转换为true。</li></ul><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><ul><li>在某些情况下，即使我们不提供显示转换， JavaScript会<strong>自动转换表达式中对象的类型</strong>以<strong>完成表达式求值</strong>，主要情况有以下几种：</li></ul><h5 id="用于检测是否为非数值的函数：isNaN-mix"><a href="#用于检测是否为非数值的函数：isNaN-mix" class="headerlink" title="用于检测是否为非数值的函数：isNaN(mix)"></a>用于检测是否为非数值的函数：isNaN(mix)</h5><ul><li><code>isNaN()</code>函数，经测试发现，该函数会尝试将参数值用<code>Number()</code>进行转换，如果结果为”非数值”则返回<code>true</code>，否则返回<code>false</code>。</li></ul><h5 id="加法运算操作符"><a href="#加法运算操作符" class="headerlink" title="加法运算操作符"></a>加法运算操作符</h5><ul><li><p>加号运算操作符在Javascript也用于字符串连接符，所以加号操作符的规则分两种情况：<br>如果两个操作值都是数值，其规则为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)如果一个操作数为NaN，则结果为NaN</span><br><span class="line">(2)如果是Infinity+Infinity，结果是Infinity</span><br><span class="line">(3)如果是-Infinity+(-Infinity)，结果是-Infinity</span><br><span class="line">(4)如果是Infinity+(-Infinity)，结果是NaN</span><br><span class="line">(5)如果是+0+(+0)，结果为+0</span><br><span class="line">(6)如果是(-0)+(-0)，结果为-0</span><br><span class="line">(7)如果是(+0)+(-0)，结果为+0</span><br></pre></td></tr></table></figure></li><li><p>如果有一个操作值为字符串，表达式的值便是一个String，且：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.如果两个操作值都是字符串，则将它们拼接起来</span><br><span class="line">b.如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来</span><br><span class="line">c.如果一个操作数是对象、数值或者布尔值，则调用toString()方法取得字符串值，然后再应用前面的字符串规则。对于undefined和null，分别调用String()显式转换为字符串。</span><br></pre></td></tr></table></figure></li></ul><h5 id="乘除、减号运算符、取模运算符"><a href="#乘除、减号运算符、取模运算符" class="headerlink" title="乘除、减号运算符、取模运算符"></a>乘除、减号运算符、取模运算符</h5><ul><li>这些操作符针对的是运算，所以他们具有共同性：如果操作值之一不是数值，则被隐式调用<code>Number()</code>函数进行转换。</li></ul><h5 id="逻辑操作符（-、-amp-amp-、-）"><a href="#逻辑操作符（-、-amp-amp-、-）" class="headerlink" title="逻辑操作符（!、&amp;&amp;、||）"></a>逻辑操作符（!、&amp;&amp;、||）</h5><ul><li><strong>逻辑非（!）操作符</strong>首先通过<code>Boolean()</code>函数将它的操作值转换为布尔值，然后求反。</li><li><p><strong>逻辑与（&amp;&amp;）操作符</strong>，如果一个操作值不是布尔值时，遵循以下规则进行转换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）如果第一个操作数经Boolean()转换后为<span class="literal">true</span>，则返回第二个操作值，否则返回第一个值（不是Boolean()转换后的值）</span><br><span class="line">（2）如果有一个操作值为null，返回null</span><br><span class="line">（3）如果有一个操作值为NaN，返回NaN</span><br><span class="line">（4）如果有一个操作值为undefined，返回undefined</span><br></pre></td></tr></table></figure></li><li><p><strong>逻辑或（||）操作符</strong>，如果一个操作值不是布尔值，遵循以下规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）如果第一个操作值经Boolean()转换后为<span class="literal">false</span>，则返回第二个操作值，否则返回第一个操作值（不是Boolean()转换后的值）</span><br><span class="line">（2）对于undefined、null和NaN的处理规则与逻辑与（&amp;&amp;）相同</span><br></pre></td></tr></table></figure></li></ul><h5 id="关系操作符（-lt-gt-lt-gt-）"><a href="#关系操作符（-lt-gt-lt-gt-）" class="headerlink" title="关系操作符（&lt;, &gt;, &lt;=, &gt;=）"></a>关系操作符（&lt;, &gt;, &lt;=, &gt;=）</h5><ul><li><p>与上述操作符一样，<strong>关系操作符的操作值也可以是任意类型的</strong>，所以使用非数值类型参与比较时也需要系统进行隐式类型转换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）如果两个操作值都是数值，则进行数值比较。</span><br><span class="line">（2）如果两个操作值都是字符串，则比较字符串对应的字符编码值。</span><br><span class="line">（3）如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较。</span><br><span class="line">（4）如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较。</span><br><span class="line">（5）如果一个操作值是布尔值，则将其转换为数值，再进行比较。</span><br></pre></td></tr></table></figure></li><li><p>注：<strong>NaN</strong>是非常特殊的值，它<strong>不和任何类型的值相等</strong>，<strong>包括它自己</strong>，同时它<strong>与任何类型的值比较大小时都返回false</strong>。</p></li></ul><h5 id="相等操作符（-）"><a href="#相等操作符（-）" class="headerlink" title="相等操作符（==）"></a>相等操作符（==）</h5><ul><li>相等操作符会对操作值进行隐式转换后进行比较：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）如果一个操作值为布尔值，则在比较之前先将其转换为数值。</span><br><span class="line">（2）如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值。</span><br><span class="line">（3）如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较。</span><br><span class="line">（4）null与undefined是相等的。</span><br><span class="line">（5）如果一个操作值为NaN，则相等比较返回<span class="literal">false</span>。</span><br><span class="line">（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。</span><br></pre></td></tr></table></figure></li></ul><h5 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h5><ul><li>判断语句中的判断条件需要是<strong>Boolean类型</strong>，所以条件表达式会被隐式转换为Boolean。其转换规则同Boolean的构造函数。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在JavaScript中&lt;strong&gt;声明变量不需指定类型&lt;/strong&gt;，&lt;strong&gt;对变量赋值&lt;/strong&gt;也&lt;strong&gt;没有类型检查&lt;/strong&gt;，同时JavaScript&lt;strong&gt;允许隐式类型转换&lt;/strong&gt;。这些特征说明JavaScript属于&lt;strong&gt;弱类型的语言&lt;/strong&gt;。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="类型转换" scheme="https://chongtianhong.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>vue之观察者watch</title>
    <link href="https://chongtianhong.github.io/2018/04/06/vueWatch/"/>
    <id>https://chongtianhong.github.io/2018/04/06/vueWatch/</id>
    <published>2018-04-06T02:56:27.000Z</published>
    <updated>2018-07-26T14:17:32.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言：computed和watch区别"><a href="#前言：computed和watch区别" class="headerlink" title="前言：computed和watch区别"></a>前言：computed和watch区别</h4><ul><li>computed：监听<strong>多个</strong>数据或者<strong>一个</strong>数据来维护返回一个状态值，<strong>只要其中一个或多个数据发生了变化</strong>，则会<strong>重新计算整个函数体</strong>，<strong>重新返回状态值</strong>。(computed中监听的值可以不在data中设置，而watch中监听的值则需要在data中定义)</li><li>watch：只能<strong>监听单个数据</strong>，只要这个<strong>数据发生变化</strong>，就会<strong>返回两个参数</strong>，第一个是<strong>当前的值</strong>，第二个是<strong>变化前的值</strong>。每当变化的时候，则会触发函数体的逻辑行为，根据逻辑行为做后续的操作。<a id="more"></a></li></ul><h4 id="Watch用法"><a href="#Watch用法" class="headerlink" title="Watch用法"></a>Watch用法</h4><ul><li>Watch：它用于<strong>观察Vue实例上的数据变动</strong>。对应一个对象，<strong>键</strong>是<strong>观察表达式</strong>，<strong>值</strong>是<strong>对应回调</strong>。值也可以是方法名，或者是对象，包含选项。具体的用法可以直接看下面的示例，简单直接。</li></ul><blockquote>用法一：数组与对象都用handler</blockquote><ul><li><p>数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        winChips: new Array(11).fill(0)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    winChips: &#123;</span><br><span class="line">        handler(newValue, oldValue) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; newValue.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldValue[i] != newValue[i]) &#123;</span><br><span class="line">                    console.log(newValue)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: <span class="literal">true</span>  // 开启深入监听，一般用于监听数组中的值；如果不开启，将只监听数组整体，而不会监听数组中的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        bet: &#123;</span><br><span class="line">            pokerState: 53,</span><br><span class="line">            pokerHistory: <span class="string">'local'</span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    bet: &#123;</span><br><span class="line">        handler(newValue, oldValue) &#123;</span><br><span class="line">            console.log(newValue)</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: <span class="literal">true</span>   // 开启深入监听，一般用于监听对象中的键对值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中如果要对对象中的键值进行监听，需要加引号:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        bet: &#123;</span><br><span class="line">            pokerState: 53,</span><br><span class="line">            pokerHistory: <span class="string">'local'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    <span class="string">'bet.pokerHistory'</span>:<span class="keyword">function</span>(val,oldval)&#123; //键路径必须加上引号</span><br><span class="line">        console.log(val+<span class="string">"aaa"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    // 通过这个办法可以直接监听对象中的某个键对值而不用deep。</span><br><span class="line">    // 弊端是这里只能监听固定的键对值</span><br></pre></td></tr></table></figure></li></ul><blockquote>用法二：正常的值</blockquote><ul><li>当所要监听的值为基本类型时：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        frontPoints: 0    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    frontPoints(newValue, oldValue) &#123;</span><br><span class="line">        console.log(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="对handler方法和、immediate属性和deep属性的解析"><a href="#对handler方法和、immediate属性和deep属性的解析" class="headerlink" title="对handler方法和、immediate属性和deep属性的解析"></a>对handler方法和、immediate属性和deep属性的解析</h4><ul><li><code>handler</code>方法：其实<strong>watch方法里面</strong>，都是<strong>默认用handler方法</strong>，不管你是否写了handler方法，因为Vue.js会处理这个逻辑，然后<strong>最终编译为handler</strong>。</li><li><p><code>immediate</code>属性：watch 的一个特点是，最初绑定的时候是不会执行的，要等到 监听值改变时才执行监听计算。immediate属性一般和handler联用，当这个属性是true时，表示声明了handler所监听的元素在watch<strong>声明完了后就立即执行</strong>。如下面的例子中，当设置了immediate属性后，当该watch声明完firstName后，会立即执行，fullName被初始化为<code>“Dawei Lou”</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div id=<span class="string">"root"</span>&gt;</span><br><span class="line">    &lt;p&gt;FullName: &#123;&#123;fullName&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;FirstName:</span><br><span class="line">        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"firstName"</span>&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// JS</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#root'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: <span class="string">'Dawei'</span>,</span><br><span class="line">        lastName: <span class="string">'Lou'</span>,</span><br><span class="line">        fullName: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        firstName: &#123;</span><br><span class="line">            handler(newName, oldName) &#123;</span><br><span class="line">                this.fullName = newName + <span class="string">' '</span> + this.lastName;</span><br><span class="line">            &#125;,</span><br><span class="line">            immediate: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>deep</code>属性：当属性值为true时，为<strong>深入解析</strong>，<strong>一般用于数组与对象</strong>中。如果我们<strong>不用它</strong>，那么在一般情况下，我们<strong>只能监听到该对象的变化</strong>以及<strong>数组整体的变化</strong>，而<strong>不能深入监听对象里的键对值变化</strong>以及<strong>数组里的值的变化</strong>。</p></li></ul><h4 id="watch-API"><a href="#watch-API" class="headerlink" title="$watch API"></a>$watch API</h4><ul><li>该API可实现<strong>动态添加观察者watch</strong>以及<strong>动态删除</strong>。</li></ul><blockquote>动态添加</blockquote><ul><li><p>$watch的语法很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="variable">$watch</span>(expOrFn(要监听的属性), callback, [options])</span><br></pre></td></tr></table></figure></li><li><p>其中vm指的是Vue中的一个实例，就是我们的app。如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> watch = app.<span class="variable">$watch</span>(<span class="string">'count'</span>, <span class="keyword">function</span>(newValue, oldValue)&#123; </span><br><span class="line">    alert(<span class="string">'Count changed from '</span> + oldValue + <span class="string">' to '</span> + newValue + <span class="string">'!'</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>当我们要对data的对象中的键值进行监听时，有两种方法：</p></li><li><p>方法一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="variable">$watch</span>(<span class="string">'person.name.firstName'</span>, <span class="keyword">function</span>(newValue, oldValue)&#123; </span><br><span class="line">    alert(<span class="string">'firstName 从 '</span> + oldValue + <span class="string">' 变成 '</span> + newValue + <span class="string">'!'</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="variable">$watch</span>(<span class="string">'person.name'</span>, <span class="keyword">function</span>(newValue, oldValue)&#123; alert(<span class="string">'firstName从 '</span> + oldValue.firstName + <span class="string">' 变成 '</span> + <span class="string">'newValue.firstName'</span> + <span class="string">'!'</span>)&#125;, &#123;deep: <span class="literal">true</span>&#125;)</span><br><span class="line">    //这里我们只监听到对象中的name。</span><br><span class="line">    //但是如果我们想要监听到name中的firstname时，需要加个参数 deep: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><blockquote>动态删除</blockquote><ul><li>为什么要注销 watch？因为我们的组件是经常要被销毁的，比如我们跳一个路由，从一个页面跳到另外一个页面，那么原来的页面的 watch 其实就没用了，这时候我们应该注销掉原来页面的 watch 的，不然的话可能会<strong>导致内置溢出</strong>。如果平时 watch 是写在组件的选项中的，它会随着组件的销毁而销毁。</li><li><p>而对于动态添加的watch，则需要手动注销：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const unWatch = app.<span class="variable">$watch</span>(<span class="string">'text'</span>, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">  console.log(`<span class="variable">$&#123;newVal&#125;</span> : <span class="variable">$&#123;oldVal&#125;</span>`);</span><br><span class="line">&#125;)</span><br><span class="line">// app.<span class="variable">$watch</span>调用后会返回一个值，就是unWatch方法</span><br><span class="line">// 注销 watch 只要调用unWatch方法就可以了。</span><br><span class="line">unWatch(); // 手动注销watch</span><br></pre></td></tr></table></figure></li><li><p>也可以把watch当做函数运行一遍就相当于删除观察者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//watch运作5秒后删除</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">    watch();  // 当成函数运行一遍</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言：computed和watch区别&quot;&gt;&lt;a href=&quot;#前言：computed和watch区别&quot; class=&quot;headerlink&quot; title=&quot;前言：computed和watch区别&quot;&gt;&lt;/a&gt;前言：computed和watch区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;computed：监听&lt;strong&gt;多个&lt;/strong&gt;数据或者&lt;strong&gt;一个&lt;/strong&gt;数据来维护返回一个状态值，&lt;strong&gt;只要其中一个或多个数据发生了变化&lt;/strong&gt;，则会&lt;strong&gt;重新计算整个函数体&lt;/strong&gt;，&lt;strong&gt;重新返回状态值&lt;/strong&gt;。(computed中监听的值可以不在data中设置，而watch中监听的值则需要在data中定义)&lt;/li&gt;
&lt;li&gt;watch：只能&lt;strong&gt;监听单个数据&lt;/strong&gt;，只要这个&lt;strong&gt;数据发生变化&lt;/strong&gt;，就会&lt;strong&gt;返回两个参数&lt;/strong&gt;，第一个是&lt;strong&gt;当前的值&lt;/strong&gt;，第二个是&lt;strong&gt;变化前的值&lt;/strong&gt;。每当变化的时候，则会触发函数体的逻辑行为，根据逻辑行为做后续的操作。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="Vue.js" scheme="https://chongtianhong.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>JS性能优化之函数去抖</title>
    <link href="https://chongtianhong.github.io/2018/04/05/debounce/"/>
    <id>https://chongtianhong.github.io/2018/04/05/debounce/</id>
    <published>2018-04-05T06:59:50.000Z</published>
    <updated>2018-07-26T14:04:44.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><strong>概念</strong>：函数去抖是<strong>通过一个定时器</strong>，<strong>阻断连续重复的函数调用</strong>，从而一定程度上<strong>优化性能</strong>。</li><li><strong>用途</strong>：主要用于<strong>用户界面</strong>调用的函数，如：<strong>resize事件</strong>、<strong>mousemove事件</strong>、<strong>keyup事件</strong>的<strong>监听函数</strong>。 </li><li>这类监听函数的主要特征：<br>1、短时间内连续多次重复触发；<br>2、大量的DOM操作。</li><li><strong>意义</strong>：在用户察觉范围外，<strong>降低函数调用的频率</strong>，从而提升性能。<a id="more"></a></li></ul><h4 id="函数去抖的原理"><a href="#函数去抖的原理" class="headerlink" title="函数去抖的原理"></a>函数去抖的原理</h4><ul><li>某些代码不可以在没有间断的情况<strong>连续重复执行</strong>。</li><li>第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。</li><li>如果前一个定时器已经执行过了，这个操作就没有任何意义。</li><li>然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有<strong>在执行函数的请求停止了一段时间之后才执行</strong>。</li></ul><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><ul><li>例如： <ul><li>使用onresize事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。<strong>在onresize 事件处理程序内部</strong>如果<strong>尝试进行DOM操作</strong>，其<strong>高频率的更改</strong>可能会<strong>让浏览器崩溃</strong>。 </li><li>另一个常见的是搜索功能，我们一般是绑定keyup事件，每按下一次键盘就搜索一次。但是我们的目的主要是<strong>每输入一些内容搜索一次</strong>而已。</li></ul></li><li>为了解决这些问题，就可以<strong>使用定时器对函数进行去抖</strong>。</li><li>下面以keyup为例，对<strong>函数去抖</strong>的具体用法进行介绍。</li></ul><blockquote>1、不使用函数去抖的情况</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"search"</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"search"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> queryData(text)&#123;</span><br><span class="line">    console.log(<span class="string">"搜索："</span> + text);</span><br><span class="line">&#125;</span><br><span class="line">var input = document.getElementById(<span class="string">"search"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="keyword">function</span>(event)&#123; </span><br><span class="line">    queryData(this.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>结果如图：<br><img src="/images/search1.png" alt="不使用函数防抖的情况"></li></ul><blockquote>2、使用基本函数防抖的情况</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"search1"</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"search"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> queryData(text)&#123;</span><br><span class="line">    console.log(<span class="string">"搜索："</span> + text);</span><br><span class="line">&#125;</span><br><span class="line">var input = document.getElementById(<span class="string">"search"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    debounce(queryData, null, 500, this.value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> debounce(fn, context, delay, text)&#123;</span><br><span class="line">    clearTimeout(fn.timeoutId);</span><br><span class="line">    fn.timeoutId = setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        fn.call(context, text);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如图：<br><img src="/images/search2.png" alt="使用函数防抖的情况"></li><li>实际上，我们更希望的是，<strong>当达到某个时间值时，一定要执行一次这个搜索函数</strong>。所以，就有了函数防抖的<strong>改进模式</strong>。</li></ul><blockquote>3、函数防抖增强版</blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"search"</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"search"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> queryData(text)&#123;</span><br><span class="line">    console.log(<span class="string">"搜索："</span> + text);</span><br><span class="line">&#125;</span><br><span class="line">var input = document.getElementById(<span class="string">"search"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    debounce(queryData, null, 500, this.value, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> debounce(fn, context, delay, text, mustApplyTime)&#123;</span><br><span class="line">    clearTimeout(fn.timer);</span><br><span class="line">    fn._cur = Date.now(); //记录当前时间</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fn._start)&#123; //若该函数是第一次调用，则直接设置_start,即开始时间，为_cur，即此刻的时间</span><br><span class="line">        fn._start = fn._cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fn._cur-fn._start &gt; mustApplyTime)&#123; </span><br><span class="line">    //当前时间与上一次函数被执行的时间作差，与mustApplyTime比较，若大于，则必须执行一次函数，若小于，则重新设置计时器</span><br><span class="line">        fn.call(context, text);</span><br><span class="line">        fn._start = fn._cur;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fn.timer = setTimeout(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            fn.call(context, text);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如图：<br><img src="/images/search3.png" alt="函数防抖增强版"></li><li>显然，连续的输入，到一定时间间隔之后，queryData函数必然会被调用，但是又不是频繁的调用。这既达到了防抖的目的，又不会影响用户体验。</li></ul><blockquote>4、进一步的优化</blockquote><ul><li>进一步的话，就是可以在调用debounce函数之前，先对输入的内容进行判断，若其值为空、值不变时都不用再调用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;概念&lt;/strong&gt;：函数去抖是&lt;strong&gt;通过一个定时器&lt;/strong&gt;，&lt;strong&gt;阻断连续重复的函数调用&lt;/strong&gt;，从而一定程度上&lt;strong&gt;优化性能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：主要用于&lt;strong&gt;用户界面&lt;/strong&gt;调用的函数，如：&lt;strong&gt;resize事件&lt;/strong&gt;、&lt;strong&gt;mousemove事件&lt;/strong&gt;、&lt;strong&gt;keyup事件&lt;/strong&gt;的&lt;strong&gt;监听函数&lt;/strong&gt;。 &lt;/li&gt;
&lt;li&gt;这类监听函数的主要特征：&lt;br&gt;1、短时间内连续多次重复触发；&lt;br&gt;2、大量的DOM操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;：在用户察觉范围外，&lt;strong&gt;降低函数调用的频率&lt;/strong&gt;，从而提升性能。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="函数去抖" scheme="https://chongtianhong.github.io/tags/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96/"/>
    
  </entry>
  
  <entry>
    <title>函数节流和函数防抖之间的区别</title>
    <link href="https://chongtianhong.github.io/2018/04/04/throttleAndDebounce/"/>
    <id>https://chongtianhong.github.io/2018/04/04/throttleAndDebounce/</id>
    <published>2018-04-04T08:49:11.000Z</published>
    <updated>2018-08-02T11:43:32.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>函数节流和函数防抖，两者都是<strong>优化高频率执行js代码</strong>的一种手段。</li><li>在一些场景中，函数会因为一些用户操作被频繁触发，例如<strong>频繁操作DOM</strong>，<strong>重绘Layout</strong>，<strong>加载资源</strong>，<strong>请求数据</strong>，而导致浏览器<strong>卡顿</strong>或者<strong>崩溃</strong>。</li><li>常见场景有：<strong>输入监听</strong>，<strong>滚动监听</strong>，<strong>鼠标移入/移出/移动</strong>。这个时候就需要我们去优化，从而提高Javascript性能。<a id="more"></a></li></ul><h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><ul><li><strong>throttle</strong>：<strong>一定的时间间隔内执行</strong>，即设定一个时间间隔，当大于或等于时间间隔时，立即执行一次方法。</li><li>简而言之，指定时间间隔内<strong>只会执行一次任务</strong>。</li><li><p>比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</span><br><span class="line">    // 判断是否已空闲，如果在执行中，则直接<span class="built_in">return</span></span><br><span class="line">    <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'执行'</span>);</span><br><span class="line">        canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如上例子所示, 只要resize事件触发一次, 500ms之后立即触发函数一次, 在这其中不管resize方法再被触发了多少次都不理会, 反正500ms执行一次方法。</p></li><li><p>重新封装一下throttle方法，便于调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> throttle(fn, interval = 500) &#123;</span><br><span class="line">    <span class="built_in">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        // 判断是否已空闲，如果在执行中，则直接<span class="built_in">return</span></span><br><span class="line">        <span class="keyword">if</span>(!canRun)&#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        canRun = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">            canRun = <span class="literal">true</span>;</span><br><span class="line">        &#125;, interval);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, throttle(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'执行'</span>)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li><p><strong>函数节流</strong>的要点是，<strong>声明一个变量当标志位</strong>，<strong>记录当前代码是否在执行</strong>。</p><ul><li>如果空闲，则可以正常触发方法执行。</li><li>如果代码正在执行，则取消这次方法执行，直接return。</li></ul></li></ul><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><ul><li><strong>debounce</strong>：<strong>固定的时间间隔内</strong>，如果<strong>事件再次被触发</strong>，则<strong>重置时间</strong>，<strong>直到大于等于时间间隔</strong>才执行方法。</li><li>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</li><li><p>比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> timer = null;</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, () =&gt; &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">'执行'</span>);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如上例子所示，只要resize事件被触发一次就重置一次timeout，直到500ms后事件都没有被触发，才执行方法。</p></li><li><p>重新封装一下debounce方法，便于调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> debounce(fn, interval=500)&#123;</span><br><span class="line">    <span class="built_in">let</span> timer = null;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments);</span><br><span class="line">        &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, debounce(()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">'执行'</span>)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li><p><strong>函数防抖</strong>的要点，也是需要一个setTimeout来辅助实现。延迟执行需要跑的代码。</p><ul><li>如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始计时。</li><li>如果计时完毕，没有方法进来访问触发，则执行代码。</li></ul></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><strong>throttle</strong>：一辆定时的地铁，每五分钟出发一辆，不管你有没有上到车，只要执行命令下来过五分钟之后就出发。</li><li><strong>debounce</strong>：就跟电梯的原理一样，只要10s之内有人来就重置时间，直到等待时间大于等于10s之后没人进来才出发。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>两个方法，两种原理，适用的范围和场景也不一样，看实际的看法需求和业务。在不影响用户体验的前提下，<strong>优化Javascript性能</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;函数节流和函数防抖，两者都是&lt;strong&gt;优化高频率执行js代码&lt;/strong&gt;的一种手段。&lt;/li&gt;
&lt;li&gt;在一些场景中，函数会因为一些用户操作被频繁触发，例如&lt;strong&gt;频繁操作DOM&lt;/strong&gt;，&lt;strong&gt;重绘Layout&lt;/strong&gt;，&lt;strong&gt;加载资源&lt;/strong&gt;，&lt;strong&gt;请求数据&lt;/strong&gt;，而导致浏览器&lt;strong&gt;卡顿&lt;/strong&gt;或者&lt;strong&gt;崩溃&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;常见场景有：&lt;strong&gt;输入监听&lt;/strong&gt;，&lt;strong&gt;滚动监听&lt;/strong&gt;，&lt;strong&gt;鼠标移入/移出/移动&lt;/strong&gt;。这个时候就需要我们去优化，从而提高Javascript性能。
    
    </summary>
    
      <category term="开发" scheme="https://chongtianhong.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="https://chongtianhong.github.io/tags/JavaScript/"/>
    
      <category term="开发" scheme="https://chongtianhong.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="性能优化" scheme="https://chongtianhong.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Web" scheme="https://chongtianhong.github.io/tags/Web/"/>
    
      <category term="函数去抖" scheme="https://chongtianhong.github.io/tags/%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96/"/>
    
      <category term="函数节流" scheme="https://chongtianhong.github.io/tags/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
</feed>
